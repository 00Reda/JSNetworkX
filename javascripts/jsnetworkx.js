(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.jsnx = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Arrays.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var shuffle = _babelHelpers.interopRequire(require("lodash/collection/shuffle"));

var sample = _babelHelpers.interopRequire(require("lodash/collection/sample"));

module.exports = { shuffle: shuffle, sample: sample };

},{"babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","lodash/collection/sample":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/collection/sample.js","lodash/collection/shuffle":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/collection/shuffle.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Map.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

/**
 * @fileoverview
 * A shim for ES6 maps and support for custom hash functions via toString()
 * and does not accept arrays as keys (just like Python does not accept lists).
 */

var clear = _babelHelpers.interopRequire(require("./clear"));

var isIterator = _babelHelpers.interopRequire(require("./isIterator"));

var isFunction = _babelHelpers.interopRequire(require("lodash/lang/isFunction"));

var isObject = _babelHelpers.interopRequire(require("lodash/lang/isObject"));

var isArrayLike = _babelHelpers.interopRequire(require("./isArrayLike"));

var size = _babelHelpers.interopRequire(require("lodash/collection/size"));

var Map = (function () {
  /**
   * @param {Iterable=} opt_data An object, array or iterator to
   *  populate the map with. If 'data' is an array or iterable, each element is
   *  expected to be a 2-tuple. The first element will be the key and second the
   *  value.
   *  If it is an object, the property names will be the keys and the value the
   *  values.
   */

  function Map(optData) {
    _babelHelpers.classCallCheck(this, Map);

    // Can't use class syntax because of generator functions
    this._stringValues = Object.create(null); // strings
    this._numberValues = Object.create(null); // numbers
    this._values = Object.create(null); // every other value
    this._keys = Object.create(null);

    var key, value;

    if (optData != null) {
      if (isIterator(optData)) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _core.$for.getIterator(optData), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _babelHelpers.slicedToArray(_step.value, 2);

            var key = _step$value[0];
            var value = _step$value[1];

            this.set(key, value);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else if (isArrayLike(optData)) {
        for (var i = 0; i < optData.length; i++) {
          var _ref = optData[i];

          var _ref2 = _babelHelpers.slicedToArray(_ref, 2);

          key = _ref2[0];
          value = _ref2[1];

          this.set(key, value);
        }
      } else if (isObject(optData)) {
        for (var key in optData) {
          this.set(isNaN(+key) ? key : +key, optData[key]);
        }
      }
    }
  }

  _babelHelpers.prototypeProperties(Map, null, (function () {
    var _babelHelpers$prototypeProperties = {
      _getStorage: {

        /**
         * Returns the appropriate storage object for a given key.
         *
         * @param {*} key
         * @return {Object}
         * @private
         */

        value: function _getStorage(key) {
          switch (typeof key) {
            case "number":
              return this._numberValues;
            case "string":
              return this._stringValues;
            default:
              return this._values;
          }
        },
        writable: true,
        configurable: true
      },
      get: {

        /**
         * Returns the value for the given key.
         *
         * Unlike native ES6 maps, this also accepts a default value which is returned
         * if the map does not contain the value.
         *
         * @param {*} key
         * @param {*=} optDefaultValue
         *
         * @return {*}
         * @export
         */

        value: function get(key, optDefaultValue) {
          var storage = this._getStorage(key);
          return key in storage ? storage[key] : optDefaultValue;
        },
        writable: true,
        configurable: true
      },
      has: {

        /**
         * Returns true if the key is in the map.
         *
         * @param {*} key
         *
         * @return {boolean}
         * @export
         */

        value: function has(key) {
          return key in this._getStorage(key);
        },
        writable: true,
        configurable: true
      },
      set: {

        /**
         * Adds the value and key to the map.
         *
         * @param {*} key
         * @param {*} value
         *
         * @return {Map} the map object itself
         * @export
         */

        value: function set(key, value) {
          var values = this._getStorage(key);
          values[key] = value;

          // save actual key value
          if (values === this._values) {
            this._keys[key] = key;
          }

          return this;
        },
        writable: true,
        configurable: true
      },
      "delete": {

        /**
         * Remove value with given key.
         *
         * @param {*} key
         *
         * @return {boolean}
         * @export
         */

        value: function _delete(key) {
          var values = this._getStorage(key);
          if (key in values) {
            delete values[key];
            if (values === this._values) {
              delete this._keys[key];
            }
            return true;
          }
          return false;
        },
        writable: true,
        configurable: true
      },
      entries: {

        /**
         * Returns an array of (key, value) tuples.
         *
         * @return {!Iterator}
         * @export
        */

        value: _regeneratorRuntime.mark(function entries() {
          var _this = this;

          var key;
          return _regeneratorRuntime.wrap(function entries$(context$3$0) {
            while (1) switch (context$3$0.prev = context$3$0.next) {
              case 0:
                context$3$0.t4 = _regeneratorRuntime.keys(_this._numberValues);

              case 1:
                if ((context$3$0.t5 = context$3$0.t4()).done) {
                  context$3$0.next = 7;
                  break;
                }

                key = context$3$0.t5.value;
                context$3$0.next = 5;
                return [+key, _this._numberValues[key]];

              case 5:
                context$3$0.next = 1;
                break;

              case 7:
                context$3$0.t6 = _regeneratorRuntime.keys(_this._stringValues);

              case 8:
                if ((context$3$0.t7 = context$3$0.t6()).done) {
                  context$3$0.next = 14;
                  break;
                }

                key = context$3$0.t7.value;
                context$3$0.next = 12;
                return [key, _this._stringValues[key]];

              case 12:
                context$3$0.next = 8;
                break;

              case 14:
                context$3$0.t8 = _regeneratorRuntime.keys(_this._values);

              case 15:
                if ((context$3$0.t9 = context$3$0.t8()).done) {
                  context$3$0.next = 21;
                  break;
                }

                key = context$3$0.t9.value;
                context$3$0.next = 19;
                return [_this._keys[key], _this._values[key]];

              case 19:
                context$3$0.next = 15;
                break;

              case 21:
              case "end":
                return context$3$0.stop();
            }
          }, entries, this);
        }),
        writable: true,
        configurable: true
      },
      keys: {

        /**
         * Returns an iterator over keys.
         *
         * @return {!Iterator}
         * @export
        */

        value: _regeneratorRuntime.mark(function keys() {
          var _this = this;

          var key;
          return _regeneratorRuntime.wrap(function keys$(context$3$0) {
            while (1) switch (context$3$0.prev = context$3$0.next) {
              case 0:
                context$3$0.t10 = _regeneratorRuntime.keys(_this._numberValues);

              case 1:
                if ((context$3$0.t11 = context$3$0.t10()).done) {
                  context$3$0.next = 7;
                  break;
                }

                key = context$3$0.t11.value;
                context$3$0.next = 5;
                return +key;

              case 5:
                context$3$0.next = 1;
                break;

              case 7:
                context$3$0.t12 = _regeneratorRuntime.keys(_this._stringValues);

              case 8:
                if ((context$3$0.t13 = context$3$0.t12()).done) {
                  context$3$0.next = 14;
                  break;
                }

                key = context$3$0.t13.value;
                context$3$0.next = 12;
                return key;

              case 12:
                context$3$0.next = 8;
                break;

              case 14:
                context$3$0.t14 = _regeneratorRuntime.keys(_this._values);

              case 15:
                if ((context$3$0.t15 = context$3$0.t14()).done) {
                  context$3$0.next = 21;
                  break;
                }

                key = context$3$0.t15.value;
                context$3$0.next = 19;
                return _this._keys[key];

              case 19:
                context$3$0.next = 15;
                break;

              case 21:
              case "end":
                return context$3$0.stop();
            }
          }, keys, this);
        }),
        writable: true,
        configurable: true
      },
      values: {

        /**
         * Returns an array of values.
         *
         * @return {!Array}
         * @export
        */

        value: _regeneratorRuntime.mark(function values() {
          var _this = this;

          var key;
          return _regeneratorRuntime.wrap(function values$(context$3$0) {
            while (1) switch (context$3$0.prev = context$3$0.next) {
              case 0:
                context$3$0.t16 = _regeneratorRuntime.keys(_this._numberValues);

              case 1:
                if ((context$3$0.t17 = context$3$0.t16()).done) {
                  context$3$0.next = 7;
                  break;
                }

                key = context$3$0.t17.value;
                context$3$0.next = 5;
                return _this._numberValues[key];

              case 5:
                context$3$0.next = 1;
                break;

              case 7:
                context$3$0.t18 = _regeneratorRuntime.keys(_this._stringValues);

              case 8:
                if ((context$3$0.t19 = context$3$0.t18()).done) {
                  context$3$0.next = 14;
                  break;
                }

                key = context$3$0.t19.value;
                context$3$0.next = 12;
                return _this._stringValues[key];

              case 12:
                context$3$0.next = 8;
                break;

              case 14:
                context$3$0.t20 = _regeneratorRuntime.keys(_this._values);

              case 15:
                if ((context$3$0.t21 = context$3$0.t20()).done) {
                  context$3$0.next = 21;
                  break;
                }

                key = context$3$0.t21.value;
                context$3$0.next = 19;
                return _this._values[key];

              case 19:
                context$3$0.next = 15;
                break;

              case 21:
              case "end":
                return context$3$0.stop();
            }
          }, values, this);
        }),
        writable: true,
        configurable: true
      },
      size: {

        /**
         * Returns the number of element in the map.
         *
         * @return {number}
         * @export
        */

        get: function () {
          return size(this._values) + size(this._numberValues) + size(this._stringValues);
        },
        configurable: true
      },
      clear: {

        /**
         * Empties the map.
         *
         * @export
        */

        value: (function (_clear) {
          var _clearWrapper = function clear() {
            return _clear.apply(this, arguments);
          };

          _clearWrapper.toString = function () {
            return _clear.toString();
          };

          return _clearWrapper;
        })(function () {
          clear(this._stringValues);
          clear(this._numberValues);
          clear(this._values);
          clear(this._keys);
        }),
        writable: true,
        configurable: true
      },
      forEach: {

        /**
         * Executes the provided callback for each item in the map.
         *
         * @param {function(*,*)} callback A function which gets the key as first
         *  argument and value as second argument.
         * @param {*=} opt_this Object/value to set this to inside the callback
         * @export
        */

        value: function forEach(callback, optThis) {
          if (!isFunction(callback)) {
            throw new TypeError("callback must be a function");
          }
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _core.$for.getIterator(this.entries()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var v = _step.value;

              callback.call(optThis, v[1], v[0], this);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        },
        writable: true,
        configurable: true
      }
    };
    _babelHelpers$prototypeProperties[_core.Symbol.iterator] = {

      /**
      * Returns an iterator for the map object.
      *
      * @return {Iterator}
      */

      value: function () {
        return this.entries();
      },
      writable: true,
      configurable: true
    };
    return _babelHelpers$prototypeProperties;
  })());

  return Map;
})();

module.exports = Map;

},{"./clear":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/clear.js","./isArrayLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isArrayLike.js","./isIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterator.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js","lodash/collection/size":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/collection/size.js","lodash/lang/isFunction":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isFunction.js","lodash/lang/isObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isObject.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/PriorityQueue.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

function sorter(a, b) {
  return b[0] - a[0];
}

/**
 * A simple priority queue implementation.
 */

var PriorityQueue = (function () {

  /**
   * Accepts an iterable that emits `[priority, value]` pairs. Iterates over the
   * iterable only once.
   *
   * `priority` must be a number.
   *
   * @param {Iterable} iterable
   */

  function PriorityQueue(iterable) {
    _babelHelpers.classCallCheck(this, PriorityQueue);

    this._values = [];
    if (iterable != null) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _core.$for.getIterator(iterable), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _babelHelpers.slicedToArray(_step.value, 2);

          var priority = _step$value[0];
          var value = _step$value[1];

          this._values.push([priority, value]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._values.sort(sorter);
    }
  }

  _babelHelpers.prototypeProperties(PriorityQueue, null, {
    enqueue: {

      /**
       * Adds a value to the queue. It will be inserted into the queue according to
       * `priority`.
       *
       * @param {number} priority
       * @param {*} value
       */

      value: function enqueue(priority, value) {
        this._values.push([priority, value]);
        this._values.sort(sorter);
      },
      writable: true,
      configurable: true
    },
    dequeue: {

      /**
       * Removes and returns the smallest [priority, value] tuple from the queue.
       *
       * @return {?}
       */

      value: function dequeue() {
        return this._values.pop();
      },
      writable: true,
      configurable: true
    },
    size: {

      /**
       * Returns the current size of the queue.
       *
       * @return {number}
       */

      get: function () {
        return this._values.length;
      },
      configurable: true
    }
  });

  return PriorityQueue;
})();

module.exports = PriorityQueue;

},{"babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Set.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

/**
 * @fileoverview
 * A shim for ES6 maps and support for custom hash functions via toString().
 */

/*jshint ignore:start */

var Map = _babelHelpers.interopRequire(require("./Map"));

/*jshint ignore:end */

var toIterator = require("./toIterator");

var Set = (function () {

  /**
   * @param {Iterable} opt_data An object, array or iterator to populate the set
   * with.
   */

  function Set(optData) {
    _babelHelpers.classCallCheck(this, Set);

    this._map = new Map();

    if (optData != null) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _core.$for.getIterator(toIterator(optData)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var v = _step.value;

          this.add(v);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }

  _babelHelpers.prototypeProperties(Set, null, (function () {
    var _babelHelpers$prototypeProperties = {
      has: {

        /**
         * Returns true if the key is in the map.
         *
         * @param {*} value
         *
         * @return {boolean}
         */

        value: function has(value) {
          return this._map.has(value);
        },
        writable: true,
        configurable: true
      },
      add: {

        /**
         * Adds the value and key to the map.
         *
         * @param {*} value
         *
         * @export
         */

        value: function add(value) {
          this._map.set(value, true);
        },
        writable: true,
        configurable: true
      },
      "delete": {

        /**
         * Remove value with given key.
         *
         * @param {*} value
         *
         * @export
         */

        value: function _delete(value) {
          return this._map["delete"](value);
        },
        writable: true,
        configurable: true
      },
      values: {

        /**
         * Returns an array of values.
         *
         * @return {!Iterator}
         * @export
         */

        value: function values() {
          return this._map.keys();
        },
        writable: true,
        configurable: true
      },
      keys: {

        /**
         * Returns an array of values.
         *
         * @return {!Iterator}
         * @export
         */

        value: function keys() {
          return this.values();
        },
        writable: true,
        configurable: true
      },
      entries: {

        /**
         * Returns an array of values.
         *
         * @return {!Iterator}
         * @export
         */

        value: _regeneratorRuntime.mark(function entries() {
          var _this = this;

          var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, v;

          return _regeneratorRuntime.wrap(function entries$(context$3$0) {
            while (1) switch (context$3$0.prev = context$3$0.next) {
              case 0:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$3$0.prev = 3;
                _iterator = _core.$for.getIterator(_this.values());

              case 5:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  context$3$0.next = 12;
                  break;
                }

                v = _step.value;
                context$3$0.next = 9;
                return [v, v];

              case 9:
                _iteratorNormalCompletion = true;
                context$3$0.next = 5;
                break;

              case 12:
                context$3$0.next = 18;
                break;

              case 14:
                context$3$0.prev = 14;
                context$3$0.t22 = context$3$0["catch"](3);
                _didIteratorError = true;
                _iteratorError = context$3$0.t22;

              case 18:
                context$3$0.prev = 18;
                context$3$0.prev = 19;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                  _iterator["return"]();
                }

              case 21:
                context$3$0.prev = 21;

                if (!_didIteratorError) {
                  context$3$0.next = 24;
                  break;
                }

                throw _iteratorError;

              case 24:
                return context$3$0.finish(21);

              case 25:
                return context$3$0.finish(18);

              case 26:
              case "end":
                return context$3$0.stop();
            }
          }, entries, this, [[3, 14, 18, 26], [19,, 21, 25]]);
        }),
        writable: true,
        configurable: true
      },
      size: {

        /**
         * Returns the number of element in the set.
         *
         * @return {number}
         * @export
         */

        get: function () {
          return this._map.size;
        },
        configurable: true
      },
      clear: {

        /**
         * Empties the set.
         *
         * @export
         */

        value: function clear() {
          this._map.clear();
        },
        writable: true,
        configurable: true
      },
      forEach: {

        /**
         * Executes the provided callback for each item in the set.
         *
         * @param {function(*)} callback A function which gets the key as first
         *  argument and value as second argument.
         * @param {*=} opt_this Object/value to set this to inside the callback
         * @export
        */

        value: function forEach(callback, optThis) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _core.$for.getIterator(this.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var v = _step.value;

              callback.call(optThis, v, v, this);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        },
        writable: true,
        configurable: true
      },
      difference: {

        /** EXTENSIONS **/
        /**
         * The following methods are not part of the ES6 Set class but are provided
         * for convenience. Once Sets become more widely available, we could simply
         * extend the native Set class.
         */

        /**
         * Returns a new set with the values of this set, not found in the other
         * sets.
         *
         * @param {...(Set|Array)} others
         */

        value: function difference() {
          for (var _len = arguments.length, others = Array(_len), _key = 0; _key < _len; _key++) {
            others[_key] = arguments[_key];
          }

          var result = new Set(this);
          for (var i = 0, l = others.length; i < l; i++) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = _core.$for.getIterator(others[i]), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var v = _step.value;

                result["delete"](v);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
          return result;
        },
        writable: true,
        configurable: true
      },
      intersection: {

        /**
         * Returns a new set containing only elements found in this and every
         * other set/array.
         *
         * @param {...(Set|Array)} others
         */

        value: function intersection() {
          for (var _len = arguments.length, others = Array(_len), _key = 0; _key < _len; _key++) {
            others[_key] = arguments[_key];
          }

          var result = new Set();
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _core.$for.getIterator(this), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var v = _step.value;

              if (others.every(function (other) {
                return other.has(v);
              })) {
                result.add(v);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return result;
        },
        writable: true,
        configurable: true
      },
      pop: {

        /**
         * Removes and returns an element from the set.
         *
         * @return {?}
         */

        value: function pop() {
          try {
            var value = this.values().next().value;
            this["delete"](value);
            return value;
          } catch (ex) {}
        },
        writable: true,
        configurable: true
      }
    };
    _babelHelpers$prototypeProperties[_core.Symbol.iterator] = {

      /**
       * Returns an iterator for the set object.
       *
       * @return {Iterator}
       */

      value: function () {
        return this.values();
      },
      writable: true,
      configurable: true
    };
    return _babelHelpers$prototypeProperties;
  })());

  return Set;
})();

module.exports = Set;

},{"./Map":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Map.js","./toIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/toIterator.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/clear.js":[function(require,module,exports){
"use strict";

/**
 * Removes every property of the object.
 *
 * @param {Object} obj
 */
module.exports = clear;

function clear(obj) {
  for (var prop in obj) {
    delete obj[prop];
  }
}

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/clone.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var clone = _babelHelpers.interopRequire(require("lodash/lang/clone"));

module.exports = clone;

},{"babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","lodash/lang/clone":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/clone.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/deepcopy.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Creates a deep copy of the value, also of maps and sets.
 *
 * @param {*} value The value to be cloned
 * @return {?}
 */
module.exports = deepcopy;

var baseClone = _babelHelpers.interopRequire(require("lodash/internal/baseClone"));

var isGraph = _babelHelpers.interopRequire(require("./isGraph"));

var isMap = _babelHelpers.interopRequire(require("./isMap"));

var isSet = _babelHelpers.interopRequire(require("./isSet"));

function deepcopyInstance(obj, stackA, stackB) {
  // temporary constructor, we don't know if the original expects
  // parameter
  /**
   * @constructor
   */
  var T_ = function T_() {};
  T_.prototype = obj.constructor.prototype;
  var ownProps = {};
  var prop;
  var instance;

  // collect instance properties
  for (prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      ownProps[prop] = obj[prop];
    }
  }

  // deepcopy them
  ownProps = deepcopyImplementation(ownProps, stackA, stackB);

  // create a new instance and assign properties
  instance = new T_();
  for (prop in ownProps) {
    instance[prop] = ownProps[prop];
  }

  return instance;
}

function deepcopyImplementation(value, stackA, stackB) {
  return baseClone(value, true, function (v) {
    if (isMap(v) || isSet(v) || isGraph(v)) {
      var copy = deepcopyInstance(v, stackA, stackB);
      stackA.push(v);
      stackB.push(copy);
      return copy;
    }
  }, null, null, stackA, stackB);
}
function deepcopy(value) {
  return deepcopyImplementation(value, [], []);
}

/*jshint latedef:false*/

},{"./isGraph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isGraph.js","./isMap":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isMap.js","./isSet":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isSet.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","lodash/internal/baseClone":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseClone.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/deepmerge.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var merge = _babelHelpers.interopRequire(require("lodash/object/merge"));

module.exports = merge;

},{"babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","lodash/object/merge":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/merge.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/delegateToWorker.js":[function(require,module,exports){
(function (global){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * DON'T CALL THIS FUNCTION EXPLICITLY. It's inserted by a transform.
 *
 * Tries to create a worker and pass the arguments to it. Copying large graphs
 * is not very fast, but still faster than running most algorithms
 * synchronously.
 *
 * Falls back to synchronous execution if browser doesn't support workers.
 *
 * This returns a promise which gets resolved with the result sent from the
 * worker or the synchronous functions.
 *
 * @param {string} method The name on the root jsnx object to execute.
 * @param {Array} args An array of arguments to send to the worker.
 *    Some types, such as graphs, are converted to a different format first.
 * @return {Promise}
 */
module.exports = delegateToWorker;

var delegate = _babelHelpers.interopRequire(require("./delegate"));

var _message = require("./message");

var isSupported = _message.isSupported;
var serialize = _message.serialize;
var deserialize = _message.deserialize;

var delegateImplementation;
if (typeof global.Worker === "function") {
  // Workers are supported
  delegateImplementation = function (method, args) {
    var serializedArgs = new Array(args.length);
    var serializable = args.every(function (arg, i) {
      var supported = isSupported(arg);
      if (supported) {
        serializedArgs[i] = serialize(arg);
      }
      return supported;
    });

    if (!serializable) {
      console.info("At least one argument can't be serialized and sent to the worker. " + ("We will run " + method + " in the same thread instead."));
      delegate(method, args);
    }

    return new _core.Promise(function (resolve, reject) {
      var worker = new global.Worker("{{BUNDLE}}");
      worker.addEventListener("message", function (oEvent) {
        resolve(deserialize(oEvent.data));
      }, false);
      worker.addEventListener("error", reject, false);
      worker.postMessage({ method: method, args: serializedArgs });
    });
  };
} else {
  delegateImplementation = function (method, args) {
    console.info("Workers are not supported in this environment, so \"" + method + "\" will " + "run in the same thread instead. This might block the environment.");
    delegate(method, args);
  };
}
function delegateToWorker(method, args) {
  return delegateImplementation(method, args);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./delegate":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/delegateToWorker.js","./message":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/message.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/fillArray.js":[function(require,module,exports){
"use strict";

/**
 * Creates an array of `n` elements, each being `value`.
 *
 * @param {number} n Number of elements in the array
 * @param {?} value The value to put in each location
 * @return {Array}
 */
module.exports = fillArray;

function fillArray(n, value) {
  var array = new Array(n);
  for (var i = 0; i < n; i++) {
    array[i] = value;
  }
  return array;
}

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/forEach.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Helper to iterate over sequence types (arrays, array-like objects,
 * objects, etc)
 *
 * @param {Iterable} seq
 * @param {function(this:T, ...)} callback
 * @param {T=} optThisObj
 * @template T
 */
module.exports = forEach;

var _forEach = _babelHelpers.interopRequire(require("lodash/collection/forEach"));

var isIterable = _babelHelpers.interopRequire(require("./isIterable"));

var isIterator = _babelHelpers.interopRequire(require("./isIterator"));

function forEach(seq, callback, optThisObj) {
  if (Array.isArray(seq)) {
    seq.forEach(callback, optThisObj);
    return;
  }
  if (isIterable(seq)) {
    seq = _core.$for.getIterator(seq);
  }
  if (isIterator(seq)) {
    var v;
    var i;
    // Avoiding call if it is not necessary is faster in some browsers
    if (optThisObj !== undefined) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _core.$for.getIterator(seq), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          v = _step.value;

          i += 1;
          callback.call(optThisObj, v, i);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _core.$for.getIterator(seq), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          v = _step2.value;

          i += 1;
          callback(v, i);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } else if (seq && typeof seq === "object") {
    _forEach(seq, callback, optThisObj);
  }
}

},{"./isIterable":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterable.js","./isIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterator.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","lodash/collection/forEach":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/collection/forEach.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/gcd.js":[function(require,module,exports){
"use strict";

/**
 * Computes the greatest common divisor of two numbers using Euclid's algorithm.
 *
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
module.exports = gcd;

function gcd(a, b) {
  while (b !== 0) {
    var _ = a;
    a = b;
    b = _ % b;
  }
  return a;
}

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/genCombinations.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _babelHelpers = require("babel-runtime/helpers")["default"];

var genCombinations = _regeneratorRuntime.mark(

/**
 * Implements Python's itertools.combinations
 *
 * Return r length subsequences of elements from the input iterable.
 *
 * @param {Iterable} iterable
 * @param {number} r
 *
 * @return {Iterator}
 */
function genCombinations(iterable, r) {
  var pool, n, indicies, reversedIndicies, i, k, j;
  return _regeneratorRuntime.wrap(function genCombinations$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        pool = _core.Array.from(iterable);
        n = pool.length;

        if (!(r > n)) {
          context$1$0.next = 4;
          break;
        }

        return context$1$0.abrupt("return");

      case 4:
        indicies = range(r);
        reversedIndicies = reversed(indicies);
        context$1$0.next = 8;
        return indicies.map(function (i) {
          return pool[i];
        });

      case 8:
        if (!true) {
          context$1$0.next = 25;
          break;
        }

        k = 0;

      case 10:
        if (!(k < reversedIndicies.length)) {
          context$1$0.next = 17;
          break;
        }

        i = reversedIndicies[k];

        if (!(indicies[i] !== i + n - r)) {
          context$1$0.next = 14;
          break;
        }

        return context$1$0.abrupt("break", 17);

      case 14:
        k++;
        context$1$0.next = 10;
        break;

      case 17:
        if (!(reversedIndicies.length === k)) {
          context$1$0.next = 19;
          break;
        }

        return context$1$0.abrupt("return");

      case 19:
        indicies[i] += 1;
        for (j = i + 1; j < r; j++) {
          indicies[j] = indicies[j - 1] + 1;
        }
        context$1$0.next = 23;
        return indicies.map(function (i) {
          return pool[i];
        });

      case 23:
        context$1$0.next = 8;
        break;

      case 25:
      case "end":
        return context$1$0.stop();
    }
  }, genCombinations, this);
});

module.exports = genCombinations;

var range = _babelHelpers.interopRequire(require("./range"));

function reversed(array) {
  return array.slice().reverse();
}
// genCombinations('ABCD', 2) --> AB AC AD BC BD CD
// genCombinations(range(4), 3) --> 012 013 023 123

},{"./range":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/range.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/genPermutations.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _babelHelpers = require("babel-runtime/helpers")["default"];

var genPermutations = _regeneratorRuntime.mark(

/**
 * Implements Python's itertools.permutations
 *
 * Return successive r length permutations of elements in the iterable.
 * *
 * @param {Iterable} iterable
 * @param {number=} opt_r
 *
 * @return {Iterator}
 */
function genPermutations(iterable, r) {
  var pool, n, indicies, cycles, rangeR, k, i, index, j;
  return _regeneratorRuntime.wrap(function genPermutations$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        pool = _core.Array.from(iterable);
        n = pool.length;

        r = r == null ? n : r;

        if (!(r > n)) {
          context$1$0.next = 5;
          break;
        }

        return context$1$0.abrupt("return");

      case 5:
        indicies = range(n);
        cycles = range(n, n - r, -1);
        rangeR = range(r - 1, -1, -1);
        context$1$0.next = 10;
        return indicies.slice(0, r).map(function (i) {
          return pool[i];
        });

      case 10:
        if (!true) {
          context$1$0.next = 35;
          break;
        }

        k = 0;

      case 12:
        if (!(k < rangeR.length)) {
          context$1$0.next = 31;
          break;
        }

        i = rangeR[k];

        cycles[i] -= 1;
        index = indicies[i];

        if (!(cycles[i] === 0)) {
          context$1$0.next = 22;
          break;
        }

        indicies.splice(i, 1);
        indicies.push(index);
        cycles[i] = n - i;
        context$1$0.next = 28;
        break;

      case 22:
        j = cycles[i];

        indicies[i] = indicies[indicies.length - j];
        indicies[indicies.length - j] = index;
        context$1$0.next = 27;
        return indicies.slice(0, r).map(function (i) {
          return pool[i];
        });

      case 27:
        return context$1$0.abrupt("break", 31);

      case 28:
        k++;
        context$1$0.next = 12;
        break;

      case 31:
        if (!(rangeR.length === k)) {
          context$1$0.next = 33;
          break;
        }

        return context$1$0.abrupt("return");

      case 33:
        context$1$0.next = 10;
        break;

      case 35:
      case "end":
        return context$1$0.stop();
    }
  }, genPermutations, this);
});

module.exports = genPermutations;

var range = _babelHelpers.interopRequire(require("./range"));

// genPermutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
// genPermutations(range(3)) --> 012 021 102 120 201 210

},{"./range":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/range.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/genRange.js":[function(require,module,exports){
"use strict";

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var genRange = _regeneratorRuntime.mark(

/**
 * Implements Python's range function, returns an iterator.
 *
 * If one argument n is passed, iterates over 0...n.
 * If two arguments i,j are passed, iterates over i...j.
 * If three arguments i,j,k are passed, iterates over i, i+k, i+2k, ...j
 *
 * @param {?number=} opt_start Number to start from
 * @param {?number=} opt_end Number to count to
 * @param {?number=} opt_step Step size
 * @return {!Iterator}
 */
function genRange(optStart, optEnd, optStep) {
  var negative, i;
  return _regeneratorRuntime.wrap(function genRange$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!(optStart == null)) {
          context$1$0.next = 4;
          break;
        }

        return context$1$0.abrupt("return");

      case 4:
        if (!(optEnd == null)) {
          context$1$0.next = 10;
          break;
        }

        optEnd = optStart;
        optStart = 0;
        optStep = 1;
        context$1$0.next = 16;
        break;

      case 10:
        if (!(optStep == null)) {
          context$1$0.next = 14;
          break;
        }

        optStep = 1;
        context$1$0.next = 16;
        break;

      case 14:
        if (!(optStep === 0)) {
          context$1$0.next = 16;
          break;
        }

        throw new RangeError("opt_step can't be 0");

      case 16:
        negative = optStep < 0;
        i = optStart;

      case 18:
        if (!(negative && i > optEnd || !negative && i < optEnd)) {
          context$1$0.next = 24;
          break;
        }

        context$1$0.next = 21;
        return i;

      case 21:
        i += optStep;
        context$1$0.next = 18;
        break;

      case 24:
      case "end":
        return context$1$0.stop();
    }
  }, genRange, this);
});

module.exports = genRange;

},{"babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/getDefault.js":[function(require,module,exports){
"use strict";

/**
 * Returns the second argument if the first argument is null or undefined.
 *
 * @param {*} value
 * @param {*} defaultValue
 * @return {?}
 */
module.exports = get;

function get(value, defaultValue) {
  return value == null ? defaultValue : value;
}

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var Arrays = _babelHelpers.interopRequire(require("./Arrays"));

var Map = _babelHelpers.interopRequire(require("./Map"));

var PriorityQueue = _babelHelpers.interopRequire(require("./PriorityQueue"));

var Set = _babelHelpers.interopRequire(require("./Set"));

var clone = _babelHelpers.interopRequire(require("./clone"));

var clear = _babelHelpers.interopRequire(require("./clear"));

var deepcopy = _babelHelpers.interopRequire(require("./deepcopy"));

var deepmerge = _babelHelpers.interopRequire(require("./deepmerge"));

var gcd = _babelHelpers.interopRequire(require("./gcd"));

var genCombinations = _babelHelpers.interopRequire(require("./genCombinations"));

var genPermutations = _babelHelpers.interopRequire(require("./genPermutations"));

var genRange = _babelHelpers.interopRequire(require("./genRange"));

var getDefault = _babelHelpers.interopRequire(require("./getDefault"));

var fillArray = _babelHelpers.interopRequire(require("./fillArray"));

var forEach = _babelHelpers.interopRequire(require("./forEach"));

var isArrayLike = _babelHelpers.interopRequire(require("./isArrayLike"));

var isBoolean = _babelHelpers.interopRequire(require("./isBoolean"));

var isGraph = _babelHelpers.interopRequire(require("./isGraph"));

var isIterable = _babelHelpers.interopRequire(require("./isIterable"));

var isIterator = _babelHelpers.interopRequire(require("./isIterator"));

var isMap = _babelHelpers.interopRequire(require("./isMap"));

var isPlainObject = _babelHelpers.interopRequire(require("./isPlainObject"));

var mapIterator = _babelHelpers.interopRequire(require("./mapIterator"));

var mapSequence = _babelHelpers.interopRequire(require("./mapSequence"));

var max = _babelHelpers.interopRequire(require("./max"));

var next = _babelHelpers.interopRequire(require("./next"));

var nodesAreEqual = _babelHelpers.interopRequire(require("./nodesAreEqual"));

var range = _babelHelpers.interopRequire(require("./range"));

var someIterator = _babelHelpers.interopRequire(require("./someIterator"));

var toIterator = _babelHelpers.interopRequire(require("./toIterator"));

var _tuple = require("./tuple");

var tuple = _babelHelpers.interopRequireWildcard(_tuple);

var size = _babelHelpers.interopRequire(require("./size"));

var sprintf = _babelHelpers.interopRequire(require("./sprintf"));

var zipIterator = _babelHelpers.interopRequire(require("./zipIterator"));

var zipSequence = _babelHelpers.interopRequire(require("./zipSequence"));

exports.Arrays = Arrays;
exports.Map = Map;
exports.PriorityQueue = PriorityQueue;
exports.Set = Set;
exports.clone = clone;
exports.clear = clear;
exports.deepcopy = deepcopy;
exports.deepmerge = deepmerge;
exports.gcd = gcd;
exports.genCombinations = genCombinations;
exports.genPermutations = genPermutations;
exports.genRange = genRange;
exports.getDefault = getDefault;
exports.fillArray = fillArray;
exports.forEach = forEach;
exports.isArrayLike = isArrayLike;
exports.isBoolean = isBoolean;
exports.isGraph = isGraph;
exports.isIterable = isIterable;
exports.isIterator = isIterator;
exports.isMap = isMap;
exports.isPlainObject = isPlainObject;
exports.mapIterator = mapIterator;
exports.mapSequence = mapSequence;
exports.max = max;
exports.next = next;
exports.nodesAreEqual = nodesAreEqual;
exports.range = range;
exports.someIterator = someIterator;
exports.toIterator = toIterator;
exports.tuple = tuple;
exports.size = size;
exports.sprintf = sprintf;
exports.zipIterator = zipIterator;
exports.zipSequence = zipSequence;

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_tuple));

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"./Arrays":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Arrays.js","./Map":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Map.js","./PriorityQueue":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/PriorityQueue.js","./Set":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Set.js","./clear":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/clear.js","./clone":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/clone.js","./deepcopy":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/deepcopy.js","./deepmerge":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/deepmerge.js","./fillArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/fillArray.js","./forEach":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/forEach.js","./gcd":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/gcd.js","./genCombinations":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/genCombinations.js","./genPermutations":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/genPermutations.js","./genRange":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/genRange.js","./getDefault":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/getDefault.js","./isArrayLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isArrayLike.js","./isBoolean":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isBoolean.js","./isGraph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isGraph.js","./isIterable":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterable.js","./isIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterator.js","./isMap":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isMap.js","./isPlainObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isPlainObject.js","./mapIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/mapIterator.js","./mapSequence":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/mapSequence.js","./max":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/max.js","./next":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/next.js","./nodesAreEqual":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/nodesAreEqual.js","./range":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/range.js","./size":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/size.js","./someIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/someIterator.js","./sprintf":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/sprintf.js","./toIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/toIterator.js","./tuple":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/tuple.js","./zipIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/zipIterator.js","./zipSequence":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/zipSequence.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isArrayLike.js":[function(require,module,exports){
"use strict";

/**
 * Returns true of the array is an object and has a numerical length property.
 *
 * @param {?} v
 * @return {bool}
 */
module.exports = isArrayLike;

function isArrayLike(v) {
  return v && typeof v === "object" && typeof v.length === "number" && typeof v !== "function";
}

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isBoolean.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var isBoolean = _babelHelpers.interopRequire(require("lodash/lang/isBoolean"));

module.exports = isBoolean;

},{"babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","lodash/lang/isBoolean":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isBoolean.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isGraph.js":[function(require,module,exports){
"use strict";

/**
 * Returns true if value is a Graph
 *
 * @param {*} value
 * @return {bool}
 */
module.exports = isGraph;

function isGraph(value) {
  // We are not using instanceof to avoid circular dependencies
  return value && typeof value.addNode === "function";
}

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterable.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

/**
 * Returns true if object implement the @@iterator method.
 *
 * @param {*} obj

 * @return {boolean}
 */
module.exports = isIterable;

function isIterable(obj) {
  return typeof obj[_core.Symbol.iterator] === "function";
}

},{"babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterator.js":[function(require,module,exports){
"use strict";

/**
 * Returns true if object is an iterator
 *
 * @param {*} obj
 *
 * @return {boolean}
 */
module.exports = isIterator;

function isIterator(obj) {
  return typeof obj.next === "function";
}

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isMap.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Tests whether the value is a Map.
 *
 * @param {*} v The value to test
 * @return {bool}
 */
module.exports = isMap;

var Map = _babelHelpers.interopRequire(require("./Map"));

function isMap(v) {
  return v instanceof Map;
}

},{"./Map":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Map.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isPlainObject.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var isPlainObject = _babelHelpers.interopRequire(require("lodash/lang/isPlainObject"));

module.exports = isPlainObject;

},{"babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","lodash/lang/isPlainObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isPlainObject.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isSet.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Tests whether the value is a Map.
 *
 * @param {*} v The value to test
 * @return {bool}
 */
module.exports = isSet;

var Set = _babelHelpers.interopRequire(require("./Set"));

function isSet(v) {
  return v instanceof Set;
}

},{"./Set":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Set.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/mapIterator.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var mapIterator = _regeneratorRuntime.mark(

/**
 * Returns a new iterator which maps every value from the provided iterator via
 * the callback function.
 *
 * @param {Iterator} iterator
 * @param {function} map
 * @param {?=} opt_this_obj
 * @return {Iterator}
 */
function mapIterator(iterator, map, optThisObj) {
  var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, v;

  return _regeneratorRuntime.wrap(function mapIterator$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 3;
        _iterator = _core.$for.getIterator(iterator);

      case 5:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 12;
          break;
        }

        v = _step.value;
        context$1$0.next = 9;
        return map.call(optThisObj, v);

      case 9:
        _iteratorNormalCompletion = true;
        context$1$0.next = 5;
        break;

      case 12:
        context$1$0.next = 18;
        break;

      case 14:
        context$1$0.prev = 14;
        context$1$0.t70 = context$1$0["catch"](3);
        _didIteratorError = true;
        _iteratorError = context$1$0.t70;

      case 18:
        context$1$0.prev = 18;
        context$1$0.prev = 19;

        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }

      case 21:
        context$1$0.prev = 21;

        if (!_didIteratorError) {
          context$1$0.next = 24;
          break;
        }

        throw _iteratorError;

      case 24:
        return context$1$0.finish(21);

      case 25:
        return context$1$0.finish(18);

      case 26:
      case "end":
        return context$1$0.stop();
    }
  }, mapIterator, this, [[3, 14, 18, 26], [19,, 21, 25]]);
});

module.exports = mapIterator;

},{"babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/mapSequence.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Helper to map sequence types (arrays, array-like objects, objects, etc).
 * Note that if an array-like object is passed, an array is returned:
 *
 * Array -> Array
 * ArrayLike -> Array
 * Iterator -> Iterator
 * Iterable -> Iterator
 * Object -> Object
 *
 * @param {Iterable} sequence
 * @param {function(this:T,...)} callback
 * @param {T=} this_obj
 * @template T
 *
 * @return {(Array|Object|Iterator)}
 */
module.exports = mapSequence;

var isPlainObject = _babelHelpers.interopRequire(require("lodash/lang/isPlainObject"));

var mapValues = _babelHelpers.interopRequire(require("lodash/object/mapValues"));

var isArrayLike = _babelHelpers.interopRequire(require("./isArrayLike"));

var isIterable = _babelHelpers.interopRequire(require("./isIterable"));

var isIterator = _babelHelpers.interopRequire(require("./isIterator"));

var mapIterator = _babelHelpers.interopRequire(require("./mapIterator"));

var nativeMap = Array.prototype.map;
function mapSequence(sequence, callback, thisObj) {
  if (isArrayLike(sequence)) {
    return nativeMap.call(sequence, callback, thisObj);
  } else if (isIterable(sequence)) {
    sequence = _core.$for.getIterator(sequence);
  }
  if (isIterator(sequence)) {
    return mapIterator(sequence, callback, thisObj);
  } else if (isPlainObject(sequence)) {
    return mapValues(sequence, callback, thisObj);
  } else {
    throw new TypeError("Can't map value of type %s", typeof sequence);
  }
}

},{"./isArrayLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isArrayLike.js","./isIterable":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterable.js","./isIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterator.js","./mapIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/mapIterator.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","lodash/lang/isPlainObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isPlainObject.js","lodash/object/mapValues":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/mapValues.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/max.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Returns the maximum value from an iterable. It uses the optional callback
 * function to determine the value to compare.
 *
 * @param {Iterable} iterable
 * @param {function(?): ?} map
 * @return {?}
 */
module.exports = max;

var forEach = _babelHelpers.interopRequire(require("./forEach"));

function max(iterable, map) {
  var maxComparisonValue = -Infinity;
  var maxValue;

  forEach(iterable, function (value) {
    var comparisonValue = map ? map(value) : value;
    if (comparisonValue > maxComparisonValue) {
      maxComparisonValue = comparisonValue;
      maxValue = value;
    }
  });

  return maxValue;
}

},{"./forEach":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/forEach.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/message.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

/**
 * Returns true if the value can be properly serialized, otherwise false.
 *
 * @param {*} value
 * @return {boolean}
 */
exports.isSupported = isSupported;
exports.serialize = serialize;
exports.deserialize = deserialize;

var isIterable = _babelHelpers.interopRequire(require("./isIterable"));

var isPlainObject = _babelHelpers.interopRequire(require("./isPlainObject"));

var Map = _babelHelpers.interopRequire(require("./Map"));

var Set = _babelHelpers.interopRequire(require("./Set"));

var classes = _babelHelpers.interopRequireWildcard(require("../classes"));

var KEY = "__type-jsnx__";

/**
 * @fileoverview
 * Helper methods to serialize and unserialize data for communicating with
 * workers.
 */

function serializeSet(value) {
  // TODO: serialize nested values
  return (function () {
    var _ref = {};

    _babelHelpers.defineProperty(_ref, KEY, "Set");

    _babelHelpers.defineProperty(_ref, "data", _core.Array.from(value.values()));

    return _ref;
  })();
}

function deserializeSet(value) {
  return new Set(value.data);
}

function serializeMap(value) {
  // TODO: serialize nested values
  return (function () {
    var _ref = {};

    _babelHelpers.defineProperty(_ref, KEY, "Map");

    _babelHelpers.defineProperty(_ref, "data", (function () {
      var _data = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _core.$for.getIterator(value), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _babelHelpers.slicedToArray(_step.value, 2);

          var k = _step$value[0];
          var v = _step$value[1];

          _data.push([k, serialize(v)]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return _data;
    })());

    return _ref;
  })();
}

function deserializeMap(value) {
  return new Map(value.data.map(function (kv) {
    return (kv[1] = deserialize(kv[1]), kv);
  }));
}

function serializeGraph(value) {
  // TODO: serialize complex edge and node data
  return (function () {
    var _ref = {};

    _babelHelpers.defineProperty(_ref, KEY, value.constructor.__name__);

    _babelHelpers.defineProperty(_ref, "data", value.graph);

    _babelHelpers.defineProperty(_ref, "nodes", _core.Array.from(value.node));

    _babelHelpers.defineProperty(_ref, "edges", value.edges(null, true));

    return _ref;
  })();
}

function deserializeGraph(value) {
  var G = new classes[value[KEY]](value.edges, value.data);
  G.addNodesFrom(value.nodes);
  return G;
}
function isSupported(value) {
  var type = typeof value;
  return (
    // Primitives
    value == null || type === "string" || type === "number" || type === "boolean" ||

    // Objects and arrays (we just assume they contain only primitives)
    isPlainObject(value) || Array.isArray(value) ||

    // Our custom collections (shallow)
    value instanceof Map || value instanceof Set ||

    // Graphs
    value.constructor.__name__ === "Graph" || value.constructor.__name__ === "DiGraph" ||

    // Generic iterables
    isIterable(value)
  );
}

function serialize(value) {
  // primitives
  var type = typeof value;
  if (!value || type === "string" || type === "number" || type === "boolean") {
    return value;
  }
  // Collections
  if (value instanceof Set) {
    return serializeSet(value);
  } else if (value instanceof Map) {
    return serializeMap(value);
  }
  // Graphs
  else if (value.constructor.__name__ === "Graph" || value.constructor.__name__ === "DiGraph") {
    return serializeGraph(value);
  }
  // Iterables
  else if (isIterable(value)) {
    // We keep it simple for now and don't serialize the values of the iterable
    // itself
    return _core.Array.from(value);
  }
  // TODO: Handle arrays and objects better

  // default
  return value;
}

function deserialize(value) {
  // primitives
  var type = typeof value;
  if (!value || type === "string" || type === "number" || type === "boolean") {
    return value;
  }
  // custom serializtion?
  if (value[KEY]) {
    switch (value[KEY]) {
      case "Map":
        return deserializeMap(value);
      case "Set":
        return deserializeSet(value);
      case "Graph":
      case "DiGraph":
        return deserializeGraph(value);
    }
  }
  // TODO: Handle arrays and objects better

  // default
  return value;
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"../classes":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/index.js","./Map":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Map.js","./Set":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Set.js","./isIterable":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterable.js","./isPlainObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isPlainObject.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/next.js":[function(require,module,exports){
"use strict";

/**
 * Returns the next value of an iterator or throws an error if the iterator was
 * already consumed.
 *
 * @param {Iterator} iterator
 * @return {?}
 */
module.exports = next;

function next(iterator) {
  var result = iterator.next();
  if (result.done) {
    throw new Error("Iterator is already exhausted");
  }
  return result.value;
}

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/nodesAreEqual.js":[function(require,module,exports){
"use strict";

/**
 * Returns true if the two values are equal node values. If the values are
 * primitives, they are compared directly. If they are objects, their string
 * representation is compared.
 *
 * @param {Node} a
 * @param {Node} b
 * @return {boolean}
 */
module.exports = nodesAreEqual;

function nodesAreEqual(a, b) {
  return a === b || typeof a === "object" && a.toString() === b.toString();
}

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/range.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Implements Python's range function, returns an array.
 *
 * If one argument n is passed, iterates over 0...n.
 * If two arguments i,j are passed, iterates over i...j.
 * If three arguments i,j,k are passed, iterates over i, i+k, i+2k, ...j
 *
 * @param {?number=} optStart Number to start from
 * @param {?number=} optEnd Number to count to
 * @param {?number=} optStep Step size
 * @return {!Array}
 */
module.exports = range;

var genRange = _babelHelpers.interopRequire(require("./genRange"));

function range(optStart, optEnd, optStep) {
  return _core.Array.from(genRange(optStart, optEnd, optStep));
}

},{"./genRange":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/genRange.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/size.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Returns the number of elements in the container. That is
 * the number of elements in the array or object or the length
 * of a string.
 *
 * @param {(string|Object|ArrayLike|Graph)} obj
 *    Object to determine the length of
 *
 * @return {number} The number of elements
 * @throws {TypeError} When length cannot be determined
 */
module.exports = size;

var isArrayLike = _babelHelpers.interopRequire(require("./isArrayLike"));

var isGraph = _babelHelpers.interopRequire(require("./isGraph"));

var isPlainObject = _babelHelpers.interopRequire(require("lodash/lang/isPlainObject"));

var objectSize = _babelHelpers.interopRequire(require("lodash/collection/size"));

function size(obj) {
  if (isGraph(obj)) {
    return obj.numberOfNodes();
  } else if (typeof obj === "string" || isArrayLike(obj)) {
    return obj.length;
  } else if (isPlainObject(obj)) {
    return objectSize(obj);
  } else {
    throw new TypeError("Expected a graph object, array, string or object, but got %s instead", typeof obj);
  }
}

},{"./isArrayLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isArrayLike.js","./isGraph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isGraph.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","lodash/collection/size":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/collection/size.js","lodash/lang/isPlainObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isPlainObject.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/someIterator.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

/**
 * Returns true if the callback function returns true for any of the elements
 * of the iterator.
 *
 * @param {Iterator} iterator
 * @param {function} callback
 * @return {boolean}
 */
module.exports = someIterator;

function someIterator(iterator, callback) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(iterator), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      if (callback(value)) {
        return true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return false;
}

},{"babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/sprintf.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var sprintf = _babelHelpers.interopRequire(require("tiny-sprintf"));

sprintf.j = function (value) {
  try {
    return JSON.stringify(value);
  } catch (e) {
    return value;
  }
};

module.exports = sprintf;

},{"babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","tiny-sprintf":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/tiny-sprintf/dist/sprintf.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/toIterator.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Returns an iterator object for the given array, array-like object
 * or object. Should behave like Python's iter:
 * http://docs.python.org/library/functions.html#iter
 *
 *
 * The iterator object implements the goog.iter.Iterator interface.
 *
 * @param {Iterable} seq
 * @return {!Iterator}
 */
module.exports = toIterator;

var isArrayLike = _babelHelpers.interopRequire(require("./isArrayLike"));

var isIterator = _babelHelpers.interopRequire(require("./isIterator"));

var isIterable = _babelHelpers.interopRequire(require("./isIterable"));

function toIterator(seq) {
  /*jshint expr:true*/
  if (isIterator(seq)) {
    return seq;
  } else if (isIterable(seq)) {
    return _core.$for.getIterator(seq);
  } else if (Array.isArray(seq) || isArrayLike(seq)) {
    return _regeneratorRuntime.mark(function callee$1$0(seq) {
      var i, l;
      return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            i = 0, l = seq.length;

          case 1:
            if (!(i < l)) {
              context$2$0.next = 7;
              break;
            }

            context$2$0.next = 4;
            return seq[i];

          case 4:
            i++;
            context$2$0.next = 1;
            break;

          case 7:
          case "end":
            return context$2$0.stop();
        }
      }, callee$1$0, this);
    })(seq);
  } else {
    throw new TypeError("Unable to convert " + seq + " to an iterator");
  }
}

},{"./isArrayLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isArrayLike.js","./isIterable":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterable.js","./isIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterator.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/tuple.js":[function(require,module,exports){
"use strict";

/**
 * This function always returns the same instance of an array for a given number
 * of arguments.
 * It should be used instead of creating temporary arrays, if the arrays are
 * consumed immediately anyways.
 *
 * @param {...*} var_args The elemens of the tuple
 * @return {Array}
 */
exports.tuple2 = tuple2;
exports.tuple3 = tuple3;
exports.tuple4 = tuple4;

/**
 * Same as tuple2, but sets the values on container instead of the allocated
 * array here. Useful to reuse an existing array.
 *
 * @param {...*} var_args The elemens of the tuple
 * @param {Array} opt_container If present, set values there instead
 * @return {Array}
 */
exports.tuple2c = tuple2c;
exports.tuple3c = tuple3c;
exports.tuple4c = tuple4c;
exports.createTupleFactory = createTupleFactory;

var t2 = new Array(2);
var t3 = new Array(3);
var t4 = new Array(4);
function tuple2(x, y) {
  t2[0] = x;
  t2[1] = y;
  return t2;
}

function tuple3(x, y, z) {
  t3[0] = x;
  t3[1] = y;
  t3[2] = z;
  return t3;
}

function tuple4(a, b, c, d) {
  t4[0] = a;
  t4[1] = b;
  t4[2] = c;
  t4[3] = d;
  return t4;
}

function tuple2c(x, y, container) {
  container.length = 2;
  container[0] = x;
  container[1] = y;
  return container;
}

function tuple3c(x, y, z, container) {
  container.length = 3;
  container[0] = x;
  container[1] = y;
  container[2] = z;
  return container;
}

function tuple4c(a, b, c, d, container) {
  container.length = 4;
  container[0] = a;
  container[1] = b;
  container[2] = c;
  container[3] = d;
  return container;
}

function createTupleFactory(count) {
  var t = new Array(count);
  switch (count) {
    case 2:
      return function (a, b) {
        t[0] = a;
        t[1] = b;
        return t;
      };
    case 3:
      return function (a, b, c) {
        t[0] = a;
        t[1] = b;
        t[2] = c;
        return t;
      };
    default:
      throw new Error("Typle size not supported.");
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/zipIterator.js":[function(require,module,exports){
"use strict";

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var zipIterator = _regeneratorRuntime.mark(

/**
 * Takes a number of iterators and returns a new iterator which emits an array
 * of each of the iterators next values. Stops when the shortest iterator is
 * exhausted.
 *
 * @param {...Iterator} var_args
 * @return {Iterator}
 */
function zipIterator() {
  var _arguments = arguments;
  var varArgs, length, done, nextZip, i, next;
  return _regeneratorRuntime.wrap(function zipIterator$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        varArgs = _arguments;
        length = varArgs.length;

      case 2:
        if (!true) {
          context$1$0.next = 21;
          break;
        }

        done = false;
        nextZip = new Array(length);
        i = 0;

      case 6:
        if (!(i < length)) {
          context$1$0.next = 15;
          break;
        }

        next = varArgs[i].next();

        if (!next.done) {
          context$1$0.next = 11;
          break;
        }

        done = true;
        return context$1$0.abrupt("break", 15);

      case 11:
        nextZip[i] = next.value;

      case 12:
        i++;
        context$1$0.next = 6;
        break;

      case 15:
        if (!done) {
          context$1$0.next = 17;
          break;
        }

        return context$1$0.abrupt("break", 21);

      case 17:
        context$1$0.next = 19;
        return nextZip;

      case 19:
        context$1$0.next = 2;
        break;

      case 21:
      case "end":
        return context$1$0.stop();
    }
  }, zipIterator, this);
});

module.exports = zipIterator;

// TODO: Use rest parameter once 6to5 is fixed (2.0)

},{"babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/zipSequence.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Helper to zip sequence types (arrays, array-like objects, objects, etc).
 * All arguments must be the same type. The first argument is used to determine
 * the type.
 * This behaves the same as Python's zip function, i.e. the result has the
 * length of the shortest input.
 *
 * Array -> Array
 * Array-like -> Array
 * Iterator -> Iterator
 *
 * @param {...(Iterable)} var_args
 *
 * @return {!(Array|Iterator)}
 */
module.exports = zipSequence;

var isArrayLike = _babelHelpers.interopRequire(require("./isArrayLike"));

var isIterator = _babelHelpers.interopRequire(require("./isIterator"));

var zipIterator = _babelHelpers.interopRequire(require("./zipIterator"));

function zipArray() {
  for (var _len = arguments.length, varArgs = Array(_len), _key = 0; _key < _len; _key++) {
    varArgs[_key] = arguments[_key];
  }

  // Pre-allocation arrays speeds up assignment drastically, so we want to
  // optimize for that case
  var length = varArgs.length;
  var min = Infinity;
  var i;
  var result;
  var nextZip = new Array(length);

  // first pass
  for (i = 0; i < length; i++) {
    var array = varArgs[i];
    var arrayLength = array.length;
    if (arrayLength < min) {
      min = arrayLength;
      if (min === 0) {
        return []; // backout early
      }
    }
    nextZip[i] = array[0];
  }
  result = new Array(min);
  result[0] = nextZip;

  for (i = 1; i < min; i++) {
    nextZip = new Array(length);
    for (var j = 0; j < length; j++) {
      nextZip[j] = varArgs[j][i];
    }
    result[i] = nextZip;
  }
  return result;
}
function zipSequence() {
  for (var _len = arguments.length, varArgs = Array(_len), _key = 0; _key < _len; _key++) {
    varArgs[_key] = arguments[_key];
  }

  var first = varArgs[0];

  if (isArrayLike(first)) {
    return zipArray.apply(null, varArgs);
  } else if (isIterator(first)) {
    return zipIterator.apply(null, varArgs);
  } else {
    throw new TypeError("Expected an iterator, array-like object or object, but got %s instead", first);
  }
}

},{"./isArrayLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isArrayLike.js","./isIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/isIterator.js","./zipIterator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/zipIterator.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/centrality/betweenness.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

exports.betweennessCentrality = betweennessCentrality;
exports.genBetweennessCentrality = genBetweennessCentrality;
exports.edgeBetweennessCentrality = edgeBetweennessCentrality;
exports.genEdgeBetweennessCentrality = genEdgeBetweennessCentrality;

var delegate = _babelHelpers.interopRequire(require("../../_internals/delegate"));

"use strict";

var _internals = require("../../_internals");

var Arrays = _internals.Arrays;
var Map = _internals.Map;
var PriorityQueue = _internals.PriorityQueue;
var getDefault = _internals.getDefault;
var tuple2 = _internals.tuple2;

var betweennessCentralityArgs;

function betweennessCentrality(G) {
  var _this = this;

  var optArgDict = arguments[1] === undefined ? {} : arguments[1];

  // TODO: Use destructuring defaults once 6to5 supports it
  // {k=null, normalized=true, weight=null, endpoints=false}
  var k = optArgDict.k;
  var normalized = optArgDict.normalized;
  var weight = optArgDict.weight;
  var endpoints = optArgDict.endpoints;

  normalized = normalized == null ? true : normalized;
  endpoints = endpoints == null ? false : endpoints;

  var betweenness = new Map(_regeneratorRuntime.mark(function callee$1$0() {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, v;

    return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 3;
          _iterator = _core.$for.getIterator(G);

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            context$2$0.next = 12;
            break;
          }

          v = _step.value;
          context$2$0.next = 9;
          return tuple2(v, 0);

        case 9:
          _iteratorNormalCompletion = true;
          context$2$0.next = 5;
          break;

        case 12:
          context$2$0.next = 18;
          break;

        case 14:
          context$2$0.prev = 14;
          context$2$0.t71 = context$2$0["catch"](3);
          _didIteratorError = true;
          _iteratorError = context$2$0.t71;

        case 18:
          context$2$0.prev = 18;
          context$2$0.prev = 19;

          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }

        case 21:
          context$2$0.prev = 21;

          if (!_didIteratorError) {
            context$2$0.next = 24;
            break;
          }

          throw _iteratorError;

        case 24:
          return context$2$0.finish(21);

        case 25:
          return context$2$0.finish(18);

        case 26:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, _this, [[3, 14, 18, 26], [19,, 21, 25]]);
  })());

  var nodes = G.nodes();
  if (k != null) {
    nodes = Arrays.sample(nodes, k);
  }

  nodes.forEach(function (s) {
    // single source shortest paths

    var _ref = weight == null ? singleSourceShortestPathBasic(G, s) : // use BFS
    singleSourceDijkstraPathBasic(G, s, weight);

    var _ref2 = _babelHelpers.slicedToArray(_ref, 3);

    var S = _ref2[0];
    var P = _ref2[1];
    var sigma = _ref2[2];
    // use Dijkstra's algorithm
    // accumulation
    betweenness = endpoints ? accumulateEndpoints(betweenness, S, P, sigma, s) : accumulateBasic(betweenness, S, P, sigma, s);
  });
  // rescaling
  return rescale(betweenness, G.order(), normalized, G.isDirected(), k);
}

function genBetweennessCentrality(G, optArgDict) {
  return delegate("betweennessCentrality", [G, optArgDict]);
}

;

var edgeBetweennessCentralityArgs;

function edgeBetweennessCentrality(G) {
  var _this = this;

  var optArgDict = arguments[1] === undefined ? {} : arguments[1];

  // TODO: Use destructuring defaults once 6to5 supports it
  var normalized = optArgDict.normalized;
  var weight = optArgDict.weight;

  normalized = normalized == null ? true : normalized;

  var betweenness = new Map(_regeneratorRuntime.mark(function callee$1$0() {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, v;

    return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 3;
          _iterator = _core.$for.getIterator(G);

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            context$2$0.next = 12;
            break;
          }

          v = _step.value;
          context$2$0.next = 9;
          return tuple2(v, 0);

        case 9:
          _iteratorNormalCompletion = true;
          context$2$0.next = 5;
          break;

        case 12:
          context$2$0.next = 18;
          break;

        case 14:
          context$2$0.prev = 14;
          context$2$0.t72 = context$2$0["catch"](3);
          _didIteratorError = true;
          _iteratorError = context$2$0.t72;

        case 18:
          context$2$0.prev = 18;
          context$2$0.prev = 19;

          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }

        case 21:
          context$2$0.prev = 21;

          if (!_didIteratorError) {
            context$2$0.next = 24;
            break;
          }

          throw _iteratorError;

        case 24:
          return context$2$0.finish(21);

        case 25:
          return context$2$0.finish(18);

        case 26:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, _this, [[3, 14, 18, 26], [19,, 21, 25]]);
  })());
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(G.edgesIter()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var edge = _step.value;

      betweenness.set(edge, 0);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var nodes = G.nodes();
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = _core.$for.getIterator(G), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var s = _step2.value;

      // single source shortest paths

      var _ref = weight == null ? singleSourceShortestPathBasic(G, s) : // use BFS
      singleSourceDijkstraPathBasic(G, s, weight);

      var _ref2 = _babelHelpers.slicedToArray(_ref, 3);

      var S = _ref2[0];
      var P = _ref2[1];
      var sigma = _ref2[2];
      // use Dijkstra's algorithm
      // accumulation
      betweenness = accumulateEdges(betweenness, S, P, sigma, s);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  // rescaling
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = _core.$for.getIterator(G), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var n = _step3.value;

      betweenness["delete"](n);
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return rescaleE(betweenness, G.order(), normalized, G.isDirected());
}

function genEdgeBetweennessCentrality(G, optArgDict) {
  return delegate("edgeBetweennessCentrality", [G, optArgDict]);
}

;

function singleSourceShortestPathBasic(G, s) {
  var _this = this;

  var S = [];
  var P = new Map(_regeneratorRuntime.mark(function callee$1$0() {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _v;

    return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 3;
          _iterator = _core.$for.getIterator(G);

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            context$2$0.next = 12;
            break;
          }

          _v = _step.value;
          context$2$0.next = 9;
          return tuple2(_v, []);

        case 9:
          _iteratorNormalCompletion = true;
          context$2$0.next = 5;
          break;

        case 12:
          context$2$0.next = 18;
          break;

        case 14:
          context$2$0.prev = 14;
          context$2$0.t73 = context$2$0["catch"](3);
          _didIteratorError = true;
          _iteratorError = context$2$0.t73;

        case 18:
          context$2$0.prev = 18;
          context$2$0.prev = 19;

          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }

        case 21:
          context$2$0.prev = 21;

          if (!_didIteratorError) {
            context$2$0.next = 24;
            break;
          }

          throw _iteratorError;

        case 24:
          return context$2$0.finish(21);

        case 25:
          return context$2$0.finish(18);

        case 26:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, _this, [[3, 14, 18, 26], [19,, 21, 25]]);
  })());
  var sigma = new Map(_regeneratorRuntime.mark(function callee$1$1() {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _v;

    return _regeneratorRuntime.wrap(function callee$1$1$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 3;
          _iterator = _core.$for.getIterator(G);

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            context$2$0.next = 12;
            break;
          }

          _v = _step.value;
          context$2$0.next = 9;
          return tuple2(_v, 0);

        case 9:
          _iteratorNormalCompletion = true;
          context$2$0.next = 5;
          break;

        case 12:
          context$2$0.next = 18;
          break;

        case 14:
          context$2$0.prev = 14;
          context$2$0.t74 = context$2$0["catch"](3);
          _didIteratorError = true;
          _iteratorError = context$2$0.t74;

        case 18:
          context$2$0.prev = 18;
          context$2$0.prev = 19;

          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }

        case 21:
          context$2$0.prev = 21;

          if (!_didIteratorError) {
            context$2$0.next = 24;
            break;
          }

          throw _iteratorError;

        case 24:
          return context$2$0.finish(21);

        case 25:
          return context$2$0.finish(18);

        case 26:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$1, _this, [[3, 14, 18, 26], [19,, 21, 25]]);
  })());
  var D = new Map();

  sigma.set(s, 1);
  D.set(s, 0);
  var Q = [s];
  while (Q.length > 0) {
    // use BFS to find shortest paths
    var v = Q.shift();
    S.push(v);
    var Dv = D.get(v);
    var sigmav = sigma.get(v);
    G.neighbors(v).forEach(function (w) {
      if (!D.has(w)) {
        Q.push(w);
        D.set(w, Dv + 1);
      }
      if (D.get(w) === Dv + 1) {
        // this is a shortest path, count paths
        sigma.set(w, sigma.get(w) + sigmav);
        P.get(w).push(v); // predecessors
      }
    });
  }
  return [S, P, sigma];
}

function singleSourceDijkstraPathBasic(G, s) {
  var _this = this;

  var weight = arguments[2] === undefined ? "weight" : arguments[2];

  // modified from Eppstein
  var S = [];
  var P = new Map(_regeneratorRuntime.mark(function callee$1$0() {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _v;

    return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 3;
          _iterator = _core.$for.getIterator(G);

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            context$2$0.next = 12;
            break;
          }

          _v = _step.value;
          context$2$0.next = 9;
          return tuple2(_v, []);

        case 9:
          _iteratorNormalCompletion = true;
          context$2$0.next = 5;
          break;

        case 12:
          context$2$0.next = 18;
          break;

        case 14:
          context$2$0.prev = 14;
          context$2$0.t75 = context$2$0["catch"](3);
          _didIteratorError = true;
          _iteratorError = context$2$0.t75;

        case 18:
          context$2$0.prev = 18;
          context$2$0.prev = 19;

          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }

        case 21:
          context$2$0.prev = 21;

          if (!_didIteratorError) {
            context$2$0.next = 24;
            break;
          }

          throw _iteratorError;

        case 24:
          return context$2$0.finish(21);

        case 25:
          return context$2$0.finish(18);

        case 26:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, _this, [[3, 14, 18, 26], [19,, 21, 25]]);
  })());
  var sigma = new Map(_regeneratorRuntime.mark(function callee$1$1() {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _v;

    return _regeneratorRuntime.wrap(function callee$1$1$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 3;
          _iterator = _core.$for.getIterator(G);

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            context$2$0.next = 12;
            break;
          }

          _v = _step.value;
          context$2$0.next = 9;
          return tuple2(_v, 0);

        case 9:
          _iteratorNormalCompletion = true;
          context$2$0.next = 5;
          break;

        case 12:
          context$2$0.next = 18;
          break;

        case 14:
          context$2$0.prev = 14;
          context$2$0.t76 = context$2$0["catch"](3);
          _didIteratorError = true;
          _iteratorError = context$2$0.t76;

        case 18:
          context$2$0.prev = 18;
          context$2$0.prev = 19;

          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }

        case 21:
          context$2$0.prev = 21;

          if (!_didIteratorError) {
            context$2$0.next = 24;
            break;
          }

          throw _iteratorError;

        case 24:
          return context$2$0.finish(21);

        case 25:
          return context$2$0.finish(18);

        case 26:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$1, _this, [[3, 14, 18, 26], [19,, 21, 25]]);
  })());
  var D = new Map();

  sigma.set(s, 1);
  var seen = new Map([tuple2(s, 0)]);
  // use Q as heap with (distance,node id) tuples
  var Q = new PriorityQueue();
  Q.enqueue(0, [s, s]);
  while (Q.size > 0) {
    var _Q$dequeue = Q.dequeue();

    var _Q$dequeue2 = _babelHelpers.slicedToArray(_Q$dequeue, 2);

    var dist = _Q$dequeue2[0];

    var _Q$dequeue2$1 = _babelHelpers.slicedToArray(_Q$dequeue2[1], 2);

    var pred = _Q$dequeue2$1[0];
    var v = _Q$dequeue2$1[1];

    if (D.has(v)) {
      continue; // already searched this node.
    }
    sigma.set(v, sigma.get(v) + sigma.get(pred)); // count paths
    S.push(v);
    D.set(v, dist);

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(G.get(v)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _babelHelpers.slicedToArray(_step.value, 2);

        var w = _step$value[0];
        var edgedata = _step$value[1];

        var vw_dist = dist + getDefault(edgedata[weight], 1);
        if (!D.has(w) && (!seen.has(w) || vw_dist < seen.get(w))) {
          seen.set(w, vw_dist);
          Q.enqueue(vw_dist, [v, w]);
          sigma.set(w, 0);
          P.set(w, [v]);
        } else if (vw_dist === seen.get(w)) {
          // handle equal paths
          sigma.set(w, sigma.get(w) + sigma.get(v));
          P.get(w).push(v);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
  return [S, P, sigma];
}

function accumulateBasic(betweenness, S, P, sigma, s) {
  var _this = this;

  var delta = new Map(_regeneratorRuntime.mark(function callee$1$0() {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _s;

    return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 3;
          _iterator = _core.$for.getIterator(S);

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            context$2$0.next = 12;
            break;
          }

          _s = _step.value;
          context$2$0.next = 9;
          return tuple2(_s, 0);

        case 9:
          _iteratorNormalCompletion = true;
          context$2$0.next = 5;
          break;

        case 12:
          context$2$0.next = 18;
          break;

        case 14:
          context$2$0.prev = 14;
          context$2$0.t77 = context$2$0["catch"](3);
          _didIteratorError = true;
          _iteratorError = context$2$0.t77;

        case 18:
          context$2$0.prev = 18;
          context$2$0.prev = 19;

          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }

        case 21:
          context$2$0.prev = 21;

          if (!_didIteratorError) {
            context$2$0.next = 24;
            break;
          }

          throw _iteratorError;

        case 24:
          return context$2$0.finish(21);

        case 25:
          return context$2$0.finish(18);

        case 26:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, _this, [[3, 14, 18, 26], [19,, 21, 25]]);
  })());

  while (S.length > 0) {
    var w = S.pop();
    var coeff = (1 + delta.get(w)) / sigma.get(w);
    P.get(w).forEach(function (v) {
      delta.set(v, delta.get(v) + sigma.get(v) * coeff);
    });
    // handle object nodes
    if (w !== s || typeof w === "object" && w.toString() !== s.toString()) {
      betweenness.set(w, betweenness.get(w) + delta.get(w));
    }
  }
  return betweenness;
}

function accumulateEndpoints(betweenness, S, P, sigma, s) {
  var _this = this;

  betweenness.set(s, betweenness.get(s) + S.length - 1);
  var delta = new Map(_regeneratorRuntime.mark(function callee$1$0() {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _s;

    return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 3;
          _iterator = _core.$for.getIterator(S);

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            context$2$0.next = 12;
            break;
          }

          _s = _step.value;
          context$2$0.next = 9;
          return tuple2(_s, 0);

        case 9:
          _iteratorNormalCompletion = true;
          context$2$0.next = 5;
          break;

        case 12:
          context$2$0.next = 18;
          break;

        case 14:
          context$2$0.prev = 14;
          context$2$0.t78 = context$2$0["catch"](3);
          _didIteratorError = true;
          _iteratorError = context$2$0.t78;

        case 18:
          context$2$0.prev = 18;
          context$2$0.prev = 19;

          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }

        case 21:
          context$2$0.prev = 21;

          if (!_didIteratorError) {
            context$2$0.next = 24;
            break;
          }

          throw _iteratorError;

        case 24:
          return context$2$0.finish(21);

        case 25:
          return context$2$0.finish(18);

        case 26:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, _this, [[3, 14, 18, 26], [19,, 21, 25]]);
  })());

  while (S.length > 0) {
    var w = S.pop();
    var coeff = (1 + delta.get(w)) / sigma.get(w);
    P.get(w).forEach(function (v) {
      delta.set(v, delta.get(v) + sigma.get(v) * coeff);
    });
    // handle object nodes
    if (w !== s || typeof w === "object" && w.toString() !== s.toString()) {
      betweenness.set(w, betweenness.get(w) + delta.get(w) + 1);
    }
  }
  return betweenness;
}

function accumulateEdges(betweenness, S, P, sigma, s) {
  var _this = this;

  var delta = new Map(_regeneratorRuntime.mark(function callee$1$0() {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _s;

    return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 3;
          _iterator = _core.$for.getIterator(S);

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            context$2$0.next = 12;
            break;
          }

          _s = _step.value;
          context$2$0.next = 9;
          return tuple2(_s, 0);

        case 9:
          _iteratorNormalCompletion = true;
          context$2$0.next = 5;
          break;

        case 12:
          context$2$0.next = 18;
          break;

        case 14:
          context$2$0.prev = 14;
          context$2$0.t79 = context$2$0["catch"](3);
          _didIteratorError = true;
          _iteratorError = context$2$0.t79;

        case 18:
          context$2$0.prev = 18;
          context$2$0.prev = 19;

          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }

        case 21:
          context$2$0.prev = 21;

          if (!_didIteratorError) {
            context$2$0.next = 24;
            break;
          }

          throw _iteratorError;

        case 24:
          return context$2$0.finish(21);

        case 25:
          return context$2$0.finish(18);

        case 26:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, _this, [[3, 14, 18, 26], [19,, 21, 25]]);
  })());

  while (S.length > 0) {
    var w = S.pop();
    var coeff = (1 + delta.get(w)) / sigma.get(w);
    P.get(w).forEach(function (v) {
      var c = sigma.get(v) * coeff;
      var edge = [v, w];
      if (!betweenness.has(edge)) {
        edge = [w, v];
      }
      betweenness.set(edge, betweenness.get(edge) + c);
      delta.set(v, delta.get(v) + c);
    });
    // handle object nodes
    if (w !== s || typeof w === "object" && w.toString() !== s.toString()) {
      betweenness.set(w, betweenness.get(w) + delta.get(w));
    }
  }
  return betweenness;
}

function rescale(betweenness, n, optNormalized, _x, optK) {
  var optDirected = arguments[3] === undefined ? false : arguments[3];

  var scale;
  if (optNormalized) {
    scale = n <= 2 ? null : 1 / ((n - 1) * (n - 2));
  } else {
    // rescale by 2 for undirected graphs
    scale = !optDirected ? 1 / 2 : null;
  }
  if (scale != null) {
    if (optK != null) {
      scale = scale * n / optK;
    }
    betweenness.forEach(function (v, k) {
      return betweenness.set(k, v * scale);
    });
  }
  return betweenness;
}

function rescaleE(betweenness, n, optNormalized, optDirected) {
  var scale;
  if (optNormalized) {
    scale = n <= 1 ? null : 1 / (n * (n - 1));
  } else {
    // rescale by 2 for undirected graphs
    scale = !optDirected ? 1 / 2 : null;
  }
  if (scale != null) {
    betweenness.forEach(function (v, k) {
      return betweenness.set(k, v * scale);
    });
  }
  return betweenness;
}
Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"../../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../../_internals/delegate":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/delegateToWorker.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/centrality/index.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _betweenness = require("./betweenness");

var betweenness = _babelHelpers.interopRequireWildcard(_betweenness);

exports.betweenness = betweenness;

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_betweenness));

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"./betweenness":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/centrality/betweenness.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/clique.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var findCliques = _regeneratorRuntime.mark(function findCliques(G) {
  var adj, subgraph, candidates, Q, u, ext_u, stack, q, adj_q, subgraph_q, candidates_q, _ref, _ref2;

  return _regeneratorRuntime.wrap(function findCliques$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!(G.numberOfNodes() === 0)) {
          context$1$0.next = 2;
          break;
        }

        return context$1$0.abrupt("return", []);

      case 2:
        adj = new Map(mapIterator(G, function (u) {
          var neighbors = new Set(G.neighborsIter(u));
          neighbors["delete"](u);
          return tuple2(u, neighbors);
        }));
        subgraph = new Set(G);
        candidates = new Set(G);
        Q = [null];
        u = max(subgraph, function (u) {
          return candidates.intersection(adj.get(u)).size;
        });
        ext_u = candidates.difference(adj.get(u));
        stack = [];

      case 9:
        if (!true) {
          context$1$0.next = 35;
          break;
        }

        if (!(ext_u.size > 0)) {
          context$1$0.next = 25;
          break;
        }

        q = ext_u.pop();

        candidates["delete"](q);
        Q[Q.length - 1] = q;
        adj_q = adj.get(q);
        subgraph_q = subgraph.intersection(adj_q);

        if (!(subgraph_q.size === 0)) {
          context$1$0.next = 21;
          break;
        }

        context$1$0.next = 19;
        return Q.slice();

      case 19:
        context$1$0.next = 23;
        break;

      case 21:
        candidates_q = candidates.intersection(adj_q);

        if (candidates_q.size > 0) {
          stack.push([subgraph, candidates, ext_u]);
          Q.push(null);
          subgraph = subgraph_q;
          candidates = candidates_q;
          u = max(subgraph, function (u) {
            return candidates.intersection(adj.get(u)).size;
          });
          ext_u = candidates.difference(adj.get(u));
        }

      case 23:
        context$1$0.next = 33;
        break;

      case 25:
        if (!(Q.length === 0 || stack.length === 0)) {
          context$1$0.next = 27;
          break;
        }

        return context$1$0.abrupt("break", 35);

      case 27:
        Q.pop();
        _ref = stack.pop();
        _ref2 = _babelHelpers.slicedToArray(_ref, 3);
        subgraph = _ref2[0];
        candidates = _ref2[1];
        ext_u = _ref2[2];

      case 33:
        context$1$0.next = 9;
        break;

      case 35:
      case "end":
        return context$1$0.stop();
    }
  }, findCliques, this);
});

var findCliquesRecursive = _regeneratorRuntime.mark(function findCliquesRecursive(G) {
  var expand = _regeneratorRuntime.mark(function expand(subgraph, candidates) {
    var u, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, q, adj_q, subgraph_q, candidates_q;

    return _regeneratorRuntime.wrap(function expand$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          u = max(subgraph, function (u) {
            return candidates.intersection(adj.get(u)).size;
          });
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 4;
          _iterator = _core.$for.getIterator(candidates.difference(adj.get(u)));

        case 6:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            context$2$0.next = 24;
            break;
          }

          q = _step.value;

          candidates["delete"](q);
          Q.push(q);
          adj_q = adj.get(q);
          subgraph_q = subgraph.intersection(adj_q);

          if (!(subgraph_q.size === 0)) {
            context$2$0.next = 17;
            break;
          }

          context$2$0.next = 15;
          return Q.slice();

        case 15:
          context$2$0.next = 20;
          break;

        case 17:
          candidates_q = candidates.intersection(adj_q);

          if (!(candidates_q.size > 0)) {
            context$2$0.next = 20;
            break;
          }

          return context$2$0.delegateYield(expand(subgraph_q, candidates_q), "t58", 20);

        case 20:
          Q.pop();

        case 21:
          _iteratorNormalCompletion = true;
          context$2$0.next = 6;
          break;

        case 24:
          context$2$0.next = 30;
          break;

        case 26:
          context$2$0.prev = 26;
          context$2$0.t59 = context$2$0["catch"](4);
          _didIteratorError = true;
          _iteratorError = context$2$0.t59;

        case 30:
          context$2$0.prev = 30;
          context$2$0.prev = 31;

          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }

        case 33:
          context$2$0.prev = 33;

          if (!_didIteratorError) {
            context$2$0.next = 36;
            break;
          }

          throw _iteratorError;

        case 36:
          return context$2$0.finish(33);

        case 37:
          return context$2$0.finish(30);

        case 38:
        case "end":
          return context$2$0.stop();
      }
    }, expand, this, [[4, 26, 30, 38], [31,, 33, 37]]);
  });

  var adj, Q;
  return _regeneratorRuntime.wrap(function findCliquesRecursive$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!(G.size === 0)) {
          context$1$0.next = 3;
          break;
        }

        context$1$0.next = 3;
        return [];

      case 3:
        adj = new Map(mapIterator(G, function (u) {
          var neighbors = new Set(G.neighborsIter(u));
          neighbors["delete"](u);
          return tuple2(u, neighbors);
        }));
        Q = [];
        return context$1$0.delegateYield(expand(new Set(G), new Set(G)), "t60", 6);

      case 6:
      case "end":
        return context$1$0.stop();
    }
  }, findCliquesRecursive, this);
});

exports.findCliques = findCliques;
exports.genFindCliques = genFindCliques;
exports.findCliquesRecursive = findCliquesRecursive;
exports.genFindCliquesRecursive = genFindCliquesRecursive;
exports.graphCliqueNumber = graphCliqueNumber;
exports.genGraphCliqueNumber = genGraphCliqueNumber;
exports.graphNumberOfCliques = graphNumberOfCliques;
exports.genGraphNumberOfCliques = genGraphNumberOfCliques;
exports.numberOfCliques = numberOfCliques;
exports.genNumberOfCliques = genNumberOfCliques;

var delegate = _babelHelpers.interopRequire(require("../_internals/delegate"));

"use strict";

var _internals = require("../_internals");

var Map = _internals.Map;
var Set = _internals.Set;
var mapIterator = _internals.mapIterator;
var max = _internals.max;
var tuple2 = _internals.tuple2;

function genFindCliques(G) {
  return delegate("findCliques", [G]);
}

;

function genFindCliquesRecursive(G) {
  return delegate("findCliquesRecursive", [G]);
}

;

function graphCliqueNumber(G, optCliques) {
  if (optCliques == null) {
    optCliques = findCliques(G);
  }
  return max(optCliques, function (c) {
    return c.length;
  }).length;
}

function genGraphCliqueNumber(G, optCliques) {
  return delegate("graphCliqueNumber", [G, optCliques]);
}

;

function graphNumberOfCliques(G, optCliques) {
  if (optCliques == null) {
    optCliques = findCliques(G);
  }
  return _core.Array.from(optCliques).length;
}

function genGraphNumberOfCliques(G, optCliques) {
  return delegate("graphNumberOfCliques", [G, optCliques]);
}

;

function numberOfCliques(G, optNodes, optCliques) {
  optCliques = _core.Array.from(optCliques || findCliques(G));

  if (optNodes == null) {
    optNodes = G.nodes(); // none, get entire graph
  }

  var numcliq;
  if (!Array.isArray(optNodes)) {
    var v = optNodes;
    numcliq = optCliques.filter(function (c) {
      return new Set(c).has(v);
    }).length;
  } else {
    optCliques = optCliques.map(function (c) {
      return new Set(c);
    });
    numcliq = new Map();
    optNodes.forEach(function (v) {
      numcliq.set(v, optCliques.filter(function (c) {
        return c.has(v);
      }).length);
    });
  }
  return numcliq;
}

function genNumberOfCliques(G, optNodes, optCliques) {
  return delegate("numberOfCliques", [G, optNodes, optCliques]);
}

;
Object.defineProperty(exports, "__esModule", {
  value: true
});

/*jshint ignore:start*/

/*jshint ignore:end*/

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../_internals/delegate":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/delegateToWorker.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/cluster.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var trianglesAndDegreeIter = _regeneratorRuntime.mark(function trianglesAndDegreeIter(G, optNodes) {
  var nodesNbrs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, v, vNbrs, vset, ntriangles, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, w, wset;

  return _regeneratorRuntime.wrap(function trianglesAndDegreeIter$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!G.isMultigraph()) {
          context$1$0.next = 2;
          break;
        }

        throw new JSNetworkXError("Not defined for multigraphs.");

      case 2:
        nodesNbrs = mapIterator(optNodes == null ? G : G.nbunchIter(optNodes), function (n) {
          return tuple2(n, G.get(n));
        });
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 6;
        _iterator = _core.$for.getIterator(nodesNbrs);

      case 8:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 39;
          break;
        }

        _step$value = _babelHelpers.slicedToArray(_step.value, 2);
        v = _step$value[0];
        vNbrs = _step$value[1];
        vset = new Set(vNbrs.keys());

        vset["delete"](v);
        ntriangles = 0;
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 18;

        for (_iterator2 = _core.$for.getIterator(vset); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          w = _step2.value;
          wset = new Set(G.get(w).keys());

          wset["delete"](w);
          ntriangles += vset.intersection(wset).size;
        }
        context$1$0.next = 26;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t61 = context$1$0["catch"](18);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t61;

      case 26:
        context$1$0.prev = 26;
        context$1$0.prev = 27;

        if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
          _iterator2["return"]();
        }

      case 29:
        context$1$0.prev = 29;

        if (!_didIteratorError2) {
          context$1$0.next = 32;
          break;
        }

        throw _iteratorError2;

      case 32:
        return context$1$0.finish(29);

      case 33:
        return context$1$0.finish(26);

      case 34:
        context$1$0.next = 36;
        return tuple3(v, vset.size, ntriangles);

      case 36:
        _iteratorNormalCompletion = true;
        context$1$0.next = 8;
        break;

      case 39:
        context$1$0.next = 45;
        break;

      case 41:
        context$1$0.prev = 41;
        context$1$0.t62 = context$1$0["catch"](6);
        _didIteratorError = true;
        _iteratorError = context$1$0.t62;

      case 45:
        context$1$0.prev = 45;
        context$1$0.prev = 46;

        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }

      case 48:
        context$1$0.prev = 48;

        if (!_didIteratorError) {
          context$1$0.next = 51;
          break;
        }

        throw _iteratorError;

      case 51:
        return context$1$0.finish(48);

      case 52:
        return context$1$0.finish(45);

      case 53:
      case "end":
        return context$1$0.stop();
    }
  }, trianglesAndDegreeIter, this, [[6, 41, 45, 53], [18, 22, 26, 34], [27,, 29, 33], [46,, 48, 52]]);
});

var weightedTrianglesAndDegreeIter = _regeneratorRuntime.mark(function weightedTrianglesAndDegreeIter(G, optNodes) {
  var optWeight = arguments[2] === undefined ? "weight" : arguments[2];

  var maxWeight, nodesNbrs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, i, nbrs, inbrs, weightedTriangles, seen, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, j, weightij, jnbrs, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, k, weightjk, weightki;

  return _regeneratorRuntime.wrap(function weightedTrianglesAndDegreeIter$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!G.isMultigraph()) {
          context$1$0.next = 2;
          break;
        }

        throw new JSNetworkXError("Not defined for multigraphs.");

      case 2:
        maxWeight = optWeight == null || G.edges().length === 0 ? 1 : max(mapIterator(G.edgesIter(true), function (_ref) {
          var _ref2 = _babelHelpers.slicedToArray(_ref, 3);

          var u = _ref2[0];
          var v = _ref2[1];
          var data = _ref2[2];
          return getDefault(data[optWeight], 1);
        }));
        nodesNbrs = mapIterator(optNodes == null ? G : G.nbunchIter(optNodes), function (n) {
          return tuple2(n, G.get(n));
        });
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 7;
        _iterator = _core.$for.getIterator(nodesNbrs);

      case 9:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 67;
          break;
        }

        _step$value = _babelHelpers.slicedToArray(_step.value, 2);
        i = _step$value[0];
        nbrs = _step$value[1];
        inbrs = new Set(nbrs.keys()).difference([i]);
        weightedTriangles = 0;
        seen = new Set();
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 19;
        _iterator2 = _core.$for.getIterator(inbrs);

      case 21:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 48;
          break;
        }

        j = _step2.value;
        weightij = getDefault(nbrs.get(j)[optWeight], 1) / maxWeight;

        seen.add(j);
        jnbrs = new Set(G.get(j).keys()).difference(seen);
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 29;

        for (_iterator3 = _core.$for.getIterator(inbrs.intersection(jnbrs)); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          k = _step3.value;
          weightjk = getDefault(G.get(j).get(k)[optWeight], 1) / maxWeight;
          weightki = getDefault(nbrs.get(k)[optWeight], 1) / maxWeight;

          weightedTriangles += Math.pow(weightij * weightjk * weightki, 1 / 3);
        }
        context$1$0.next = 37;
        break;

      case 33:
        context$1$0.prev = 33;
        context$1$0.t63 = context$1$0["catch"](29);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t63;

      case 37:
        context$1$0.prev = 37;
        context$1$0.prev = 38;

        if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
          _iterator3["return"]();
        }

      case 40:
        context$1$0.prev = 40;

        if (!_didIteratorError3) {
          context$1$0.next = 43;
          break;
        }

        throw _iteratorError3;

      case 43:
        return context$1$0.finish(40);

      case 44:
        return context$1$0.finish(37);

      case 45:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 21;
        break;

      case 48:
        context$1$0.next = 54;
        break;

      case 50:
        context$1$0.prev = 50;
        context$1$0.t64 = context$1$0["catch"](19);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t64;

      case 54:
        context$1$0.prev = 54;
        context$1$0.prev = 55;

        if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
          _iterator2["return"]();
        }

      case 57:
        context$1$0.prev = 57;

        if (!_didIteratorError2) {
          context$1$0.next = 60;
          break;
        }

        throw _iteratorError2;

      case 60:
        return context$1$0.finish(57);

      case 61:
        return context$1$0.finish(54);

      case 62:
        context$1$0.next = 64;
        return tuple3(i, inbrs.size, weightedTriangles * 2);

      case 64:
        _iteratorNormalCompletion = true;
        context$1$0.next = 9;
        break;

      case 67:
        context$1$0.next = 73;
        break;

      case 69:
        context$1$0.prev = 69;
        context$1$0.t65 = context$1$0["catch"](7);
        _didIteratorError = true;
        _iteratorError = context$1$0.t65;

      case 73:
        context$1$0.prev = 73;
        context$1$0.prev = 74;

        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }

      case 76:
        context$1$0.prev = 76;

        if (!_didIteratorError) {
          context$1$0.next = 79;
          break;
        }

        throw _iteratorError;

      case 79:
        return context$1$0.finish(76);

      case 80:
        return context$1$0.finish(73);

      case 81:
      case "end":
        return context$1$0.stop();
    }
  }, weightedTrianglesAndDegreeIter, this, [[7, 69, 73, 81], [19, 50, 54, 62], [29, 33, 37, 45], [38,, 40, 44], [55,, 57, 61], [74,, 76, 80]]);
});

exports.triangles = triangles;
exports.genTriangles = genTriangles;
exports.averageClustering = averageClustering;
exports.genAverageClustering = genAverageClustering;
exports.clustering = clustering;
exports.genClustering = genClustering;
exports.transitivity = transitivity;
exports.genTransitivity = genTransitivity;
exports.squareClustering = squareClustering;
exports.genSquareClustering = genSquareClustering;

var delegate = _babelHelpers.interopRequire(require("../_internals/delegate"));

"use strict";

var JSNetworkXError = require("../exceptions/JSNetworkXError");

var _internals = require("../_internals");

var Map = _internals.Map;
var Set = _internals.Set;
var genCombinations = _internals.genCombinations;
var getDefault = _internals.getDefault;
var mapIterator = _internals.mapIterator;
var max = _internals.max;
var next = _internals.next;
var tuple2 = _internals.tuple2;
var tuple3 = _internals.tuple3;

function triangles(G, optNodes) {
  if (G.isDirected()) {
    throw new JSNetworkXError("triangles() is not defined for directed graphs.");
  }

  if (optNodes != null && G.hasNode(optNodes)) {
    // return single value
    return Math.floor(next(trianglesAndDegreeIter(G, optNodes))[2] / 2);
  }

  return new Map(mapIterator(trianglesAndDegreeIter(G, optNodes), function (_ref) {
    var _ref2 = _babelHelpers.slicedToArray(_ref, 3);

    var v = _ref2[0];
    var _ = _ref2[1];
    var triangles = _ref2[2];
    return tuple2(v, Math.floor(triangles / 2), v);
  }));
}

function genTriangles(G, optNodes) {
  return delegate("triangles", [G, optNodes]);
}

;

function averageClustering(G, optNodes, optWeight) {
  var optCountZeros = arguments[3] === undefined ? true : arguments[3];

  var clusters = _core.Array.from(clustering(G, optNodes, optWeight).values());

  if (!optCountZeros) {
    clusters = clusters.filter(function (v) {
      return v > 0;
    });
  }
  return clusters.reduce(function (s, x) {
    return s + x;
  }, 0) / clusters.length;
}

function genAverageClustering(G, optNodes, optWeight, optCountZeros) {
  return delegate("averageClustering", [G, optNodes, optWeight, optCountZeros]);
}

;

function clustering(G, optNodes, optWeight) {
  if (G.isDirected()) {
    throw new JSNetworkXError("Clustering algorithms are not defined for directed graphs.");
  }

  var trianglesIter = optWeight == null ? trianglesAndDegreeIter(G, optNodes) : weightedTrianglesAndDegreeIter(G, optNodes, optWeight);

  var clusters = new Map(mapIterator(trianglesIter, function (_ref) {
    var _ref2 = _babelHelpers.slicedToArray(_ref, 3);

    var node = _ref2[0];
    var degree = _ref2[1];
    var triangles = _ref2[2];

    return tuple2(node, triangles === 0 ? 0 : triangles / (degree * (degree - 1)));
  }));

  return G.hasNode(optNodes) ? next(clusters.values()) : clusters;
}

function genClustering(G, optNodes, optWeight) {
  return delegate("clustering", [G, optNodes, optWeight]);
}

;

function transitivity(G) {
  var triangles = 0; // 6 times number of triangles
  var triples = 0; // 2 times number of connected triples

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(trianglesAndDegreeIter(G)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _babelHelpers.slicedToArray(_step.value, 3);

      var node = _step$value[0];
      var degree = _step$value[1];
      var triangles_ = _step$value[2];

      triples += degree * (degree - 1);
      triangles += triangles_;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return triangles === 0 ? 0 : triangles / triples;
}

function genTransitivity(G) {
  return delegate("transitivity", [G]);
}

;

function squareClustering(G, optNodes) {
  var nodesIter = optNodes == null ? G : G.nbunchIter(optNodes);
  var clustering = new Map();

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(nodesIter), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var v = _step.value;

      clustering.set(v, 0);
      var potential = 0;

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _core.$for.getIterator(genCombinations(G.get(v).keys(), 2)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = _babelHelpers.slicedToArray(_step2.value, 2);

          var u = _step2$value[0];
          var w = _step2$value[1];

          var squares = new Set(G.get(u).keys()).intersection(new Set(G.get(w).keys()));
          squares["delete"](v);
          squares = squares.size;

          clustering.set(v, clustering.get(v) + squares);
          var degm = squares + 1;
          if (G.get(u).has(w)) {
            degm += 1;
          }
          potential += (G.get(u).size - degm) * (G.get(w).size - degm) + squares;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (potential > 0) {
        clustering.set(v, clustering.get(v) / potential);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (G.hasNode(optNodes)) {
    return next(clustering.values()); // return single value
  }
  return clustering;
}

function genSquareClustering(G, optNodes) {
  return delegate("squareClustering", [G, optNodes]);
}

;
Object.defineProperty(exports, "__esModule", {
  value: true
});

/*jshint ignore:start*/

/*jshint ignore:end*/

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../_internals/delegate":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/delegateToWorker.js","../exceptions/JSNetworkXError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXError.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/dag.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

exports.isDirectedAcyclicGraph = isDirectedAcyclicGraph;
exports.genIsDirectedAcyclicGraph = genIsDirectedAcyclicGraph;
exports.topologicalSort = topologicalSort;
exports.genTopologicalSort = genTopologicalSort;
exports.topologicalSortRecursive = topologicalSortRecursive;
exports.genTopologicalSortRecursive = genTopologicalSortRecursive;
exports.isAperiodic = isAperiodic;
exports.genIsAperiodic = genIsAperiodic;

var delegate = _babelHelpers.interopRequire(require("../_internals/delegate"));

"use strict";

var JSNetworkXError = _babelHelpers.interopRequire(require("../exceptions/JSNetworkXError"));

var JSNetworkXUnfeasible = _babelHelpers.interopRequire(require("../exceptions/JSNetworkXUnfeasible"));

var _internals = require("../_internals");

var Map = _internals.Map;
var Set = _internals.Set;
var forEach = _internals.forEach;
var gcd = _internals.gcd;

function isDirectedAcyclicGraph(G) {
  try {
    topologicalSort(G);
    return true;
  } catch (ex) {
    if (ex instanceof JSNetworkXUnfeasible) {
      return false;
    }
    throw ex;
  }
}

function genIsDirectedAcyclicGraph(G) {
  return delegate("isDirectedAcyclicGraph", [G]);
}

;

function topologicalSort(G, optNbunch) {
  if (!G.isDirected()) {
    throw new JSNetworkXError("Topological sort not defined on undirected graphs.");
  }

  // nonrecursive version
  var seen = new Set();
  var orderExplored = []; // provide order and
  // fast search without more general priorityDictionary
  var explored = new Set();

  if (optNbunch == null) {
    optNbunch = G.nodesIter();
  }

  forEach(optNbunch, function (v) {
    // process all vertices in G
    if (explored.has(v)) {
      return; // continue
    }

    var fringe = [v]; // nodes yet to look at
    while (fringe.length > 0) {
      var w = fringe[fringe.length - 1]; // depth first search
      if (explored.has(w)) {
        // already looked down this branch
        fringe.pop();
        continue;
      }
      seen.add(w); // mark as seen
      // Check successors for cycles for new nodes
      var newNodes = [];
      /*jshint loopfunc:true*/
      G.get(w).forEach(function (_, n) {
        if (!explored.has(n)) {
          if (seen.has(n)) {
            // CYCLE !!
            throw new JSNetworkXUnfeasible("Graph contains a cycle.");
          }
          newNodes.push(n);
        }
      });
      if (newNodes.length > 0) {
        // add new nodes to fringe
        fringe.push.apply(fringe, newNodes);
      } else {
        explored.add(w);
        orderExplored.unshift(w);
      }
    }
  });

  return orderExplored;
}

function genTopologicalSort(G, optNbunch) {
  return delegate("topologicalSort", [G, optNbunch]);
}

;

function topologicalSortRecursive(G, optNbunch) {
  if (!G.isDirected()) {
    throw new JSNetworkXError("Topological sort not defined on undirected graphs.");
  }

  // function for recursive dfs
  /**
   * @param {Graph} G graph
   * @param {Set} seen
   * @param {Array} explored
   * @param {string} v
   * @return {boolean}
   */
  function _dfs(G, seen, explored, v) {
    seen.add(v);
    G.get(v).forEach(function (_, w) {
      if (!seen.has(w)) {
        if (!_dfs(G, seen, explored, w)) {
          return false;
        }
      } else if (seen.has(w) && explored.indexOf(w) === -1) {
        throw new JSNetworkXUnfeasible("Graph contains a cycle.");
      }
    });
    explored.unshift(v);
    return true;
  }

  var seen = new Set();
  var explored = [];

  if (optNbunch == null) {
    optNbunch = G.nodesIter();
  }

  forEach(optNbunch, function (v) {
    if (explored.indexOf(v) === -1) {
      if (!_dfs(G, seen, explored, v)) {
        throw new JSNetworkXUnfeasible("Graph contains a cycle.");
      }
    }
  });

  return explored;
}

function genTopologicalSortRecursive(G, optNbunch) {
  return delegate("topologicalSortRecursive", [G, optNbunch]);
}

;

function isAperiodic(_x) {
  var _left;

  var _again = true;

  _function: while (_again) {
    _again = false;
    var G = _x;
    next = levels = thisLevel = g = l = nextLevel = i = u = undefined;

    if (!G.isDirected()) {
      throw new JSNetworkXError("is_aperiodic not defined for undirected graphs.");
    }

    var next = G.nodesIter().next();
    if (next.done) {
      return true;
    }
    var levels = new Map();
    levels.set(next.value, 0);
    var thisLevel = [next.value];
    var g = 0;
    var l = 1;

    while (thisLevel.length > 0) {
      var nextLevel = [];
      for (var i = 0; i < thisLevel.length; i++) {
        var u = thisLevel[i];
        /*jshint loopfunc:true*/
        G.get(u).forEach(function (_, v) {
          if (levels.has(v)) {
            // non-tree edge
            g = gcd(g, levels.get(u) - levels.get(v) + 1);
          } else {
            // tree edge
            nextLevel.push(v);
            levels.set(v, l);
          }
        });
      }
      thisLevel = nextLevel;
      l += 1;
    }

    if (levels.size === G.numberOfNodes()) {
      return g === 1;
    }

    if (!(_left = g === 1)) {
      return _left;
    }

    _x = G.subgraph(new Set(G.nodes()).difference(levels.keys()));
    _again = true;
    continue _function;
  }
}

function genIsAperiodic(G) {
  return delegate("isAperiodic", [G]);
}

;
Object.defineProperty(exports, "__esModule", {
  value: true
});

/*jshint ignore:start*/

/*jshint ignore:end*/

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../_internals/delegate":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/delegateToWorker.js","../exceptions/JSNetworkXError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXError.js","../exceptions/JSNetworkXUnfeasible":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXUnfeasible.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/graphical.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

exports.isGraphical = isGraphical;
exports.genIsGraphical = genIsGraphical;
exports.isValidDegreeSequence = isValidDegreeSequence;
exports.genIsValidDegreeSequence = genIsValidDegreeSequence;
exports.isValidDegreeSequenceHavelHakimi = isValidDegreeSequenceHavelHakimi;
exports.genIsValidDegreeSequenceHavelHakimi = genIsValidDegreeSequenceHavelHakimi;
exports.isValidDegreeSequenceErdosGallai = isValidDegreeSequenceErdosGallai;
exports.genIsValidDegreeSequenceErdosGallai = genIsValidDegreeSequenceErdosGallai;

var delegate = _babelHelpers.interopRequire(require("../_internals/delegate"));

"use strict";

var _exceptions = require("../exceptions");

var JSNetworkXException = _exceptions.JSNetworkXException;
var JSNetworkXUnfeasible = _exceptions.JSNetworkXUnfeasible;

var fillArray = _babelHelpers.interopRequire(require("../_internals/fillArray"));

function isGraphical(sequence) {
  var optMethod = arguments[1] === undefined ? "hh" : arguments[1];

  switch (optMethod) {
    case "eg":
      return isValidDegreeSequenceErdosGallai(_core.Array.from(sequence));
    case "hh":
      return isValidDegreeSequenceHavelHakimi(_core.Array.from(sequence));
    default:
      throw new JSNetworkXException("`opt_method` must be 'eg' or 'hh'");
  }
}

function genIsGraphical(sequence, optMethod) {
  return delegate("isGraphical", [sequence, optMethod]);
}

;

function isValidDegreeSequence(sequence, optMethod) {
  return isGraphical(sequence, optMethod);
}

function genIsValidDegreeSequence(sequence, optMethod) {
  return delegate("isValidDegreeSequence", [sequence, optMethod]);
}

;

function basicGraphicalTests(sequence) {
  // sort and perform some simple tests on the sequence
  if (!sequence.every(function (x) {
    return Math.floor(x) === x;
  })) {
    // list of positive intengers
    throw new JSNetworkXUnfeasible();
  }

  var numberOfNodes = sequence.length;
  var numDegress = fillArray(numberOfNodes, 0);
  var maxDegree = 0;
  var minDegree = numberOfNodes;
  var degreeSum = 0;
  var n = 0;

  for (var i = 0; i < numberOfNodes; i++) {
    var degree = sequence[i];
    // Reject if degree is negative or larger than the sequence length
    if (degree < 0 || degree >= numberOfNodes) {
      throw new JSNetworkXUnfeasible();
    }
    // process only the non-zero integers
    else if (degree > 0) {
      maxDegree = Math.max(maxDegree, degree);
      minDegree = Math.min(minDegree, degree);
      degreeSum += degree;
      n += 1;
      numDegress[degree] += 1;
    }
  }
  // Reject sequence if it has odd sum or is over-saturated
  if (degreeSum % 2 === 1 || degreeSum > n * (n - 1)) {
    throw new JSNetworkXUnfeasible();
  }
  return [maxDegree, minDegree, degreeSum, n, numDegress];
}

function isValidDegreeSequenceHavelHakimi(degreeSequence) {
  var _;
  var maxDegree;
  var minDegree;
  var n;
  var numDegrees;

  try {
    var _ref = basicGraphicalTests(degreeSequence);

    var _ref2 = _babelHelpers.slicedToArray(_ref, 5);

    maxDegree = _ref2[0];
    minDegree = _ref2[1];
    _ = _ref2[2];
    n = _ref2[3];
    numDegrees = _ref2[4];
  } catch (ex) {
    if (ex instanceof JSNetworkXUnfeasible) {
      return false;
    } else {
      throw ex;
    }
  }
  // Accept if sequence has no non-zero degrees or passes the ZZ condition
  if (n === 0 || 4 * minDegree * n >= Math.pow(maxDegree + minDegree + 1, 2)) {
    return true;
  }

  var modstubs = fillArray(maxDegree + 1, 0);
  // successively reduce degree sequence by removing node of maximum degree
  while (n > 0) {
    // Retrieve the maximum degree in the sequence
    while (numDegrees[maxDegree] === 0) {
      maxDegree -= 1;
    }
    // If there are not enough stubs to connect to, then the sequence is not
    // graphical
    if (maxDegree > n - 1) {
      return false;
    }

    // Remove largest stub in list
    numDegrees[maxDegree] -= 1;
    n -= 1;
    // Reduce the next maxDegree largest stubs
    var mslen = 0;
    var k = maxDegree;
    for (var i = 0; i < maxDegree; i++) {
      while (numDegrees[k] === 0) {
        k -= 1;
      }
      numDegrees[k] -= 1;
      n -= 1;
      if (k > 1) {
        modstubs[mslen] = k - 1;
        mslen += 1;
      }
    }
    // Add back to the list any non-zero stubs that were removed
    for (i = 0; i < mslen; i++) {
      var stub = modstubs[i];
      numDegrees[stub] += 1;
      n += 1;
    }
  }
  return true;
}

function genIsValidDegreeSequenceHavelHakimi(degreeSequence) {
  return delegate("isValidDegreeSequenceHavelHakimi", [degreeSequence]);
}

;

function isValidDegreeSequenceErdosGallai(degreeSequence) {
  var maxDegree;
  var minDegree;
  var _;
  var n;
  var numDegrees;

  try {
    var _ref = basicGraphicalTests(degreeSequence);

    var _ref2 = _babelHelpers.slicedToArray(_ref, 5);

    maxDegree = _ref2[0];
    minDegree = _ref2[1];
    _ = _ref2[2];
    n = _ref2[3];
    numDegrees = _ref2[4];
  } catch (ex) {
    if (ex instanceof JSNetworkXUnfeasible) {
      return false;
    } else {
      throw ex;
    }
  }
  // Accept if sequence has no non-zero degrees or passes the ZZ condition
  if (n === 0 || 4 * minDegree * n >= Math.pow(maxDegree + minDegree + 1, 2)) {
    return true;
  }

  // Perform the EG checks using the reformulation of Zverovich and Zverovich
  var k = 0;
  var degreeSum = 0;
  var sumnj = 0;
  var sumjnj = 0;

  for (var dk = maxDegree; dk >= minDegree; dk -= 1) {
    if (dk < k + 1) {
      // Check if already past Durfee index
      return true;
    }
    if (numDegrees[dk] > 0) {
      var runSize = numDegrees[dk]; // Process a run of identical-valued degrees
      if (dk < k + runSize) {
        // Check if end of run is past Durfee index
        runSize = dk - k; // Adjust back to Durfee index
      }
      degreeSum += runSize * dk;
      for (var v = 0; v < runSize; v++) {
        sumnj += numDegrees[k + v];
        sumjnj += (k + v) * numDegrees[k + v];
      }
      k += runSize;
      if (degreeSum > k * (n - 1) - k * sumnj + sumjnj) {
        return false;
      }
    }
  }
  return true;
}

function genIsValidDegreeSequenceErdosGallai(degreeSequence) {
  return delegate("isValidDegreeSequenceErdosGallai", [degreeSequence]);
}

;
Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"../_internals/delegate":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/delegateToWorker.js","../_internals/fillArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/fillArray.js","../exceptions":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/index.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/index.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _centrality = require("./centrality");

var centrality = _babelHelpers.interopRequireWildcard(_centrality);

var _clique = require("./clique");

var clique = _babelHelpers.interopRequireWildcard(_clique);

var _cluster = require("./cluster");

var cluster = _babelHelpers.interopRequireWildcard(_cluster);

var _dag = require("./dag");

var dag = _babelHelpers.interopRequireWildcard(_dag);

var _graphical = require("./graphical");

var graphical = _babelHelpers.interopRequireWildcard(_graphical);

var _isomorphism = require("./isomorphism");

var isomorphism = _babelHelpers.interopRequireWildcard(_isomorphism);

var _shortestPaths = require("./shortestPaths");

var shortestPaths = _babelHelpers.interopRequireWildcard(_shortestPaths);

exports.centrality = centrality;
exports.clique = clique;
exports.cluster = cluster;
exports.dag = dag;
exports.graphical = graphical;
exports.isomorphism = isomorphism;
exports.shortestPaths = shortestPaths;

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_centrality));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_clique));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_cluster));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_dag));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_graphical));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_isomorphism));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_shortestPaths));

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"./centrality":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/centrality/index.js","./clique":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/clique.js","./cluster":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/cluster.js","./dag":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/dag.js","./graphical":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/graphical.js","./isomorphism":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/isomorphism/index.js","./shortestPaths":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/shortestPaths/index.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/isomorphism/index.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(require("./isomorph")));

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"./isomorph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/isomorphism/isomorph.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/isomorphism/isomorph.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var _babelHelpers = require("babel-runtime/helpers")["default"];

exports.couldBeIsomorphic = couldBeIsomorphic;
exports.genCouldBeIsomorphic = genCouldBeIsomorphic;
exports.fastCouldBeIsomorphic = fastCouldBeIsomorphic;
exports.genFastCouldBeIsomorphic = genFastCouldBeIsomorphic;
exports.fasterCouldBeIsomorphic = fasterCouldBeIsomorphic;
exports.genFasterCouldBeIsomorphic = genFasterCouldBeIsomorphic;

var delegate = _babelHelpers.interopRequire(require("../../_internals/delegate"));

"use strict";

var numberOfCliques = require("../clique").numberOfCliques;

var triangles = require("../cluster").triangles;

function couldBeIsomorphic(G1, G2) {
  // Check global properties
  if (G1.order() !== G2.order()) {
    return false;
  }

  // Check local properties
  var degree1 = G1.degree();
  var triangles1 = triangles(G1);
  var cliques1 = numberOfCliques(G1);
  var props1 = [];
  degree1.forEach(function (_, v) {
    props1.push([degree1.get(v), triangles1.get(v), cliques1.get(v)]);
  });
  props1.sort(function (a, b) {
    return a[0] - b[0] || a[1] - b[1] || a[2] - b[2];
  });

  var degree2 = G2.degree();
  var triangles2 = triangles(G2);
  var cliques2 = numberOfCliques(G2);
  var props2 = [];
  degree2.forEach(function (_, v) {
    props2.push([degree2.get(v), triangles2.get(v), cliques2.get(v)]);
  });
  props2.sort(function (a, b) {
    return a[0] - b[0] || a[1] - b[1] || a[2] - b[2];
  });

  return props1.every(function (a, i) {
    var b = props2[i];
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  });
}

function genCouldBeIsomorphic(G1, G2) {
  return delegate("couldBeIsomorphic", [G1, G2]);
}

;

function fastCouldBeIsomorphic(G1, G2) {
  // Check global properties
  if (G1.order() !== G2.order()) {
    return false;
  }

  // Check local properties
  var degree1 = G1.degree();
  var triangles1 = triangles(G1);
  var props1 = [];
  degree1.forEach(function (_, v) {
    props1.push([degree1.get(v), triangles1.get(v)]);
  });
  props1.sort(function (a, b) {
    return a[0] - b[0] || a[1] - b[1];
  });

  var degree2 = G2.degree();
  var triangles2 = triangles(G2);
  var props2 = [];
  degree2.forEach(function (_, v) {
    props2.push([degree2.get(v), triangles2.get(v)]);
  });
  props2.sort(function (a, b) {
    return a[0] - b[0] || a[1] - b[1];
  });

  return props1.every(function (a, i) {
    var b = props2[i];
    return a[0] === b[0] && a[1] === b[1];
  });
}

function genFastCouldBeIsomorphic(G1, G2) {
  return delegate("fastCouldBeIsomorphic", [G1, G2]);
}

;

function fasterCouldBeIsomorphic(G1, G2) {
  // Check global properties
  if (G1.order() !== G2.order()) {
    return false;
  }

  // Check local properties
  var degree1 = _core.Array.from(G1.degree().values());
  degree1.sort(function (a, b) {
    return a - b;
  });

  var degree2 = _core.Array.from(G2.degree().values());
  degree2.sort(function (a, b) {
    return a - b;
  });

  return degree1.every(function (v, i) {
    return v === degree2[i];
  });
}

function genFasterCouldBeIsomorphic(G1, G2) {
  return delegate("fasterCouldBeIsomorphic", [G1, G2]);
}

;
Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"../../_internals/delegate":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/delegateToWorker.js","../clique":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/clique.js","../cluster":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/cluster.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/shortestPaths/index.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _unweighted = require("./unweighted");

var unweighted = _babelHelpers.interopRequireWildcard(_unweighted);

exports.unweighted = unweighted;

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_unweighted));

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"./unweighted":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/shortestPaths/unweighted.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/shortestPaths/unweighted.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

exports.singleSourceShortestPathLength = singleSourceShortestPathLength;
exports.genSingleSourceShortestPathLength = genSingleSourceShortestPathLength;
exports.allPairsShortestPathLength = allPairsShortestPathLength;
exports.genAllPairsShortestPathLength = genAllPairsShortestPathLength;
exports.bidirectionalShortestPath = bidirectionalShortestPath;
exports.genBidirectionalShortestPath = genBidirectionalShortestPath;
exports.singleSourceShortestPath = singleSourceShortestPath;
exports.genSingleSourceShortestPath = genSingleSourceShortestPath;
exports.allPairsShortestPath = allPairsShortestPath;
exports.genAllPairsShortestPath = genAllPairsShortestPath;
exports.predecessor = predecessor;
exports.genPredecessor = genPredecessor;

var delegate = _babelHelpers.interopRequire(require("../../_internals/delegate"));

"use strict";

var JSNetworkXNoPath = require("../../exceptions").JSNetworkXNoPath;

var _internals = require("../../_internals");

var Map = _internals.Map;
var getDefault = _internals.getDefault;
var nodesAreEqual = _internals.nodesAreEqual;
var sprintf = _internals.sprintf;

function singleSourceShortestPathLength(G, source, optCutoff) {
  var seen = new Map(); // level (number of hops) when seen n BFS
  var level = 0; // the current level
  // map of nodes to check at next level
  var nextlevel = new Map([[source, 1]]);

  while (nextlevel.size > 0) {
    var thislevel = nextlevel;
    nextlevel = new Map();
    /*jshint loopfunc:true*/
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(thislevel.keys()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var v = _step.value;

        if (!seen.has(v)) {
          seen.set(v, level);
          G.get(v).forEach(function (_, n) {
            return nextlevel.set(n, 1);
          });
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (optCutoff != null && optCutoff <= level) {
      break;
    }
    level += 1;
  }
  return seen;
}

function genSingleSourceShortestPathLength(G, source, optCutoff) {
  return delegate("singleSourceShortestPathLength", [G, source, optCutoff]);
}

;

function allPairsShortestPathLength(G, optCutoff) {
  var paths = new Map();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(G), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var n = _step.value;

      paths.set(n, singleSourceShortestPathLength(G, n, optCutoff));
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return paths;
}

function genAllPairsShortestPathLength(G, optCutoff) {
  return delegate("allPairsShortestPathLength", [G, optCutoff]);
}

;

function bidirectionalShortestPath(G, source, target) {
  // call helper to do the real work

  var _bidirectionalPredSucc = bidirectionalPredSucc(G, source, target);

  var _bidirectionalPredSucc2 = _babelHelpers.slicedToArray(_bidirectionalPredSucc, 3);

  var pred = _bidirectionalPredSucc2[0];
  var succ = _bidirectionalPredSucc2[1];
  var w = _bidirectionalPredSucc2[2];

  // build path from pred+w+succ
  var path = [];
  // from source to w
  while (w != null) {
    path.push(w);
    w = pred.get(w);
  }
  w = succ.get(path[0]);
  path.reverse();
  // from w to target
  while (w != null) {
    path.push(w);
    w = succ.get(w);
  }
  return path;
}

function genBidirectionalShortestPath(G, source, target) {
  return delegate("bidirectionalShortestPath", [G, source, target]);
}

;

function bidirectionalPredSucc(G, source, target) {
  // does BFS from both source and target and meets in the middle
  if (nodesAreEqual(source, target)) {
    return [new Map([[source, null]]), new Map([[target, null]]), source];
  }

  // handle either directed or undirected
  var Gpred, Gsucc;
  if (G.isDirected()) {
    Gpred = G.predecessorsIter.bind(G);
    Gsucc = G.successorsIter.bind(G);
  } else {
    Gpred = G.neighborsIter.bind(G);
    Gsucc = G.neighborsIter.bind(G);
  }

  // predecesssor and successors in search
  var pred = new Map([[source, null]]);
  var succ = new Map([[target, null]]);
  //
  // initialize fringes, start with forward
  var forwardFringe = [source];
  var reverseFringe = [target];
  var thisLevel;
  var v, w;

  /*jshint newcap:false*/
  while (forwardFringe.length > 0 && reverseFringe.length > 0) {
    if (forwardFringe.length <= reverseFringe.length) {
      thisLevel = forwardFringe;
      forwardFringe = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _core.$for.getIterator(thisLevel), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          v = _step.value;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = _core.$for.getIterator(Gsucc(v)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              w = _step2.value;

              if (!pred.has(w)) {
                forwardFringe.push(w);
                pred.set(w, v);
              }
              if (succ.has(w)) {
                return [pred, succ, w]; // found path
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else {
      thisLevel = reverseFringe;
      reverseFringe = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = _core.$for.getIterator(thisLevel), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          v = _step3.value;
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = _core.$for.getIterator(Gpred(v)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              w = _step4.value;

              if (!succ.has(w)) {
                reverseFringe.push(w);
                succ.set(w, v);
              }
              if (pred.has(w)) {
                return [pred, succ, w]; // found path
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }
  throw new JSNetworkXNoPath(sprintf("No path between `%j` and `%j`.", source, target));
}

function singleSourceShortestPath(G, source, optCutoff) {
  var level = 0;
  var nextlevel = new Map([[source, 1]]);
  var paths = new Map([[source, [source]]]);
  if (optCutoff === 0) {
    return paths;
  }
  /*jshint loopfunc:true*/
  while (nextlevel.size > 0) {
    var thislevel = nextlevel;
    nextlevel = new Map();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(thislevel.keys()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var v = _step.value;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = _core.$for.getIterator(G.get(v).keys()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var w = _step2.value;

            if (!paths.has(w)) {
              paths.set(w, paths.get(v).concat([w]));
              nextlevel.set(w, 1);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    level += 1;
    if (optCutoff != null && optCutoff <= level) {
      break;
    }
  }
  return paths;
}

function genSingleSourceShortestPath(G, source, optCutoff) {
  return delegate("singleSourceShortestPath", [G, source, optCutoff]);
}

;

function allPairsShortestPath(G, optCutoff) {
  var paths = new Map();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(G), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var n = _step.value;

      paths.set(n, singleSourceShortestPath(G, n, optCutoff));
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return paths;
}

function genAllPairsShortestPath(G, optCutoff) {
  return delegate("allPairsShortestPath", [G, optCutoff]);
}

;

function predecessor(G, source) {
  var optArgs = arguments[2] === undefined ? {} : arguments[2];

  // TODO: use parameter destructuring
  // {target, cutoff, returnSeen}
  var target = optArgs.target;
  var cutoff = optArgs.cutoff;
  var returnSeen = optArgs.returnSeen;

  var level = 0;
  var nextlevel = [source];
  var seen = new Map([[source, level]]);
  var pred = new Map([[source, []]]);

  /*jshint loopfunc:true*/
  while (nextlevel.length > 0) {
    level += 1;
    var thislevel = nextlevel;
    nextlevel = [];
    thislevel.forEach(function (v) {
      G.get(v).forEach(function (_, w) {
        if (!seen.has(w)) {
          pred.set(w, [v]);
          seen.set(w, level);
          nextlevel.push(w);
        } else if (seen.get(w) === level) {
          // add v to predecesssor list if it
          pred.get(w).push(v); // is at the correct level
        }
      });
    });
    if (cutoff != null && cutoff <= level) {
      break;
    }
  }

  if (target != null) {
    if (returnSeen) {
      return pred.has(target) ? [pred.get(target), seen.get(target)] : [[], -1];
    } else {
      return getDefault(pred.get(target), []);
    }
  }
  return returnSeen ? [pred, seen] : pred;
}

function genPredecessor(G, source, optArgs) {
  return delegate("predecessor", [G, source, optArgs]);
}

;
Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"../../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../../_internals/delegate":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/delegateToWorker.js","../../exceptions":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/index.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/browser.js":[function(require,module,exports){
(function (global){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _internalsMessage = require("./_internals/message");

var serialize = _internalsMessage.serialize;
var deserialize = _internalsMessage.deserialize;

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(require("./")));

if (!global.document) {
  // inside worker
  global.onmessage = function (event) {
    var args = event.data.args.map(deserialize);
    var result = exports[event.data.method].apply(null, args);
    global.postMessage(serialize(result));
    global.close();
  };
}
Object.defineProperty(exports, "__esModule", {
  value: true
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/index.js","./_internals/message":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/message.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/DiGraph.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var Graph = _babelHelpers.interopRequire(require("./Graph"));

/*jshint ignore:start*/

var Map = _babelHelpers.interopRequire(require("../_internals/Map"));

/*jshint ignore:end*/

var JSNetworkXError = _babelHelpers.interopRequire(require("../exceptions/JSNetworkXError"));

var convert = _babelHelpers.interopRequire(require("../convert"));

var _internals = require("../_internals");

var clear = _internals.clear;
var clone = _internals.clone;
var createTupleFactory = _internals.createTupleFactory;
var deepcopy = _internals.deepcopy;
var forEach = _internals.forEach;
var isBoolean = _internals.isBoolean;
var isPlainObject = _internals.isPlainObject;
var mapIterator = _internals.mapIterator;
var next = _internals.next;
var size = _internals.size;
var sprintf = _internals.sprintf;
var tuple2 = _internals.tuple2;
var tuple3 = _internals.tuple3;
var tuple3c = _internals.tuple3c;
var zipIterator = _internals.zipIterator;

/**
 * Base class for directed graphs.
 *
 * A DiGraph stores nodes and edges with optional data, or attributes.
 *
 * DiGraphs hold directed edges.  Self loops are allowed but multiple
 * (parallel) edges are not.
 *
 * Nodes can be arbitrary (hashable) Python objects with optional
 * key/value attributes.
 *
 * Edges are represented as links between nodes with optional
 * key/value attributes.
 *
 * @see Graph
 * @see MultiGraph
 * @see MultiDiGraph
 *
 * @param {?=} optData
 *      Data to initialize graph.  If data=None (default) an empty
 *      graph is created.  The data can be an edge list, or any
 *      NetworkX graph object.
 *
 * @param {Object=} optAttr
 *       Attributes to add to graph as key=value pairs.
 *
 * @extends Graph
 * @constructor
 */

var DiGraph = (function (Graph) {
  function DiGraph(optData, optAttr) {
    _babelHelpers.classCallCheck(this, DiGraph);

    // makes it possible to call DiGraph without new
    if (!(this instanceof DiGraph)) {
      return new DiGraph(optData, optAttr);
    }

    this.graph = {}; // dictionary for graph attributes
    this.node = new Map(); // dictionary for node attributes
    // We store two adjacency lists:
    // the  predecessors of node n are stored in the dict self.pred
    // the successors of node n are stored in the dict self.succ=self.adj
    this.adj = new Map(); // empty adjacency dictionary
    this.pred = new Map(); // predecessor
    this.succ = this.adj; // successor

    //attempt to load graph with data
    if (optData != null) {
      convert.toNetworkxGraph(optData, this);
    }
    // load graph attributes (must be afte convert)
    _core.Object.assign(this.graph, optAttr || {});
    this.edge = this.adj;
  }

  _babelHelpers.inherits(DiGraph, Graph);

  _babelHelpers.prototypeProperties(DiGraph, {
    __name__: {

      /**
       * Holds the graph type (class) name for information.
       * This is compatible to Pythons __name__ property.
       *
       * @type {string}
       */

      get: function () {
        return "DiGraph";
      },
      configurable: true
    }
  }, {
    addNode: {

      /**
       * Add a single node n and update node attributes.
       *
       * @see #add_nodes_from
       *
       * @param {Node} n Node
       * @param {Object=} opt_attr_dict Dictionary of node attributes.
       *      Key/value pairs will update existing data associated with the node.
       *
       * @override
       * @export
       */

      value: function addNode(n) {
        var optAttrDict = arguments[1] === undefined ? {} : arguments[1];

        if (!isPlainObject(optAttrDict)) {
          throw new JSNetworkXError("The opt_attr_dict argument must be an object.");
        }

        if (!this.succ.has(n)) {
          this.succ.set(n, new Map());
          this.pred.set(n, new Map());
          this.node.set(n, optAttrDict);
        } else {
          // update attr even if node already exists
          _core.Object.assign(this.node.get(n), optAttrDict);
        }
      },
      writable: true,
      configurable: true
    },
    addNodesFrom: {

      /**
       * Add multiple nodes.
       *
       * @see #add_node
       *
       * @param {NodeContainer} nodes
       *      A container of nodes (list, dict, set, etc.).
       *      OR
       *      A container of (node, attribute dict) tuples.
       *
       * @param {Object=} opt_attr  Update attributes for all nodes in nodes.
       *       Node attributes specified in nodes as a tuple
       *       take precedence over attributes specified generally.
       *
       * @override
       * @export
       */

      value: function addNodesFrom(nodes) {
        var optAttr = arguments[1] === undefined ? {} : arguments[1];

        // if an object, only iterate over the keys
        forEach(nodes, function (n) {
          var newnode = !this.succ.has(n);

          // test whether n is a (node, attr) tuple
          if (Array.isArray(n) && n.length === 2 && isPlainObject(n[1])) {
            var nn = n[0];
            var ndict = n[1];

            if (!this.succ.has(nn)) {
              this.succ.set(nn, new Map());
              this.pred.set(nn, new Map());
              var newdict = clone(optAttr);
              _core.Object.assign(newdict, ndict);
              this.node.set(nn, newdict);
            } else {
              var olddict = this.node.get(nn);
              _core.Object.assign(olddict, optAttr, ndict);
            }
          } else if (newnode) {
            this.succ.set(n, new Map());
            this.pred.set(n, new Map());
            this.node.set(n, clone(optAttr));
          } else {
            _core.Object.assign(this.node.get(n), optAttr);
          }
        }, this);
      },
      writable: true,
      configurable: true
    },
    removeNode: {

      /**
       * Remove node n.
       *
       * Removes the node n and all adjacent edges.
       * Attempting to remove a non-existent node will raise an exception.
       *
       * @see #remove_nodes_from
       *
       * @param {Node} n  A node in the graph
       *
       * @override
       * @export
       */

      value: function removeNode(n) {
        if (this.node["delete"](n)) {
          var nbrs = this.succ.get(n);
          nbrs.forEach(function (_, u) {
            this.pred.get(u)["delete"](n); // remove all edges n-u in digraph
          }, this);
          this.succ["delete"](n); // remove node from succ
          this.pred.get(n).forEach(function (_, u) {
            this.succ.get(u)["delete"](n); // remove all edges n-u in digraph
          }, this);
          this.pred["delete"](n); // remove node from pred
        } else {
          throw new JSNetworkXError(sprintf("The node \"%j\" is not in the graph", n));
        }
      },
      writable: true,
      configurable: true
    },
    removeNodesFrom: {

      /**
       * Remove multiple nodes.
       *
       * @see #remove_node
       *
       * @param {NodeContainer} nodes  A container of nodes.
       *      If a node in the container is not in the graph it is silently ignored.
       *
       * @override
       * @export
       */

      value: function removeNodesFrom(nodes) {
        forEach(nodes, function (n) {
          if (this.succ.has(n)) {
            var succs = this.succ.get(n);

            this.node["delete"](n);
            succs.forEach(function (_, u) {
              // remove all edges n-u in digraph
              this.pred.get(u)["delete"](n);
            }, this);
            this.succ["delete"](n); // remove node from succ
            this.pred.get(n).forEach(function (_, u) {
              // remove all edges n-u in digraph
              this.succ.get(u)["delete"](n);
            }, this);
            this.pred["delete"](n); // remove node from pred
          }
        }, this);
      },
      writable: true,
      configurable: true
    },
    addEdge: {

      /**
       * Add an edge between u and v.
       *
       * The nodes u and v will be automatically added if they are
       * not already in the graph.
       *
       * Edge attributes can be specified with keywords or by providing
       * a dictionary with key/value pairs.
       *
       * @see #add_edges_from
       *
       * Note: Adding an edge that already exists updates the edge data.
       *
       *       Many NetworkX algorithms designed for weighted graphs use as
       *       the edge weight a numerical value assigned to a keyword
       *       which by default is 'weight'.
       *
       * @param {Node} u Node
       * @param {Node} v Node
       * @param {Object=} opt_attr_dict Dictionary of edge attributes.
       *      Key/value pairs will update existing data associated with the edge.
       *
       * @override
       * @export
       */

      value: function addEdge(u, v) {
        var optAttrDict = arguments[2] === undefined ? {} : arguments[2];

        if (!isPlainObject(optAttrDict)) {
          throw new JSNetworkXError("The optAttrDict argument must be a plain object.");
        }

        // add nodes
        if (!this.succ.has(u)) {
          this.succ.set(u, new Map());
          this.pred.set(u, new Map());
          this.node.set(u, {});
        }

        if (!this.succ.has(v)) {
          this.succ.set(v, new Map());
          this.pred.set(v, new Map());
          this.node.set(v, {});
        }

        // add the edge
        var datadict = this.adj.get(u).get(v) || {};
        _core.Object.assign(datadict, optAttrDict);
        this.succ.get(u).set(v, datadict);
        this.pred.get(v).set(u, datadict);
      },
      writable: true,
      configurable: true
    },
    addEdgesFrom: {

      /**
       * Add all the edges in ebunch.
       *
       * Notes:
       * Adding the same edge twice has no effect but any edge data
       * will be updated when each duplicate edge is added.
       *
       * @see #add_edge
       * @see #add_weighted_edges_from
       *
       * @param {?} ebunch container of edges
       *      Each edge given in the container will be added to the
       *      graph. The edges must be given as as 2-tuples (u,v) or
       *      3-tuples (u,v,d) where d is a dictionary containing edge data.
       *
       * @param {Object=} opt_attr_dict Dictionary of edge attributes.
       *      Dictionary of edge attributes.  Key/value pairs will
       *      update existing data associated with each edge.
       *
       * @override
       * @export
       */

      value: function addEdgesFrom(ebunch) {
        var optAttrDict = arguments[1] === undefined ? {} : arguments[1];

        if (!isPlainObject(optAttrDict)) {
          throw new JSNetworkXError("The opt_attr_dict argument must be an object.");
        }

        // process ebunch
        forEach(ebunch, function (edge) {
          var length = size(edge);
          var u, v, edgeData;
          if (length === 3) {
            u = edge[0];
            v = edge[1];
            edgeData = edge[2];
          } else if (length === 2) {
            u = edge[0];
            v = edge[1];
            edgeData = {};
          } else {
            throw new JSNetworkXError(sprintf("Edge tuple \"%j\" must be a 2-tuple or 3-tuple.", edge));
          }

          if (!this.succ.has(u)) {
            this.succ.set(u, new Map());
            this.pred.set(u, new Map());
            this.node.set(u, {});
          }
          if (!this.succ.has(v)) {
            this.succ.set(v, new Map());
            this.pred.set(v, new Map());
            this.node.set(v, {});
          }

          var datadict = this.adj.get(u).get(v) || {};
          _core.Object.assign(datadict, optAttrDict, edgeData);
          this.succ.get(u).set(v, datadict);
          this.pred.get(v).set(u, datadict);
        }, this);
      },
      writable: true,
      configurable: true
    },
    removeEdge: {

      /**
       * Remove the edge between u and v.
       *
       * @see #remove_edges_from
       *
       * @param {Node} u Node
       * @param {Node} v Node
       *
       * @override
       * @export
       */

      value: function removeEdge(u, v) {
        var edge = this.succ.get(u);
        if (edge !== undefined && edge["delete"](v)) {
          this.pred.get(v)["delete"](u);
        } else {
          throw new JSNetworkXError(sprintf("The edge \"%j-%j\" is not in the graph", u, v));
        }
      },
      writable: true,
      configurable: true
    },
    removeEdgesFrom: {

      /**
       * Remove all edges specified in ebunch.
       *
       * Notes: Will fail silently if an edge in ebunch is not in the graph.
       *
       * @param {?} ebunch 1list or container of edge tuples
       *      Each edge given in the list or container will be removed
       *      from the graph. The edges can be:
       *          - 2-tuples (u,v) edge between u and v.
       *          - 3-tuples (u,v,k) where k is ignored.
       *
       * @override
       * @export
       */

      value: function removeEdgesFrom(ebunch) {
        forEach(ebunch, function (edge) {
          var u = edge[0]; // ignore edge data if present
          var v = edge[1];

          try {
            this.succ.get(u)["delete"](v);
            this.pred.get(v)["delete"](u);
          } catch (ex) {}
        }, this);
      },
      writable: true,
      configurable: true
    },
    hasSuccessor: {

      /**
       * Return True if node u has successor v.
       *
       * This is true if graph has the edge u->v.
       *
       * @param {Node} u Node
       * @param {Node} v Node
       *
       * @return {boolean} True if node u has successor v
       *
       * @export
       */

      value: function hasSuccessor(u, v) {
        return this.succ.has(u) && this.succ.get(u).has(v);
      },
      writable: true,
      configurable: true
    },
    hasPredecessor: {

      /**
       * Return True if node u has predecessor v.
       *
       * This is true if graph has the edge u<-v.
       *
       * @param {Node} u Node
       * @param {Node} v Node
       *
       * @return {boolean} True if node u has predecessor v
       *
       * @export
       */

      value: function hasPredecessor(u, v) {
        return this.pred.has(u) && this.pred.get(u).has(v);
      },
      writable: true,
      configurable: true
    },
    successorsIter: {

      /**
       * Return an iterator over successor nodes of n.
       *
       * {@code neighbors_iter()} and {@code successors_iter()} are the same.
       *
       * @param {Node} n Node
       *
       * @return {!Iterator} Iterator over successor nodes of n
       *
       * @export
       */

      value: function successorsIter(n) {
        var nbrs = this.succ.get(n);
        if (nbrs !== undefined) {
          return nbrs.keys();
        }
        throw new JSNetworkXError(sprintf("The node \"%j\" is not in the digraph.", n));
      },
      writable: true,
      configurable: true
    },
    predecessorsIter: {

      /**
       * Return an iterator over predecessor nodes of n.
       *
       * @param {Node} n Node
       *
       * @return {!Iterator} Iterator over predecessor nodes of n
       *
       * @export
       */

      value: function predecessorsIter(n) {
        var nbrs = this.pred.get(n);
        if (nbrs !== undefined) {
          return nbrs.keys();
        }
        throw new JSNetworkXError(sprintf("The node \"%j\" is not in the digraph.", n));
      },
      writable: true,
      configurable: true
    },
    successors: {

      /**
       * Return a list of successor nodes of n.
       *
       * {@code neighbors()} and {@code successors()} are the same.
       *
       * @param {Node} n Node
       *
       * @return {!Array} List of successor nodes of n
       *
       * @export
       */

      value: function successors(n) {
        return _core.Array.from(this.successorsIter(n));
      },
      writable: true,
      configurable: true
    },
    predecessors: {

      /**
       * Return list of predecessor nodes of n.
       *
       * @param {Node} n Node
       *
       * @return {!Array} List of predecessor nodes of n
       *
       * @export
       */

      value: function predecessors(n) {
        return _core.Array.from(this.predecessorsIter(n));
      },
      writable: true,
      configurable: true
    },
    neighbors: {

      // digraph definitions
      /**
       * @see #successors
       *
       * @override
       * @export
       */

      get: function () {
        return this.successors;
      },
      configurable: true
    },
    neighborsIter: {

      /**
       * @see #successors_iter
       *
       * @override
       * @export
       */

      get: function () {
        return this.successorsIter;
      },
      configurable: true
    },
    edgesIter: {

      /**
       * Return an iterator over the edges.
       *
       * Edges are returned as tuples with optional data
       * in the order (node, neighbor, data).
       *
       * @see #edges
       *
       * Note:
       *
       *      Nodes in nbunch that are not in the graph will be (quietly) ignored.
       *
       * @param {?(NodeContainer|boolean)=} opt_nbunch A container of nodes.
       *       The container will be iterated through once.
       *
       * @param {?boolean=} opt_data
       *      If True, return edge attribute dict in 3-tuple (u,v,data).
       *
       * @return {!Iterator} An iterator of (u,v) or (u,v,d) tuples of edges.
       *
       * @override
       * @export
       */

      value: _regeneratorRuntime.mark(function edgesIter(optNbunch) {
        var _this = this;

        var optData = arguments[1] === undefined ? false : arguments[1];

        var nodesNbrs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, nodeNbrs, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, nbrData, result;

        return _regeneratorRuntime.wrap(function edgesIter$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              // handle calls with opt_data being the only argument
              if (isBoolean(optNbunch)) {
                optData = optNbunch;
                optNbunch = undefined;
              }

              if (optNbunch === undefined) {
                nodesNbrs = _this.adj;
              } else {
                nodesNbrs = mapIterator(_this.nbunchIter(optNbunch), function (n) {
                  return tuple2(n, _this.adj.get(n));
                });
              }

              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              context$2$0.prev = 5;
              _iterator = _core.$for.getIterator(nodesNbrs);

            case 7:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                context$2$0.next = 40;
                break;
              }

              nodeNbrs = _step.value;
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              context$2$0.prev = 12;
              _iterator2 = _core.$for.getIterator(nodeNbrs[1]);

            case 14:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                context$2$0.next = 23;
                break;
              }

              nbrData = _step2.value;
              result = [nodeNbrs[0], nbrData[0]];

              if (optData) {
                result[2] = nbrData[1];
              }
              context$2$0.next = 20;
              return result;

            case 20:
              _iteratorNormalCompletion2 = true;
              context$2$0.next = 14;
              break;

            case 23:
              context$2$0.next = 29;
              break;

            case 25:
              context$2$0.prev = 25;
              context$2$0.t23 = context$2$0["catch"](12);
              _didIteratorError2 = true;
              _iteratorError2 = context$2$0.t23;

            case 29:
              context$2$0.prev = 29;
              context$2$0.prev = 30;

              if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                _iterator2["return"]();
              }

            case 32:
              context$2$0.prev = 32;

              if (!_didIteratorError2) {
                context$2$0.next = 35;
                break;
              }

              throw _iteratorError2;

            case 35:
              return context$2$0.finish(32);

            case 36:
              return context$2$0.finish(29);

            case 37:
              _iteratorNormalCompletion = true;
              context$2$0.next = 7;
              break;

            case 40:
              context$2$0.next = 46;
              break;

            case 42:
              context$2$0.prev = 42;
              context$2$0.t24 = context$2$0["catch"](5);
              _didIteratorError = true;
              _iteratorError = context$2$0.t24;

            case 46:
              context$2$0.prev = 46;
              context$2$0.prev = 47;

              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }

            case 49:
              context$2$0.prev = 49;

              if (!_didIteratorError) {
                context$2$0.next = 52;
                break;
              }

              throw _iteratorError;

            case 52:
              return context$2$0.finish(49);

            case 53:
              return context$2$0.finish(46);

            case 54:
            case "end":
              return context$2$0.stop();
          }
        }, edgesIter, this, [[5, 42, 46, 54], [12, 25, 29, 37], [30,, 32, 36], [47,, 49, 53]]);
      }),
      writable: true,
      configurable: true
    },
    outEdgesIter: {

      // alias out_edges to edges

      /**
       * @see #edges_iter
       */

      value: function outEdgesIter(optNbunch, optData) {
        return this.edgesIter(optNbunch, optData);
      },
      writable: true,
      configurable: true
    },
    outEdges: {

      /**
       * @see Graph#edges
       */

      value: function outEdges(optNbunch, optData) {
        return this.edges(optNbunch, optData);
      },
      writable: true,
      configurable: true
    },
    inEdgesIter: {

      /**
       * Return an iterator over the incoming edges.
       *
       * @see #edges_iter
       *
       *
       * @param {(?NodeContainer|boolean)=} opt_nbunch A container of nodes.
       *       The container will be iterated through once.
       *
       * @param {?boolean=} opt_data
       *      If True, return edge attribute dict in 3-tuple (u,v,data).
       *
       * @return {!Iterator} An iterator of (u,v) or (u,v,d) tuples of
       *      incoming edges.
       *
       * @export
       */

      value: _regeneratorRuntime.mark(function inEdgesIter(optNbunch) {
        var _this = this;

        var optData = arguments[1] === undefined ? false : arguments[1];

        var nodesNbrs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, nodeNbrs, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, nbrData, result;

        return _regeneratorRuntime.wrap(function inEdgesIter$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              // handle calls with opt_data being the only argument
              if (isBoolean(optNbunch)) {
                optData = optNbunch;
                optNbunch = undefined;
              }

              if (optNbunch === undefined) {
                nodesNbrs = _this.pred;
              } else {
                nodesNbrs = mapIterator(_this.nbunchIter(optNbunch), function (n) {
                  return tuple2(n, _this.pred.get(n));
                });
              }

              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              context$2$0.prev = 5;
              _iterator = _core.$for.getIterator(nodesNbrs);

            case 7:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                context$2$0.next = 40;
                break;
              }

              nodeNbrs = _step.value;
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              context$2$0.prev = 12;
              _iterator2 = _core.$for.getIterator(nodeNbrs[1]);

            case 14:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                context$2$0.next = 23;
                break;
              }

              nbrData = _step2.value;
              result = [nbrData[0], nodeNbrs[0]];

              if (optData) {
                result[2] = nbrData[1];
              }
              context$2$0.next = 20;
              return result;

            case 20:
              _iteratorNormalCompletion2 = true;
              context$2$0.next = 14;
              break;

            case 23:
              context$2$0.next = 29;
              break;

            case 25:
              context$2$0.prev = 25;
              context$2$0.t25 = context$2$0["catch"](12);
              _didIteratorError2 = true;
              _iteratorError2 = context$2$0.t25;

            case 29:
              context$2$0.prev = 29;
              context$2$0.prev = 30;

              if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                _iterator2["return"]();
              }

            case 32:
              context$2$0.prev = 32;

              if (!_didIteratorError2) {
                context$2$0.next = 35;
                break;
              }

              throw _iteratorError2;

            case 35:
              return context$2$0.finish(32);

            case 36:
              return context$2$0.finish(29);

            case 37:
              _iteratorNormalCompletion = true;
              context$2$0.next = 7;
              break;

            case 40:
              context$2$0.next = 46;
              break;

            case 42:
              context$2$0.prev = 42;
              context$2$0.t26 = context$2$0["catch"](5);
              _didIteratorError = true;
              _iteratorError = context$2$0.t26;

            case 46:
              context$2$0.prev = 46;
              context$2$0.prev = 47;

              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }

            case 49:
              context$2$0.prev = 49;

              if (!_didIteratorError) {
                context$2$0.next = 52;
                break;
              }

              throw _iteratorError;

            case 52:
              return context$2$0.finish(49);

            case 53:
              return context$2$0.finish(46);

            case 54:
            case "end":
              return context$2$0.stop();
          }
        }, inEdgesIter, this, [[5, 42, 46, 54], [12, 25, 29, 37], [30,, 32, 36], [47,, 49, 53]]);
      }),
      writable: true,
      configurable: true
    },
    inEdges: {

      /**
       * Return a list of the incoming edges.
       *
       * @see #edges
       *
       * @param {NodeContainer} opt_nbunch A container of nodes.
       *       The container will be iterated through once.
       *
       * @param {boolean} opt_data
       *      If True, return edge attribute dict in 3-tuple (u,v,data).
       *
       * @return {!Array} A list of incoming edges
       *
       * @export
       */

      value: function inEdges(optNbunch) {
        var optData = arguments[1] === undefined ? false : arguments[1];

        return _core.Array.from(this.inEdgesIter(optNbunch, optData));
      },
      writable: true,
      configurable: true
    },
    degreeIter: {

      /**
       * Return an iterator for (node, degree).
       *
       * The node degree is the number of edges adjacent to the node.
       *
       * @see #degree
       * @see #in_degree
       * @see #out_degree
       * @see #in_degree_iter
       * @see #out_degree_iter
       *
       *
       * @param {(Node|NodeContainer)=} opt_nbunch  A container of nodes.
       *       The container will be iterated through once.
       *
       * @param {string=} opt_weight
       *       The edge attribute that holds the numerical value used
       *       as a weight.  If None, then each edge has weight 1.
       *       The degree is the sum of the edge weights adjacent to the node.
       *
       *
       * WARNING: Since both parameters are optional, and the weight attribute
       * name could be equal to a node name, nbunch as to be set to null explicitly
       * to use the second argument as weight attribute name.
       *
       * @return {!Iterator}  The iterator returns two-tuples of (node, degree).
       *
       * @override
       * @export
       */

      value: function degreeIter(optNbunch, optWeight) {
        var _this = this;

        var nodesNbrs;

        if (optNbunch == null) {
          nodesNbrs = zipIterator(this.succ.entries(), this.pred.entries());
        } else {
          var tuple2Succ = createTupleFactory(2);
          var tuple2Pred = createTupleFactory(2);
          nodesNbrs = zipIterator(mapIterator(this.nbunchIter(optNbunch), function (n) {
            return tuple2Succ(n, _this.succ.get(n));
          }), mapIterator(this.nbunchIter(optNbunch), function (n) {
            return tuple2Pred(n, _this.pred.get(n));
          }));
        }

        if (optWeight == null) {
          return mapIterator(nodesNbrs, function (_ref) {
            var _ref2 = _babelHelpers.slicedToArray(_ref, 2);

            var _ref2$0 = _babelHelpers.slicedToArray(_ref2[0], 2);

            var node = _ref2$0[0];
            var succ = _ref2$0[1];

            var _ref2$1 = _babelHelpers.slicedToArray(_ref2[1], 2);

            var u = _ref2$1[0];
            var pred = _ref2$1[1];
            return [node, pred.size + succ.size];
          });
        } else {
          // edge weighted graph - degree is sum of edge weights
          return mapIterator(nodesNbrs, function (_ref) {
            var _ref2 = _babelHelpers.slicedToArray(_ref, 2);

            var _ref2$0 = _babelHelpers.slicedToArray(_ref2[0], 2);

            var node = _ref2$0[0];
            var succ = _ref2$0[1];

            var _ref2$1 = _babelHelpers.slicedToArray(_ref2[1], 2);

            var _ = _ref2$1[0];
            var pred = _ref2$1[1];

            var sum = 0;

            function sumData(data) {
              var weight = data[optWeight];
              sum += weight != null ? +weight : 1;
            }

            succ.forEach(sumData);
            pred.forEach(sumData);

            return [node, sum];
          });
        }
      },
      writable: true,
      configurable: true
    },
    inDegreeIter: {

      /**
       * Return an iterator for (node, in-degree).
       *
       * The node in-degree is the number of edges pointing in to the node.
       *
       * @see #degree
       * @see #in_degree
       * @see #out_degree
       * @see #out_degree_iter
       *
       * @param {(Node|NodeContainer)=} opt_nbunch  A container of nodes.
       *       The container will be iterated through once.
       *
       * @param {string=} opt_weight
       *       The edge attribute that holds the numerical value used
       *       as a weight.  If None, then each edge has weight 1.
       *       The degree is the sum of the edge weights adjacent to the node.
       *
       *
       * WARNING: Since both parameters are optional, and the weight attribute
       * name could be equal to a node name, nbunch as to be set to null explicitly
       * to use the second argument as weight attribute name.
       *
       * @return {Iterator}  The iterator returns two-tuples of (node, in-degree).
       *
       * @export
       */

      value: function inDegreeIter(optNbunch, optWeight) {
        var _this = this;

        var nodesNbrs;

        if (optNbunch == null) {
          nodesNbrs = this.pred;
        } else {
          nodesNbrs = mapIterator(this.nbunchIter(optNbunch), function (n) {
            return tuple2(n, _this.pred.get(n));
          });
        }

        if (optWeight == null) {
          return mapIterator(nodesNbrs, function (_ref) {
            var _ref2 = _babelHelpers.slicedToArray(_ref, 2);

            var node = _ref2[0];
            var pred = _ref2[1];
            return [node, pred.size];
          });
        } else {
          return mapIterator(nodesNbrs, function (_ref) {
            var _ref2 = _babelHelpers.slicedToArray(_ref, 2);

            var node = _ref2[0];
            var pred = _ref2[1];

            var sum = 0;
            pred.forEach(function (data) {
              var weight = data[optWeight];
              sum += weight != null ? +weight : 1;
            });
            return [node, sum];
          });
        }
      },
      writable: true,
      configurable: true
    },
    outDegreeIter: {

      /**
       * Return an iterator for (node, out-degree).
       *
       * The node out-degree is the number of edges pointing in to the node.
       *
       * @see #degree
       * @see #in_degree
       * @see #out_degree
       * @see #in_degree_iter
       *
       * @param {NodeContainer=} opt_nbunch  A container of nodes.
       *       The container will be iterated through once.
       *
       * @param {string=} opt_weight
       *       The edge attribute that holds the numerical value used
       *       as a weight.  If None, then each edge has weight 1.
       *       The degree is the sum of the edge weights adjacent to the node.
       *
       *
       * WARNING: Since both parameters are optional, and the weight attribute
       * name could be equal to a node name, nbunch as to be set to null explicitly
       * to use the second argument as weight attribute name.
       *
       * @return {Iterator}  The iterator returns two-tuples of (node, out-degree).
       * @export
       */

      value: function outDegreeIter(optNbunch, optWeight) {
        var _this = this;

        var nodesNbrs;

        if (optNbunch == null) {
          nodesNbrs = this.succ;
        } else {
          nodesNbrs = mapIterator(this.nbunchIter(optNbunch), function (n) {
            return tuple2(n, _this.succ.get(n));
          });
        }

        if (optWeight == null) {
          return mapIterator(nodesNbrs, function (_ref) {
            var _ref2 = _babelHelpers.slicedToArray(_ref, 2);

            var node = _ref2[0];
            var succ = _ref2[1];
            return [node, succ.size];
          });
        } else {
          return mapIterator(nodesNbrs, function (_ref) {
            var _ref2 = _babelHelpers.slicedToArray(_ref, 2);

            var node = _ref2[0];
            var succ = _ref2[1];

            var sum = 0;
            succ.forEach(function (data) {
              var weight = data[optWeight];
              sum += weight != null ? +weight : 1;
            });
            return [node, sum];
          });
        }
      },
      writable: true,
      configurable: true
    },
    inDegree: {

      /**
       * Return the in-degree of a node or nodes.
       *
       * The node in-degree is the number of edges pointing in to the node.
       *
       * @see #degree
       * @see #out_degree
       * @see #in_degree_iter
       *
       *
       * @param {NodeContainer=} opt_nbunch  A container of nodes.
       *       The container will be iterated through once.
       *
       * @param {string=} opt_weight
       *       The edge attribute that holds the numerical value used
       *       as a weight.  If None, then each edge has weight 1.
       *       The degree is the sum of the edge weights adjacent to the node.
       *
       *
       * WARNING: Since both parameters are optional, and the weight attribute
       * name could be equal to a node name, nbunch as to be set to null explicitly
       * to use the second argument as weight attribute name.
       *
       * @return {(number|Map)}
       *       A dictionary with nodes as keys and in-degree as values or
       *       a number if a single node is specified.
       *
       * @export
       */

      value: function inDegree(optNbunch, optWeight) {
        if (optNbunch != null && this.hasNode(optNbunch)) {
          // return a single node
          return next(this.inDegreeIter(optNbunch, optWeight))[1];
        } else {
          return new Map(this.inDegreeIter(optNbunch, optWeight));
        }
      },
      writable: true,
      configurable: true
    },
    outDegree: {

      /**
       * Return the out-degree of a node or nodes.
       *
       * The node out-degree is the number of edges pointing out of the node.
       *
       * @see #degree
       * @see #out_degree
       * @see #in_degree_iter
       *
       *
       * @param {NodeContainer=} opt_nbunch  A container of nodes.
       *       The container will be iterated through once.
       *
       * @param {string=} opt_weight
       *       The edge attribute that holds the numerical value used
       *       as a weight.  If None, then each edge has weight 1.
       *       The degree is the sum of the edge weights adjacent to the node.
       *
       *
       * WARNING: Since both parameters are optional, and the weight attribute
       * name could be equal to a node name, nbunch as to be set to null explicitly
       * to use the second argument as weight attribute name.
       *
       * @return {(number|Map)}
       *       A dictionary with nodes as keys and in-degree as values or
       *       a number if a single node is specified.
       *
       * @export
       */

      value: function outDegree(optNbunch, optWeight) {
        if (optNbunch != null && this.hasNode(optNbunch)) {
          // return a single node
          return next(this.outDegreeIter(optNbunch, optWeight))[1];
        } else {
          return new Map(this.outDegreeIter(optNbunch, optWeight));
        }
      },
      writable: true,
      configurable: true
    },
    clear: {

      /**
       * Remove all nodes and edges from the graph.
       *
       * This also removes the name, and all graph, node, and edge attributes.
       *
       * @override
       * @export
       */

      value: (function (_clear) {
        var _clearWrapper = function clear() {
          return _clear.apply(this, arguments);
        };

        _clearWrapper.toString = function () {
          return _clear.toString();
        };

        return _clearWrapper;
      })(function () {
        this.succ.clear();
        this.pred.clear();
        this.node.clear();
        clear(this.graph);
      }),
      writable: true,
      configurable: true
    },
    isMultigraph: {

      /**
       * Return True if graph is a multigraph, False otherwise.
       *
       * @return {boolean} True if graph is a multigraph, False otherwise.
       *
       * @override
       * @export
       */

      value: function isMultigraph() {
        return false;
      },
      writable: true,
      configurable: true
    },
    isDirected: {

      /**
       * Return True if graph is directed, False otherwise.
       *
       * @return {boolean}  True if graph is directed, False otherwise.
       *
       * @override
       * @export
       */

      value: function isDirected() {
        return true;
      },
      writable: true,
      configurable: true
    },
    toDirected: {

      /**
       * Return a directed copy of the graph.
       *
       * Notes:
       *
       *      This returns a "deepcopy" of the edge, node, and
       *      graph attributes which attempts to completely copy
       *      all of the data and references.
       *
       *      This is in contrast to the similar D = new DiGraph(G) which returns a
       *      shallow copy of the data.
       *
       * @return {!DiGraph} A deepcopy of the graph
       *
       * @override
       * @export
       */

      value: function toDirected() {
        return deepcopy(this);
      },
      writable: true,
      configurable: true
    },
    toUndirected: {

      /**
      * Return an undirected representation of the digraph.
      *
      * Notes:
      *
      * If edges in both directions (u,v) and (v,u) exist in the
      * graph, attributes for the new undirected edge will be a combination of
      * the attributes of the directed edges.  The edge data is updated
      * in the (arbitrary) order that the edges are encountered.  For
      * more customized control of the edge attributes use add_edge().
      *
      * This returns a "deepcopy" of the edge, node, and
      * graph attributes which attempts to completely copy
      * all of the data and references.
      *
      * This is in contrast to the similar G=DiGraph(D) which returns a
      * shallow copy of the data.
      *
      * @param {boolean=} opt_reciprocal
      *      If True only keep edges that appear in both directions
      *      in the original digraph.
      *
      * @return {!Graph}
      *      An undirected graph with the same name and nodes and
      *      with edge (u,v,data) if either (u,v,data) or (v,u,data)
      *      is in the digraph.  If both edges exist in digraph and
      *      their edge data is different, only one edge is created
      *      with an arbitrary choice of which edge data to use.
      *      You must check and correct for this manually if desired.
      *
      * @override
      * @export
      */

      value: function toUndirected(optReciprocal) {
        var H = new Graph();
        H.name = this.name;
        H.addNodesFrom(this);

        var thisPred = this.pred;

        if (optReciprocal) {
          H.addEdgesFrom(_regeneratorRuntime.mark(function callee$2$0() {
            var _this = this;

            var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, nodeData, node, predecessors, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, nbrData;

            return _regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
              while (1) switch (context$3$0.prev = context$3$0.next) {
                case 0:
                  _iteratorNormalCompletion = true;
                  _didIteratorError = false;
                  _iteratorError = undefined;
                  context$3$0.prev = 3;
                  _iterator = _core.$for.getIterator(_this.adjacencyIter());

                case 5:
                  if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$3$0.next = 39;
                    break;
                  }

                  nodeData = _step.value;
                  node = nodeData[0];
                  predecessors = thisPred.get(node);
                  _iteratorNormalCompletion2 = true;
                  _didIteratorError2 = false;
                  _iteratorError2 = undefined;
                  context$3$0.prev = 12;
                  _iterator2 = _core.$for.getIterator(nodeData[1]);

                case 14:
                  if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                    context$3$0.next = 22;
                    break;
                  }

                  nbrData = _step2.value;

                  if (!predecessors.has(nbrData[0])) {
                    context$3$0.next = 19;
                    break;
                  }

                  context$3$0.next = 19;
                  return tuple3(node, nbrData[0], deepcopy(nbrData[1]));

                case 19:
                  _iteratorNormalCompletion2 = true;
                  context$3$0.next = 14;
                  break;

                case 22:
                  context$3$0.next = 28;
                  break;

                case 24:
                  context$3$0.prev = 24;
                  context$3$0.t27 = context$3$0["catch"](12);
                  _didIteratorError2 = true;
                  _iteratorError2 = context$3$0.t27;

                case 28:
                  context$3$0.prev = 28;
                  context$3$0.prev = 29;

                  if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                    _iterator2["return"]();
                  }

                case 31:
                  context$3$0.prev = 31;

                  if (!_didIteratorError2) {
                    context$3$0.next = 34;
                    break;
                  }

                  throw _iteratorError2;

                case 34:
                  return context$3$0.finish(31);

                case 35:
                  return context$3$0.finish(28);

                case 36:
                  _iteratorNormalCompletion = true;
                  context$3$0.next = 5;
                  break;

                case 39:
                  context$3$0.next = 45;
                  break;

                case 41:
                  context$3$0.prev = 41;
                  context$3$0.t28 = context$3$0["catch"](3);
                  _didIteratorError = true;
                  _iteratorError = context$3$0.t28;

                case 45:
                  context$3$0.prev = 45;
                  context$3$0.prev = 46;

                  if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                  }

                case 48:
                  context$3$0.prev = 48;

                  if (!_didIteratorError) {
                    context$3$0.next = 51;
                    break;
                  }

                  throw _iteratorError;

                case 51:
                  return context$3$0.finish(48);

                case 52:
                  return context$3$0.finish(45);

                case 53:
                case "end":
                  return context$3$0.stop();
              }
            }, callee$2$0, this, [[3, 41, 45, 53], [12, 24, 28, 36], [29,, 31, 35], [46,, 48, 52]]);
          }).call(this));
        } else {
          H.addEdgesFrom(_regeneratorRuntime.mark(function callee$2$1() {
            var _this = this;

            var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, nodeData, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, nbrData;

            return _regeneratorRuntime.wrap(function callee$2$1$(context$3$0) {
              while (1) switch (context$3$0.prev = context$3$0.next) {
                case 0:
                  _iteratorNormalCompletion = true;
                  _didIteratorError = false;
                  _iteratorError = undefined;
                  context$3$0.prev = 3;
                  _iterator = _core.$for.getIterator(_this.adjacencyIter());

                case 5:
                  if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$3$0.next = 36;
                    break;
                  }

                  nodeData = _step.value;
                  _iteratorNormalCompletion2 = true;
                  _didIteratorError2 = false;
                  _iteratorError2 = undefined;
                  context$3$0.prev = 10;
                  _iterator2 = _core.$for.getIterator(nodeData[1]);

                case 12:
                  if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                    context$3$0.next = 19;
                    break;
                  }

                  nbrData = _step2.value;
                  context$3$0.next = 16;
                  return tuple3(nodeData[0], nbrData[0], deepcopy(nbrData[1]));

                case 16:
                  _iteratorNormalCompletion2 = true;
                  context$3$0.next = 12;
                  break;

                case 19:
                  context$3$0.next = 25;
                  break;

                case 21:
                  context$3$0.prev = 21;
                  context$3$0.t29 = context$3$0["catch"](10);
                  _didIteratorError2 = true;
                  _iteratorError2 = context$3$0.t29;

                case 25:
                  context$3$0.prev = 25;
                  context$3$0.prev = 26;

                  if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                    _iterator2["return"]();
                  }

                case 28:
                  context$3$0.prev = 28;

                  if (!_didIteratorError2) {
                    context$3$0.next = 31;
                    break;
                  }

                  throw _iteratorError2;

                case 31:
                  return context$3$0.finish(28);

                case 32:
                  return context$3$0.finish(25);

                case 33:
                  _iteratorNormalCompletion = true;
                  context$3$0.next = 5;
                  break;

                case 36:
                  context$3$0.next = 42;
                  break;

                case 38:
                  context$3$0.prev = 38;
                  context$3$0.t30 = context$3$0["catch"](3);
                  _didIteratorError = true;
                  _iteratorError = context$3$0.t30;

                case 42:
                  context$3$0.prev = 42;
                  context$3$0.prev = 43;

                  if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                  }

                case 45:
                  context$3$0.prev = 45;

                  if (!_didIteratorError) {
                    context$3$0.next = 48;
                    break;
                  }

                  throw _iteratorError;

                case 48:
                  return context$3$0.finish(45);

                case 49:
                  return context$3$0.finish(42);

                case 50:
                case "end":
                  return context$3$0.stop();
              }
            }, callee$2$1, this, [[3, 38, 42, 50], [10, 21, 25, 33], [26,, 28, 32], [43,, 45, 49]]);
          }).call(this));
        }

        H.graph = deepcopy(this.graph);
        H.node = deepcopy(this.node);
        return H;
      },
      writable: true,
      configurable: true
    },
    reverse: {

      /**
      * Return the reverse of the graph.
      *
      * The reverse is a graph with the same nodes and edges
      * but with the directions of the edges reversed.
      *
      * @param {boolean=} opt_copy (default=True)
      *      If True, return a new DiGraph holding the reversed edges.
      *      If False, reverse the reverse graph is created using
      *      the original graph (this changes the original graph).
      *
      * @return {!DiGraph} A copy of the graph or the graph itself
      *
      * @export
      */

      value: function reverse() {
        var optCopy = arguments[0] === undefined ? true : arguments[0];

        var H;
        if (optCopy) {
          H = new this.constructor(null, { name: "Reverse of (" + this.name + ")" });
          H.addNodesFrom(this);
          H.addEdgesFrom(mapIterator(this.edgesIter(null, true), function (edge) {
            return tuple3c(edge[1], edge[0], deepcopy(edge[2]), edge);
          }));
          H.graph = deepcopy(this.graph);
          H.node = deepcopy(this.node);
        } else {
          var thisPred = this.pred;
          var thisSucc = this.succ;

          this.succ = thisPred;
          this.pred = thisSucc;
          this.adj = this.succ;
          H = this;
        }
        return H;
      },
      writable: true,
      configurable: true
    },
    subgraph: {

      /**
      * Return the subgraph induced on nodes in nbunch.
      *
      * The induced subgraph of the graph contains the nodes in nbunch
      * and the edges between those nodes.
      *
      * Notes:
      *
      * The graph, edge or node attributes just point to the original graph.
      * So changes to the node or edge structure will not be reflected in
      * the original graph while changes to the attributes will.
      *
      * To create a subgraph with its own copy of the edge/node attributes use:
      * nx.Graph(G.subgraph(nbunch))
      *
      * If edge attributes are containers, a deep copy can be obtained using:
      * G.subgraph(nbunch).copy()
      *
      * For an inplace reduction of a graph to a subgraph you can remove nodes:
      * G.remove_nodes_from([ n in G if n not in set(nbunch)])
      *
      * @param {NodeContainer} nbunch
      *      A container of nodes which will be iterated through once.
      *
      * @return {DiGraph} A subgraph of the graph with the same edge
      *   attributes.
      *
      *
      * @override
      * @export
      */

      value: function subgraph(nbunch) {
        var bunch = this.nbunchIter(nbunch);
        var n;
        // create new graph and copy subgraph into it
        var H = new this.constructor();
        // copy node and attribute dictionaries
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _core.$for.getIterator(bunch), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            n = _step.value;

            H.node.set(n, this.node.get(n));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        // namespace shortcuts for speed
        var HSucc = H.succ;
        var HPred = H.pred;

        // add nodes
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = _core.$for.getIterator(H), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            n = _step2.value;

            HSucc.set(n, new Map());
            HPred.set(n, new Map());
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        // add edges
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = _core.$for.getIterator(HSucc), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var unbrs = _step3.value;

            var _unbrs = _babelHelpers.slicedToArray(unbrs, 2);

            var u = _unbrs[0];
            var Hnbrs = _unbrs[1];
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = _core.$for.getIterator(this.succ.get(u)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var vdataddict = _step4.value;

                var _vdataddict = _babelHelpers.slicedToArray(vdataddict, 2);

                var v = _vdataddict[0];
                var datadict = _vdataddict[1];

                if (HSucc.has(v)) {
                  // add both representations of edge: u-v and v-u
                  Hnbrs.set(v, datadict);
                  HPred.get(v).set(u, datadict);
                }
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
                  _iterator4["return"]();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        H.graph = this.graph;
        return H;
      },
      writable: true,
      configurable: true
    }
  });

  return DiGraph;
})(Graph);

module.exports = DiGraph;

// pass

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../_internals/Map":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Map.js","../convert":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/convert.js","../exceptions/JSNetworkXError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXError.js","./Graph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/Graph.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/Graph.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var KeyError = _babelHelpers.interopRequire(require("../exceptions/KeyError"));

/* jshint ignore:start */

var Map = _babelHelpers.interopRequire(require("../_internals/Map"));

var Set = _babelHelpers.interopRequire(require("../_internals/Set"));

/* jshint ignore:end */

var JSNetworkXError = _babelHelpers.interopRequire(require("../exceptions/JSNetworkXError"));

var isBoolean = _babelHelpers.interopRequire(require("lodash/lang/isBoolean"));

var isString = _babelHelpers.interopRequire(require("lodash/lang/isString"));

var convert = _babelHelpers.interopRequire(require("../convert"));

var _internals = require("../_internals");

var clear = _internals.clear;
var clone = _internals.clone;
var deepcopy = _internals.deepcopy;
var forEach = _internals.forEach;
var isPlainObject = _internals.isPlainObject;
var mapIterator = _internals.mapIterator;
var mapSequence = _internals.mapSequence;
var toIterator = _internals.toIterator;
var sprintf = _internals.sprintf;
var tuple2 = _internals.tuple2;
var tuple2c = _internals.tuple2c;
var tuple3 = _internals.tuple3;
var tuple3c = _internals.tuple3c;
var zipSequence = _internals.zipSequence;

/*jshint expr:false*/

/*
 * Base class for undirected graphs.
 *
 * A Graph stores nodes and edges with optional data, or attributes.
 *
 * Graphs hold undirected edges.  Self loops are allowed but multiple
 * (parallel) edges are not.
 *
 * Nodes can be arbitrary (hashable) Python objects with optional
 * key/value attributes.
 *
 * Edges are represented as links between nodes with optional
 * key/value attributes.
 *
 * See Also
 * --------
 * DiGraph
 * MultiGraph
 * MultiDiGraph
 *
 * @param {*=} opt_data Data to initialize graph.  If data=None (default) an
 *       empty graph is created. The data can be an edge list, or any
 *       NetworkX graph object.
 * @param {Object=} opt_attr (default= no attributes)
 *       Attributes to add to graph as key=value pairs.
 */

var Graph = (function () {
  function Graph(optData, optAttr) {
    _babelHelpers.classCallCheck(this, Graph);

    // makes it possible to call Graph without new
    if (!(this instanceof Graph)) {
      return new Graph(optData, optAttr);
    }

    this.graph = {}; // dictionary for graph attributes
    this.node = new Map(); // empty node dict (created before convert)
    this.adj = new Map(); // empty adjacency dict

    // attempt to load graph with data
    if (optData != null) {
      convert.toNetworkxGraph(optData, this);
    }

    // load graph attributes (must be after convert)
    if (optAttr) {
      _core.Object.assign(this.graph, optAttr);
    }
    this.edge = this.adj;
  }

  _babelHelpers.prototypeProperties(Graph, {
    __name__: {

      /**
       * Holds the graph type (class) name for information.
       * This is compatible to Pythons __name__ property.
       *
       * @type {string}
       */

      get: function () {
        return "Graph";
      },
      configurable: true
    }
  }, (function () {
    var _babelHelpers$prototypeProperties = {
      name: {

        /**
         * Gets or sets the name of the graph.
         *
         * @param {string=} opt_name Graph name.
         *
         * @return {(string|undefined)} Graph name if no parameter was passed.
         * @export
         */

        get: function () {
          return this.graph.name || "";
        },
        set: function (name) {
          this.graph.name = name;
        },
        configurable: true
      },
      toString: {

        // Implements __str__
        /**
         * Return the graph name
         *
         * @return {string} Graph name.
         * @export
         */

        value: function toString() {
          return this.name;
        },
        writable: true,
        configurable: true
      },
      forEach: {

        /* for convenience */

        value: function forEach(callback, optThisValue) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _core.$for.getIterator(this.adj.keys()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var n = _step.value;

              if (optThisValue) {
                callback.call(optThisValue, n);
              } else {
                callback(n);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        },
        writable: true,
        configurable: true
      },
      get: {

        // __contains__ is not supported, has_node has to be used

        // __len__ is not supported, number_of_nodes or order has to be used

        // Implements __getitem__
        /**
         * Return a dict of neighbors of node n.
         *
         * @param {Node} n  A node in the graph.
         *
         * @return {!Map} The adjacency dictionary for nodes
         *   connected to n.
         * @export
         */

        value: function get(n) {
          var value = this.adj.get(n);
          if (typeof value === "undefined") {
            throw new KeyError("Graph does not contain node " + n + ".");
          }
          return value;
        },
        writable: true,
        configurable: true
      },
      addNode: {

        /**
         * Add a single node n and update node attributes.
         *
         * Since JavaScript does not provide keyword arguments,
         * all attributes must be passed in an object as second
         * argument.
         *
         * @param {!Node} n A node.
         * @param {Object=} opt_attr_dict Dictionary of node attributes.
         *      Key/value pairs will update existing data associated with the node.
         * @export
         */

        value: function addNode(n) {
          var optAttrDict = arguments[1] === undefined ? {} : arguments[1];

          if (!isPlainObject(optAttrDict)) {
            throw new JSNetworkXError("The attr_dict argument must be an object.");
          }

          if (!this.node.has(n)) {
            this.adj.set(n, new Map());
            this.node.set(n, optAttrDict);
          } else {
            // update attr even if node already exists
            _core.Object.assign(this.node.get(n), optAttrDict);
          }
        },
        writable: true,
        configurable: true
      },
      addNodesFrom: {

        /**
         * Add multiple nodes.
         *
         * Since JavaScript does not provide keyword arguments,
         * all attributes must be passed in an object as second
         * argument.
         *
         * @param {!NodeContainer} nodes
         *       A container of nodes (Array, Object, Array-like).
         *       OR
         *       A container of (node, attribute dict) tuples.
         *
         * @param {Object=} opt_attr  Update attributes for all nodes in nodes.
         *       Node attributes specified in nodes as a tuple
         *       take precedence over attributes specified generally.
         * @export
         */

        value: function addNodesFrom(nodes) {
          var optAttr = arguments[1] === undefined ? {} : arguments[1];

          forEach(nodes, function (node) {
            if (Array.isArray(node) && node.length === 2 && isPlainObject(node[1])) {
              var _node = _babelHelpers.slicedToArray(node, 2);

              var nn = _node[0];
              var ndict = _node[1];

              if (!this.adj.has(nn)) {
                this.adj.set(nn, new Map());
                var newdict = clone(optAttr);
                this.node.set(nn, _core.Object.assign(newdict, ndict));
              } else {
                var olddict = this.node.get(nn);
                _core.Object.assign(olddict, optAttr, ndict);
              }
              return; // continue next iteration
            }
            var newnode = !this.node.has(node);
            if (newnode) {
              this.adj.set(node, new Map());
              this.node.set(node, clone(optAttr));
            } else {
              _core.Object.assign(this.node.get(node), optAttr);
            }
          }, this);
        },
        writable: true,
        configurable: true
      },
      removeNode: {

        /**
         * Remove node n.
         *
         * Removes the node n and all adjacent edges.
         * Attempting to remove a non-existent node will raise an exception.
         *
         * @param {Node} n A node in the graph.
         * @export
         */

        value: function removeNode(n) {
          var adj = this.adj;

          if (this.node["delete"](n)) {
            adj.get(n).forEach(function (_, u) {
              return adj.get(u)["delete"](n) // remove all edges n-u in graph
              ;
            });
            adj["delete"](n); // now remove node
          } else {
            throw new JSNetworkXError("The node %s is not in the graph", n);
          }
        },
        writable: true,
        configurable: true
      },
      removeNodesFrom: {

        /**
         * Remove multiple nodes.
         *
         * @param {NodeContainer} nodes A container of nodes
         *      If a node in the container is not in the graph it is silently ignored.
         *
         * @export
         */

        value: function removeNodesFrom(nodes) {
          var adj = this.adj;
          var node = this.node;

          forEach(nodes, function (n) {
            if (node["delete"](n)) {
              adj.get(n).forEach(function (_, u) {
                return adj.get(u)["delete"](n);
              });
              adj["delete"](n);
            }
          });
        },
        writable: true,
        configurable: true
      },
      nodesIter: {

        /**
         * Return an iterator over the nodes.
         *
         * @param {boolean=} opt_data (default false) If false the iterator returns
         *   nodes. If true return a two-tuple of node and node data dictionary.
         *
         * @return {Iterator} of nodes If data=true the iterator gives
         *           two-tuples containing (node, node data, dictionary).
         * @export
         */

        value: function nodesIter(optData) {
          if (optData) {
            return toIterator(this.node);
          }
          return this.node.keys();
        },
        writable: true,
        configurable: true
      },
      nodes: {

        /**
         * Return a list of the nodes in the graph.
         *
         * @param {boolean=} opt_data (default false) If false the iterator returns
         *   nodes. If true return a two-tuple of node and node data dictionary.
         *
         * @return {!Array} of nodes If data=true a list of two-tuples containing
         *           (node, node data dictionary).
         * @export
         */

        value: function nodes(optData) {
          return _core.Array.from(optData ? this.node.entries() : this.node.keys());
        },
        writable: true,
        configurable: true
      },
      numberOfNodes: {

        /**
         * Return the number of nodes in the graph.
         *
         * @return {number} The number of nodes in the graph.
         * @export
         */

        value: function numberOfNodes() {
          return this.node.size;
        },
        writable: true,
        configurable: true
      },
      order: {

        /**
         * Return the number of nodes in the graph.
         *
         * @return {number} The number of nodes in the graph.
         * @export
         */

        value: function order() {
          return this.node.size;
        },
        writable: true,
        configurable: true
      },
      hasNode: {

        /**
         * Return true if the graph contains the node n.
         *
         * @param {!(Node|NodeContainer)} n node.
         *
         * @return {boolean}
         * @export
         */

        value: function hasNode(n) {
          return this.node.has(n);
        },
        writable: true,
        configurable: true
      },
      addEdge: {

        /**
         * Add an edge between u and v.
         *
         * The nodes u and v will be automatically added if they are
         * not already in the graph.
         *
         * Edge attributes can be specified by providing
         * a dictionary with key/value pairs.
         *
         * Unlike in Python, attributes can only be defined
         * via the dictionary.
         *
         * @param {Node} u Node.
         * @param {Node} v Node.
         * @param {?Object=} opt_attr_dict Dictionary of edge attributes.
         *      Key/value pairs will update existing data associated with the edge.
         *
         * @export
         */

        value: function addEdge(u, v, optAttrDict) {
          if (optAttrDict && !isPlainObject(optAttrDict)) {
            throw new JSNetworkXError("The attr_dict argument must be an object.");
          }

          // add nodes
          if (!this.node.has(u)) {
            this.adj.set(u, new Map());
            this.node.set(u, {});
          }
          if (!this.node.has(v)) {
            this.adj.set(v, new Map());
            this.node.set(v, {});
          }

          // add the edge
          var datadict = this.adj.get(u).get(v) || {};
          _core.Object.assign(datadict, optAttrDict);
          this.adj.get(u).set(v, datadict);
          this.adj.get(v).set(u, datadict);
        },
        writable: true,
        configurable: true
      },
      addEdgesFrom: {

        /**
         * Add all the edges in ebunch.
         *
         * Adding the same edge twice has no effect but any edge data
         * will be updated when each duplicate edge is added.
         *
         * Edge attributes specified in edges as a tuple take precedence
         * over attributes specified generally.
         *
         * @param {Iterable} ebunch container of edges
         *      Each edge given in the container will be added to the
         *      graph. The edges must be given as as 2-tuples (u,v) or
         *      3-tuples (u,v,d) where d is a dictionary containing edge
         *      data.
         *
         * @param {Object=} opt_attr_dict
         *     Dictionary of edge attributes.  Key/value pairs will
         *     update existing data associated with each edge.
         * @export
         */

        value: function addEdgesFrom(ebunch, optAttrDict) {
          if (optAttrDict && !isPlainObject(optAttrDict)) {
            throw new JSNetworkXError("The attr_dict argument must be an object.");
          }

          // process ebunch
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _core.$for.getIterator(ebunch), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var tuple = _step.value;

              if (tuple.length == null) {
                throw new JSNetworkXError(sprintf("Edge tuple %j must be a 2-tuple or 3-tuple.", tuple));
              }

              var _tuple = _babelHelpers.slicedToArray(tuple, 3);

              var u = _tuple[0];
              var v = _tuple[1];
              var data = _tuple[2];

              if (!isPlainObject(data)) {
                data = {};
              }
              if (u == null || v == null || tuple[3] != null) {
                throw new JSNetworkXError(sprintf("Edge tuple %j must be a 2-tuple or 3-tuple.", tuple));
              }

              if (!this.node.has(u)) {
                this.adj.set(u, new Map());
                this.node.set(u, {});
              }
              if (!this.node.has(v)) {
                this.adj.set(v, new Map());
                this.node.set(v, {});
              }

              // add the edge
              var datadict = this.adj.get(u).get(v) || {};
              _core.Object.assign(datadict, optAttrDict, data);
              this.adj.get(u).set(v, datadict);
              this.adj.get(v).set(u, datadict);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        },
        writable: true,
        configurable: true
      },
      addWeightedEdgesFrom: {

        /**
         * Add all the edges in ebunch as weighted edges with specified weights.
         *
         *
         * Adding the same edge twice for Graph/DiGraph simply updates
         * the edge data.  For MultiGraph/MultiDiGraph, duplicate edges
         * are stored.
         *
         * Since JavaScript does not support keyword arguments, all attributes
         * must be passed in the attr object.
         *
         * @param {?} ebunch  container of edges
         *      Each edge given in the list or container will be added
         *      to the graph. The edges must be given as 3-tuples (u,v,w)
         *      where w is a number.
         *
         * @param {string=} opt_weight (default 'weight')
         *      The attribute name for the edge weights to be added.
         *
         * @param {Object=} opt_attr Edge attributes to add/update for all edges.
         *
         * @export
         */

        value: function addWeightedEdgesFrom(ebunch, optWeight, optAttr) {
          optAttr = optAttr || {};
          if (!isString(optWeight)) {
            optAttr = optWeight;
            optWeight = "weight";
          }

          this.addEdgesFrom(mapSequence(ebunch, function (e) {
            var attr = {};
            attr[optWeight] = e[2];
            if (attr[optWeight] == null) {
              // simulate too few value to unpack error
              throw new TypeError("Values must consist of three elements: %s.", e);
            }
            return [e[0], e[1], attr];
          }), optAttr);
        },
        writable: true,
        configurable: true
      },
      removeEdge: {

        /**
         * Remove the edge between u and v.
         *
         * @param {Node} u Node.
         * @param {Node} v Node.
         *
         * @export
         */

        value: function removeEdge(u, v) {
          var node = this.adj.get(u);
          if (node != null) {
            node["delete"](v);
            // self-loop needs only one entry removed
            var vnode = this.adj.get(v);
            if (vnode !== node) {
              vnode["delete"](u);
            }
          } else {
            throw new JSNetworkXError("The edge %s-%s is not in the graph", u, v);
          }
        },
        writable: true,
        configurable: true
      },
      removeEdgesFrom: {

        /**
         * Remove all edges specified in ebunch.
         *
         * Notes: Will fail silently if an edge in ebunch is not in the graph.
         *
         * @param {?} ebunch 1list or container of edge tuples
         *      Each edge given in the list or container will be removed
         *      from the graph. The edges can be:
         *          - 2-tuples (u,v) edge between u and v.
         *          - 3-tuples (u,v,k) where k is ignored.
         * @export
         */

        value: function removeEdgesFrom(ebunch) {
          var adj = this.adj;
          forEach(ebunch, function (_ref) {
            var _ref2 = _babelHelpers.slicedToArray(_ref, 2);

            var u = _ref2[0];
            var v = _ref2[1];

            var unode = adj.get(u);
            if (unode != null && unode.has(v)) {
              unode["delete"](v);
              var vnode = adj.get(v);
              if (vnode !== unode) {
                vnode["delete"](u);
              }
            }
          });
        },
        writable: true,
        configurable: true
      },
      hasEdge: {

        /**
         * Return True if the edge (u,v) is in the graph.
         *
         * @param {Node} u Node.
         * @param {Node} v Node.
         *
         * @return {boolean} True if edge is in the graph, False otherwise.
         * @export
         */

        value: function hasEdge(u, v) {
          var unode = this.adj.get(u);
          return unode && unode.has(v);
        },
        writable: true,
        configurable: true
      },
      neighbors: {

        /**
         * Return a list of the nodes connected to the node n.
         *
         * @param {!Node} n A node in the graph.
         *
         * @return {!Array} A list of nodes that are adjacent to n.
         * @export
         */

        value: function neighbors(n) {
          return _core.Array.from(this.neighborsIter(n));
        },
        writable: true,
        configurable: true
      },
      neighborsIter: {

        /**
         * Return an iterator over all neighbors of node n.
         *
         * @param {!Node} n A node in the graph.
         *
         * @return {!Iterator} A list of nodes that are adjacent to n.
         * @export
         */

        value: function neighborsIter(n) {
          var node = this.adj.get(n);
          if (node != null) {
            return node.keys();
          } else {
            throw new JSNetworkXError("The node %s is not in the graph.", n);
          }
        },
        writable: true,
        configurable: true
      },
      edges: {

        /**
         * Return a list of edges.
         *
         * Edges are returned as tuples with optional data
         * in the order (node, neighbor, data).
         *
         * Note: Nodes in nbunch that are not in the graph will be (quietly) ignored.
         * For directed graphs this returns the out-edges.
         *
         * @param {?NodeContainer=} opt_nbunch A container of nodes.
         *      The container will be iterated through once.
         * @param {?boolean=} opt_data Return two tuples (u,v) (False)
         *      or three-tuples (u,v,data) (True).
         *
         * @return {!Array} list of edge tuples
         *      Edges that are adjacent to any node in nbunch, or a list
         *      of all edges if nbunch is not specified.
         * @export
         */

        value: function edges(optNbunch, optData) {
          return _core.Array.from(this.edgesIter(optNbunch, optData));
        },
        writable: true,
        configurable: true
      },
      edgesIter: {

        /**
         * Return an iterator over the edges.
         *
         * Edges are returned as tuples with optional data
         * in the order (node, neighbor, data).
         *
         * Note: Nodes in nbunch that are not in the graph will be (quietly) ignored.
         * For directed graphs this returns the out-edges.
         *
         * @param {?(NodeContainer|boolean)=} opt_nbunch A container of nodes.
         *      The container will be iterated through once.
         * @param {?boolean=} opt_data Return two tuples (u,v) (False)
         *      or three-tuples (u,v,data) (True).
         *
         * @return {!Iterator} list of edge tuples
         *      Edges that are adjacent to any node in nbunch, or a list
         *      of all edges if nbunch is not specified.
         * @export
         */

        value: _regeneratorRuntime.mark(function edgesIter(optNbunch, optData) {
          var _this = this;

          var seen, nodesNbrs, adj, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, nodeData, node, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, neighborsData;

          return _regeneratorRuntime.wrap(function edgesIter$(context$3$0) {
            while (1) switch (context$3$0.prev = context$3$0.next) {
              case 0:

                // handle calls with data being the only argument
                if (isBoolean(optNbunch)) {
                  optData = optNbunch;
                  optNbunch = null;
                }

                seen = new Set();

                if (optNbunch == null) {
                  nodesNbrs = _this.adj.entries();
                } else {
                  adj = _this.adj;

                  nodesNbrs = mapIterator(_this.nbunchIter(optNbunch), function (n) {
                    return tuple2(n, adj.get(n));
                  });
                }

                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$3$0.prev = 6;
                _iterator = _core.$for.getIterator(nodesNbrs);

              case 8:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  context$3$0.next = 49;
                  break;
                }

                nodeData = _step.value;
                node = nodeData[0];
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                context$3$0.prev = 14;
                _iterator2 = _core.$for.getIterator(nodeData[1].entries());

              case 16:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  context$3$0.next = 30;
                  break;
                }

                neighborsData = _step2.value;

                if (seen.has(neighborsData[0])) {
                  context$3$0.next = 27;
                  break;
                }

                if (!optData) {
                  context$3$0.next = 25;
                  break;
                }

                neighborsData.unshift(node);
                context$3$0.next = 23;
                return neighborsData;

              case 23:
                context$3$0.next = 27;
                break;

              case 25:
                context$3$0.next = 27;
                return [node, neighborsData[0]];

              case 27:
                _iteratorNormalCompletion2 = true;
                context$3$0.next = 16;
                break;

              case 30:
                context$3$0.next = 36;
                break;

              case 32:
                context$3$0.prev = 32;
                context$3$0.t31 = context$3$0["catch"](14);
                _didIteratorError2 = true;
                _iteratorError2 = context$3$0.t31;

              case 36:
                context$3$0.prev = 36;
                context$3$0.prev = 37;

                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                  _iterator2["return"]();
                }

              case 39:
                context$3$0.prev = 39;

                if (!_didIteratorError2) {
                  context$3$0.next = 42;
                  break;
                }

                throw _iteratorError2;

              case 42:
                return context$3$0.finish(39);

              case 43:
                return context$3$0.finish(36);

              case 44:
                seen.add(node);
                nodeData.length = 0;

              case 46:
                _iteratorNormalCompletion = true;
                context$3$0.next = 8;
                break;

              case 49:
                context$3$0.next = 55;
                break;

              case 51:
                context$3$0.prev = 51;
                context$3$0.t32 = context$3$0["catch"](6);
                _didIteratorError = true;
                _iteratorError = context$3$0.t32;

              case 55:
                context$3$0.prev = 55;
                context$3$0.prev = 56;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                  _iterator["return"]();
                }

              case 58:
                context$3$0.prev = 58;

                if (!_didIteratorError) {
                  context$3$0.next = 61;
                  break;
                }

                throw _iteratorError;

              case 61:
                return context$3$0.finish(58);

              case 62:
                return context$3$0.finish(55);

              case 63:
              case "end":
                return context$3$0.stop();
            }
          }, edgesIter, this, [[6, 51, 55, 63], [14, 32, 36, 44], [37,, 39, 43], [56,, 58, 62]]);
        }),
        writable: true,
        configurable: true
      },
      getEdgeData: {

        /**
         * Return the attribute dictionary associated with edge (u,v).
         *
         * @param {Node} u Node.
         * @param {Node} v Node.
         * @param {T=} opt_default (default=null)
         *      Value to return if the edge (u,v) is not found.
         *
         * @return {(Object|T)} The edge attribute dictionary.
         * @template T
         *
         * @export
         */

        value: function getEdgeData(u, v, optDefault) {
          var nbrs = this.adj.get(u);
          if (nbrs != null) {
            var data = nbrs.get(v);
            if (data != null) {
              return data;
            }
          }
          return optDefault;
        },
        writable: true,
        configurable: true
      },
      adjacencyList: {

        /**
         * Return an adjacency list representation of the graph.
         *
         * The output adjacency list is in the order of G.nodes().
         * For directed graphs, only outgoing adjacencies are included.
         *
         * @return {!Array.<Array>} The adjacency structure of the graph as a
         *      list of lists.
         * @export
         */

        value: function adjacencyList() {
          return _core.Array.from(mapIterator(this.adjacencyIter(), function (_ref) {
            var _ref2 = _babelHelpers.slicedToArray(_ref, 2);

            var _ = _ref2[0];
            var adj = _ref2[1];
            return _core.Array.from(adj.keys());
          }));
        },
        writable: true,
        configurable: true
      },
      adjacencyIter: {

        /**
         * Return an iterator of (node, adjacency dict) tuples for all nodes.
         *
         *
         * @return {!Iterator} An array of (node, adjacency dictionary)
         *      for all nodes in the graph.
         * @export
         */

        value: function adjacencyIter() {
          return this.adj.entries();
        },
        writable: true,
        configurable: true
      },
      degree: {

        /**
         * Return the degree of a node or nodes.
         *
         * The node degree is the number of edges adjacent to that node.
         *
         * WARNING: Since both parameters are optional, and the weight attribute
         * name could be equal to a node name, nbunch as to be set to null explicitly
         * to use the second argument as weight attribute name.
         *
         * @param {(Node|NodeContainer)=} opt_nbunch (default=all nodes)
         *      A container of nodes.  The container will be iterated
         *      through once.
         *
         * @param {string=} opt_weight (default=None)
         *      The edge attribute that holds the numerical value used
         *      as a weight.  If null or not defined, then each edge has weight 1.
         *      The degree is the sum of the edge weights adjacent to the node.
         *
         * @return {!(number|Map)} A dictionary with nodes as keys and
         * degree as values or a number if a single node is specified.
         * @export
         */

        value: function degree(optNbunch, optWeight) {
          if (optNbunch != null && this.hasNode(optNbunch)) {
            // return a single node
            return this.degreeIter(optNbunch, optWeight).next().value[1];
          } else {
            return new Map(this.degreeIter(optNbunch, optWeight));
          }
        },
        writable: true,
        configurable: true
      },
      degreeIter: {

        /**
         * Return an array for (node, degree).
         *
         *
         * @param {(Node|NodeContainer)=} opt_nbunch (default=all nodes)
         *       A container of nodes.  The container will be iterated
         *       through once.
         * @param {string=} opt_weight (default=None)
         *      The edge attribute that holds the numerical value used
         *      as a weight.  If null or not defined, then each edge has weight 1.
         *      The degree is the sum of the edge weights adjacent to the node.
         *
         * WARNING: Since both parameters are optional, and the weight attribute
         * name could be equal to a node name, nbunch as to be set to null explicitly
         * to use the second argument as weight attribute name.
         *
         * @return {!Iterator} of two-tuples of (node, degree).
         *
         * @export
         */

        value: function degreeIter(optNbunch, optWeight) {
          var nodesNbrs;
          var iterator;

          if (optNbunch == null) {
            nodesNbrs = this.adj.entries();
          } else {
            var adj = this.adj;
            nodesNbrs = mapIterator(this.nbunchIter(optNbunch), function (n) {
              return tuple2(n, adj.get(n));
            });
          }

          if (!optWeight) {
            iterator = mapIterator(nodesNbrs, function (_ref) {
              var _ref2 = _babelHelpers.slicedToArray(_ref, 2);

              var node = _ref2[0];
              var nbrs = _ref2[1];

              return [node, nbrs.size + +nbrs.has(node)];
            });
          } else {
            iterator = mapIterator(nodesNbrs, function (_ref) {
              var _ref2 = _babelHelpers.slicedToArray(_ref, 2);

              var n = _ref2[0];
              var nbrs = _ref2[1];

              var sum = 0;

              nbrs.forEach(function (data) {
                var weight = data[optWeight];
                sum += +(weight != null ? weight : 1);
              });

              if (nbrs.has(n)) {
                var weight = nbrs.get(n)[optWeight];
                sum += +(weight != null ? weight : 1);
              }

              return [n, sum];
            });
          }

          return iterator;
        },
        writable: true,
        configurable: true
      },
      clear: {

        /**
         * Remove all nodes and edges from the graph.
         *
         * This also removes the name, and all graph, node, and edge attributes.
         *
         * @export
         */

        value: (function (_clear) {
          var _clearWrapper = function clear() {
            return _clear.apply(this, arguments);
          };

          _clearWrapper.toString = function () {
            return _clear.toString();
          };

          return _clearWrapper;
        })(function () {
          this.name = "";
          this.adj.clear();
          this.node.clear();
          clear(this.graph);
        }),
        writable: true,
        configurable: true
      },
      copy: {

        /**
         * Return a copy of the graph.
         *
         * This makes a complete copy of the graph including all of the
         * node or edge attributes.
         *
         * @return {!Graph}
         * @export
         */

        value: function copy() {
          return deepcopy(this);
        },
        writable: true,
        configurable: true
      },
      isMultigraph: {

        /**
         * Return True if graph is a multigraph, False otherwise.
         *
         * @return {boolean} True if graph is a multigraph, False otherwise.
         * @export
         */

        value: function isMultigraph() {
          return false;
        },
        writable: true,
        configurable: true
      },
      isDirected: {

        /**
         * Return True if graph is directed, False otherwise.
         *
         * @return {boolean}  True if graph is directed, False otherwise.
         * @export
         */

        value: function isDirected() {
          return false;
        },
        writable: true,
        configurable: true
      },
      toDirected: {

        /**
         * Return a directed representation of the graph.
         *
         * This returns a "deepcopy" of the edge, node, and
         * graph attributes which attempts to completely copy
         * all of the data and references.
         *
         * This is in contrast to the similar D=DiGraph(G) which returns a
         * shallow copy of the data.
         *
         * @return {!DiGraph}
         * @export
         */

        value: function toDirected() {
          var G = new (require("./DiGraph"))();
          G.name = this.name;
          G.addNodesFrom(this);
          G.addEdgesFrom(_regeneratorRuntime.mark(function callee$3$0() {
            var _this = this;

            var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, nd, u, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, nbr;

            return _regeneratorRuntime.wrap(function callee$3$0$(context$4$0) {
              while (1) switch (context$4$0.prev = context$4$0.next) {
                case 0:
                  _iteratorNormalCompletion = true;
                  _didIteratorError = false;
                  _iteratorError = undefined;
                  context$4$0.prev = 3;
                  _iterator = _core.$for.getIterator(_this.adjacencyIter());

                case 5:
                  if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$4$0.next = 37;
                    break;
                  }

                  nd = _step.value;
                  u = nd[0];
                  _iteratorNormalCompletion2 = true;
                  _didIteratorError2 = false;
                  _iteratorError2 = undefined;
                  context$4$0.prev = 11;
                  _iterator2 = _core.$for.getIterator(nd[1]);

                case 13:
                  if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                    context$4$0.next = 20;
                    break;
                  }

                  nbr = _step2.value;
                  context$4$0.next = 17;
                  return tuple3(u, nbr[0], deepcopy(nbr[1]));

                case 17:
                  _iteratorNormalCompletion2 = true;
                  context$4$0.next = 13;
                  break;

                case 20:
                  context$4$0.next = 26;
                  break;

                case 22:
                  context$4$0.prev = 22;
                  context$4$0.t33 = context$4$0["catch"](11);
                  _didIteratorError2 = true;
                  _iteratorError2 = context$4$0.t33;

                case 26:
                  context$4$0.prev = 26;
                  context$4$0.prev = 27;

                  if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                    _iterator2["return"]();
                  }

                case 29:
                  context$4$0.prev = 29;

                  if (!_didIteratorError2) {
                    context$4$0.next = 32;
                    break;
                  }

                  throw _iteratorError2;

                case 32:
                  return context$4$0.finish(29);

                case 33:
                  return context$4$0.finish(26);

                case 34:
                  _iteratorNormalCompletion = true;
                  context$4$0.next = 5;
                  break;

                case 37:
                  context$4$0.next = 43;
                  break;

                case 39:
                  context$4$0.prev = 39;
                  context$4$0.t34 = context$4$0["catch"](3);
                  _didIteratorError = true;
                  _iteratorError = context$4$0.t34;

                case 43:
                  context$4$0.prev = 43;
                  context$4$0.prev = 44;

                  if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                  }

                case 46:
                  context$4$0.prev = 46;

                  if (!_didIteratorError) {
                    context$4$0.next = 49;
                    break;
                  }

                  throw _iteratorError;

                case 49:
                  return context$4$0.finish(46);

                case 50:
                  return context$4$0.finish(43);

                case 51:
                case "end":
                  return context$4$0.stop();
              }
            }, callee$3$0, this, [[3, 39, 43, 51], [11, 22, 26, 34], [27,, 29, 33], [44,, 46, 50]]);
          }).call(this));
          G.graph = deepcopy(this.graph);
          G.node = deepcopy(this.node);

          return G;
        },
        writable: true,
        configurable: true
      },
      toUndirected: {

        /**
         * Return an undirected copy of the graph.
         *
         * This returns a "deepcopy" of the edge, node, and
         * graph attributes which attempts to completely copy
         * all of the data and references.
         *
         * This is in contrast to the similar G=DiGraph(D) which returns a
         * shallow copy of the data.
         *
         * @return {!Graph}
         * @export
         */

        value: function toUndirected() {
          return deepcopy(this);
        },
        writable: true,
        configurable: true
      },
      subgraph: {

        /**
         * Return the subgraph induced on nodes in nbunch.
         *
         * The induced subgraph of the graph contains the nodes in nbunch
         * and the edges between those nodes.
         *
         * The graph, edge or node attributes just point to the original graph.
         * So changes to the node or edge structure will not be reflected in
         * the original graph while changes to the attributes will.
         *
         * To create a subgraph with its own copy of the edge/node attributes use:
         * `jsnx.Graph(G.subgraph(nbunch))`.
         *
         * If edge attributes are containers, a deep copy can be obtained using:
         * `G.subgraph(nbunch).copy()`
         *
         * For an inplace reduction of a graph to a subgraph you can remove nodes:
         *
         * ```
         * G.removeNodesFrom(G.nodes().filter(function(n) {
         *      return nbunch.indexOf(n) > -1;
         * }))
         * ```
         *
         * @param {NodeContainer} nbunch
         *      A container of nodes which will be iterated through once.
         *
         * @return {Graph}
         * @export
         */

        value: function subgraph(nbunch) {
          var bunch = this.nbunchIter(nbunch);
          var n;

          // create new graph and copy subgraph into it
          var H = new this.constructor();
          // copy node and attribute dictionaries
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _core.$for.getIterator(bunch), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              n = _step.value;

              H.node.set(n, this.node.get(n));
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          // namespace shortcuts for speed
          var HAdj = H.adj;
          var thisAdj = this.adj;

          // add nodes and edges (undirected method)
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = _core.$for.getIterator(H), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              n = _step2.value;

              var Hnbrs = new Map();
              HAdj.set(n, Hnbrs);

              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = _core.$for.getIterator(thisAdj.get(n)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var nbrdata = _step3.value;

                  var nbr = nbrdata[0];
                  var data = nbrdata[1];
                  if (HAdj.has(nbr)) {
                    // add both representations of edge: n-nbr and nbr-n
                    Hnbrs.set(nbr, data);
                    HAdj.get(nbr).set(n, data);
                  }
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
                    _iterator3["return"]();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          H.graph = this.graph;

          return H;
        },
        writable: true,
        configurable: true
      },
      nodesWithSelfloops: {

        /**
         * Return a list of nodes with self loops.
         *
         * A node with a self loop has an edge with both ends adjacent
         * to that node.
         *
         * @return {Array.<string>} A list of nodes with self loops.
         * @export
         */

        value: function nodesWithSelfloops() {
          var nodes = [];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _core.$for.getIterator(this.adj.entries()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var nd = _step.value;

              if (nd[1].has(nd[0])) {
                nodes.push(nd[0]);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return nodes;
        },
        writable: true,
        configurable: true
      },
      selfloopEdges: {

        /**
         * Return a list of selfloop edges.
         *
         * A selfloop edge has the same node at both ends.
         *
         * @param {boolean=} opt_data (default=False)
         *      Return selfloop edges as two tuples (u,v) (data=False)
         *      or three-tuples (u,v,data) (data=True).
         *
         * @return {Array}  A list of all selfloop edges.
         * @export
         */

        value: function selfloopEdges(optData) {
          var edges = [];

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _core.$for.getIterator(this.adj.entries()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var nd = _step.value;

              var _nd = _babelHelpers.slicedToArray(nd, 2);

              var node = _nd[0];
              var nbrs = _nd[1];

              if (nbrs.has(node)) {
                if (optData) {
                  edges.push(tuple3c(node, node, nbrs.get(node), nd));
                } else {
                  edges.push(tuple2c(node, node, nd));
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return edges;
        },
        writable: true,
        configurable: true
      },
      numberOfSelfloops: {

        /**
         * Return the number of selfloop edges.
         *
         * A selfloop edge has the same node at both ends.
         *
         * @return {number} The number of selfloops.
         * @export
         */

        value: function numberOfSelfloops() {
          return this.selfloopEdges().length;
        },
        writable: true,
        configurable: true
      },
      size: {

        /**
         * Return the number of edges.
         *
         * @param {string=} opt_weight The edge attribute that holds the numerical
         *      value used as a weight.  If not defined, then each edge has weight 1.
         *
         * @return {number} The number of edges or sum of edge weights in the graph.
         * @export
         */

        value: function size(optWeight) {
          var s = 0;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _core.$for.getIterator(this.degree(null, optWeight).values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var v = _step.value;

              s += v;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          s = s / 2;

          if (optWeight == null) {
            return Math.floor(s); // int(s)
          } else {
            return s; // no need to cast to float
          }
        },
        writable: true,
        configurable: true
      },
      numberOfEdges: {

        /**
         * Return the number of edges between two nodes.
         *
         * @param {!Node=} u node.
         * @param {!Node=} v node
         *       If u and v are specified, return the number of edges between
         *       u and v. Otherwise return the total number of all edges.
         *
         * @return {number} The number of edges in the graph.
         *      If nodes u and v are specified return the number of edges between
         *      those nodes.
         * @export
         */

        value: function numberOfEdges(u, v) {
          if (u == null) {
            return Math.floor(this.size());
          }
          if (this.adj.get(u).has(v)) {
            return 1;
          } else {
            return 0;
          }
        },
        writable: true,
        configurable: true
      },
      addStar: {

        /**
         * Add a star.
         *
         * The first node in nodes is the middle of the star.  It is connected
         * to all other nodes.
         *
         * @param {NodeContainer} nodes A container of nodes.
         * @param {Object=} opt_attr  Attributes to add to every edge in star.
         * @export
         */

        value: function addStar(nodes, optAttr) {
          var niter = toIterator(nodes);
          var v = niter.next().value;
          var edges = mapIterator(niter, function (n) {
            return tuple2(v, n);
          });
          this.addEdgesFrom(edges, optAttr);
        },
        writable: true,
        configurable: true
      },
      addPath: {

        /**
         * Add a path.
         *
         * @param {NodeContainer} nodes A container of nodes.
         *      A path will be constructed from the nodes (in order)
         *      and added to the graph.
         * @param {Object=} opt_attr Attributes to add to every edge in path.
         * @export
         */

        value: function addPath(nodes, optAttr) {
          var nlist = _core.Array.from(nodes);
          var edges = zipSequence(nlist.slice(0, nlist.length - 1), nlist.slice(1));
          this.addEdgesFrom(edges, optAttr);
        },
        writable: true,
        configurable: true
      },
      addCycle: {

        /**
         * Add a cycle.
         *
         * @param {NodeContainer} nodes A container of nodes.
         *      A cycle will be constructed from the nodes (in order)
         *      and added to the graph.
         * @param {Object=} opt_attr  Attributes to add to every edge in cycle.
         * @export
         */

        value: function addCycle(nodes, optAttr) {
          var nlist = _core.Array.from(nodes);
          var edges = zipSequence(nlist, nlist.slice(1).concat([nlist[0]]));
          this.addEdgesFrom(edges, optAttr);
        },
        writable: true,
        configurable: true
      },
      nbunchIter: {

        /**
         * Return an iterator of nodes contained in nbunch that are
         * also in the graph.
         *
         * The nodes in nbunch are checked for membership in the graph
         * and if not are silently ignored.
         *
         * Notes
         * -----
         * When nbunch is an iterator, the returned iterator yields values
         * directly from nbunch, becoming exhausted when nbunch is exhausted.
         *
         * To test whether nbunch is a single node, one can use
         * "if(this.has_node(nbunch)", even after processing with this routine.
         *
         * If nbunch is not a node or a (possibly empty) sequence/iterator
         * or not defined, an Error is raised.
         *
         * @param {(Node|NodeContainer)=} opt_nbunch (default=all nodes)
         *      A container of nodes.  The container will be iterated
         *      through once.
         *
         * @return {!Iterator} An iterator over nodes in nbunch
         *      that are also in the graph.
         *      If nbunch is null or not defined, iterate over all nodes in the graph.
         * @export
         */

        value: _regeneratorRuntime.mark(function nbunchIter(optNbunch) {
          var _this = this;

          var adj, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, n;

          return _regeneratorRuntime.wrap(function nbunchIter$(context$3$0) {
            while (1) switch (context$3$0.prev = context$3$0.next) {
              case 0:
                if (!(optNbunch == null)) {
                  context$3$0.next = 4;
                  break;
                }

                return context$3$0.delegateYield(_this.adj.keys(), "t35", 2);

              case 2:
                context$3$0.next = 44;
                break;

              case 4:
                if (!_this.hasNode(optNbunch)) {
                  context$3$0.next = 9;
                  break;
                }

                context$3$0.next = 7;
                return optNbunch;

              case 7:
                context$3$0.next = 44;
                break;

              case 9:
                adj = _this.adj;
                context$3$0.prev = 10;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$3$0.prev = 14;
                _iterator = _core.$for.getIterator(toIterator(optNbunch));

              case 16:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  context$3$0.next = 24;
                  break;
                }

                n = _step.value;

                if (!adj.has(n)) {
                  context$3$0.next = 21;
                  break;
                }

                context$3$0.next = 21;
                return n;

              case 21:
                _iteratorNormalCompletion = true;
                context$3$0.next = 16;
                break;

              case 24:
                context$3$0.next = 30;
                break;

              case 26:
                context$3$0.prev = 26;
                context$3$0.t36 = context$3$0["catch"](14);
                _didIteratorError = true;
                _iteratorError = context$3$0.t36;

              case 30:
                context$3$0.prev = 30;
                context$3$0.prev = 31;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                  _iterator["return"]();
                }

              case 33:
                context$3$0.prev = 33;

                if (!_didIteratorError) {
                  context$3$0.next = 36;
                  break;
                }

                throw _iteratorError;

              case 36:
                return context$3$0.finish(33);

              case 37:
                return context$3$0.finish(30);

              case 38:
                context$3$0.next = 44;
                break;

              case 40:
                context$3$0.prev = 40;
                context$3$0.t37 = context$3$0["catch"](10);

                if (!(context$3$0.t37 instanceof TypeError)) {
                  context$3$0.next = 44;
                  break;
                }

                throw new JSNetworkXError("nbunch is not a node or a sequence of nodes");

              case 44:
              case "end":
                return context$3$0.stop();
            }
          }, nbunchIter, this, [[10, 40], [14, 26, 30, 38], [31,, 33, 37]]);
        }),
        writable: true,
        configurable: true
      }
    };
    _babelHelpers$prototypeProperties[_core.Symbol.iterator] = {
      value: function () {
        return this.node.keys();
      },
      writable: true,
      configurable: true
    };
    return _babelHelpers$prototypeProperties;
  })());

  return Graph;
})();

module.exports = Graph;
// helper dict to keep track of multiply stored edges
// include all nodes
/*jshint expr:true*/
// if nbunch is a single node
// if nbunch is a sequence of nodes

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../_internals/Map":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Map.js","../_internals/Set":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Set.js","../convert":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/convert.js","../exceptions/JSNetworkXError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXError.js","../exceptions/KeyError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/KeyError.js","./DiGraph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/DiGraph.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js","lodash/lang/isBoolean":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isBoolean.js","lodash/lang/isString":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isString.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/MultiDiGraph.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var yieldEdges = _regeneratorRuntime.mark(function yieldEdges(nodesNbrs, data, keys, type) {
  var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, n, nbrs, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _step2$value, nbr, keydict, key, result;

  return _regeneratorRuntime.wrap(function yieldEdges$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 3;
        _iterator = _core.$for.getIterator(nodesNbrs);

      case 5:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 48;
          break;
        }

        _step$value = _babelHelpers.slicedToArray(_step.value, 2);
        n = _step$value[0];
        nbrs = _step$value[1];
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 12;
        _iterator2 = _core.$for.getIterator(nbrs);

      case 14:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 31;
          break;
        }

        _step2$value = _babelHelpers.slicedToArray(_step2.value, 2);
        nbr = _step2$value[0];
        keydict = _step2$value[1];
        context$1$0.t51 = _regeneratorRuntime.keys(keydict);

      case 19:
        if ((context$1$0.t52 = context$1$0.t51()).done) {
          context$1$0.next = 28;
          break;
        }

        key = context$1$0.t52.value;
        result = type === "out" ? [n, nbr] : [nbr, n];

        if (keys) {
          result[2] = isNaN(key) ? key : +key;
        }
        if (data) {
          result.push(keydict[key]);
        }
        context$1$0.next = 26;
        return result;

      case 26:
        context$1$0.next = 19;
        break;

      case 28:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 14;
        break;

      case 31:
        context$1$0.next = 37;
        break;

      case 33:
        context$1$0.prev = 33;
        context$1$0.t53 = context$1$0["catch"](12);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t53;

      case 37:
        context$1$0.prev = 37;
        context$1$0.prev = 38;

        if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
          _iterator2["return"]();
        }

      case 40:
        context$1$0.prev = 40;

        if (!_didIteratorError2) {
          context$1$0.next = 43;
          break;
        }

        throw _iteratorError2;

      case 43:
        return context$1$0.finish(40);

      case 44:
        return context$1$0.finish(37);

      case 45:
        _iteratorNormalCompletion = true;
        context$1$0.next = 5;
        break;

      case 48:
        context$1$0.next = 54;
        break;

      case 50:
        context$1$0.prev = 50;
        context$1$0.t54 = context$1$0["catch"](3);
        _didIteratorError = true;
        _iteratorError = context$1$0.t54;

      case 54:
        context$1$0.prev = 54;
        context$1$0.prev = 55;

        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }

      case 57:
        context$1$0.prev = 57;

        if (!_didIteratorError) {
          context$1$0.next = 60;
          break;
        }

        throw _iteratorError;

      case 60:
        return context$1$0.finish(57);

      case 61:
        return context$1$0.finish(54);

      case 62:
      case "end":
        return context$1$0.stop();
    }
  }, yieldEdges, this, [[3, 50, 54, 62], [12, 33, 37, 45], [38,, 40, 44], [55,, 57, 61]]);
});

var yieldDegree = _regeneratorRuntime.mark(function yieldDegree(graph, edges, nBunch, weight) {
  var nodesNbrs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, n, nbrs, sum, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, keydict, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _step3$value;

  return _regeneratorRuntime.wrap(function yieldDegree$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        nodesNbrs = nBunch == null ? edges : mapIterator(graph.nbunchIter(nBunch), function (n) {
          return tuple2(n, edges.get(n));
        });

        if (!(weight == null)) {
          context$1$0.next = 52;
          break;
        }

        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 5;
        _iterator = _core.$for.getIterator(nodesNbrs);

      case 7:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 36;
          break;
        }

        _step$value = _babelHelpers.slicedToArray(_step.value, 2);
        n = _step$value[0];
        nbrs = _step$value[1];
        sum = 0;
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 15;

        for (_iterator2 = _core.$for.getIterator(nbrs.values()); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          keydict = _step2.value;

          sum += _core.Object.keys(keydict).length;
        }
        context$1$0.next = 23;
        break;

      case 19:
        context$1$0.prev = 19;
        context$1$0.t55 = context$1$0["catch"](15);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t55;

      case 23:
        context$1$0.prev = 23;
        context$1$0.prev = 24;

        if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
          _iterator2["return"]();
        }

      case 26:
        context$1$0.prev = 26;

        if (!_didIteratorError2) {
          context$1$0.next = 29;
          break;
        }

        throw _iteratorError2;

      case 29:
        return context$1$0.finish(26);

      case 30:
        return context$1$0.finish(23);

      case 31:
        context$1$0.next = 33;
        return [n, sum];

      case 33:
        _iteratorNormalCompletion = true;
        context$1$0.next = 7;
        break;

      case 36:
        context$1$0.next = 42;
        break;

      case 38:
        context$1$0.prev = 38;
        context$1$0.t56 = context$1$0["catch"](5);
        _didIteratorError = true;
        _iteratorError = context$1$0.t56;

      case 42:
        context$1$0.prev = 42;
        context$1$0.prev = 43;

        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }

      case 45:
        context$1$0.prev = 45;

        if (!_didIteratorError) {
          context$1$0.next = 48;
          break;
        }

        throw _iteratorError;

      case 48:
        return context$1$0.finish(45);

      case 49:
        return context$1$0.finish(42);

      case 50:
        context$1$0.next = 80;
        break;

      case 52:
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 55;
        _iterator3 = _core.$for.getIterator(nodesNbrs);

      case 57:
        if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
          context$1$0.next = 66;
          break;
        }

        _step3$value = _babelHelpers.slicedToArray(_step3.value, 2);
        n = _step3$value[0];
        nbrs = _step3$value[1];
        context$1$0.next = 63;
        return [n, sumEdgeAttribute(nbrs, weight, 1)];

      case 63:
        _iteratorNormalCompletion3 = true;
        context$1$0.next = 57;
        break;

      case 66:
        context$1$0.next = 72;
        break;

      case 68:
        context$1$0.prev = 68;
        context$1$0.t57 = context$1$0["catch"](55);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t57;

      case 72:
        context$1$0.prev = 72;
        context$1$0.prev = 73;

        if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
          _iterator3["return"]();
        }

      case 75:
        context$1$0.prev = 75;

        if (!_didIteratorError3) {
          context$1$0.next = 78;
          break;
        }

        throw _iteratorError3;

      case 78:
        return context$1$0.finish(75);

      case 79:
        return context$1$0.finish(72);

      case 80:
      case "end":
        return context$1$0.stop();
    }
  }, yieldDegree, this, [[5, 38, 42, 50], [15, 19, 23, 31], [24,, 26, 30], [43,, 45, 49], [55, 68, 72, 80], [73,, 75, 79]]);
});

var DiGraph = _babelHelpers.interopRequire(require("./DiGraph"));

var MultiGraph = _babelHelpers.interopRequire(require("./MultiGraph"));

var JSNetworkXError = _babelHelpers.interopRequire(require("../exceptions/JSNetworkXError"));

var _internals = require("../_internals");

var Map = _internals.Map;
var clone = _internals.clone;
var deepcopy = _internals.deepcopy;
var getDefault = _internals.getDefault;
var isPlainObject = _internals.isPlainObject;
var mapIterator = _internals.mapIterator;
var sprintf = _internals.sprintf;
var tuple2 = _internals.tuple2;
var tuple4 = _internals.tuple4;
var createTupleFactory = _internals.createTupleFactory;
var zipIterator = _internals.zipIterator;

/**
 * A directed graph class that can store multiedges.
 *
 * Multiedges are multiple edges between two nodes. Each edge can hold optional
 * data or attributes.
 *
 * A MultiDiGraph holds directed edges. Self loops are allowed. Edges are
 * respresented as links between nodes with optional key/value attributes.
 *
 * ### Example
 *
 * Create an empty graph structure (a "null graph") with no nodes and no edges:
 *
 * ```
 * var G = new jsnx.MultiDiGraph();
 * ```
 *
 * G can be grown in several ways.
 *
 * #### Nodes
 *
 * Add one node at a time:
 *
 * ```
 * G.addNode(1);
 * ```
 *
 * Add the nodes from any iterable:
 *
 * ```
 * G.addNodesFrom([2,3]);
 * var H = new jsnx.Graph();
 * H.addPath([0,1,2,3,4,5]);
 * G.addNodesFrom(H);
 * ```
 *
 * In addition to strings and integers, any object that implements a custom
 * `toString` method can represent a node.
 *
 * #### Edges
 *
 * `G` can also be grown by adding edges. Add one edge,
 *
 * ```
 * G.addEdge(1, 2);
 * ```
 *
 * a list of edges,
 *
 * ```
 * G.addEdgesFrom([[1,2], [1,3]]);
 * ```
 *
 * or a collection of edges
 *
 * ```
 * G.addEdgesFrom(H.edges());
 * ```
 *
 * If some edges connect nodes not yet in the graph, the nodes are added
 * automatically. If an edge already exists, an additional edge is created and
 * stored using a key to identify the edge. By default the key is the lowest
 * unused integer.
 *
 * ```
 * G.addEdgesFrom([[4,5,{route:282}], [4,5,{route:37}]]);
 * G.get(4);
 * // Map {5: {0: {}, 1: {route: 282}, 2: {route: 37}}}
 *
 * #### Attributes
 *
 * Each graph, node and edge can hold key/value attribute pairs in an associated
 * attribute object. By default these are empty, but can be added or changed
 * using `addEdge` or `addNode`.
 *
 * ```
 * G.addNode(1, {time: '5pm'});
 * G.addNodesFrom([3], {time: '2pm'});
 * G.nodes(true);
 * // [[1, {time: '5pm'}], [3, {time: '2pm'}]]
 * ```
 *
 * Add edge attributes using `addEdge` and `addEdgesFrom`:
 *
 * ```
 * G.addEdge(1, 2, {weight: 4.7});
 * G.addEdgesFrom([[3,4], [4,5]], {color: 'red'});
 * G.addEdgesFrom([[1,2,{color: 'blue'}], [2,3,{weight: 8}]]);
 * ```
 */

var MultiDiGraph = (function (DiGraph) {

  /**
   * @param {(Object|Array|Graph)} optData Data to initialize graph.
   *   If no data is passed, an empty graph is created. The data can be an edge
   *   list, or any JSNetworkX graph object.
   * @param {Object=} opt_attr (default= no attributes)
   *       Attributes to add to graph as key=value pairs.
   */

  function MultiDiGraph(optData, optAttr) {
    _babelHelpers.classCallCheck(this, MultiDiGraph);

    if (!(this instanceof MultiDiGraph)) {
      return new MultiDiGraph(optData, optAttr);
    }
    _babelHelpers.get(_core.Object.getPrototypeOf(MultiDiGraph.prototype), "constructor", this).call(this, optData, optAttr);
  }

  _babelHelpers.inherits(MultiDiGraph, DiGraph);

  _babelHelpers.prototypeProperties(MultiDiGraph, {
    __name__: {

      /**
       * Holds the graph type (class) name for information.
       *
       * @type {string}
       */

      get: function () {
        return "MultiDiGraph";
      },
      configurable: true
    }
  }, {
    addEdge: {

      /**
       * Add an edge between u and v.
       *
       * The nodes u and v will be automatically added if they are not already in
       * the graph.
       *
       * Edge attributes can be specified by providing an object with key/value
       * pairs.
       *
       * ### Note
       *
       * To replace/update edge data, use the optional key argument to identify a
       * unique edge. Otherwise a new edge will be created.
       *
       * ### Example
       *
       * The following add the edge e=(1,2) to graph G:
       *
       * ```
       * var G = new jsnx.MultiDiGraph();
       * G.addEdge(1, 2);
       * G.addEdgesFrom([[1,2]]);
       * ```
       *
       * Associate data to edges using keywords:
       *
       * ```
       * G.addEdge(1, 2, {weight: 3});
       * G.addEdge(1, 2, 0, {weight: 4}); // update data for key=0
       * G.addEdge(1, 3, {weight: 7, capacity: 15, length: 342.7});
       * ```
       * @param {Node} u
       * @param {Node} v
       * @param {(string|number)} optKey (default=lowest unused integer) Used to
       *   distinguish multiedges between a pair of nodes.
       * @param {Object} opAttrDict Object of edge attributes. Key/value pairs will
       *   update existing data associated with the edge.
       */

      value: function addEdge(u, v, optKey, optAttrDict) {
        if (optKey && typeof optKey === "object") {
          optAttrDict = optKey;
          optKey = null;
        }

        if (optAttrDict && !isPlainObject(optAttrDict)) {
          throw new JSNetworkXError("The optAttrDict argument must be a plain object.");
        }

        // add nodes
        var keydict;
        if (!this.succ.has(u)) {
          this.succ.set(u, new Map());
          this.pred.set(u, new Map());
          this.node.set(u, {});
        }
        if (!this.succ.has(v)) {
          this.succ.set(v, new Map());
          this.pred.set(v, new Map());
          this.node.set(v, {});
        }
        if (this.succ.get(u).has(v)) {
          keydict = this.get(u).get(v);
          if (optKey == null) {
            // find unique integer key
            optKey = _core.Object.keys(keydict).length;
            while (keydict[optKey]) {
              optKey += 1;
            }
          }
          keydict[optKey] = _core.Object.assign(getDefault(keydict[optKey], {}), optAttrDict);
        } else {
          // selfloops work this way without special treatment
          if (optKey == null) {
            optKey = 0;
          }
          keydict = _babelHelpers.defineProperty({}, optKey, _core.Object.assign({}, optAttrDict));
          this.succ.get(u).set(v, keydict);
          this.pred.get(v).set(u, keydict);
        }
      },
      writable: true,
      configurable: true
    },
    removeEdge: {

      /**
       * Remove an edge between u and v.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiDiGraph();
       * G.addPath([0,1,2,3]);
       * G.removeEdge(0, 1);
       * ```
       *
       * For multiple edges:
       *
       * ```
       * var G = new jsnx.MultiDiGraph();
       * G.addEdgesFrom([[1,2], [1,2], [1,2]]);
       * G.removeEdge(1, 2); // remove a single (arbitrary) edge
       * ```
       *
       * For edges with keys:
       *
       * ```
       * var G = new jsnx.MultiDiGraph();
       * G.addEdge(1, 2, 'first');
       * G.addEdge(1, 2, 'second');
       * G.removeEdge(1, 2, 'second');
       * ```
       * @param {Node} u
       * @param {Node} v
       * @param {(string|number)} optKey Used to distinguish multiple edges between
       *   a pair of nodes. If undefined, remove a single (arbitrary) edge between
       *   u and v.
       */

      value: function removeEdge(u, v, optKey) {
        var keydict;
        var neightborsOfU = this.adj.get(u);
        if (neightborsOfU) {
          keydict = neightborsOfU.get(v);
        }
        if (keydict == null) {
          throw new JSNetworkXError(sprintf("The edge %j-%j is not in the graph", u, v));
        }

        // remove the edge with specified data
        if (optKey == null) {
          for (var key in keydict) {
            delete keydict[key];
            break;
          }
        } else {
          if (!keydict[optKey]) {
            throw new JSNetworkXError(sprintf("The edge %j-%j with key %j is not in the graph", u, v, optKey));
          }
          delete keydict[optKey];
        }
        if (_core.Object.keys(keydict).length === 0) {
          // remove the key entries if last edge
          this.succ.get(u)["delete"](v);
          this.pred.get(v)["delete"](u);
        }
      },
      writable: true,
      configurable: true
    },
    edgesIter: {

      /**
       * Return an iterator over the edges.
       *
       * Edges are returned as tuples with optional data and keys in the order
       * `(node, neighbor, key, data)`.
       *
       * ### Note
       *
       * Nodes in `optNbunch` that are not in the graph will be (quietly) ignored.
       * For directed graphs this returns the out-edges.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiDiGraph();
       * G.addPath([0,1,2,3]);
       * Array.from(G.edgesIter());
       * // [[0,1], [1,2], [2,3]]
       * Array.from(G.edgesIter(true));
       * // [[0,1,{}], [1,2,{}], [2,3,{}]]
       * Array.from(G.edgesIter([0,2]));
       * // [[0,1], [2,3]]
       * ```
       *
       * @alias outEdgesIter
       *
       * @param {Iterable} optNbunch (default=all nodes) A container of nodes.
       *   The container will be iterated over only once.
       * @param {boolean} optData (default=false) If true, return edge attribute
       *   dictionaries with each edge.
       * @param {boolean} optKeys (default=flase) If true, return edge keys with
       *   each edge.
       * @return {Iterator} An iterator of `(u,v)`, `(u,v,d)` or `(u,v,key,d)` edges
       */

      value: _regeneratorRuntime.mark(function edgesIter(optNbunch) {
        var _this = this;

        var optData = arguments[1] === undefined ? false : arguments[1];
        var optKeys = arguments[2] === undefined ? false : arguments[2];
        var nodesNbrs;
        return _regeneratorRuntime.wrap(function edgesIter$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              if (typeof optNbunch === "boolean") {
                optKeys = optData;
                optData = optNbunch;
                optNbunch = null;
              }

              nodesNbrs = optNbunch == null ? _this.adj : mapIterator(_this.nbunchIter(optNbunch), function (n) {
                return tuple2(n, _this.adj.get(n));
              });
              return context$2$0.delegateYield(yieldEdges(nodesNbrs, optData, optKeys, "out"), "t43", 3);

            case 3:
            case "end":
              return context$2$0.stop();
          }
        }, edgesIter, this);
      }),
      writable: true,
      configurable: true
    },
    outEdgesIter: {

      /**
       * @alias edgesIter
       */

      value: function outEdgesIter(optNbunch, optData, optKeys) {
        return this.edgesIter(optNbunch, optData, optKeys);
      },
      writable: true,
      configurable: true
    },
    outEdges: {

      /**
       * Return a list of the outgoing edges.
       *
       * Edges are returned as tuples with optional data and keys in the order
       * `(node, neighbor, key, data)`.
       *
       * ### Note
       *
       * Nodes in `optNbunch` that are not in the graph will be (quietly) ignored.
       * For directed graphs `edges()` is the same as `outEdges()`.
       *
       * @see inEdges
       *
       * @param {Iterable} optNbunch (default=all nodes) A container of nodes.
       *   The container will be iterated over only once.
       * @param {boolean} optData (default=false) If true, return edge attribute
       *   dictionaries with each edge.
       * @param {boolean} optKeys (default=flase) If true, return edge keys with
       *   each edge.
       * @return {Array} A list of `(u,v)`, `(u,v,d)` or `(u,v,key,d)` tuples of
       *   edges
       */

      value: function outEdges(optNbunch, optData, optKeys) {
        return _core.Array.from(this.outEdgesIter(optNbunch, optData, optKeys));
      },
      writable: true,
      configurable: true
    },
    inEdgesIter: {

      /**
       * Return an iterator over the incoming edges.
       *
       * Edges are returned as tuples with optional data and keys in the order
       * `(node, neighbor, key, data)`.
       *
       * @see edgesIter
       *
       * @param {Iterable=} optNbunch (default=all nodes) A container of nodes.
       *   The container will be iterated over only once.
       * @param {boolean=} optData (default=false) If true, return edge attribute
       *   dictionaries with each edge.
       * @param {boolean=} optKeys (default=flase) If true, return edge keys with
       *   each edge.
       * @return {Iterator} An iterator of `(u,v)`, `(u,v,d)` or `(u,v,key,d)` edges
       */

      value: _regeneratorRuntime.mark(function inEdgesIter(optNbunch) {
        var _this = this;

        var optData = arguments[1] === undefined ? false : arguments[1];
        var optKeys = arguments[2] === undefined ? false : arguments[2];
        var nodesNbrs;
        return _regeneratorRuntime.wrap(function inEdgesIter$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              if (typeof optNbunch === "boolean") {
                optKeys = optData;
                optData = optNbunch;
                optNbunch = null;
              }

              nodesNbrs = optNbunch == null ? _this.pred : mapIterator(_this.nbunchIter(optNbunch), function (n) {
                return tuple2(n, _this.pred.get(n));
              });
              return context$2$0.delegateYield(yieldEdges(nodesNbrs, optData, optKeys, "in"), "t44", 3);

            case 3:
            case "end":
              return context$2$0.stop();
          }
        }, inEdgesIter, this);
      }),
      writable: true,
      configurable: true
    },
    inEdges: {

      /**
       * Return a list of the incoming edges.
       *
       * @see outEdges
       *
       * @param {Iterable=} optNbunch (default=all nodes) A container of nodes.
       *   The container will be iterated over only once.
       * @param {boolean=} optData (default=false) If true, return edge attribute
       *   dictionaries with each edge.
       * @param {boolean=} optKeys (default=flase) If true, return edge keys with
       *   each edge.
       * @return {Array} A list of `(u,v)`, `(u,v,d)` or `(u,v,key,d)` tuples of
       *   edges
       */

      value: function inEdges(optNbunch, optData, optKeys) {
        return _core.Array.from(this.inEdgesIter(optNbunch, optData, optKeys));
      },
      writable: true,
      configurable: true
    },
    degreeIter: {

      /**
       * Return an iterator for `(node, degree)`.
       *
       * The node degree is the number of edges adjacent to the node.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiDiGraph();
       * G.addPath([0,1,2,3]);
       * Array.from(G.degreeIter([0,1]));
       * // [[0,1], [1,2]]
       * ```
       *
       * @param {Iterable=} optNbunch (default=all nodes) A container of nodes.
       *   The container will be iterated through once.
       * @param {string=} optString (default=null)
       *   The edge attribute that holds the numerical value used as a weight. If
       *   None, then each edge has weight 1.
       *   The degree is the sum of the edge weights.
       * @return {Iterator} The iterator returns two-tuples of `(node, degree)`.
       */

      value: _regeneratorRuntime.mark(function degreeIter(optNbunch, optWeight) {
        var _this = this;

        var tuple2Succ, tuple2Pred, nodesNbrs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, _step$value$0, n, succ, _step$value$1, _, pred, keydict, inDegree, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, outDegree, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _step4$value, _step4$value$0, _step4$value$1;

        return _regeneratorRuntime.wrap(function degreeIter$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              tuple2Succ = createTupleFactory(2);
              tuple2Pred = createTupleFactory(2);
              nodesNbrs = optNbunch == null ? zipIterator(_this.succ.entries(), _this.pred.entries()) : zipIterator(mapIterator(_this.nbunchIter(optNbunch), function (n) {
                return tuple2Succ(n, _this.succ.get(n));
              }), mapIterator(_this.nbunchIter(optNbunch), function (n) {
                return tuple2Pred(n, _this.pred.get(n));
              }));

              if (!(optWeight == null)) {
                context$2$0.next = 78;
                break;
              }

              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              context$2$0.prev = 7;
              _iterator = _core.$for.getIterator(nodesNbrs);

            case 9:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                context$2$0.next = 62;
                break;
              }

              _step$value = _babelHelpers.slicedToArray(_step.value, 2);
              _step$value$0 = _babelHelpers.slicedToArray(_step$value[0], 2);
              n = _step$value$0[0];
              succ = _step$value$0[1];
              _step$value$1 = _babelHelpers.slicedToArray(_step$value[1], 2);
              _ = _step$value$1[0];
              pred = _step$value$1[1];
              inDegree = 0;
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              context$2$0.prev = 21;

              for (_iterator2 = _core.$for.getIterator(pred.values()); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                keydict = _step2.value;

                inDegree += _core.Object.keys(keydict).length;
              }
              context$2$0.next = 29;
              break;

            case 25:
              context$2$0.prev = 25;
              context$2$0.t45 = context$2$0["catch"](21);
              _didIteratorError2 = true;
              _iteratorError2 = context$2$0.t45;

            case 29:
              context$2$0.prev = 29;
              context$2$0.prev = 30;

              if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                _iterator2["return"]();
              }

            case 32:
              context$2$0.prev = 32;

              if (!_didIteratorError2) {
                context$2$0.next = 35;
                break;
              }

              throw _iteratorError2;

            case 35:
              return context$2$0.finish(32);

            case 36:
              return context$2$0.finish(29);

            case 37:
              outDegree = 0;
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              context$2$0.prev = 41;

              for (_iterator3 = _core.$for.getIterator(succ.values()); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                keydict = _step3.value;

                inDegree += _core.Object.keys(keydict).length;
              }
              context$2$0.next = 49;
              break;

            case 45:
              context$2$0.prev = 45;
              context$2$0.t46 = context$2$0["catch"](41);
              _didIteratorError3 = true;
              _iteratorError3 = context$2$0.t46;

            case 49:
              context$2$0.prev = 49;
              context$2$0.prev = 50;

              if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
                _iterator3["return"]();
              }

            case 52:
              context$2$0.prev = 52;

              if (!_didIteratorError3) {
                context$2$0.next = 55;
                break;
              }

              throw _iteratorError3;

            case 55:
              return context$2$0.finish(52);

            case 56:
              return context$2$0.finish(49);

            case 57:
              context$2$0.next = 59;
              return [n, inDegree + outDegree];

            case 59:
              _iteratorNormalCompletion = true;
              context$2$0.next = 9;
              break;

            case 62:
              context$2$0.next = 68;
              break;

            case 64:
              context$2$0.prev = 64;
              context$2$0.t47 = context$2$0["catch"](7);
              _didIteratorError = true;
              _iteratorError = context$2$0.t47;

            case 68:
              context$2$0.prev = 68;
              context$2$0.prev = 69;

              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }

            case 71:
              context$2$0.prev = 71;

              if (!_didIteratorError) {
                context$2$0.next = 74;
                break;
              }

              throw _iteratorError;

            case 74:
              return context$2$0.finish(71);

            case 75:
              return context$2$0.finish(68);

            case 76:
              context$2$0.next = 110;
              break;

            case 78:
              _iteratorNormalCompletion4 = true;
              _didIteratorError4 = false;
              _iteratorError4 = undefined;
              context$2$0.prev = 81;
              _iterator4 = _core.$for.getIterator(nodesNbrs);

            case 83:
              if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                context$2$0.next = 96;
                break;
              }

              _step4$value = _babelHelpers.slicedToArray(_step4.value, 2);
              _step4$value$0 = _babelHelpers.slicedToArray(_step4$value[0], 2);
              n = _step4$value$0[0];
              succ = _step4$value$0[1];
              _step4$value$1 = _babelHelpers.slicedToArray(_step4$value[1], 2);
              _ = _step4$value$1[0];
              pred = _step4$value$1[1];
              context$2$0.next = 93;
              return [n, sumEdgeAttribute(pred, optWeight, 1) + sumEdgeAttribute(succ, optWeight, 1)];

            case 93:
              _iteratorNormalCompletion4 = true;
              context$2$0.next = 83;
              break;

            case 96:
              context$2$0.next = 102;
              break;

            case 98:
              context$2$0.prev = 98;
              context$2$0.t48 = context$2$0["catch"](81);
              _didIteratorError4 = true;
              _iteratorError4 = context$2$0.t48;

            case 102:
              context$2$0.prev = 102;
              context$2$0.prev = 103;

              if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
                _iterator4["return"]();
              }

            case 105:
              context$2$0.prev = 105;

              if (!_didIteratorError4) {
                context$2$0.next = 108;
                break;
              }

              throw _iteratorError4;

            case 108:
              return context$2$0.finish(105);

            case 109:
              return context$2$0.finish(102);

            case 110:
            case "end":
              return context$2$0.stop();
          }
        }, degreeIter, this, [[7, 64, 68, 76], [21, 25, 29, 37], [30,, 32, 36], [41, 45, 49, 57], [50,, 52, 56], [69,, 71, 75], [81, 98, 102, 110], [103,, 105, 109]]);
      }),
      writable: true,
      configurable: true
    },
    inDegreeIter: {

      /**
       * Return an iterator for `(node, in-degree)`.
       *
       * The node in-degree is the number of edges pointing to the node.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiDiGraph();
       * G.addPath([0,1,2,3]);
       * Array.from(G.degreeIter([0,1]));
       * // [[0,0], [1,1]]
       * ```
       *
       * @param {Iterable=} optNbunch (default=all nodes) A container of nodes.
       *   The container will be iterated through once.
       * @param {string=} optString (default=null)
       *   The edge attribute that holds the numerical value used as a weight. If
       *   None, then each edge has weight 1.
       *   The degree is the sum of the edge weights.
       * @return {Iterator} The iterator returns two-tuples of `(node, degree)`.
       */

      value: _regeneratorRuntime.mark(function inDegreeIter(optNbunch, optWeight) {
        var _this = this;

        return _regeneratorRuntime.wrap(function inDegreeIter$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              return context$2$0.delegateYield(yieldDegree(_this, _this.pred, optNbunch, optWeight), "t49", 1);

            case 1:
            case "end":
              return context$2$0.stop();
          }
        }, inDegreeIter, this);
      }),
      writable: true,
      configurable: true
    },
    outDegreeIter: {

      /**
       * Return an iterator for `(node, out-degree)`.
       *
       * The node out-degree is the number of edges pointing out of the node.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiDiGraph();
       * G.addPath([0,1,2,3]);
       * Array.from(G.degreeIter([0,1]));
       * // [[0,1], [1,1]]
       * ```
       *
       * @param {Iterable=} optNbunch (default=all nodes) A container of nodes.
       *   The container will be iterated through once.
       * @param {string=} optString (default=null)
       *   The edge attribute that holds the numerical value used as a weight. If
       *   None, then each edge has weight 1.
       *   The degree is the sum of the edge weights.
       * @return {Iterator} The iterator returns two-tuples of `(node, degree)`.
       */

      value: _regeneratorRuntime.mark(function outDegreeIter(optNbunch, optWeight) {
        var _this = this;

        return _regeneratorRuntime.wrap(function outDegreeIter$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              return context$2$0.delegateYield(yieldDegree(_this, _this.succ, optNbunch, optWeight), "t50", 1);

            case 1:
            case "end":
              return context$2$0.stop();
          }
        }, outDegreeIter, this);
      }),
      writable: true,
      configurable: true
    },
    isMultigraph: {

      /**
       * Return True if graph is a multigraph, False otherwise.
       *
       * @return {boolean} True if graph is a multigraph, False otherwise.
       */

      value: function isMultigraph() {
        return true;
      },
      writable: true,
      configurable: true
    },
    isDirected: {

      /**
       * Return True if graph is directed, False otherwise.
       *
       * @return {boolean}  True if graph is directed, False otherwise.
       */

      value: function isDirected() {
        return true;
      },
      writable: true,
      configurable: true
    },
    toDirected: {

      /**
       * Return a directed copy of the graph.
       *
       * ### Notes
       *
       * This returns a deep copy of the edge, node, and
       * graph attributes which attempts to completely copy
       * all of the data and references.
       *
       * This is in contrast to the similar `var G = new MultiDiGraph(D);`, which
       * returns a shallow copy of the data.
       *
       * @return {MultiDiGraph} A deep copy of the graph.
       */

      value: function toDirected() {
        return deepcopy(this);
      },
      writable: true,
      configurable: true
    },
    toUndirected: {

      /**
       * Return an undirected representation of the digraph.
       *
       * ### Notes
       *
       * The result is an undirected graph with the same name, nodes and
       * with edge `(u,v,data)` if either `(u,v,data)` or `(v,u,data)`
       * is in the digraph.  If both edges exist in digraph and
       * their edge data is different, only one edge is created
       * with an arbitrary choice of which edge data to use.
       * You must check and correct for this manually if desired.
       *
       * This returns a deep copy of the edge, node, and
       * graph attributes which attempts to completely copy
       * all of the data and references.
       *
       * This is in contrast to the similar `var G = new MultiGraph(D);`, which
       * returns a shallow copy of the data.
       *
       * @param {boolean=} optReciprocal If true, only keep edges that appear in
       *   both directions in the original digraph.
       * @return {MultiGraph}
       */

      value: function toUndirected(optReciprocal) {
        var H = new MultiGraph();
        H.name = this.name;
        H.addNodesFrom(this);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _core.$for.getIterator(this.adjacencyIter()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _babelHelpers.slicedToArray(_step.value, 2);

            var u = _step$value[0];
            var nbrs = _step$value[1];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _core.$for.getIterator(nbrs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _step2$value = _babelHelpers.slicedToArray(_step2.value, 2);

                var v = _step2$value[0];
                var keydict = _step2$value[1];

                for (var key in keydict) {
                  if (!optReciprocal || this.hasEdge(v, u, key)) {
                    H.addEdge(u, v, key, deepcopy(keydict[key]));
                  }
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        H.graph = deepcopy(this.graph);
        H.node = deepcopy(this.node);
        return H;
      },
      writable: true,
      configurable: true
    },
    subgraph: {

      /**
       * Return the subgraph induced on nodes in `nbunch`.
       *
       * The induced subgraph of the graph contains the nodes in `optNbunch` and the
       * edges between those nodes.
       *
       * ### Notes
       *
       * The graph, edge or node attributes just point to the original graph.
       * So changes to the node or edge structure will not be reflected in
       * the original graph while changes to the attributes will.
       *
       * To create a subgraph with its own copy of the edge/node attributes use:
       * `jsnx.MultiDiGraph(G.subgraph(nbunch))`.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiDiGraph();
       * G.addPath([0,1,2,3]);
       * var H = G.subgraph([0,1,2]);
       * H.edges();
       * // [[0,1], [1,2]]
       * ```
       *
       * @param {Iterable} nBunch A container of nodes which will be iterated
       *   through once.
       * @return {MultiDiGraph}
       */

      value: function subgraph(nBunch) {
        var bunch = this.nbunchIter(nBunch);
        // create new graph and copy subgraph into it
        var H = new this.constructor();
        // copy node and attribute dictionaries
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _core.$for.getIterator(bunch), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var n = _step.value;

            H.node.set(n, this.node.get(n));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var HSucc = H.succ;
        var HPred = H.pred;
        var thisSucc = this.succ;

        // add nodes
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = _core.$for.getIterator(H), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var n = _step2.value;

            HSucc.set(n, new Map());
            HPred.set(n, new Map());
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        // add edges
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = _core.$for.getIterator(HSucc), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _step3$value = _babelHelpers.slicedToArray(_step3.value, 2);

            var u = _step3$value[0];
            var HNbrs = _step3$value[1];
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = _core.$for.getIterator(thisSucc.get(u)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var _step4$value = _babelHelpers.slicedToArray(_step4.value, 2);

                var v = _step4$value[0];
                var keydict = _step4$value[1];

                if (HSucc.has(v)) {
                  // add both representations of edge: u-v and v-u
                  // they share the same keydict
                  var keydictCopy = clone(keydict);
                  HNbrs.set(v, keydictCopy);
                  HPred.get(v).set(u, keydictCopy);
                }
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4["return"]) {
                  _iterator4["return"]();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        H.graph = this.graph;
        return H;
      },
      writable: true,
      configurable: true
    },
    reverse: {

      /**
       * Return the reverse of the graph.
       *
       * The reverse is a graph with the same nodes and edges but with the
       * directions of the edges reversed.
       *
       * @param {boolean=} optCopy If true, return a new MultiDiGraph holding the
       *   reversed edges. If false, the reverse graph is created using the original
       *   graph (this changes the original graph).
       * @return {?MultiDiGraph}
       */

      value: function reverse() {
        var optCopy = arguments[0] === undefined ? true : arguments[0];

        var H;
        if (optCopy) {
          H = new this.constructor(null, { name: sprintf("Reverse of (%s)", this.name) });

          H.addNodesFrom(this);
          H.addEdgesFrom(mapIterator(this.edges(true, true), function (_ref) {
            var _ref2 = _babelHelpers.slicedToArray(_ref, 4);

            var u = _ref2[0];
            var v = _ref2[1];
            var key = _ref2[2];
            var data = _ref2[3];
            return tuple4(v, u, key, deepcopy(data));
          }));
          H.graph = deepcopy(this.graph);
          H.node = deepcopy(this.node);
        } else {
          var _ref = [this.succ, this.pred];

          var _ref2 = _babelHelpers.slicedToArray(_ref, 2);

          this.pred = _ref2[0];
          this.succ = _ref2[1];

          this.adj = this.succ;
          H = this;
        }
        return H;
      },
      writable: true,
      configurable: true
    }
  });

  return MultiDiGraph;
})(DiGraph);

module.exports = MultiDiGraph;

// Simulate multiple inheritance by merging prototypes
_core.Object.getOwnPropertyNames(MultiGraph.prototype).forEach(function (prop) {
  if (!MultiDiGraph.prototype.hasOwnProperty(prop)) {
    MultiDiGraph.prototype[prop] = MultiGraph.prototype[prop];
  }
});

function sumEdgeAttribute(nbrs, attribute, def) {
  var sum = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(nbrs.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var keydict = _step.value;

      for (var key in keydict) {
        sum += getDefault(keydict[key][attribute], def);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return sum;
}

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../exceptions/JSNetworkXError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXError.js","./DiGraph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/DiGraph.js","./MultiGraph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/MultiGraph.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/MultiGraph.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var Graph = _babelHelpers.interopRequire(require("./Graph"));

var JSNetworkXError = _babelHelpers.interopRequire(require("../exceptions/JSNetworkXError"));

var _internals = require("../_internals");

var Map = _internals.Map;
var Set = _internals.Set;
var clone = _internals.clone;
var deepcopy = _internals.deepcopy;
var forEach = _internals.forEach;
var getDefault = _internals.getDefault;
var isArrayLike = _internals.isArrayLike;
var isPlainObject = _internals.isPlainObject;
var mapIterator = _internals.mapIterator;
var nodesAreEqual = _internals.nodesAreEqual;
var sprintf = _internals.sprintf;
var tuple2 = _internals.tuple2;

/**
 * An undirected graph class that can store multiedges.
 *
 * Multiedges are multiple edges between two nodes.  Each edge
 * can hold optional data or attributes. A MultiGraph holds undirected edges.
 * Self loops are allowed.
 *
 * Edges are represented as links between nodes with optional
 * key/value attributes.
 *
 * ### Examples
 *
 * Create an empty graph structure (a "null graph") with no nodes and no edges.
 *
 * ```
 * var G = jsnx.MultiGraph();
 * ```
 *
 * G can be grown in several ways.
 *
 * #### Nodes
 *
 * Add one node at a time:
 *
 * ```
 * G.addNode(1);
 * ```
 *
 * Add the nodes from any iterable:
 *
 * ```
 * G.addNodesFrom([2, 3]);
 * var H = jsnx.Graph();
 * H.addPath([0,1,2,3,4,5,6,7,8,9]);
 * G.addNodesFrom(h);
 * ```
 *
 * In addition to strings and integers, any object that implements a custom
 * `toString` method can be used as node. For example, arrays:
 *
 * ```
 * G.addNode([1,2]);
 * ```
 *
 * #### Edges
 *
 * A graph can also be grown by adding edges.
 *
 * Add one edge,
 *
 * ```
 * G.addEdge(1, 2);
 * ```
 *
 * a list or collection of edges,
 *
 * ```
 * G.addEdgesFrom([[1,2], [1,3]]);
 * G.addEdgesFrom(H.edges());
 * ```
 *
 * If some edges connect nodes not yet in the graph, the nodes are added
 * automatically. If an edge already exists, an addition edge is created and
 * stored using a key to identify the edge. By default, the key is the lowest
 * unused integer.
 *
 * ```
 * G.addEdgesFrom([[4,5,{route: 282}], [4,5,{route: 37}]]);
 * G.get(4);
 * // Map { 3: {0: {}}, 5: {0: {}, 1: {route: 282}, 2: {route: 37}}}
 * ```
 *
 * #### Attributes
 *
 * Each graph, node and edge can hold key/value attribute pairs in an associated
 * attribute "dictionary" (object). By defauly these are empty, but can be added
 * or changed using `addEdge` or `addNode`.
 *
 * ```
 * var G = jsnx.MultiGraph(null, {day: Friday}):
 * G.graph
 * // {day: 'Friday'}
 *
 * G.addNode(1, {time: '5pm'});
 * G.addNodesFrom([3], {time: '2pm'});
 * G.nodes(true);
 * // [[1, {time: '5pm'}], [3, {time: '2pm'}]]
 * ```
 *
 * @see Graph
 * @see DiGraph
 * @see MultiDiGraph
 *
 */

var MultiGraph = (function (Graph) {

  /**
   * @param {?=} optData Data to initialze graph.
   *      If no data is provided, an empty graph is created. The data can be
   *      an edge list or any graph object.
   * @param {Object=} optAttr Attributes to add to graph as key=value pairs.
   */

  function MultiGraph(optData, optAttr) {
    _babelHelpers.classCallCheck(this, MultiGraph);

    // makes it possible to call jsnx.Graph without new
    if (!(this instanceof MultiGraph)) {
      return new MultiGraph(optData, optAttr);
    }
    _babelHelpers.get(_core.Object.getPrototypeOf(MultiGraph.prototype), "constructor", this).call(this, optData, optAttr);
  }

  _babelHelpers.inherits(MultiGraph, Graph);

  _babelHelpers.prototypeProperties(MultiGraph, {
    __name__: {

      /**
       * Holds the graph type (class) name for information.
       * This is compatible to Pythons __name__ property.
       *
       * @type {string}
       */

      get: function () {
        return "MultiGraph";
      },
      configurable: true
    }
  }, {
    addEdge: {

      /**
       * Add an edge between u and v.
       *
       * The nodes u and v will be automatically added if they are
       * not already in the graph.
       *
       * Edge attributes can be specified with keywords or by providing
       * a dictionary with key/value pairs.
       *
       * ### Notes:
       *
       * To replace/update edge data, use the optional key argument
       * to identify a unique edge.  Otherwise a new edge will be created.
       *
       * NetworkX algorithms designed for weighted graphs cannot use
       * multigraphs directly because it is not clear how to handle
       * multiedge weights.  Convert to Graph using edge attribute
       * 'weight' to enable weighted graph algorithms.
       *
       * ### Example
       *
       * The following all add the edge [1,2] to the graph G:
       *
       * ```
       * var G = jsnx.MultiGraph();
       * var e = [1,2];
       * G.addEdge(1, 2);
       * G.addEdge.apply(G, e);
       * G.addEdgesFrom([e]);
       * ```
       * Associate data to edges by passing a data object:
       *
       * ```
       * G.addEdge(1, 2, {weight: 3});
       * G.addEdge(1, 2, 0, {weight: 4}); // update data for key=0
       * G.addEdge(1, 3, {weight: 7, capacity: 15, length: 342.7});
       * ```
       * @see #addEdgesFrom
       *
       * @param {Node} u node
       * @param {Node} v node
       * @param {?(number|string)=} optKey identifier
       *      Used to distinguish multiedges between a pair of nodes. Default is
       *      the lowest unused integer.
       * @param {?Object=} optAttrDict  Dictionary of edge attributes.
       *      Key/value pairs will update existing data associated with the edge.
       */

      value: function addEdge(u, v, optKey, optAttrDict) {
        var type = typeof optKey;
        if (optKey != null && type !== "number" && type !== "string") {
          optAttrDict = optKey;
          optKey = null;
        }

        // set up attribute dict
        if (optAttrDict && !isPlainObject(optAttrDict)) {
          throw new JSNetworkXError("The optAttrDict argument must be an object.");
        }

        // add nodes
        if (!this.adj.has(u)) {
          this.adj.set(u, new Map());
          this.node.set(u, {});
        }
        if (!this.adj.has(v)) {
          this.adj.set(v, new Map());
          this.node.set(v, {});
        }

        var keydict;
        if (this.adj.get(u).has(v)) {
          keydict = this.adj.get(u).get(v);
          if (optKey == null) {
            // find a unique integer key
            // other methods might be better here?
            optKey = _core.Object.keys(keydict).length;
            while (keydict[optKey]) {
              // ok, because values are objects only
              optKey += 1;
            }
          }
          var datadict = keydict[optKey] || {};
          keydict[optKey] = _core.Object.assign(datadict, optAttrDict);
        } else {
          // selfloops work this way without special treatment
          if (optKey == null) {
            optKey = 0;
          }
          keydict = Object.create(null);
          keydict[optKey] = _core.Object.assign({}, optAttrDict);
          this.adj.get(u).set(v, keydict);
          this.adj.get(v).set(u, keydict);
        }
      },
      writable: true,
      configurable: true
    },
    addEdgesFrom: {

      /**
       * Add all the edges in `ebunch`.
       *
       * Adding the same edge twice has no effect but any edge data will be updated
       * when each duplicate edge is added.
       *
       * Edge attributes specified in edges as a tuple take precedence over the
       * attributes specified generally.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiGraph();
       * G.addEdgesFrom([[0,1], [1,2]]);
       * ```
       *
       * Associate data to edges
       *
       * ```
       * G.addEdgesFrom([[1,2], [2,3]], {weight: 3});
       * G.addEdgesFrom([[1,2], [2,3]], {label: 'WN2898'});
       * ```
       *
       * @see #addEdge
       * @see #addWeightedEdgesFrom
       *
       *
       * @param {Iterable} ebunch container of edges
       *      Each edge given in the container will be added to the
       *      graph. The edges can be:
       *
       *          - 2-tuples (u,v) or
       *          - 3-tuples (u,v,d) for an edge attribute dict d or
       *          - 4-tuples (u,v,k,d) for an edge identified by key k
       *
       * @param {Object=} optAttrDict Dictionary of edge attributes.
       *       Key/value pairs will update existing data associated with each edge.
       */

      value: function addEdgesFrom(ebunch, optAttrDict) {
        var _this = this;

        if (optAttrDict && !isPlainObject(optAttrDict)) {
          throw new JSNetworkXError("The optAttrDict argument must be an object.");
        }

        // process ebunch
        forEach(ebunch, function (edge) {
          var u;
          var v;
          var key;
          var data;

          switch (edge.length) {
            case 4:
              u = edge[0];
              v = edge[1];
              key = edge[2];
              data = edge[3];
              break;
            case 3:
              u = edge[0];
              v = edge[1];
              data = edge[2];
              break;
            case 2:
              u = edge[0];
              v = edge[1];
              break;
            default:
              if (!isArrayLike(edge)) {
                throw new TypeError("Elements in edgelists must be tuples.");
              }
              throw new JSNetworkXError(sprintf("Edge tuple %j must be a 2-tuple, 3-tuple or 4-tuple.", edge));
          }

          var keydict = _this.adj.has(u) ? _this.adj.get(u).get(v) || Object.create(null) : Object.create(null);

          if (key == null) {
            // find a unique integer key
            // other methods might be better here?
            key = _core.Object.keys(keydict).length;
            while (keydict[key]) {
              key += 1;
            }
          }
          var datadict = keydict[key] || {};
          _core.Object.assign(datadict, optAttrDict, data);
          _this.addEdge(u, v, key, datadict);
        });
      },
      writable: true,
      configurable: true
    },
    removeEdge: {

      /**
       * Remove an edge between u and v.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiGraph();
       * G.addPath([0,1,2,3]);
       * G.removeEdge(0, 1);
       * ```
       *
       * For multiple edges
       *
       * ```
       * var G = new jsnx.MultiGraph();
       * G.addEdgesFrom([[1,2], [1,2], [1,2]]);
       * G.removeEdge(1, 2); // remove a single edge
       * ```
       *
       * For edges with keys
       *
       * ```
       * var G = new jsnx.MultiGraph();
       * G.addEdge(1, 2, 'first');
       * G.addEdge(1, 2, 'second');
       * G.removeEdge(1, 2, 'second');
       * ```
       *
       * @see #removeEdgesFrom
       *
       * @param {Node} u
       * @param {Node} v
       * @param {(number|string)=} optKey
       *      Used to distinguish multiple edges between a pair of nodes.
       *      If null or undefined remove a single (arbitrary) edge between u and v.
       */

      value: function removeEdge(u, v, optKey) {
        var keydict;
        var neightborsOfU = this.adj.get(u);
        if (neightborsOfU) {
          keydict = neightborsOfU.get(v);
        }
        if (keydict == null) {
          throw new JSNetworkXError(sprintf("The edge %j-%j is not in the graph", u, v));
        }

        // remove the edge with specified data
        if (optKey == null) {
          for (var key in keydict) {
            delete keydict[key];
            break;
          }
        } else {
          if (!keydict[optKey]) {
            throw new JSNetworkXError(sprintf("The edge %j-%j with key %j is not in the graph", u, v, optKey));
          }
          delete keydict[optKey];
        }
        if (_core.Object.keys(keydict).length === 0) {
          // remove the key entries if last edge
          neightborsOfU["delete"](v);
          if (!nodesAreEqual(u, v)) {
            this.adj.get(v)["delete"](u);
          }
        }
      },
      writable: true,
      configurable: true
    },
    removeEdgesFrom: {

      /**
       * Remove all edges specified in `ebunch`.
       *
       * Will fail silently if an edge in `ebunch` is not in the graph.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiGraph();
       * G.addPath([0,1,2,3]);
       * var ebunch = [[1,2], [2,3]];
       * G.removeEdgesFrom(ebunch);
       * ```
       *
       * Removing multiple copies of edges.
       *
       * ```
       * var G = new jsnx.MultiGraph();
       * G.addEdgesFrom([[1,2], [1,2], [1,2]]);
       * G.removeEdgesFrom([[1,2], [1,2]]);
       * G.edges();
       * // [[1,2]]
       * ```
       *
       * @see #removeEdge
       *
       * @param {?} ebunch list or container of edge tuples
       *      Each edge given in the list or container will be removed
       *      from the graph. The edges can be:
       *
       *        - 2-tuples (u,v) All edges between u and v are removed.
       *        - 3-tuples (u,v,key) The edge identified by key is removed.
       */

      value: function removeEdgesFrom(ebunch) {
        var _this = this;

        forEach(ebunch, function (edge) {
          try {
            _this.removeEdge(edge[0], edge[1], edge[2]);
          } catch (ex) {
            if (!(ex instanceof JSNetworkXError)) {
              throw ex;
            }
          }
        });
      },
      writable: true,
      configurable: true
    },
    hasEdge: {

      /**
       * Return True if the graph has an edge between nodes u and v.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiGraph();
       * G.addPath([0,1,2,3]);
       * G.hasEdge(0,1);
       * // true
       * G.addEdge(0, 1, 'a');
       * G.hasEdge(0, 1, 'a');
       * // true
       * ```
       *
       * The following syntax are equivalent:
       *
       * ```
       * G.hasEdge(0, 1);
       * // true
       * G.get(0).has(1);
       * // true
       * ```
       *
       * @param {Node} u node
       * @param {Node} v node
       * @param {(string|number)=} optKey If specified return true only
       *      if the edge with key is found.
       *
       * @return {boolean} true if edge is in the graph, false otherwise.
       */

      value: function hasEdge(u, v, optKey) {
        var neighborsOfU = this.adj.get(u);
        if (neighborsOfU) {
          return neighborsOfU.has(v) && (optKey == null || !!neighborsOfU.get(v)[optKey]);
        }
        return false;
      },
      writable: true,
      configurable: true
    },
    edges: {

      /**
       * Return a list of edges.
       *
       * Edges are returned as tuples with optional data and keys in the order
       * (node, neighbor, key, data).
       *
       * Nodes in `nbunch` that are not in the graph will be (quietly) ignored.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiGraph();
       * G.addPath([0,1,2,3]);
       * G.edges();
       * // [[0,1], [1,2], [2,3]]
       * G.edges(true);
       * // [[0,1,{}], [1,2,{}], [2,3,{}]]
       * G.edges(false, true);
       * // [[0,1,0], [1,2,0], [2,3,0]]
       * G.edges(true, true);
       * // [[0,1,0,{}], [1,2,0,{}], [2,3,0,{}]]
       * G.edges([0,3]);
       * // [[0,1], [3, 2]]
       * G.edges(0);
       * // [[0,1]]
       * ```
       *
       * @see #edgesIter
       *
       * @param {?NodeContainer=} optNbunch A container of nodes.
       *      The container will be iterated through once.
       * @param {?boolean=} optData (default=False)
       *      Return two tuples (u,v) (False) or three-tuples (u,v,data) (True).
       * @param {?boolean=} optKeys (default=False)
       *      Return two tuples (u,v) (False) or three-tuples (u,v,key) (True).
       *
       * @return {!Array} list of edge tuples
       *      Edges that are adjacent to any node in nbunch, or a list
       *      of all edges if nbunch is not specified.
       */

      value: function edges(optNbunch, optData, optKeys) {
        return _core.Array.from(this.edgesIter(optNbunch, optData, optKeys));
      },
      writable: true,
      configurable: true
    },
    edgesIter: {

      /**
       * Return an iterator over edges.
       *
       * Edges are returned as tuples with optional data and keys
       * in the order (node, neighbor, key, data).
       *
       * Nodes in nbunch that are not in the graph will be (quietly) ignored.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiGraph();
       * G.addPath([0,1,2,3]);
       * Array.from(G.edgesIter);
       * // [[0,1], [1,2], [2,3]]
       * Array.from(G.edges(true));
       * // [[0,1,{}], [1,2,{}], [2,3,{}]]
       * Array.from(G.edges(false, true));
       * // [[0,1,0], [1,2,0], [2,3,0]]
       * Array.from(G.edges(true, true));
       * // [[0,1,0,{}], [1,2,0,{}], [2,3,0,{}]]
       * Array.from(G.edges([0,3]));
       * // [[0,1], [3, 2]]
       * Array.from(G.edges(0));
       * // [[0,1]]
       * ```
       *
       * @see #edges
       *
       * @param {?(NodeContainer|boolean)=} optNbunch A container of nodes.
       *      The container will be iterated through once.
       * @param {?boolean=} optData (default=False)
       *      If True, return edge attribute dict with each edge.
       * @param {?boolean=} optKeys (default=False)
       *      If True, return edge keys with each edge.
       *
       * @return {!Iterator}
       *      An iterator of (u,v), (u,v,d) or (u,v,key,d) tuples of edges.
       *
       * @override
       * @export
       */

      value: _regeneratorRuntime.mark(function edgesIter(optNbunch) {
        var _this = this;

        var optData = arguments[1] === undefined ? false : arguments[1];
        var optKeys = arguments[2] === undefined ? false : arguments[2];

        var seen, nodesNbrs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, n, nbrs, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _step2$value, nbr, keydict, key, tuple;

        return _regeneratorRuntime.wrap(function edgesIter$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              if (typeof optNbunch === "boolean") {
                optKeys = optData;
                optData = optNbunch;
                optNbunch = null;
              }

              seen = new Set();
              nodesNbrs = optNbunch == null ? _this.adj : mapIterator(_this.nbunchIter(optNbunch), function (n) {
                return tuple2(n, _this.adj.get(n));
              });
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              context$2$0.prev = 6;
              _iterator = _core.$for.getIterator(nodesNbrs);

            case 8:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                context$2$0.next = 53;
                break;
              }

              _step$value = _babelHelpers.slicedToArray(_step.value, 2);
              n = _step$value[0];
              nbrs = _step$value[1];
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              context$2$0.prev = 15;
              _iterator2 = _core.$for.getIterator(nbrs);

            case 17:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                context$2$0.next = 36;
                break;
              }

              _step2$value = _babelHelpers.slicedToArray(_step2.value, 2);
              nbr = _step2$value[0];
              keydict = _step2$value[1];

              if (seen.has(nbr)) {
                context$2$0.next = 33;
                break;
              }

              context$2$0.t38 = _regeneratorRuntime.keys(keydict);

            case 23:
              if ((context$2$0.t39 = context$2$0.t38()).done) {
                context$2$0.next = 32;
                break;
              }

              key = context$2$0.t39.value;
              tuple = [n, nbr];

              if (optKeys) {
                tuple[2] = key;
              }
              if (optData) {
                tuple.push(keydict[key]);
              }
              context$2$0.next = 30;
              return tuple;

            case 30:
              context$2$0.next = 23;
              break;

            case 32:
              seen.add(n);

            case 33:
              _iteratorNormalCompletion2 = true;
              context$2$0.next = 17;
              break;

            case 36:
              context$2$0.next = 42;
              break;

            case 38:
              context$2$0.prev = 38;
              context$2$0.t40 = context$2$0["catch"](15);
              _didIteratorError2 = true;
              _iteratorError2 = context$2$0.t40;

            case 42:
              context$2$0.prev = 42;
              context$2$0.prev = 43;

              if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                _iterator2["return"]();
              }

            case 45:
              context$2$0.prev = 45;

              if (!_didIteratorError2) {
                context$2$0.next = 48;
                break;
              }

              throw _iteratorError2;

            case 48:
              return context$2$0.finish(45);

            case 49:
              return context$2$0.finish(42);

            case 50:
              _iteratorNormalCompletion = true;
              context$2$0.next = 8;
              break;

            case 53:
              context$2$0.next = 59;
              break;

            case 55:
              context$2$0.prev = 55;
              context$2$0.t41 = context$2$0["catch"](6);
              _didIteratorError = true;
              _iteratorError = context$2$0.t41;

            case 59:
              context$2$0.prev = 59;
              context$2$0.prev = 60;

              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }

            case 62:
              context$2$0.prev = 62;

              if (!_didIteratorError) {
                context$2$0.next = 65;
                break;
              }

              throw _iteratorError;

            case 65:
              return context$2$0.finish(62);

            case 66:
              return context$2$0.finish(59);

            case 67:
            case "end":
              return context$2$0.stop();
          }
        }, edgesIter, this, [[6, 55, 59, 67], [15, 38, 42, 50], [43,, 45, 49], [60,, 62, 66]]);
      }),
      writable: true,
      configurable: true
    },
    getEdgeData: {

      /**
       * Return the attribute dictionary associated with edge (u,v).
       *
       * ### Example
       *
       * ```
       * var G = jsnx.MultiGraph();
       * G.addPath([0,1,2,3]);
       * G.getEdgeData(0, 1);
       * // {0: {}}
       * G.getEdgeData('a', 'b', null, 0); // edge not in graph, return 0
       * // 0
       * ```
       *
       * @param {Node} u node
       * @param {Node} v node
       * @param {(string|number)=} optKey Return data only for the edge with
       *      specified key.
       * @param {T=} optDefault Value to return if the edge (u,v) is not found.
       *
       * @return {(Object|T)} The edge attribute dictionary.
       * @template T
       */

      value: function getEdgeData(u, v, optKey, optDefault) {
        var neightborsOfU = this.adj.get(u);
        if (neightborsOfU) {
          if (optKey == null) {
            return neightborsOfU.get(v) || optDefault;
          }
          return neightborsOfU.has(v) && neightborsOfU.get(v)[optKey] || optDefault;
        }
      },
      writable: true,
      configurable: true
    },
    degreeIter: {

      /**
       * Return an iterator for (node, degree).
       *
       * The node degree is the number of edges adjacent to the node.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.Graph();
       * G.addPath([0,1,2,3]);
       * Array.from(G.degreeIter(0));
       * // [[0,1]]  // node 0 with degree 1
       * Array.from(G.degreeIter([0,1]));
       * // [[0,1], [1,2]]
       *
       * @see #degree
       *
       * @param {?(Node|NodeContainer)=} optNbunch  A container of nodes
       *      The container will be iterated through once.
       * @param {?string=} optWeight  The edge attribute that holds the numerical
       *      value used as a weight.  If undefined, then each edge has weight 1.
       *      The degree is the sum of the edge weights adjacent to the node.
       *
       * @return {!Iterator} The iterator returns two-tuples of (node, degree).
       */

      value: _regeneratorRuntime.mark(function degreeIter(optNbunch, optWeight) {
        var _this = this;

        var nodesNbrs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, n, nbrs, deg, keydict, key;

        return _regeneratorRuntime.wrap(function degreeIter$(context$2$0) {
          while (1) switch (context$2$0.prev = context$2$0.next) {
            case 0:
              if (typeof optNbunch === "string") {
                optWeight = optNbunch;
                optNbunch = null;
              }
              nodesNbrs = optNbunch == null ? _this.adj : mapIterator(_this.nbunchIter(optNbunch), function (n) {
                return tuple2(n, _this.adj.get(n));
              });
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              context$2$0.prev = 5;
              _iterator = _core.$for.getIterator(nodesNbrs);

            case 7:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                context$2$0.next = 25;
                break;
              }

              _step$value = _babelHelpers.slicedToArray(_step.value, 2);
              n = _step$value[0];
              nbrs = _step$value[1];
              deg = 0;

              if (!(optWeight == null)) {
                context$2$0.next = 18;
                break;
              }

              nbrs.forEach(function (keydict) {
                return deg += _core.Object.keys(keydict).length;
              });
              context$2$0.next = 16;
              return [n, deg + +(nbrs.has(n) && _core.Object.keys(nbrs.get(n)).length)];

            case 16:
              context$2$0.next = 22;
              break;

            case 18:
              // edge weighted graph - degree is sum of nbr edge weights
              nbrs.forEach(function (keydict) {
                for (var key in keydict) {
                  deg += getDefault(keydict[key][optWeight], 1);
                }
              });

              if (nbrs.has(n)) {
                keydict = nbrs.get(n);

                for (key in keydict) {
                  deg += getDefault(keydict[key][optWeight], 1);
                }
              }

              context$2$0.next = 22;
              return [n, deg];

            case 22:
              _iteratorNormalCompletion = true;
              context$2$0.next = 7;
              break;

            case 25:
              context$2$0.next = 31;
              break;

            case 27:
              context$2$0.prev = 27;
              context$2$0.t42 = context$2$0["catch"](5);
              _didIteratorError = true;
              _iteratorError = context$2$0.t42;

            case 31:
              context$2$0.prev = 31;
              context$2$0.prev = 32;

              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }

            case 34:
              context$2$0.prev = 34;

              if (!_didIteratorError) {
                context$2$0.next = 37;
                break;
              }

              throw _iteratorError;

            case 37:
              return context$2$0.finish(34);

            case 38:
              return context$2$0.finish(31);

            case 39:
            case "end":
              return context$2$0.stop();
          }
        }, degreeIter, this, [[5, 27, 31, 39], [32,, 34, 38]]);
      }),
      writable: true,
      configurable: true
    },
    isMultigraph: {

      /**
       * Return true if graph is a multigraph, false otherwise.
       *
       * @return {boolean} true if graph is a multigraph, false otherwise.
       */

      value: function isMultigraph() {
        return true;
      },
      writable: true,
      configurable: true
    },
    isDirected: {

      /**
       * Return true if graph is directed, false otherwise.
       *
       * @return {boolean}  True if graph is directed, False otherwise.
       */

      value: function isDirected() {
        return false;
      },
      writable: true,
      configurable: true
    },
    toDirected: {

      /**
       * Return a directed representation of the graph.
       *
       * ### Notes
       *
       * This returns a "deepcopy" of the edge, node, and graph attributes which
       * attempts to completely copy all of the data and references.
       *
       * This is in contrast to the similar D = DiGraph(G) which returns a shallow
       * copy of the data.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiGraph();
       * G.addPath([0,1]);
       * var H = G.toDirected();
       * G.edges();
       * // [[0,1], [1,0]]
       * ```
       *
       * If already directed, return a (deep) copy
       *
       * ```
       * var G = new jsnx.MultiDiGraph();
       * G.addPath([0,1]);
       * var H = G.toDirected();
       * G.edges();
       * // [[0,1]]
       * ```
       *
       * @return {!MultiDiGraph}
       *      A directed graph with the same name, same nodes, and with
       *      each edge (u,v,data) replaced by two directed edges
       *      (u,v,data) and (v,u,data).
       */

      value: function toDirected() {
        var G = new (require("./MultiDiGraph"))();
        G.addNodesFrom(this);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _core.$for.getIterator(this.adjacencyIter()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _babelHelpers.slicedToArray(_step.value, 2);

            var u = _step$value[0];
            var nbrs = _step$value[1];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _core.$for.getIterator(nbrs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _step2$value = _babelHelpers.slicedToArray(_step2.value, 2);

                var v = _step2$value[0];
                var keydict = _step2$value[1];

                for (var key in keydict) {
                  G.addEdge(u, v, key, deepcopy(keydict[key]));
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        G.graph = deepcopy(this.graph);
        G.node = deepcopy(this.node);
        return G;
      },
      writable: true,
      configurable: true
    },
    selfloopEdges: {

      /**
       * Return a list of selfloop edges.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiGraph();
       * G.addEdge(1, 1);
       * G.addEdge(1, 2);
       * G.selfloopEdges();
       * // [[1,1]]
       * G.selfloopEdges(true);
       * // [[1,1,{}]]
       * G.selfloopEdges(false, true);
       * // [[1,1,0]]
       * G.selfloopEdges(true, true);
       * // [[1,1,0,{}]]
       *
       * @see #nodesWithSelfloops
       * @see #numberOfSelfloops
       *
       *
       * @param {boolean=} optData  (default=False)
       *      Return selfloop edges as two tuples (u,v) (data=False)
       *      or three-tuples (u,v,data) (data=True)
       * @param {boolean=} optKeys  (default=False)
       *       If True, return edge keys with each edge
       *
       * @return {Array} A list of all selfloop edges
       */

      value: function selfloopEdges() {
        var optData = arguments[0] === undefined ? false : arguments[0];
        var optKeys = arguments[1] === undefined ? false : arguments[1];

        var edges = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _core.$for.getIterator(this.adj), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _babelHelpers.slicedToArray(_step.value, 2);

            var n = _step$value[0];
            var nbrs = _step$value[1];

            if (nbrs.has(n)) {
              var keydict = nbrs.get(n);
              for (var key in keydict) {
                var edge = [n, n];
                if (optKeys) {
                  edge[2] = key;
                }
                if (optData) {
                  edge.push(keydict[key]);
                }
                edges.push(edge);
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return edges;
      },
      writable: true,
      configurable: true
    },
    numberOfEdges: {

      /**
       * Return the number of edges between two nodes.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.MultiGraph();
       * G.addPath([0,1,2,3]);
       * G.numberOfEdges();
       * // 3
       * G.numberOfEdges(0,1);
       * // 1
       * ```
       *
       * @see #size
       *
       * @param {Node=} optU node
       * @param {Node=} optV node
       *      If u and v are specified, return the number of edges between
       *      u and v. Otherwise return the total number of all edges.
       *
       * @return {number} The number of edges in the graph.
       *      If nodes u and v are specified return the number of edges between
       *      those nodes.
       */

      value: function numberOfEdges(optU, optV) {
        if (optU == null || optV == null) {
          return this.size();
        }

        var neightborsOfU = this.get(optU);
        if (neightborsOfU) {
          return neightborsOfU.has(optV) ? _core.Object.keys(neightborsOfU.get(optV)).length : 0;
        }
        return 0;
      },
      writable: true,
      configurable: true
    },
    subgraph: {

      /**
       * Return the subgraph induced on nodes in nbunch.
       *
       * The induced subgraph of the graph contains the nodes in nbunch and the
       * edges between those nodes.
       *
       * ### Notes
       *
       * The graph, edge or node attributes just point to the original graph.
       * So changes to the node or edge structure will not be reflected in
       * the original graph while changes to the attributes will.
       *
       * To create a subgraph with its own copy of the edge/node attributes use:
       * `jsnx.Graph(G.subgraph(nbunch))`
       *
       * If edge attributes are containers, a deep copy can be obtained using:
       * `G.subgraph(nbunch).copy()`.
       *
       * ### Example
       *
       * ```
       * var G = new jsnx.Graph();
       * G.addPath([0,1,2,3]);
       * var H = G.subgraph([0,1,2]);
       * H.edges();
       * // [[0,1], [1,2]]
       * ```
       *
       * @param {NodeContainer=} nbunch A container of nodes which will be
       *      iterated through once.
       * @return {MultiGraph} A subgraph of the graph with the same edge attributes.
       */

      value: function subgraph(nbunch) {
        var bunch = this.nbunchIter(nbunch);
        // create new graph and copy subgraph into it
        var H = new this.constructor();
        // copy node and attribute dictionaries
        this.node.forEach(function (d, n) {
          return H.node.set(n, d);
        });
        // namespace shortcuts for speed
        var HAdj = H.adj,
            thisAdj = this.adj;

        // add nodes and edges (undirected method)
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _core.$for.getIterator(bunch), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var n = _step.value;

            var Hnbrs = new Map();
            HAdj.set(n, Hnbrs);

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _core.$for.getIterator(thisAdj.get(n)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _step2$value = _babelHelpers.slicedToArray(_step2.value, 2);

                var nbr = _step2$value[0];
                var edgedict = _step2$value[1];

                if (HAdj.has(nbr)) {
                  // add both representations of edge: n-nbr and nbr-n
                  // they share the same edgedict
                  var ed = clone(edgedict);
                  Hnbrs.set(nbr, ed);
                  HAdj.get(nbr).set(n, ed);
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        H.graph = this.graph;
        return H;
      },
      writable: true,
      configurable: true
    }
  });

  return MultiGraph;
})(Graph);

module.exports = MultiGraph;

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../exceptions/JSNetworkXError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXError.js","./Graph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/Graph.js","./MultiDiGraph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/MultiDiGraph.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/functions.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Return a copy of the graph nodes in a list.
 *
 * @param {Graph} G Graph
 * @return {Array} List of nodes
 */
exports.nodes = nodes;

/**
 * Return an iterator over the graph nodes.
 *
 * @param {Graph} G Graph
 * @return {Iterator} Iterator over graph nodes
 */
exports.nodesIter = nodesIter;

/**
 * Return a list of edges adjacent to nodes in nbunch.
 *
 * Return all edges if nbunch is unspecified or nbunch=None.
 * For digraphs, edges=out_edges
 *
 * @param {Graph} G Graph
 * @param {NodeContainer=} opt_nbunch Nodes
 * @return {Array} List of edges
 */
exports.edges = edges;

/**
 * Return iterator over  edges adjacent to nodes in nbunch.
 *
 * Return all edges if nbunch is unspecified or nbunch=None.
 * For digraphs, edges=out_edges
 *
 * @param {Graph} G Graph
 * @param {NodeContainer=} opt_nbunch Nodes
 * @return {Iterator} Iterator over edges
 */
exports.edgesIter = edgesIter;

/**
 * Return degree of single node or of nbunch of nodes.
 * If nbunch is omitted, then return degrees of *all* nodes.
 *
 * @param {Graph} G Graph
 * @param {NodeContainer=} opt_nbunch Nodes
 * @param {string=} opt_weight Weight attribute name
 * @return {(number|Map)} Degree of node(s)
 */
exports.degree = degree;

/**
 * Return a list of nodes connected to node n.
 *
 * @param {Graph} G Graph
 * @param {Node} n Node
 * @return {Array} List of nodes
 */
exports.neighbors = neighbors;

/**
 * Return the number of nodes in the graph.
 *
 * @param {Graph} G Graph
 * @return {number} Number of nodes
 */
exports.numberOfNodes = numberOfNodes;

/**
 * Return the number of edges in the graph.
 *
 * @param {Graph} G Graph
 * @return {number} Number of edges
 */
exports.numberOfEdges = numberOfEdges;

/**
 * Return the density of a graph.
 * The density for undirected graphs is
 *
 * ```math
 * d = \frac{2m}{n(n-1)}
 * ```
 *
 * and for directed graphs is
 *
 * ```math
 * \frac{m}{n(n-1)}
 * ```
 *
 * where n is the number of nodes and m is the number of edges in G
 *
 * The density is 0 for an graph without edges and 1.0 for a complete graph.
 * The density of multigraphs can be higher than 1.
 *
 * @param {Graph} G Graph
 * @return {number} Density
 */
exports.density = density;

/**
 * Return a list of the frequency of each degree value.
 *
 * Note: the bins are width one, hence list.length can be large
 * (Order(number_of_edges))
 *
 *
 * @param {Graph} G Graph
 * @return {Array} A list of frequencies of degrees.
 *      The degree values are the index in the list.
 */
exports.degreeHistogram = degreeHistogram;

/**
 * Return True if graph is directed.
 *
 * @param {Graph} G Graph
 * @return {boolean}  True if graph is directed
 */
exports.isDirected = isDirected;

/**
 * Modify graph to prevent addition of nodes or edges.
 *
 * This does not prevent modification of edge data.
 * To "unfreeze" a graph you must make a copy.
 *
 * @see #is_frozen
 *
 * @param {Graph} G Graph
 * @return {Graph} A reference to the input graph
 */
exports.freeze = freeze;

/**
 * Return True if graph is frozen.
 *
 * @see #freeze
 *
 * @param {Graph} G Graph
 * @return {boolean}  True if graph is frozen.
 */
exports.isFrozen = isFrozen;

/**
 * Return the subgraph induced on nodes in nbunch.
 *
 * Note:  subgraph(G) calls G.subgraph()
 *
 * @param {Graph} G Graph
 * @param {NodeContainer} nbunch
 *      A container of nodes that will be iterated through once (thus
 *      it should be an iterator or be iterable).  Each element of the
 *      container should be a valid node type: any hashable type except
 *      None.  If nbunch is None, return all edges data in the graph.
 *      Nodes in nbunch that are not in the graph will be (quietly)
 *      ignored.
 * @return {Graph} Subgraph
 */
exports.subgraph = subgraph;

/**
 * Return a copy of the graph G with all of the edges removed.
 *
 * Notes: Graph, node, and edge data is not propagated to the new graph.
 *
 * @param {Graph} G Graph
 * @param {boolean} opt_with_nodes (default=True)
 *      Include nodes.
 *
 * @return {Graph} A copy of the graph
 */
exports.createEmptyCopy = createEmptyCopy;

/**
 * Print short summary of information for the graph G or the node n.
 *
 * @param {Graph} G Graph
 * @param {Node=} opt_n A node in the graph G
 * @return {string} Info
 */
exports.info = info;

/**
 * Set node attributes from dictionary of nodes and values
 *
 * @param {Graph} G Graph
 * @param {string} name Attribute name
 * @param {(Object|Map)} attributes Dictionary of attributes keyed by node
 */
exports.setNodeAttributes = setNodeAttributes;

/**
 * Get node attributes from graph
 *
 * @param {Graph} G Graph
 * @param {string} name Attribute name
 * @return {!Map} Dictionary of attributes keyed by node.
 */
exports.getNodeAttributes = getNodeAttributes;

/**
 * Set edge attributes from dictionary of edge tuples and values
 *
 * @param {Graph} G Graph
 * @param {string} name Attribute name
 * @param {Map} attributes
 *    Dictionary of attributes keyed by edge (tuple).
 */
exports.setEdgeAttributes = setEdgeAttributes;

/**
 * Get edge attributes from graph
 *
 * Since keys can only be strings in JavaScript, the edge is returned as
 * {@code "node1,node2"} string. You'd have to call {@code .split(',')} on
 * the keys to extract the actual node names.
 *
 * @param {Graph} G Graph
 * @param {string} name Attribute name
 * @return {!Map} Dictionary of attributes keyed by edge.
 */
exports.getEdgeAttributes = getEdgeAttributes;

var JSNetworkXError = _babelHelpers.interopRequire(require("../exceptions/JSNetworkXError"));

var _internals = require("../_internals");

var fillArray = _internals.fillArray;
var isMap = _internals.isMap;
var isPlainObject = _internals.isPlainObject;
var sprintf = _internals.sprintf;

function nodes(G) {
  return G.nodes();
}

function nodesIter(G) {
  return G.nodesIter();
}

function edges(G, optNbunch) {
  return G.edges(optNbunch);
}

function edgesIter(G, optNbunch) {
  return G.edgesIter(optNbunch);
}

function degree(G, optNbunch, optWeight) {
  return G.degree(optNbunch, optWeight);
}

function neighbors(G, n) {
  return G.neighbors(n);
}

function numberOfNodes(G) {
  return G.numberOfNodes();
}

function numberOfEdges(G) {
  return G.numberOfEdges();
}

function density(G) {
  var n = G.numberOfNodes();
  var m = G.numberOfEdges();
  var d;

  if (m === 0) {
    // includes cases n === 0 and n === 1
    d = 0;
  } else {
    if (G.isDirected()) {
      d = m / (n * (n - 1));
    } else {
      d = m * 2 / (n * (n - 1));
    }
  }

  return d;
}

function degreeHistogram(G) {
  var degseq = _core.Array.from(G.degree().values());
  var dmax = Math.max.apply(Math, degseq) + 1;
  var freq = fillArray(dmax, 0);

  degseq.forEach(function (d) {
    freq[d] += 1;
  });

  return freq;
}

function isDirected(G) {
  return G.isDirected();
}

function freeze(G) {
  function frozen() {
    throw new JSNetworkXError("Frozen graph can't be modified");
  }

  // This double assignment is necessary for the closure compiler
  G.addNode = frozen;
  G.addNodesFrom = frozen;
  G.removeNode = frozen;
  G.removeNodesFrom = frozen;
  G.addEdge = frozen;
  G.addEdgesFrom = frozen;
  G.removeEdge = frozen;
  G.removeEdgesFrom = frozen;
  G.clear = frozen;
  G.frozen = true;
  return G;
}

function isFrozen(G) {
  return !!G.frozen;
}

function subgraph(G, nbunch) {
  return G.subgraph(nbunch);
}

function createEmptyCopy(G) {
  var optWithNodes = arguments[1] === undefined ? true : arguments[1];

  var H = new G.constructor();
  if (optWithNodes) {
    H.addNodesFrom(G);
  }
  return H;
}

function info(G, optN) {
  var result = "";
  if (optN == null) {
    var template = "Name: %s\n" + "Type: %s\n" + "Number of nodes: %s\n" + "Number of edges: %s\n";
    var nnodes = G.numberOfNodes();
    result = sprintf(template, G.name, G.constructor.__name__, nnodes, G.numberOfEdges());
    if (nnodes > 0) {
      if (G.isDirected()) {
        var inDegree = 0;
        var outDegree = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _core.$for.getIterator(G.inDegree().values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var degree = _step.value;

            inDegree += degree;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = _core.$for.getIterator(G.outDegree().values()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            degree = _step2.value;

            outDegree += degree;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        result += sprintf("Average in degree: %s\nAverage out degree: %s", (inDegree / nnodes).toFixed(4), (outDegree / nnodes).toFixed(4));
      } else {
        var sum = 0;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = _core.$for.getIterator(G.degree().values()), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var v = _step3.value;

            sum += v;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        result += sprintf("Average degree: %s", (sum / nnodes).toFixed(4));
      }
    }
  } else {
    if (!G.hasNode(optN)) {
      throw new JSNetworkXError(sprintf("Node %j not in graph.", optN));
    }
    result = sprintf("Node %j has the following properties:\nDegree: %s\nNeighbors: %s", optN, G.degree(optN), G.neighbors(optN).map(function (n) {
      return JSON.stringify(n);
    }).join(" "));
  }
  return result;
}

function setNodeAttributes(G, name, attributes) {
  if (isMap(attributes)) {
    attributes.forEach(function (value, node) {
      return G.node.get(node)[name] = value;
    });
  } else if (isPlainObject(attributes)) {
    for (var node in attributes) {
      node = isNaN(node) ? node : +node;
      G.node.get(node)[name] = attributes[node];
    }
  } else {
    throw new TypeError("Attributes must be a Map or a plain object");
  }
}

function getNodeAttributes(G, name) {
  var dict = new _core.Map();
  G.node.forEach(function (node, data) {
    if (data.hasOwnProperty(name)) {
      dict.set(node, data[name]);
    }
  });
  return dict;
}

function setEdgeAttributes(G, name, attributes) {
  attributes.forEach(function (edge, value) {
    G.get(edge[0]).get(edge[1])[name] = value;
  });
}

function getEdgeAttributes(G, name) {
  var dict = new _core.Map();
  G.edges(null, true).forEach(function (edged) {
    if (edged[2].hasOwnProperty(name)) {
      var value = edged[2][name];
      edged.length = 2; // cut of data
      dict.set(edged, value);
    }
  });
  return dict;
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../exceptions/JSNetworkXError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXError.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/index.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var Graph = _babelHelpers.interopRequire(require("./Graph"));

var DiGraph = _babelHelpers.interopRequire(require("./DiGraph"));

var MultiGraph = _babelHelpers.interopRequire(require("./MultiGraph"));

var MultiDiGraph = _babelHelpers.interopRequire(require("./MultiDiGraph"));

var _functions = require("./functions");

var functions = _babelHelpers.interopRequire(_functions);

exports.Graph = Graph;
exports.DiGraph = DiGraph;
exports.MultiGraph = MultiGraph;
exports.MultiDiGraph = MultiDiGraph;
exports.functions = functions;

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_functions));

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"./DiGraph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/DiGraph.js","./Graph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/Graph.js","./MultiDiGraph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/MultiDiGraph.js","./MultiGraph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/MultiGraph.js","./functions":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/functions.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/contrib/convert.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

/**
 * This module provides functions to convert JSNetworkX graphs to and from
 * non-NetworkX formats.
 */

/**
 * Return adjacency representation of graph as a map of lists.
 *
 * Completely ignores edge data for MultiGraph and MultiDiGraph.
 *
 * @param {Graph} G A graph
 * @param {NodeContainer=} opt_nodelist Use only nods specified in nodelist.
 *
 * @return {!Map}
 */
exports.toMapOfLists = toMapOfLists;

/**
 * Return a graph from a map of lists.
 * *
 * @param {!Map} map A map of lists adjacency representation.
 * @param {Graph=} opt_create_using Use specified graph for result.
 *    Otherwise a new graph is created.
 *
 * @return {!Graph}
 */
exports.fromMapOfLists = fromMapOfLists;

/**
 * Return adjacency representation of graph as a map of maps.
 *
 * @param {Graph} G A jsnx Graph
 * @param {NodeContainer=} opt_nodelist Use only nodes specified in nodelist
 * @param {Object=} opt_edge_data If provided,  the value of the map will be
 *      set to edge_data for all edges.  This is useful to make
 *      an adjacency matrix type representation with 1 as the edge data.
 *      If opt_edge_data is null or undefined, the edge data in G is used to
 *      fill the values.
 *      If G is a multigraph, the edge data is a dict for each pair (u,v).
 *
 * @return {!Map}
 */
exports.toMapOfMaps = toMapOfMaps;

/**
 * Return a graph from a map of maps.
 *
 * @param {!Map} map A map of maps adjacency representation.
 * @param {Graph=} opt_create_using Use specified graph for result.
 *      Otherwise a new graph is created.
 * @param {boolean=} opt_multigraph_input (default=False)
 *      When True, the values of the inner dict are assumed
 *      to be containers of edge data for multiple edges.
 *      Otherwise this routine assumes the edge data are singletons.
 *
 * @return {Graph}
 */
exports.fromMapOfMaps = fromMapOfMaps;

var prepCreateUsing = _babelHelpers.interopRequire(require("./prepCreateUsing"));

var _internals = require("../_internals");

var Map = _internals.Map;
var Set = _internals.Set;
var isArrayLike = _internals.isArrayLike;
var tuple2 = _internals.tuple2;

function toMapOfLists(G, optNodelist) {
  var map = new Map();

  if (optNodelist != null) {
    _core.Array.from(optNodelist).forEach(function (n) {
      return map.set(n, G.neighbors(n).filter(function (v) {
        return optNodelist.indexOf(v) > -1;
      }));
    });
  } else {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(G), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var n = _step.value;

        map.set(n, G.neighbors(n));
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return map;
}

function fromMapOfLists(map, optCreateUsing) {
  var G = prepCreateUsing(optCreateUsing);
  G.addNodesFrom(map.keys());

  if (G.isMultigraph() && !G.isDirected()) {
    // a map_of_lists can't show multiedges.  BUT for undirected graphs,
    // each edge shows up twice in the map_of_lists.
    // So we need to treat this case separately.
    var seen = new Set();

    map.forEach(function (nbrlist, node) {
      nbrlist.forEach(function (nbr) {
        if (!seen.has(nbr)) {
          G.addEdge(node, nbr);
        }
      });
      seen.add(node); // don't allow reverse edge to show up
    });
  } else {
    map.forEach(function (nbrlist, node) {
      nbrlist.forEach(function (nbr) {
        return G.addEdge(node, nbr);
      });
    });
  }

  return G;
}

function toMapOfMaps(G, optNodelist, optEdgeData) {
  var mapOfMaps = new Map();

  if (optNodelist != null) {
    optNodelist = _core.Array.from(optNodelist);
    optNodelist.forEach(function (u) {
      var mapOfU = mapOfMaps.set(u, new Map());
      G.get(u).forEach(function (v, data) {
        if (optNodelist.indexOf(v) > -1) {
          mapOfU.set(v, optEdgeData == null ? data : optEdgeData);
        }
      });
    });
  } else {
    // nodelist is undefined
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(G.adjacencyIter()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _babelHelpers.slicedToArray(_step.value, 2);

        var nbrmap = _step$value[0];
        var u = _step$value[1];

        /*jshint loopfunc:true*/
        var mapOfU = mapOfMaps.set(u, new Map());
        nbrmap.forEach(function (data, v) {
          mapOfU.set(v, optEdgeData == null ? data : optEdgeData);
        });
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return mapOfMaps;
}

function fromMapOfMaps(map, optCreateUsing, optMultigraphInput) {
  var G = prepCreateUsing(optCreateUsing);
  var seen = new Set(); // don't add both directions of undirected graph
  G.addNodesFrom(map.keys());

  // is map a MultiGraph or MultiDiGraph?
  if (optMultigraphInput) {
    // make a copy  of the list of edge data (but not the edge data)
    if (G.isDirected()) {
      map.forEach(function (nbrs, u) {
        if (isArrayLike(nbrs)) {
          // throw expection of not map (object)
          throw new TypeError("Value is not a map.");
        }
        nbrs.forEach(function (datadict, v) {
          for (var key in datadict) {
            var data = datadict[key];
            if (G.isMultigraph()) {
              G.addEdge(u, v, key, data);
            } else {
              G.addEdge(u, v, data);
            }
          }
        });
      });
    } else {
      // undirected
      var isMultigraph = G.isMultigraph();
      map.forEach(function (nbrs, u) {
        if (isArrayLike(nbrs)) {
          // throw exception of not map
          throw new TypeError("Not a map");
        }
        nbrs.forEach(function (datadict, v) {
          // this works because sets convert the value to their string
          // representation
          if (!seen.has(tuple2(u, v))) {
            for (var key in datadict) {
              var data = datadict[key];
              if (isMultigraph) {
                G.addEdge(u, v, key, data);
              } else {
                G.addEdge(u, v, data);
              }
            }
            seen.add(tuple2(v, u));
          }
        });
      });
    }
  } else {
    // not a multigraph to multigraph transfer
    if (G.isMultigraph() && !G.isDirected()) {
      // map can have both representations u-v, v-u in dict.  Only add one.
      // We don't need this check for digraphs since we add both directions,
      // or for Graph() since it is done implicitly (parallel edges not allowed)
      map.forEach(function (nbrs, u) {
        if (isArrayLike(nbrs)) {
          // throw exception of not dict (object)
          throw new TypeError("Value is not a map");
        }
        nbrs.forEach(function (data, v) {
          if (!seen.has(tuple2(u, v))) {
            G.addEdge(u, v, data);
            seen.add(tuple2(v, u));
          }
        });
      });
    } else {
      map.forEach(function (nbrs, u) {
        if (isArrayLike(nbrs)) {
          // throw exception of not dict (object)
          throw new TypeError("Value is not a map");
        }
        nbrs.forEach(function (data, v) {
          G.addEdge(u, v, data);
        });
      });
    }
  }

  return G;
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

/*jshint ignore:start*/

/*jshint ignore:end*/

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","./prepCreateUsing":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/contrib/prepCreateUsing.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/contrib/observer.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

/**
 * Makes a graph observable, i.e. external code can bind event handlers to
 * be notified about changes in the graph (adding or removing nodes or edges).
 *
 * @param {Graph} G The graph to make observable
 * @return {Graph} The same graph passed as argument (not a new graph)
 */
exports.observe = observe;

/**
 * Removes the properties added to a graph for event handling.
 *
 * @param {Graph} G
 * @return {Graph} The graph passed to the function
 */
exports.unobserve = unobserve;

/**
 * Tests whether the graph is observable.
 *
 * @param {Graph} G
 * @return {boolean}
 */
exports.isObservable = isObservable;

/**
 * A simple event object to any data can be added. It provides four methods:
 *
 * - stopPropagation to indicated that subsequent event handlers should not be
 *   executed.
 * - isPropgationStopped to test the status (internal only)
 * - preventDefault to prevent the default action
 * - isDefaultPrevented to test the status
 */

var Event = (function () {

  /**
   * @param {string} type
   * @param {*} target
   */

  function Event(type, target) {
    _babelHelpers.classCallCheck(this, Event);

    this.type = type;
    this.target = target;
    this._defaultAction = true;
    this._propagate = true;
  }

  _babelHelpers.prototypeProperties(Event, null, {
    stopPropagation: {

      /**
       * When called, should prevent the execution of subsequent handlers.
       */

      value: function stopPropagation() {
        this._propagate = false;
      },
      writable: true,
      configurable: true
    },
    isPropgationStopped: {

      /**
       * Tests whether the propagation should be stopped.
       * @return {boolean}
       */

      value: function isPropgationStopped() {
        return !this._propagate;
      },
      writable: true,
      configurable: true
    },
    preventDefault: {

      /**
       * When called, should prevent the default action.
       */

      value: function preventDefault() {
        this._defaultAction = false;
      },
      writable: true,
      configurable: true
    },
    isDefaultPrevented: {

      /**
       * Tests whether the default action should be stopped.
       *
       * @return {boolean}
       */

      value: function isDefaultPrevented() {
        return !this._defaultAction;
      },
      writable: true,
      configurable: true
    }
  });

  return Event;
})();

function observe(G) {
  if (typeof G.on === "function") {
    // graph is already observable, do nothing
    return G;
  }

  var eventHandlers = {
    addNodes: [],
    removeNodes: [],
    addEdges: [],
    removeEdges: [],
    clear: []
  };
  var proto = G.constructor.prototype;

  function triggerHandlers(event, G, funcName, args) {
    var handlers = eventHandlers[event.type];
    if (!handlers) {
      return;
    }
    // run before handlers
    for (var i = 0, l = handlers.length; i < l && !event.isPropgationStopped(); i += 3) {
      if (handlers[i + 2]) {
        handlers[i].call(handlers[i + 1] || G, event);
      }
    }

    if (!event.isDefaultPrevented()) {
      if (args) {
        proto[funcName].apply(G, args);
      } else {
        proto[funcName].call(G);
      }
      if (!event.isPropgationStopped()) {
        // run after handlers
        for (i = 0, l = handlers.length; i < l && !event.isPropgationStopped(); i += 3) {
          if (!handlers[i + 2]) {
            handlers[i].call(handlers[i + 1] || G, event);
          }
        }
      }
    }
  }

  G.on = function (event, handler, thisObj, before) {
    if (!eventHandlers[event]) {
      throw new Error("Event \"" + event + "\" is not supported.");
    }
    eventHandlers[event].push(handler, thisObj, !!before);
  };

  G.off = function (event, handler, thisObj) {
    var handlers;
    var startIndex;
    var i;
    if (arguments.length === 1) {
      // Remove all event handlers
      eventHandlers[event].length = 0;
    } else if (arguments.length === 2) {
      // Remove particular handler or object only
      handlers = eventHandlers[event];
      startIndex = handlers.length - 2;
      if (typeof handler !== "function") {
        startIndex += 1;
      }
      for (i = startIndex; i > 0; i -= 2) {
        if (handlers[i] === handler) {
          handlers.splice(i, 3);
        }
      }
    } else {
      // Remove particular handler-object combination
      handlers = eventHandlers[event];
      startIndex = handlers.length - 2;
      for (i = startIndex; i > 0; i -= 2) {
        if (handlers[i] === handler && handlers[i + 1] === thisObj) {
          handlers.splice(i, 2);
        }
      }
    }
  };

  G.addNode = function (n) {
    var newNodes = G.hasNode(n) ? [] : [n];
    var event = new Event("addNodes", this);
    event.nodes = [n];
    event.newNodes = newNodes;

    triggerHandlers(event, this, "addNode", arguments);
  };

  G.addNodesFrom = function (nbunch) {
    var nodes = [];
    var newNodes = [];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(nbunch), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var bunch = _step.value;

        var v = Array.isArray(bunch) ? bunch[0] : bunch;
        nodes.push(Array.isArray(bunch) ? bunch.slice() : bunch);
        if (!G.hasNode(v)) {
          newNodes.push(v);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var event = new Event("addNodes", this);
    event.nodes = nodes.filter(function (v) {
      return Array.isArray(v) ? v[0] : v;
    });
    event.newNodes = newNodes;

    var args = _core.Array.from(arguments);
    args[0] = nodes;

    triggerHandlers(event, this, "addNodesFrom", args);
  };

  G.addEdge = function (u, v) {
    var edges = [[u, v]];
    var newEdges = this.hasEdge(u, v) ? [] : edges;

    var event = new Event("addEdges", this);
    event.edges = edges;
    event.newEdges = newEdges;

    triggerHandlers(event, this, "addEdge", arguments);
  };

  G.addEdgesFrom = function (ebunch) {
    var edges = [];
    var newEdges = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(ebunch), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var bunch = _step.value;

        edges.push(bunch.slice());
        if (!this.hasEdge(bunch[0], bunch[1])) {
          newEdges.push(bunch.slice(0, 2));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var event = new Event("addEdges", this);
    event.edges = edges;
    event.newEdges = newEdges;

    var args = _core.Array.from(arguments);
    args[0] = edges;

    triggerHandlers(event, this, "addEdgesFrom", args);
  };

  G.removeNode = function (n) {
    var event = new Event("removeNodes", this);
    event.nodes = [n];

    triggerHandlers(event, this, "removeNode", arguments);
  };

  G.removeNodesFrom = function (nbunch) {
    var nodes = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(nbunch), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var bunch = _step.value;

        nodes.push(Array.isArray(bunch) ? bunch.slice() : bunch);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var event = new Event("removeNodes", this);
    event.nodes = nodes;

    var args = _core.Array.from(arguments);
    args[0] = nodes;

    triggerHandlers(event, this, "removeNodesFrom", args);
  };

  G.removeEdge = function (u, v) {
    var event = new Event("removeEdges", this);
    event.edges = [[u, v]];

    triggerHandlers(event, this, "removeEdge", arguments);
  };

  G.removeEdgesFrom = function (ebunch) {
    var edges = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(ebunch), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var bunch = _step.value;

        edges.push(bunch.slice());
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var event = new Event("removeEdges");
    event.edges = edges;

    var args = _core.Array.from(arguments);
    args[0] = edges;

    triggerHandlers(event, this, "removeEdgesFrom", args);
  };

  G.clear = function () {
    triggerHandlers(new Event("clear", this), this, "clear");
  };

  return G;
}

function unobserve(G) {
  var proto = G.constructor.prototype;

  if (typeof G.on !== "function") {
    // nothing to do
    return G;
  }

  G.addNode = proto.addNode;
  G.addNodesFrome = proto.addNodesFrom;
  G.addEdge = proto.addEdge;
  G.addEdgesFrome = proto.addEdgesFrom;
  G.removeNode = proto.removeNode;
  G.removeEdge = proto.removeEdge;
  G.removeNodesFrom = proto.removeNodesFrom;
  G.removeEdgesFrom = proto.removeEdgesFrom;
  G.clear = proto.clear;

  delete G.on;
  delete G.off;

  return G;
}

function isObservable(G) {
  return typeof G.on === "function" && typeof G.off === "function";
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/contrib/prepCreateUsing.js":[function(require,module,exports){
"use strict";

/**
 * Return a graph object ready to be populated.
 *
 * If create_using is null or undefined return the default (just jsnx.Graph())
 * If create_using.clear() works, assume it returns a graph object.
 * Otherwise raise an exception because create_using is not a jsnx graph.
 *
 * @param {Graph=} opt_create_using
 * @return {Graph}
 */
exports.prepCreateUsing = prepCreateUsing;

function prepCreateUsing(optCreateUsing) {
  var G;
  // can't use import statement because of circular dependency
  var Graph = require("../classes/Graph");

  if (optCreateUsing == null) {
    G = new Graph();
  } else {
    G = optCreateUsing;

    try {
      G.clear();
    } catch (e) {
      throw new TypeError("Input graph is not a jsnx graph type");
    }
  }
  return G;
}

module.exports = prepCreateUsing;
Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"../classes/Graph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/Graph.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/convert.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

/**
 * This module provides functions to convert
 * NetworkX graphs to and from other formats.
 *
 * The preferred way of converting data to a NetworkX graph
 * is through the graph constuctor.  The constructor calls
 * the to_networkx_graph() function which attempts to guess the
 * input type and convert it automatically.
 */

/*jshint ignore:start*/
var Map = require("./_internals/Map");
var Set = require("./_internals/Set");
/*jshint ignore:end*/

var convertMap = require("./contrib/convert");
var hasOwn = Object.prototype.hasOwnProperty;
var prepCreateUsing = require("./contrib/prepCreateUsing");
var _mapValues = require("lodash/object/mapValues");

var _require = require("./_internals");

var clone = _require.clone;
var forEach = _require.forEach;
var isMap = _require.isMap;
var isArrayLike = _require.isArrayLike;
var isPlainObject = _require.isPlainObject;

/**
 * Make a jsnx graph from a known data structure.
 *
 * @param {?} data An object to be converted
 *     Current known types are:
 *        any jsnx graph
 *        dict-of-dicts
 *        dict-of-lists
 *        list of edges
 *
 * @param {Graph=} opt_create_using NetworkX graph
 *     Use specified graph for result.  Otherwise a new graph is created.
 *
 * @param {boolean=} opt_multigraph_input (default false)
 *     If true and  data is a dict_of_dicts,
 *     try to create a multigraph assuming dict_of_dict_of_lists.
 *     If data and create_using are both multigraphs then create
 *     a multigraph from a multigraph.
 *
 * @return {Graph}
 * @export
 */
function toNetworkxGraph(data, optCreateUsing, optMultigraphInput) {
  var result = null;

  // jsnx graph
  if (hasOwn.call(data, "adj")) {
    try {
      result = convertMap.fromMapOfMaps(data.adj, optCreateUsing, data.isMultigraph());
      if (hasOwn.call(data, "graph") && typeof data.graph === "object") {
        result.graph = clone(data.graph);
      }
      if (hasOwn.call(data, "node") && isMap(data.node)) {
        result.node = new Map();
        data.node.forEach(function (element, k) {
          return result.node.set(k, clone(element));
        });
      }
      return result;
    } catch (ex) {
      throw ex;
    }
  }

  // map of maps / lists
  if (isMap(data)) {
    try {
      return convertMap.fromMapOfMaps(data, optCreateUsing, optMultigraphInput);
    } catch (e) {
      try {
        return convertMap.fromMapOfLists(data, optCreateUsing);
      } catch (ex) {
        throw new Error("Map data structure cannot be converted to a graph.");
      }
    }
  }

  // dict of dicts / lists
  if (isPlainObject(data)) {
    try {
      return fromDictOfDicts(data, optCreateUsing, optMultigraphInput);
    } catch (e) {
      try {
        return fromDictOfLists(data, optCreateUsing);
      } catch (ex) {
        throw new Error("Object data structure cannot be converted to a graph.");
      }
    }
  }

  // list of edges
  if (isArrayLike(data)) {
    try {
      return fromEdgelist(data, optCreateUsing);
    } catch (e) {
      throw new Error("Input is not a valid edge list");
    }
  }

  return result;
}

/**
 * Return a new undirected representation of the graph G.
 *
 * @param {Graph} G Graph to convert
 *
 * @return {!Graph}
 * @export
 */
function convertToUndirected(G) {
  return G.toUndirected();
}

/**
 * Return a new directed representation of the graph G.
 *
 * @param {Graph} G Graph to convert
 * @return {!Graph}
 * @export
 */
function convertToDirected(G) {
  return G.toDirected();
}

/**
 * Return adjacency representation of graph as a dictionary of lists.
 *
 * Completely ignores edge data for MultiGraph and MultiDiGraph.
 *
 * @param {Graph} G A jsnx graph
 * @param {NodeContainer=} opt_nodelist Use only nodes specified in nodelist
 *
 * @return {!Object.<Array>}
 * @export
 */
function toDictOfLists(G, optNodelist) {
  var contains = function contains(n) {
    return optNodelist.indexOf(n) > -1;
  };
  var d = Object.create(null);

  if (optNodelist == null) {
    optNodelist = G;
    contains = function (n) {
      return optNodelist.hasNode(n);
    };
  } else {
    optNodelist = _core.Array.from(optNodelist);
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(optNodelist), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var n = _step.value;

      d[n] = G.neighbors(n).filter(contains);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return d;
}

/**
 * Return a graph from a dictionary of lists.
 * *
 * @param {!Object.<Array>} d A dictionary of lists adjacency representation.
 * @param {Graph=} opt_create_using Use specified graph for result.
 *    Otherwise a new graph is created.
 *
 * @return {!Graph}
 * @export
 */
function fromDictOfLists(d, optCreateUsing) {
  var G = prepCreateUsing(optCreateUsing);

  // Convert numeric property names to numbers
  G.addNodesFrom(_regeneratorRuntime.mark(function callee$1$0() {
    var n;
    return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.t0 = _regeneratorRuntime.keys(d);

        case 1:
          if ((context$2$0.t1 = context$2$0.t0()).done) {
            context$2$0.next = 7;
            break;
          }

          n = context$2$0.t1.value;
          context$2$0.next = 5;
          return isNaN(n) ? n : +n;

        case 5:
          context$2$0.next = 1;
          break;

        case 7:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, this);
  })());

  var node;
  var nbrlist;
  if (G.isMultigraph() && !G.isDirected()) {
    // a dict_of_lists can't show multiedges.  BUT for undirected graphs,
    // each edge shows up twice in the dict_of_lists.
    // So we need to treat this case separately.
    var seen = new Set();

    for (node in d) {
      nbrlist = d[node];
      // treat numeric keys like numbers
      node = isNaN(node) ? node : +node;
      /*jshint loopfunc:true*/
      forEach(nbrlist, function (nbr) {
        if (!seen.has(nbr)) {
          G.addEdge(node, nbr);
        }
      });
      seen.add(node); // don't allow reverse edge to show up
    }
  } else {
    var edgeList = [];
    for (node in d) {
      nbrlist = d[node];
      // treat numeric keys like numbers
      node = isNaN(node) ? node : +node;
      forEach(nbrlist, function (nbr) {
        edgeList.push([node, nbr]);
      });
    }

    G.addEdgesFrom(edgeList);
  }

  return G;
}

/**
 * Return adjacency representation of graph as a dictionary of dictionaries.
 *
 * @param {Graph} G A jsnx Graph
 * @param {NodeContainer=} opt_nodelist Use only nodes specified in nodelist
 * @param {Object=} opt_edge_data If provided,  the value of the dictionary will
 *      be set to edge_data for all edges.  This is useful to make
 *      an adjacency matrix type representation with 1 as the edge data.
 *      If edgedata is null or undefined, the edgedata in G is used to fill
 *      the values.
 *      If G is a multigraph, the edgedata is a dict for each pair (u,v).
 *
 * @return {!Object.<Object>}
 * @export
 */
function toDictOfDicts(G, optNodelist, optEdgeData) {
  var dod = {};

  if (optNodelist != null) {
    optNodelist = _core.Array.from(optNodelist);
    if (optEdgeData != null) {
      optNodelist.forEach(function (u) {
        dod[u] = {};
        G.get(u).forEach(function (data, v) {
          if (optNodelist.indexOf(v) > -1) {
            dod[u][v] = optEdgeData;
          }
        });
      });
    } else {
      // nodelist and edge_data are defined
      optNodelist.forEach(function (u) {
        dod[u] = {};
        G.get(u).forEach(function (data, v) {
          if (optNodelist.indexOf(v) > -1) {
            dod[u][v] = data;
          }
        });
      });
    }
  } else {
    // nodelist is undefined
    if (optEdgeData != null) {
      // dn = [nbrdict, u]
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _core.$for.getIterator(G.adjacencyIter()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var dn = _step.value;

          /*jshint loopfunc:true*/
          dod[dn[1]] = _mapValues(dn[0], function () {
            return optEdgeData;
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else {
      // edge_data is defined
      // dn = [nbrdict, u]
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _core.$for.getIterator(G.adjacencyIter()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var dn = _step2.value;

          dod[dn[1]] = clone(dn[0]);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }

  return dod;
}

/**
 * Return a graph from a dictionary of dictionaries.
 *
 * @param {!Object.<!Object>} d A dictionary of dictionaries adjacency
 *      representation.
 * @param {Graph=} opt_create_using Use specified graph for result.
 *      Otherwise a new graph is created.
 * @param {boolean=} opt_multigraph_input (default=False)
 *      When True, the values of the inner dict are assumed
 *      to be containers of edge data for multiple edges.
 *      Otherwise this routine assumes the edge data are singletons.
 *
 * @return {Graph}
 * @export
 */
function fromDictOfDicts(d, optCreateUsing, optMultigraphInput) {
  var G = prepCreateUsing(optCreateUsing);
  var seen = new Set();

  // Convert numeric property names to numbers
  G.addNodesFrom(_regeneratorRuntime.mark(function callee$1$0() {
    var n;
    return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.t2 = _regeneratorRuntime.keys(d);

        case 1:
          if ((context$2$0.t3 = context$2$0.t2()).done) {
            context$2$0.next = 7;
            break;
          }

          n = context$2$0.t3.value;
          context$2$0.next = 5;
          return isNaN(n) ? n : +n;

        case 5:
          context$2$0.next = 1;
          break;

        case 7:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, this);
  })());

  // is dict a MultiGraph or MultiDiGraph?
  if (optMultigraphInput) {
    // make a copy  of the list of edge data (but not the edge data)
    if (G.isDirected()) {
      for (var u in d) {
        var nbrs = d[u];
        if (isArrayLike(nbrs)) {
          // throw exception of not dict (object)
          throw new TypeError("Inner object seems to be an array");
        }
        // treat numeric keys like numbers
        u = isNaN(u) ? u : +u;
        for (var v in nbrs) {
          var datadict = nbrs[v];
          // treat numeric keys like numbers
          v = isNaN(v) ? v : +v;
          for (var key in datadict) {
            if (G.isMultigraph()) {
              G.addEdge(u, v, key, datadict[key]);
            } else {
              G.addEdge(u, v, datadict[key]);
            }
          }
        }
      }
    } else {
      // undirected
      // don't add both directions of undirected graph
      for (var u in d) {
        var nbrs = d[u];
        if (isArrayLike(nbrs)) {
          // throw exception of not dict (object)
          throw new TypeError("Inner object seems to be an array");
        }
        // treat numeric keys like numbers
        u = isNaN(u) ? u : +u;
        for (var v in nbrs) {
          var datadict = nbrs[v];
          // treat numeric keys like numbers
          v = isNaN(v) ? v : +v;
          if (!seen.has([u, v])) {
            for (var key in datadict) {
              if (G.isMultigraph()) {
                G.addEdge(u, v, key, datadict[key]);
              } else {
                G.addEdge(u, v, datadict[key]);
              }
            }
            seen.add([v, u]);
          }
        }
      }
    }
  } else {
    // not a multigraph to multigraph transfer
    if (G.isMultigraph() && !G.isDirected()) {
      // d can have both representations u-v, v-u in dict.  Only add one.
      // We don't need this check for digraphs since we add both directions,
      // or for Graph() since it is done implicitly (parallel edges not allowed)
      for (var u in d) {
        var nbrs = d[u];
        if (isArrayLike(nbrs)) {
          // throw exception of not dict (object)
          throw new TypeError("Inner object seems to be an array");
        }
        // treat numeric keys like numbers
        u = isNaN(u) ? u : +u;
        for (var v in nbrs) {
          var data = nbrs[v];
          v = isNaN(v) ? v : +v;
          if (!seen.has([u, v])) {
            G.addEdge(u, v, data);
            seen.add([v, u]);
          }
        }
      }
    } else {
      for (var u in d) {
        var nbrs = d[u];
        if (isArrayLike(nbrs)) {
          // throw exception of not dict (object)
          throw new TypeError("Inner object seems to be an array");
        }
        // treat numeric keys like numbers
        u = isNaN(u) ? u : +u;
        for (var v in nbrs) {
          var data = nbrs[v];
          // treat numeric keys like numbers
          v = isNaN(v) ? v : +v;
          G.addEdge(u, v, data);
        }
      }
    }
  }

  return G;
}

/**
 * Return a list of edges in the graph.
 *
 * @param {Graph} G A jsnx graph
 * @param {NodeContainer=} opt_nodelist Use only nodes specified in nodelist
 *
 * @return {!Array}
 * @export
 */
function toEdgelist(G, optNodelist) {
  if (optNodelist != null) {
    return G.edges(optNodelist, true);
  } else {
    return G.edges(null, true);
  }
}

/**
 * Return a graph from a list of edges.
 *
 * @param {Array.<Array>} edgelist Edge tuples
 * @param {Graph=} opt_create_using Use specified graph for result.
 *      Otherwise a new graph is created.
 *
 * @return {!Graph}
 * @export
 */
function fromEdgelist(edgelist, optCreateUsing) {
  var G = prepCreateUsing(optCreateUsing);
  G.addEdgesFrom(edgelist);
  return G;
}

// NOT IMPLEMENTED

// to_numpy_matrix
// from_numpy_matrix
// to_numpy_recarray
// to_scipy_sparse_matrix
// from_scipy_sparse_matrix
// setup_module

module.exports = {
  toNetworkxGraph: toNetworkxGraph,
  convertToUndirected: convertToUndirected,
  convertToDirected: convertToDirected,
  toDictOfLists: toDictOfLists,
  fromDictOfLists: fromDictOfLists,
  toDictOfDicts: toDictOfDicts,
  fromDictOfDicts: fromDictOfDicts,
  toEdgelist: toEdgelist,
  fromEdgelist: fromEdgelist
};
/*jshint latedef:false*/

},{"./_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","./_internals/Map":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Map.js","./_internals/Set":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Set.js","./contrib/convert":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/contrib/convert.js","./contrib/prepCreateUsing":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/contrib/prepCreateUsing.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js","lodash/object/mapValues":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/mapValues.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/drawing/index.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _svg = require("./svg");

var svg = _babelHelpers.interopRequire(_svg);

exports.svg = svg;

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_svg));

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"./svg":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/drawing/svg.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/drawing/svg.js":[function(require,module,exports){
(function (global){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

/**
 * Draw graph G with D3.
 *
 *
 * @param {jsnx.classes.Graph} G The graph to draw
 * @param {?Object=} config A dictionary of configuration parameters
 *      for D3. The following options are available:
 *
 *      - element: DOMElement or selector string. REQUIRED
 *                 The element to draw the graph into.
 *      - d3: A reference to D3. Can be used if d3 is not global.
 *      - width: number The width of the drawing area in pixel.
 *               Default is the width of element.
 *      - height: number The height of the drawing are in pixel.
 *                Default is the height of element.
 *      - layout_attr: Object A dictionary of layout attributes.
 *              The default layout is force, so the the attributes
 *              can be size, linkDistance, linkStrength, friction,
 *              charge, theta and gravity. nodes and links are set
 *              through the graph
 *      - nodelist: Array An array of nodes to be drawn. Nodes not in the
 *          Graph are ignored
 *      - node_shape: string Name of a SVG element. Default is circle
 *      - node_attr: Object A dictionary of attributes to set on each
 *          node SVG element. See D3 documentation for more information.
 *      - node_style: Object A dictionary of CSS styles to set on each
 *          node SVG element. See D3 documentation for more information.
 *      - edge_attr: Object
 *      - edge_style: Object
 *      - with_labels: boolean (default=false) Set to true to draw labels
 *          on the nodes. Each label is a SVG text node.
 *      - labels: function or Dictionary ore string to return or retrieve the
 *          label for each node.
 *      - label_attr: Object
 *      - label_style: Object
 *      - with_edge_labels: boolean
 *      - edge_labels: function or Dictionary or string
 *      - edge_label_attr: Object
 *      - edge_label_style: Object
 *      - weighted: boolean
 *      - weights: string or function
 *      - edge_offset: number or function
 *      - pan_zoom: object with properties `enabled` (bool) and `scale` (bool)
 *
 *  @param {?boolean=} optBind Set to true to automatically update
 *      the output upon graph manipulation. Only works for adding nodes or edges
 *      for now.
 * @suppress {checkTypes}
 */
exports.draw = draw;

/**
 * @fileoverview
 *
 * D3(http://mbostock.github.com/d3/) is a powerful library to associate data
 * with elements and provides various helpful methods to visualize the data,
 * such as color generators, layouts and DOM manipulation methods.
 *
 * Note: D3 must be included before running these functions
 */

var _internals = require("../_internals");

var Map = _internals.Map;
var Set = _internals.Set;
var deepmerge = _internals.deepmerge;
var getDefault = _internals.getDefault;
var isArrayLike = _internals.isArrayLike;

var nullFunction = function nullFunction() {};

function angleFor(x1, y1, x2, y2) {
  return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
}

/**
 * Safely converts an iterator to an array. Because we often use tuples when
 * using generators internally, we have to be careful when converting the
 * generator to an array. Every element has to be converted explicitly.
 */
function toArray(iterator) {
  // shortcut. If the value is actually an array, we can just return it
  if (Array.isArray(iterator)) {
    return iterator;
  }
  var result = [];
  var i = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(iterator), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      result[i++] = Array.isArray(value) ? _core.Array.from(value) : value;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
}

/**
 * Holds a reference to the last container element for convenience.
 *
 * @type {?(string|Element)}
 * @private
 */
var LAST_ELEMENT = null;

/**
 * Holds a reference to the last configuration for convenience.
 *
 * @type {Object}
 * @private
 */
var LAST_CONFIGURATION = null;

/**
 * A list of graph mutator methods.
 *
 * @type {Array.<string>}
 * @const
 * @private
 */
var MUTATOR_METHODS = ["addNode", "addNodesFrom", "addEdge", "addEdgesFrom", "removeNode", "removeNodesFrom", "removeEdge", "removeEdgesFrom", "clear"];

/**
 * The name of the attribute the D3 data is assigned to in the node and
 * edge data.
 *
 * @type {string}
 */
var D3_DATA_NAME = "__d3datum__";

/**
 * Keep a reference to d3.
 */
var d3 = global.d3;
function draw(G, config, optBind) {
  if (typeof config === "boolean") {
    optBind = config;
    config = null;
  }

  config = config || LAST_CONFIGURATION || {};
  LAST_CONFIGURATION = config;
  if (config.d3) {
    d3 = config.d3;
  }
  config = deepmerge({}, DEFAULT_CONFIG, config);

  if (!d3) {
    throw new Error("D3 requried for draw()");
  }

  if (config.element == null && LAST_ELEMENT == null) {
    throw new Error("Output element required for draw()");
  }

  // initialize
  LAST_ELEMENT = config.element || LAST_ELEMENT;

  // remove any possible previous graph
  d3.select(LAST_ELEMENT).select("svg.jsnx").remove();

  // set up base elements
  var container = d3.select(LAST_ELEMENT);
  var d3nodes = [];
  var d3links = [];
  var canvas = container.append("svg").classed("jsnx", true).attr("pointer-events", "all");
  var parent_container = canvas.append("g");
  var edge_selection = parent_container.append("g").classed("edges", true).selectAll("g.edge");
  var node_selection = parent_container.append("g").classed("nodes", true).selectAll("g.node");
  var force = d3.layout.force();
  var width = config.width || parseInt(container.style("width"), 10);
  var height = config.height || parseInt(container.style("height"), 10);
  var layout_attr = config.layoutAttr;
  var nodelist = config.nodelist || null;
  var label_func;
  var edge_label_func;
  var weight_func;
  var directed = G.isDirected();
  var weighted = config.weighted;
  var selections = {
    node_selection: node_selection,
    edge_selection: edge_selection
  };

  // determine node label function
  if (config.withLabels) {
    var labels = config.labels;
    switch (typeof labels) {
      case "object":
        label_func = function (d) {
          return getDefault(labels[d.node], "");
        };
        break;
      case "function":
        label_func = labels;
        break;
      case "string":
        label_func = function (d) {
          return d.data[labels];
        };
        break;
      default:
        label_func = function (d) {
          return d.node;
        };
    }
  }
  config.labels = label_func;

  // if the graph should be weighted, we need a weight function
  // these will be used as edge labels if no others are provided
  if (weighted) {
    var weights = config.weights;
    switch (typeof weigths) {
      case "object":
        weight_func = function (d) {
          return getDefault(weights[d.node], 1);
        };
        break;
      case "function":
        weight_func = weights;
        break;
      case "string":
        weight_func = function (d) {
          return getDefault(d.data[weights], 1);
        };
        break;
      default:
        weight_func = function (d) {
          return 1;
        };
    }
  }

  // determine edge labels
  if (config.withEdgeLabels) {
    var elabels = config.edgeLabels;

    if (weighted && elabels == null) {
      edge_label_func = weight_func;
    } else {
      switch (typeof elabels) {
        case "object":
          edge_label_func = function (d) {
            return getDefault(labels[d.node], "");
          };
          break;
        case "function":
          edge_label_func = elabels;
          break;
        case "string":
          edge_label_func = function (d) {
            return d.data[elabels];
          };
          break;
        default:
          edge_label_func = function (d) {
            return d.edge;
          };
      }
    }
    config.edgeLabels = edge_label_func;
  }

  // scale the width of the edge according to the weight
  if (weighted && config.weightedStroke) {
    var max_weight = 1;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(G.edgesIter(null, true)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _step.value;
        var u = _step$value.u;
        var v = _step$value.v;
        var data = _step$value.data;

        var weight = weight_func({ data: data });
        if (weight > max_weight) {
          max_weight = weight;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var scale = d3.scale.linear().range([2, config.edgeStyle["stroke-width"]]).domain([0, max_weight]);

    config.edgeStyle["stroke-width"] = function (d) {
      return scale(weight_func.call(this, d));
    };
  }

  // remove any possible previous graph
  canvas.select("svg.jsnx").remove();

  // set size and hide the wild movement of nodes at the beginning
  canvas.attr("width", width + "px").attr("height", height + "px").style("opacity", 0.000001).transition().duration(1000).style("opacity", 1);

  // initialize layout
  // don't let the user set these:
  var exclude = {
    size: true,
    nodes: true,
    links: true,
    start: true
  };

  for (var attr in layout_attr) {
    if (exclude[attr] !== true) {
      force[attr](layout_attr[attr]);
    }
  }
  force.nodes(d3nodes).links(d3links).size([width, height]);

  // set up zoom and pan behaviour
  var zoom = 1;
  var inv_scale = 1; // used to scale nodes and text accordingly

  if (config.panZoom.enabled) {
    (function () {
      var scaled = config.panZoom.scale;
      var zooming = false;
      var zoom_start_scale = 1;
      var zoom_start = zoom;

      canvas.call(d3.behavior.zoom().on("zoom", function () {
        var shiftKey = d3.event.sourceEvent.shiftKey,
            zoomed = scaled && shiftKey || !(scaled || shiftKey);

        // if the graph is zoomed, we have to keep track of the
        // ration it was zoomed by
        if (zoomed && !zooming) {
          zoom_start_scale = d3.event.scale;
          zoom_start = zoom;
          zooming = true;
        } else if (!zoomed && zooming) {
          zooming = false;
        }

        zoom = zoomed ? zoom_start * (d3.event.scale / zoom_start_scale) : zoom;
        inv_scale = !zoomed ? zoom / d3.event.scale : inv_scale;

        var tr = d3.event.translate;
        parent_container.attr("transform", "translate(" + tr[0] + "," + tr[1] + ")scale(" + d3.event.scale + ")");
        redraw();
      }));
    })();
  }

  var update_edge_position = nullFunction;
  var offset = config.edgeOffset;
  var node_radius = config.nodeAttr.r;
  var node_strw = config.nodeStyle["stroke-width"];

  if (config.nodeShape === "circle") {
    if (typeof node_radius !== "function") {
      node_radius = function () {
        return config.nodeAttr.r;
      };
    }
    if (typeof node_strw !== "function") {
      node_strw = function () {
        return config.nodeStyle["stroke-width"];
      };
    }
    offset = function (d) {
      return [node_radius(d.source) + node_strw(d.source), node_radius(d.target) + node_strw(d.target)];
    };
  } else {
    if (Array.isArray(offset)) {
      offset = function () {
        return config.edgeOffset;
      };
    } else if (typeof offset === "number") {
      offset = function () {
        return [config.edgeOffset, config.edgeOffset];
      };
    }
  }
  var strw = config.edgeStyle["stroke-width"];
  if (typeof strw !== "function") {
    strw = function () {
      return config.edgeStyle["stroke-width"];
    };
  }
  var label_offset = config.edgeLabelOffset;

  if (directed) {
    // don't rotate labels and draw curvy lines
    update_edge_position = function () {
      selections.edge_selection.each(function (d) {
        if (d.source !== d.target) {
          var $this = d3.select(this);
          var x1 = d.source.x;
          var y1 = d.source.y;
          var x2 = d.target.x;
          var y2 = d.target.y;
          var angle = angleFor(x1, y1, x2, y2);
          var dx = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
          var offset_ = offset(d);

          offset_ = [offset_[0] * inv_scale, offset_[1] * inv_scale];

          $this.attr("transform", ["translate(", x1, ",", y1, ")", "rotate(", angle, ")"].join(""));

          var shift = strw(d) * inv_scale;
          var arrow_start_point = dx - offset_[1] - 2 * shift;
          var half_shift = shift / 2;
          $this.select(".line").attr("d", ["M", offset_[0], 0, "L", offset_[0], -half_shift, "L", arrow_start_point, -half_shift, "L", arrow_start_point, -shift, "L", dx - offset_[1], 0, "z"].join(" "));

          var scale = 1 / inv_scale;
          $this.select("text").attr("x", label_offset.x * scale + offset_[0] + (dx * scale - offset_[0] - offset_[1]) / 2).attr("y", -strw(d) / 2 + -label_offset.y * scale).attr("transform", "scale(" + inv_scale + ")");
        }
      });
    };
  } else {
    update_edge_position = function () {
      selections.edge_selection.each(function (d) {
        if (d.source !== d.target) {
          var $this = d3.select(this);
          var x1 = d.source.x;
          var y1 = d.source.y;
          var x2 = d.target.x;
          var y2 = d.target.y;
          var angle = angleFor(x1, y1, x2, y2);
          var dx = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
          var center = dx / 2;
          var offset_ = offset(d);

          offset_ = [offset_[0] * inv_scale, offset_[1] * inv_scale];

          var scale = 1 / inv_scale;
          var shift = strw(d) * inv_scale;
          var flip = angle > 90 && angle < 279;
          $this.attr("transform", ["translate(", x1, ",", y1, ")", "rotate(", angle, ")"].join(""));
          $this.select(".line").attr("d", ["M", offset_[0], shift / 4, "L", offset_[0], -shift / 4, "L", dx - offset_[1], -shift / 4, "L", dx - offset_[1], shift / 4, "z"].join(" "));
          if (config.withEdgeLabels) {
            $this.select("text").attr("x", (flip ? 1 : -1) * label_offset.x * scale + offset_[0] + (dx * scale - offset_[0] - offset_[1]) / 2).attr("y", -strw(d) / 4 + -label_offset.y * scale).attr("transform", "scale(" + inv_scale + ")" + (flip ? "rotate(180," + center * (1 / inv_scale) + ",0)" : ""));
          }
        }
      });
    };
  }

  var redraw = function redraw() {
    // update node position
    selections.node_selection.attr("transform", function (d) {
      return ["translate(", d.x, ",", d.y, ")", "scale(", inv_scale, ")"].join("");
    });

    update_edge_position();
  };

  force.on("tick", redraw);

  var nodes = G.nodesIter();
  var edges = G.edgesIter();

  if (nodelist) {
    // limit drawn nodes, disable binding
    optBind = false;
    nodes = G.nbunch_iter(nodelist);
    edges = G.edges_iter(nodelist);
  }

  // update d3 node and link data
  selections.node_selection = addNodes(G, nodes, force, node_selection, config);

  selections.edge_selection = addEdges(G, edges, force, edge_selection, edge_label_func);

  // apply attributes and styles
  updateNodeAttr(selections.node_selection, config);

  updateEdgeAttr(selections.edge_selection, config, null, directed);

  if (optBind) {
    bind(G, force, config, selections);
  } else {
    if (isBound(G)) {
      unbind(G);
    } else {
      clean(G);
    }
  }

  force.start();

  return force;
}

/**
* Helper function to create new node objects for the force layout and
* create the necessary SVG elements.
*
* @param {Graph} G
* @param {Iterable} nodes The nodes to include from the Graph
*      default are all nodes
* @param {d3.layout.force} force The layout
* @param {d3.selection} selection D3 DOM node selection of nodes
* @param {Object} Drawing configuration
*
* @return {!d3.selection} The new selection of SVG elements.
*/
function addNodes(G, nodes, force, selection, config) {
  // Get current data
  var layoutNodes = force.nodes();
  // add new data
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(nodes), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var node = _step.value;

      var data = G.node.get(node);
      var nobj = { node: node, data: data, G: G };
      layoutNodes.push(nobj);
      data[D3_DATA_NAME] = nobj;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  // update data join
  selection = selection.data(layoutNodes, nodeKeyFunction);
  // create new elements
  var drag = force.drag().on("dragstart", function (d) {
    // Prevent pan if node is dragged
    d3.event.sourceEvent.stopPropagation();
    if (config.stickyDrag) {
      d.fixed = true;
      d3.select(this).classed("fixed", true);
    }
  });
  var nsel = selection.enter().append("g").classed("node", true).call(drag);

  nsel.append(config.nodeShape).classed("node-shape", true);

  if (config.labels) {
    nsel.append("text").text(config.labels);
  }

  return selection;
}

/**
* Helper function to create new edge objects for the force layout.
*
* @param {Graph} G
* @param {Iterable} edges The nodes to include from the Graph
*      default are all nodes
* @param {d3.layout.force} force
* @param {d3.selection} selection D3 DOM node selection of nodes
* @param {Function=} opt_label_func Function to extract text for labels
*
* @return {!d3.selection}
*/
function addEdges(G, edges, force, selection, optLabelFunc) {
  // Get current data
  var layoutLinks = force.links();
  // add new data
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(edges), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _babelHelpers.slicedToArray(_step.value, 3);

      var u = _step$value[0];
      var v = _step$value[1];
      var data = _step$value[2];

      data = data || G.getEdgeData(u, v);
      var eobj = {
        edge: [u, v],
        source: G.node.get(u)[D3_DATA_NAME],
        target: G.node.get(v)[D3_DATA_NAME],
        data: data,
        G: G
      };
      layoutLinks.push(eobj);
      data[D3_DATA_NAME] = eobj;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  // update data join
  selection = selection.data(layoutLinks, edgeKeyFunction);
  // create new elements
  var esel = selection.enter().append("g").classed("edge", true);
  esel.append("path").classed("line", true);

  if (optLabelFunc) {
    esel.append("text").text(optLabelFunc);
  }
  return selection;
}

/**
* Updates attributes of nodes.
*
* @param {d3.selection} selection
* @param {Object} config
* @param {Iterable=} opt_nodes a container of nodes. If set,
*      only update these nodes.
*/
function updateNodeAttr(selection, config, optNodes) {
  if (optNodes != null) {
    var newNodes = new Set();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(optNodes), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var node = _step.value;

        newNodes.add(isArrayLike(node) ? node[0] : node);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    selection = selection.filter(function (d) {
      return newNodes.has(d.node);
    });
  }
  selection.selectAll(".node-shape").attr(config.nodeAttr).style(config.nodeStyle);

  if (config.withLabels) {
    selection.selectAll("text").attr(config.labelAttr).style(config.labelStyle);
  }
}

/**
* Updates attributes of edges.
*
* @param {d3.selection} selection
* @param {Object} config
* @param {?=} optEdges If set, only updates the styles of the provided
*      edges
* @param {boolean=} optDirected
*/
function updateEdgeAttr(selection, config, optEdges, optDirected) {
  if (optEdges != null) {
    var newEdges = new Map();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(optEdges), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _babelHelpers.slicedToArray(_step.value, 2);

        var u = _step$value[0];
        var v = _step$value[1];

        newEdges.set(u, v);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    selection = selection.filter(function (_ref) {
      var edge = _ref.edge;
      return newEdges.get(edge[0]) === edge[1] || optDirected || newEdges.get(edge[1]) === edge[0];
    });
  }

  selection.selectAll(".line").attr(config.edgeAttr).style(config.edgeStyle).style("stroke-width", 0);

  if (config.withEdgeLabels) {
    selection.selectAll("text").attr(config.edgeLabelAttr).style(config.edgeLabelStyle);
  }
}

/**
* Key function to extract the join value for the SVG nodes and the data.
*
* @param {Object} d The current datum
* @return {Node}
*/
function nodeKeyFunction(d) {
  return d.node;
}

/**
* Key function to extract the join value for the SVG nodes and the data.
*
* @param {Object} d The current datum
* @return {Array}
*/
function edgeKeyFunction(d) {
  return d.edge;
}

/**
* Helper function to remove node objects for the force layout.
*
* @param {Graph} G
* @param {Iterable} nodes to remove from the graph
* @param {d3.layout.force} force The force the nodes are bound to
* @param {d3.selection} selection Selection of node elements
*
* @return {d3.selection} Updated selection
*/
function removeNodes(G, nodes, force, selection) {
  // get current data set
  var data = force.nodes();

  // remove items from data
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(G.nbunchIter(nodes)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var node = _step.value;

      var index = data.indexOf(G.node.get(node)[D3_DATA_NAME]);
      if (index > -1) {
        data.splice(index, 1);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  // rebind data
  selection = selection.data(data, nodeKeyFunction);
  // remove SVG elements
  selection.exit().remove();
  return selection;
}

/**
* Helper function to remove edge objects for the force layout.
*
* @param {jsnx.classes.Graph} G
* @param {?} edges Edges to remove
* @param {d3.layout.force} force The force the edges are bound to
* @param {d3.selection} selection Selection of edge elements
*
* @return {!d3.selection} Updated selection
*/
function removeEdges(G, edges, force, selection) {
  // get current data set
  var data = force.links();
  // remove items from data
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(edges), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _babelHelpers.slicedToArray(_step.value, 2);

      var u = _step$value[0];
      var v = _step$value[1];

      var index = data.indexOf(G.getEdgeData(u, v, {})[D3_DATA_NAME]);
      if (index > -1) {
        data.splice(index, 1);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  // rebind data
  selection = selection.data(data, edgeKeyFunction);
  // remove SVG elements
  selection.exit().remove();
  return selection;
}

/**
* Binds the output to the graph. This overrides mutator methods. To "free"
* the graph, you can call jsnx.unbind (which is public)
*
* @param {Graph} G A Graph
* @param {d3.layout.force} force Force layout
* @param {Object} config The configuration for the output
* @param {{node_selection:d3.selection, edge_selection:d3.selection }} selections
*   Various D3 selections
*/
function bind(G, force, config, selections) {
  unbind(G, false);

  var proto = G.constructor.prototype;
  var edge_label_func = config.edgeLabels;
  var directed = G.isDirected();

  G.addNode = function (n, optAttr) {
    var new_node = !this.hasNode(n);
    proto.addNode.call(this, n, optAttr);

    if (new_node) {
      selections.node_selection = addNodes(this, [n], force, selections.node_selection, config);
    }

    // update node attributes
    updateNodeAttr(selections.node_selection, config, [n]);

    force.start();
  };

  G.addNodesFrom = function (nbunch, optAttr) {
    var _this = this;

    nbunch = toArray(nbunch);
    var new_nodes = nbunch.filter(function (node) {
      return !_this.hasNode(isArrayLike(node) ? node[0] : node);
    });

    proto.addNodesFrom.call(this, nbunch, optAttr);

    if (new_nodes.length > 0) {
      // add new nodes and update
      selections.node_selection = addNodes(this, new_nodes, force, selections.node_selection, config);
    }

    updateNodeAttr(selections.node_selection, config, nbunch);
    force.start();
  };

  G.addEdge = function (u, v, optAttr) {
    var _this = this;

    var new_edge = !this.hasEdge(u, v);
    var edges = [[u, v]];
    var new_nodes = new_edge ? (u === v ? [u] : edges[0]).filter(function (node) {
      return !_this.hasNode(node);
    }) : [];
    proto.addEdge.call(G, u, v, optAttr);

    if (new_nodes.length > 0) {
      selections.node_selection = addNodes(this, new_nodes, force, selections.node_selection, config);

      updateNodeAttr(selections.node_selection, config, new_nodes);
    }

    if (new_edge) {
      selections.edge_selection = addEdges(this, edges, force, selections.edge_selection, edge_label_func);
    }

    updateEdgeAttr(selections.edge_selection, config, edges, directed);
    force.start();
  };

  G.addEdgesFrom = function (ebunch, optAttr) {
    var new_edges = [];
    var new_nodes = [];
    var seen_edges = new Map();
    var seen_nodes = new Set();
    var directed = this.isDirected();

    ebunch = toArray(ebunch);

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.$for.getIterator(ebunch), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _babelHelpers.slicedToArray(_step.value, 2);

        var u = _step$value[0];
        var v = _step$value[1];

        if (!this.hasEdge(u, v) && seen_edges.get(u) !== v && (directed || seen_edges.get(v) === u)) {
          new_edges.push([u, v]);
          seen_edges.set(u, v);
          if (!this.hasNode(u) && !seen_nodes.has(u)) {
            new_nodes.push(u);
            seen_nodes.add(u);
          }
          if (!this.hasNode(v) && !seen_nodes.has(v)) {
            new_nodes.push(v);
            seen_nodes.add(v);
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    proto.addEdgesFrom.call(G, ebunch, optAttr);

    if (new_nodes.length > 0) {
      selections.node_selection = addNodes(this, new_nodes, force, selections.node_selection, config);

      updateNodeAttr(selections.node_selection, config, new_nodes);
    }

    if (new_edges.length > 0) {
      selections.edge_selection = addEdges(this, new_edges, force, selections.edge_selection, edge_label_func);
    }

    updateEdgeAttr(selections.edge_selection, config, new_edges, directed);
    force.start();
  };

  G.removeNode = function (n) {
    if (this.hasNode(n)) {
      selections.node_selection = removeNodes(this, [n], force, selections.node_selection);
      var edges = this.edgesIter([n]);

      if (this.isDirected()) {
        edges = _regeneratorRuntime.mark(function callee$2$0(G, edges) {
          return _regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
            while (1) switch (context$3$0.prev = context$3$0.next) {
              case 0:
                return context$3$0.delegateYield(edges, "t84", 1);

              case 1:
                return context$3$0.delegateYield(G.inEdgesIter([n]), "t85", 2);

              case 2:
              case "end":
                return context$3$0.stop();
            }
          }, callee$2$0, this);
        })(this, edges);
      }

      selections.edge_selection = removeEdges(this, edges, force, selections.edge_selection);

      force.resume();
    }
    proto.removeNode.call(this, n);
  };

  G.removeNodesFrom = function (nbunch) {
    nbunch = toArray(nbunch);
    selections.node_selection = removeNodes(this, nbunch, force, selections.node_selection);

    var edges = this.edgesIter(nbunch);
    if (this.isDirected()) {
      edges = _regeneratorRuntime.mark(function callee$2$0(G, edges) {
        return _regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
          while (1) switch (context$3$0.prev = context$3$0.next) {
            case 0:
              return context$3$0.delegateYield(edges, "t86", 1);

            case 1:
              return context$3$0.delegateYield(G.inEdgesIter(nbunch), "t87", 2);

            case 2:
            case "end":
              return context$3$0.stop();
          }
        }, callee$2$0, this);
      })(this, edges);
    }

    selections.edge_selection = removeEdges(this, edges, force, selections.edge_selection);

    force.resume();
    proto.removeNodesFrom.call(this, nbunch);
  };

  G.removeEdge = function (u, v) {
    selections.edge_selection = removeEdges(this, [[u, v]], force, selections.edge_selection);

    force.resume();
    proto.removeEdge.call(this, u, v);
  };

  G.removeEdgesFrom = function (ebunch) {
    ebunch = toArray(ebunch);
    selections.edge_selection = removeEdges(this, ebunch, force, selections.edge_selection);

    force.resume();
    proto.removeEdgesFrom.call(G, ebunch);
  };

  G.clear = function () {
    selections.node_selection = selections.node_selection.data([], nodeKeyFunction);
    selections.node_selection.exit().remove();
    selections.edge_selection = selections.edge_selection.data([], edgeKeyFunction);
    selections.edge_selection.exit().remove();
    force.nodes([]).links([]).resume();
    proto.clear.call(this);
  };

  /**
   * @type boolean
   */
  G.bound = true;
}

/**
* Returns True if the graph is bound to an output.
*
* @param {Graph} G A Graph
* @return {boolean}
*/
function isBound(G) {
  return G.bound;
}

/**
* Resets mutator methods to the originals
*
* @param {} G graph
* @param {boolean=} opt_clean (default=True)
*    If true, all D3 data is removed from the graph
*/
function unbind(G) {
  var optClean = arguments[1] === undefined ? true : arguments[1];

  if (isBound(G)) {
    var proto = G.constructor.prototype;
    MUTATOR_METHODS.forEach(function (m) {
      return G[m] = proto[m];
    });
    delete G.bound;
    if (optClean) {
      clean(G);
    }
  }
}

/**
* Removes any D3 data from the Graph.
*
* @param {Graph} G A Graph
*/
function clean(G) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(G.nodesIter(true)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _babelHelpers.slicedToArray(_step.value, 2);

      var _ = _step$value[0];
      var data = _step$value[1];

      delete data[D3_DATA_NAME];
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = _core.$for.getIterator(G.edgesIter(null, true)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _step2$value = _babelHelpers.slicedToArray(_step2.value, 3);

      var u = _step2$value[0];
      var v = _step2$value[1];
      var data = _step2$value[2];

      delete data[D3_DATA_NAME];
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

/**
* Default D3 configuration.
*
* @type Object
* @private
*/
var DEFAULT_CONFIG = {
  layoutAttr: {
    charge: -120,
    linkDistance: 60
  },
  nodeShape: "circle",
  nodeAttr: {
    r: 10 // radius of 10
  },
  nodeStyle: {
    "stroke-width": 2,
    stroke: "#333",
    fill: "#999",
    cursor: "pointer"
  },
  edgeAttr: {},
  edgeStyle: {
    fill: "#000",
    "stroke-width": 3
  },
  labelAttr: {},
  labelStyle: {
    "text-anchor": "middle",
    "dominant-baseline": "central",
    cursor: "pointer",
    "-webkit-user-select": "none",
    fill: "#000"
  },
  edgeLabelAttr: {},
  edgeLabelStyle: {
    "font-size": "0.8em",
    "text-anchor": "middle",
    "-webkit-user-select": "none"
  },
  edgeLabelOffset: {
    x: 0,
    y: 0.5
  },
  withLabels: false,
  withEdgeLabels: false,
  edgeOffset: 10,
  weighted: false,
  weights: "weight",
  weighted_stroke: true,
  panZoom: {
    enabled: true,
    scale: true
  }
};
Object.defineProperty(exports, "__esModule", {
  value: true
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXAlgorithmError.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var JSNetworkXException = _babelHelpers.interopRequire(require("./JSNetworkXException"));

/**
 * Exception for unexpected termination of algorithms.
 * @constructor
 * @extends {JSNetworkXException}
 */

var JSNetworkXAlgorithmError = (function (JSNetworkXException) {
  function JSNetworkXAlgorithmError(message) {
    _babelHelpers.classCallCheck(this, JSNetworkXAlgorithmError);

    _babelHelpers.get(_core.Object.getPrototypeOf(JSNetworkXAlgorithmError.prototype), "constructor", this).call(this, message);
    this.name = "JSNetworkXAlgorithmError";
  }

  _babelHelpers.inherits(JSNetworkXAlgorithmError, JSNetworkXException);

  return JSNetworkXAlgorithmError;
})(JSNetworkXException);

module.exports = JSNetworkXAlgorithmError;

},{"./JSNetworkXException":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXException.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXError.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var JSNetworkXException = _babelHelpers.interopRequire(require("./JSNetworkXException"));

var JSNetworkXError = (function (JSNetworkXException) {
  function JSNetworkXError(message) {
    _babelHelpers.classCallCheck(this, JSNetworkXError);

    _babelHelpers.get(_core.Object.getPrototypeOf(JSNetworkXError.prototype), "constructor", this).call(this, message);
    this.name = "JSNetworkXError";
  }

  _babelHelpers.inherits(JSNetworkXError, JSNetworkXException);

  return JSNetworkXError;
})(JSNetworkXException);

module.exports = JSNetworkXError;

},{"./JSNetworkXException":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXException.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXException.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var JSNetworkXException = (function (Error) {
  function JSNetworkXException(message) {
    _babelHelpers.classCallCheck(this, JSNetworkXException);

    this.name = "JSNetworkXException";
    this.message = message;
  }

  _babelHelpers.inherits(JSNetworkXException, Error);

  return JSNetworkXException;
})(Error);

module.exports = JSNetworkXException;

},{"babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXNoPath.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var JSNetworkXUnfeasible = _babelHelpers.interopRequire(require("./JSNetworkXUnfeasible"));

/**
 * Exception for algorithms that should return a path when running
 * on graphs where such a path does not exist.
 */

var JSNetworkXNoPath = (function (JSNetworkXUnfeasible) {
  function JSNetworkXNoPath(message) {
    _babelHelpers.classCallCheck(this, JSNetworkXNoPath);

    _babelHelpers.get(_core.Object.getPrototypeOf(JSNetworkXNoPath.prototype), "constructor", this).call(this, message);
    this.name = "JSNetworkXNoPath";
  }

  _babelHelpers.inherits(JSNetworkXNoPath, JSNetworkXUnfeasible);

  return JSNetworkXNoPath;
})(JSNetworkXUnfeasible);

module.exports = JSNetworkXNoPath;

},{"./JSNetworkXUnfeasible":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXUnfeasible.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXUnfeasible.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

var JSNetworkXAlgorithmError = _babelHelpers.interopRequire(require("./JSNetworkXAlgorithmError"));

/**
 * Exception raised by algorithms trying to solve a problem
 * instance that has no feasible solution.
 * @constructor
 * @extends {JSNetworkXAlgorithmError}
 */

var JSNetworkXUnfeasible = (function (JSNetworkXAlgorithmError) {
  function JSNetworkXUnfeasible(message) {
    _babelHelpers.classCallCheck(this, JSNetworkXUnfeasible);

    _babelHelpers.get(_core.Object.getPrototypeOf(JSNetworkXUnfeasible.prototype), "constructor", this).call(this, message);
    this.name = "JSNetworkXUnfeasible";
  }

  _babelHelpers.inherits(JSNetworkXUnfeasible, JSNetworkXAlgorithmError);

  return JSNetworkXUnfeasible;
})(JSNetworkXAlgorithmError);

module.exports = JSNetworkXUnfeasible;

},{"./JSNetworkXAlgorithmError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXAlgorithmError.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/KeyError.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var KeyError = (function (Error) {
  function KeyError(message) {
    _babelHelpers.classCallCheck(this, KeyError);

    this.name = "KeyError";
    this.message = message;
  }

  _babelHelpers.inherits(KeyError, Error);

  return KeyError;
})(Error);

module.exports = KeyError;

},{"babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/index.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var KeyError = _babelHelpers.interopRequire(require("./KeyError"));

var JSNetworkXAlgorithmError = _babelHelpers.interopRequire(require("./JSNetworkXAlgorithmError"));

var JSNetworkXError = _babelHelpers.interopRequire(require("./JSNetworkXError"));

var JSNetworkXException = _babelHelpers.interopRequire(require("./JSNetworkXException"));

var JSNetworkXNoPath = _babelHelpers.interopRequire(require("./JSNetworkXNoPath"));

var JSNetworkXUnfeasible = _babelHelpers.interopRequire(require("./JSNetworkXUnfeasible"));

exports.KeyError = KeyError;
exports.JSNetworkXAlgorithmError = JSNetworkXAlgorithmError;
exports.JSNetworkXError = JSNetworkXError;
exports.JSNetworkXException = JSNetworkXException;
exports.JSNetworkXNoPath = JSNetworkXNoPath;
exports.JSNetworkXUnfeasible = JSNetworkXUnfeasible;
Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"./JSNetworkXAlgorithmError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXAlgorithmError.js","./JSNetworkXError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXError.js","./JSNetworkXException":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXException.js","./JSNetworkXNoPath":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXNoPath.js","./JSNetworkXUnfeasible":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXUnfeasible.js","./KeyError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/KeyError.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/classic.js":[function(require,module,exports){
"use strict";

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _babelHelpers = require("babel-runtime/helpers")["default"];

var treeEdges = _regeneratorRuntime.mark(

/**
 * @param {number} n nodes
 * @param {number} r breadth
 * @return {Iterator}
 */
function treeEdges(n, r) {
  var nodes, parents, source, i, target;
  return _regeneratorRuntime.wrap(function treeEdges$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        nodes = genRange(n);

        if (!(n === 0)) {
          context$1$0.next = 3;
          break;
        }

        return context$1$0.abrupt("return");

      case 3:
        parents = [next(nodes)];

      case 4:
        if (!(parents.length > 0)) {
          context$1$0.next = 20;
          break;
        }

        source = parents.shift();
        i = 0;

      case 7:
        if (!(i < r)) {
          context$1$0.next = 18;
          break;
        }

        target = nodes.next();

        if (!target.done) {
          context$1$0.next = 11;
          break;
        }

        return context$1$0.abrupt("return");

      case 11:
        target = target.value;
        parents.push(target);
        context$1$0.next = 15;
        return tuple2(source, target);

      case 15:
        i++;
        context$1$0.next = 7;
        break;

      case 18:
        context$1$0.next = 4;
        break;

      case 20:
      case "end":
        return context$1$0.stop();
    }
  }, treeEdges, this);
});

/**
 * Creates a full r-ary tree of n vertices.
 * Sometimes called a k-ary, n-ary, or m-ary tree.  "... all non-leaf
 * vertices have exactly r children and all levels are full except
 * for some rightmost position of the bottom level (if a leaf at the
 * bottom level is missing, then so are all of the leaves to its
 * right."
 *
 * @param {number} r branching factor of the tree
 * @param {number} n number of nodes in the tree
 * @param {Graph=} optCreateUsing
 *   Use specified type to construct graph
 * @return {Graph} An r-ary tree with n nodes.
 */
exports.fullRaryTree = fullRaryTree;

/**
 * Return the perfectly balanced r-tree of height h.
 *
 * This is the rooted tree where all leaves are at distance h from
 * the root. The root has degree r and all other internal nodes have
 * degree r+1.
 *
 * Node labels are the integers 0 (the root) up to  numberOfNodes - 1.
 *
 * Also refered to as a complete r-ary tree.
 *
 * @param {number} r  Branching factor of the tree
 * @param {number} h Height of the tree
 * @param {Graph} optCreateUsing
 *    Use specified type to construct graph
 * @return {Graph}
 */
exports.balancedTree = balancedTree;

//TODO: barbell_graph

/**
 * Return the complete graph `$K_n$ with n nodes.
 *
 * Node labels are the integers 0 to n-1.
 * @param {number} n The number of nodes to add to the graph
 * @param {Graph=} optCreateUsing Graph instance to empty and add nodes to.
 * @return {Graph}
 */
exports.completeGraph = completeGraph;

//TODO: complete_bipartite_graph
//TODO: circular_ladder_graph

/**
 * Return the cycle graph C_n over n nodes.
 *
 * C_n is the n-path with two end-nodes connected.
 *
 * Node labels are the integers 0 to n-1
 * If create_using is a DiGraph, the direction is in increasing order.
 *
 * @param {number} n The number of nodes to add to the graph
 * @param {Graph=} optCreateUsing Graph instance to empty and add nodes to.
 * @return {Graph}
 */
exports.cycleGraph = cycleGraph;

//TODO: dorogovtsev_goltsev_mendes_graph

/**
 * Return the empty graph with n nodes and zero edges.
 *
 * Node labels are the integers 0 to n-1
 *
 * ### Example
 *
 * ```
 * var G = jsnx.emptyGraph(10)
 * G.numberOfNodes()
 * // 10
 * G.numberOfEdges()
 * // 0
 * ```
 *
 * The variable create_using should point to a "graph"-like object that
 * will be cleaned (nodes and edges will be removed) and refitted as
 * an empty "graph" with n nodes with integer labels. This capability
 * is useful for specifying the class-nature of the resulting empty
 * "graph" (i.e. Graph, DiGraph, MyWeirdGraphClass, etc.).
 *
 * The variable create_using has two main uses:
 * Firstly, the variable create_using can be used to create an
 * empty digraph, network,etc.  For example,
 *
 * ```
 * var n = 10
 * var G = jsnx.emptyGraph(n, jsnx.DiGraph())
 * ```
 *
 * will create an empty digraph on n nodes.
 *
 * Secondly, one can pass an existing graph (digraph, pseudograph,
 * etc.) via create_using. For example, if G is an existing graph
 * (resp. digraph, pseudograph, etc.), then empty_graph(n,G)
 * will empty G (i.e. delete all nodes and edges using G.clear() in
 * base) and then add n nodes and zero edges, and return the modified
 * graph (resp. digraph, pseudograph, etc.).
 *
 * @see createEmptyCopy
 *
 * @param{?number=} optN The number of nodes to add to the graph
 * @param{?Graph=} optCreateUsing Graph instance to empty and
 *     add nodes to.
 * @return {Graph}
 */
exports.emptyGraph = emptyGraph;

/**
 * Return the 2d grid graph of mxn nodes,
 * each connected to its nearest neighbors.
 * Optional argument periodic=True will connect
 * boundary nodes via periodic boundary conditions.
 *
 * @param {number} rows Number of rows
 * @param {number} columns Number of columns
 * @param {boolean=} optPeriodic
 * @param {Graph=} optCreateUsing
 * @return {Graph}
 */
exports.grid2dGraph = grid2dGraph;

//TODO: grid_graph
//TODO: hypercube_graph
//TODO: ladder_graph
//TODO: lollipop_graph

/**
 * Return the Null graph with no nodes or edges.
 *
 * See `emptyGraph` for the use of `optCreateUsing`.
 *
 * @param {Graph=} optCreateUsing Graph instance to empty and add nodes to.
 * @return {Graph}
 */
exports.nullGraph = nullGraph;

/**
 * Return the Null graph with no nodes or edges.
 *
 * See `emptyGraph` for the use of `optCreateUsing`.
 *
 * @param {number} n The number of nodes to add to the graph
 * @param {Graph=} optCreateUsing Graph instance to empty and
 *      add nodes to.
 * @return {Graph}
 */
exports.pathGraph = pathGraph;

//TODO: star_graph

/**
 * Return the Trivial graph with one node (with integer label 0) and no edges.
 *
 * @param{Graph=} optCreateUsing Graph instance to empty and
 *      add nodes to.
 * @return {Graph}
 */
exports.trivialGraph = trivialGraph;

var Graph = _babelHelpers.interopRequire(require("../classes/Graph"));

var _internals = require("../_internals");

var genCombinations = _internals.genCombinations;
var genPermutations = _internals.genPermutations;
var genRange = _internals.genRange;
var isGraph = _internals.isGraph;
var mapIterator = _internals.mapIterator;
var next = _internals.next;
var range = _internals.range;
var tuple2 = _internals.tuple2;

function fullRaryTree(r, n, optCreateUsing) {
  var G = emptyGraph(n, optCreateUsing);
  G.addEdgesFrom(treeEdges(n, r));
  return G;
}

function balancedTree(r, h, optCreateUsing) {
  var n = r === 1 ? 2 : Math.floor((1 - Math.pow(r, h + 1)) / (1 - r));
  var G = emptyGraph(n, optCreateUsing);
  G.addEdgesFrom(treeEdges(n, r));
  return G;
}

function completeGraph(n, optCreateUsing) {
  var G = emptyGraph(n, optCreateUsing);
  G.name = "complete_graph(" + n + ")";
  if (n > 1) {
    G.addEdgesFrom(G.isDirected() ? genPermutations(range(n), 2) : genCombinations(range(n), 2));
  }
  return G;
}

function cycleGraph(n, optCreateUsing) {
  var G = pathGraph(n, optCreateUsing);
  G.name = "cycle_graph(" + n + ")";
  if (n > 1) {
    G.addEdge(n - 1, 0);
  }
  return G;
}

function emptyGraph(optN, optCreateUsing) {
  if (isGraph(optN)) {
    optCreateUsing = optN;
    optN = null;
  }
  if (optN == null) {
    optN = 0;
  }

  var G;

  if (optCreateUsing == null) {
    // default empty graph is a simple graph
    G = new Graph();
  } else {
    G = optCreateUsing;
    G.clear();
  }

  G.addNodesFrom(genRange(optN));
  G.name = "emptyGraph(" + optN + ")";
  return G;
}

function grid2dGraph(rows, columns, optPeriodic, optCreateUsing) {
  var G = emptyGraph(0, optCreateUsing);
  G.name = "grid2dGraph";
  var i;
  var j;
  for (i = 0; i < rows; i++) {
    for (j = 0; j < columns; j++) {
      G.addNode([i, j]);
    }
  }
  for (i = 1; i < rows; i++) {
    for (j = 0; j < columns; j++) {
      G.addEdge([i, j], [i - 1, j]);
    }
  }
  for (i = 0; i < rows; i++) {
    for (j = 1; j < columns; j++) {
      G.addEdge([i, j], [i, j - 1]);
    }
  }
  if (G.isDirected()) {
    for (i = 0; i < rows - 1; i++) {
      for (j = 0; j < columns; j++) {
        G.addEdge([i, j], [i + 1, j]);
      }
    }
    for (i = 0; i < rows; i++) {
      for (j = 0; j < columns - 1; j++) {
        G.addEdge([i, j], [i, j + 1]);
      }
    }
  }

  if (optPeriodic) {
    if (columns > 2) {
      for (i = 0; i < rows; i++) {
        G.addEdge([i, 0], [i, columns - 1]);
      }
      if (G.isDirected()) {
        for (i = 0; i < rows; i++) {
          G.addEdge([i, columns - 1], [i, 0]);
        }
      }
    }
    if (rows > 2) {
      for (j = 0; j < columns; j++) {
        G.addEdge([0, j], [rows - 1, j]);
      }
      if (G.isDirected()) {
        for (j = 0; j < columns; j++) {
          G.addEdge([rows - 1, j], [0, j]);
        }
      }
    }
    G.name = "periodicGrid2dGraph(" + rows + "," + columns + ")";
  }
  return G;
}

function nullGraph(optCreateUsing) {
  var G = emptyGraph(0, optCreateUsing);
  G.name = "nullGraph()";
  return G;
}

function pathGraph(n, optCreateUsing) {
  var G = emptyGraph(n, optCreateUsing);
  G.name = "pathGraph(" + n + ")";
  G.addEdgesFrom(mapIterator(genRange(n - 1), function (v) {
    return tuple2(v, v + 1);
  }));
  return G;
}

function trivialGraph(optCreateUsing) {
  var G = emptyGraph(1, optCreateUsing);
  G.name = "nullGraph()";
  return G;
}

//TODO: wheel_graph

Object.defineProperty(exports, "__esModule", {
  value: true
});

// helper function for trees
// yields edges in rooted tree at 0 with n nodes and branching ratio r

/*jshint unused:false*/

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../classes/Graph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/Graph.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js","babel-runtime/regenerator":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/degreeSequence.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _core = require("babel-runtime/core-js")["default"];

exports.havelHakimiGraph = havelHakimiGraph;
exports.genHavelHakimiGraph = genHavelHakimiGraph;

var delegate = _babelHelpers.interopRequire(require("../_internals/delegate"));

"use strict";

var JSNetworkXError = _babelHelpers.interopRequire(require("../exceptions/JSNetworkXError"));

var isValidDegreeSequence = require("../algorithms/graphical").isValidDegreeSequence;

var emptyGraph = require("./classic").emptyGraph;

var sprintf = _babelHelpers.interopRequire(require("../_internals/sprintf"));

function havelHakimiGraph(degreeSequence, optCreateUsing) {
  degreeSequence = _core.Array.from(degreeSequence);
  if (!isValidDegreeSequence(degreeSequence)) {
    throw new JSNetworkXError("Invalid degree sequence");
  }
  if (optCreateUsing != null) {
    if (optCreateUsing.isDirected()) {
      throw new JSNetworkXError("Directed Graph not supported");
    }
  }
  var numberOfNodes = degreeSequence.length;
  var G = emptyGraph(numberOfNodes, optCreateUsing);
  var numDegrees = new Array(numberOfNodes);
  for (var i = 0; i < numberOfNodes; i++) {
    numDegrees[i] = [];
  }

  var maxDegree = 0;
  var degreeSum = 0;
  var n = 0;

  for (i = 0; i < numberOfNodes; i++) {
    var degree = degreeSequence[i];
    // process only the non-zero integers
    if (degree > 0) {
      numDegrees[degree].push(n);
      maxDegree = Math.max(maxDegree, degree);
      degreeSum += degree;
      n += 1;
    }
  }

  // Return graph if no edges
  if (n === 0) {
    return G;
  }

  // form list of [stubs,name] for each node.
  var modstubs = new Array(maxDegree + 1);
  for (i = 0; i < maxDegree + 1; i++) {
    modstubs[i] = [0, 0];
  }
  // Successively reduce degree sequence by removing the maximum degree
  while (n > 0) {
    // Retrieve the maximum degree in the sequence
    while (numDegrees[maxDegree].length === 0) {
      maxDegree -= 1;
    }
    // If there are not enough stubs to connect to, then the sequence is not
    // graphical
    if (maxDegree > n - 1) {
      throw new JSNetworkXError("Non-graphical integer sequence");
    }
    // Remove largest stub in list
    var source = numDegrees[maxDegree].pop();
    n -= 1;
    // Reduce the next maxDegree largest stubs
    var mslen = 0;
    var k = maxDegree;
    for (i = 0; i < maxDegree; i++) {
      while (numDegrees[k].length === 0) {
        k -= 1;
      }
      var target = numDegrees[k].pop();
      G.addEdge(source, target);
      n -= 1;
      if (k > 1) {
        modstubs[mslen] = [k - 1, target];
        mslen += 1;
      }
    }
    // Add back to the list any nonzero stubs that were removed
    for (i = 0; i < mslen; i++) {
      var _modstubs$i = _babelHelpers.slicedToArray(modstubs[i], 2);

      var stubval = _modstubs$i[0];
      var stubtarget = _modstubs$i[1];

      numDegrees[stubval].push(stubtarget);
      n += 1;
    }
  }

  G.name = sprintf("havelHakimiGraph %s nodes %d edges", G.order(), G.size());
  return G;
}

function genHavelHakimiGraph(degreeSequence, optCreateUsing) {
  return delegate("havelHakimiGraph", [degreeSequence, optCreateUsing]);
}

;
Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"../_internals/delegate":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/delegateToWorker.js","../_internals/sprintf":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/sprintf.js","../algorithms/graphical":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/graphical.js","../exceptions/JSNetworkXError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXError.js","./classic":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/classic.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/index.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _classic = require("./classic");

var classic = _babelHelpers.interopRequireWildcard(_classic);

var _degreeSequence = require("./degreeSequence");

var degreeSequence = _babelHelpers.interopRequireWildcard(_degreeSequence);

var _randomGraphs = require("./randomGraphs");

var randomGraphs = _babelHelpers.interopRequireWildcard(_randomGraphs);

var _small = require("./small");

var small = _babelHelpers.interopRequireWildcard(_small);

var _social = require("./social");

var social = _babelHelpers.interopRequireWildcard(_social);

exports.classic = classic;
exports.degreeSequence = degreeSequence;
exports.randomGraphs = randomGraphs;
exports.small = small;
exports.social = social;

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_classic));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_degreeSequence));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_randomGraphs));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_small));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_social));

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"./classic":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/classic.js","./degreeSequence":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/degreeSequence.js","./randomGraphs":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/randomGraphs.js","./small":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/small.js","./social":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/social.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/randomGraphs.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var _babelHelpers = require("babel-runtime/helpers")["default"];

exports.fastGnpRandomGraph = fastGnpRandomGraph;
exports.genFastGnpRandomGraph = genFastGnpRandomGraph;
exports.gnpRandomGraph = gnpRandomGraph;
exports.genGnpRandomGraph = genGnpRandomGraph;
exports.binomialGraph = binomialGraph;
exports.genBinomialGraph = genBinomialGraph;
exports.erdosRenyiGraph = erdosRenyiGraph;
exports.genErdosRenyiGraph = genErdosRenyiGraph;

var delegate = _babelHelpers.interopRequire(require("../_internals/delegate"));

"use strict";

var DiGraph = _babelHelpers.interopRequire(require("../classes/DiGraph"));

var Graph = _babelHelpers.interopRequire(require("../classes/Graph"));

var _classic = require("./classic");

var completeGraph = _classic.completeGraph;
var emptyGraph = _classic.emptyGraph;

var _internals = require("../_internals");

var genCombinations = _internals.genCombinations;
var genPermutations = _internals.genPermutations;
var range = _internals.range;
var sprintf = _internals.sprintf;

function fastGnpRandomGraph(n, p) {
  var optDirected = arguments[2] === undefined ? false : arguments[2];

  var G = emptyGraph(n);
  G.name = sprintf("fastGnpRandomGraph(%s, %s)", n, p);

  if (p <= 0 || p >= 1) {
    return gnpRandomGraph(n, p, optDirected);
  }
  var v;
  var w = -1;
  var lp = Math.log(1 - p);
  var lr;

  if (optDirected) {
    // Nodes in graph are from 0,n-1 (start with v as the first node index).
    v = 0;
    G = new DiGraph(G);
    while (v < n) {
      lr = Math.log(1 - Math.random());
      w = w + 1 + Math.floor(lr / lp);
      if (v === w) {
        // avoid self loops
        w = w + 1;
      }
      while (w >= n && v < n) {
        w = w - n;
        v = v + 1;
        if (v === w) {
          // avoid self loops
          w = w + 1;
        }
      }
      if (v < n) {
        G.addEdge(v, w);
      }
    }
  } else {
    v = 1; // Nodes in graph are from 0, n-1 (this is the second node index).
    while (v < n) {
      lr = Math.log(1 - Math.random());
      w = w + 1 + Math.floor(lr / lp);
      while (w >= v && v < n) {
        w = w - v;
        v = v + 1;
      }
      if (v < n) {
        G.addEdge(v, w);
      }
    }
  }
  return G;
}

function genFastGnpRandomGraph(n, p, optDirected) {
  return delegate("fastGnpRandomGraph", [n, p, optDirected]);
}

;

function gnpRandomGraph(n, p, optDirected) {
  var G = optDirected ? new DiGraph() : new Graph();
  var edges;
  var rangeN = range(n);

  G.addNodesFrom(rangeN);
  G.name = sprintf("gnpRandomGraph(%s, %s)", n, p);
  if (p <= 0) {
    return G;
  }
  if (p >= 1) {
    return completeGraph(n, G);
  }

  edges = G.isDirected() ? genPermutations(rangeN, 2) : genCombinations(rangeN, 2);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _core.$for.getIterator(edges), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var edge = _step.value;

      if (Math.random() < p) {
        G.addEdge(edge[0], edge[1]);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return G;
}

function genGnpRandomGraph(n, p, optDirected) {
  return delegate("gnpRandomGraph", [n, p, optDirected]);
}

;

function binomialGraph(n, p, optDirected) {
  return gnpRandomGraph(n, p, optDirected);
}

function genBinomialGraph(n, p, optDirected) {
  return delegate("binomialGraph", [n, p, optDirected]);
}

;

function erdosRenyiGraph(n, p, optDirected) {
  return gnpRandomGraph(n, p, optDirected);
}

function genErdosRenyiGraph(n, p, optDirected) {
  return delegate("erdosRenyiGraph", [n, p, optDirected]);
}

;
Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../_internals/delegate":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/delegateToWorker.js","../classes/DiGraph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/DiGraph.js","../classes/Graph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/Graph.js","./classic":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/classic.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/small.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Return a small undirected graph described by graph_description.
 *
 * @see makeSmallGraph.
 *
 * @param {Array} graphDescription
 *    Description of the graph to create in the form `{type, name, n, list}`.
 * @param {Graph=}
 *    optCreateUsing Graph instance to empty and add nodes to.
 *
 * @return {Graph}
 */
exports.makeSmallUndirectedGraph = makeSmallUndirectedGraph;

/**
 * Return the small graph described by graph_description.
 *
 * graphDescription is a list of the form `{type, name, n, list}`.
 *
 * Here `ltype` is one of `"adjacencylist"` or `"edgelist"`,
 * `name` is the name of the graph and `n` the number of nodes.
 * This constructs a graph of `n` nodes with integer labels 0,..,n-1.
 *
 * If `ltype="adjacencylist"` then `xlist` is an adjacency list
 * with exactly `n` entries, in with the `j`'th entry (which can be empty)
 * specifies the nodes connected to vertex `j`.
 *
 * E.g. the "square" graph `$C_4$` can be obtained by
 *
 * ```
 * var G = makeSmallGraph({
 *   type: "adjacencylist",
 *   name: "C_4",
 *   n: 4,
 *   list: [[2,4],[1,3],[2,4],[1,3]]
 * });
 * ```
 *
 * or, since we do not need to add edges twice,
 *
 * ```
 * var G = makeSmallGraph({
 *   type: "adjacencylist",
 *   name: "C_4",
 *   n: 4,
 *   list: [[2,4],[3],[4],[]]]
 * });
 *
 * If `ltype="edgelist"` then `xlist` is an edge list written as
 * `[[v1,w2],[v2,w2],...,[vk,wk]]`, where `vj` and `wj` integers in the range
 * 1,..,n
 *
 * E.g. the "square" graph `$C_4$` can be obtained by
 *
 * ```
 * var G = makeSmallGraph({
 *   type: "edgelist",
 *   name: "C_4",
 *   n: 4,
 *   list: [[1,2],[3,4],[2,3],[4,1]]]
 * });
 * ```
 *
 * Use the optCreateUsing argument to choose the graph class/type.
 *
 * @param {Array} graphDescription
 *    Description of the graph to create in the form `{type, name, n, list}`.
 * @param {Graph=} optCreateUsing Graph instance to empty and add nodes to.
 * @return {Graph}
 */
exports.makeSmallGraph = makeSmallGraph;

// TODO: LCF_graph

/**
 * Return the Bull graph.
 *
 * @param {Graph=} optCreateUsing  Graph instance to empty and add nodes to.
 * @return {Graph}
 */
exports.bullGraph = bullGraph;

// TODO: chvatal_graph
// TODO: cubical_graph
// TODO: desargues_graph
// TODO: diamond_graph
// TODO: dodecahedral_graph
// TODO: frucht_graph
// TODO: heawood_graph
// TODO: house_graph
// TODO: house_x_graph
// TODO: icosahedral_graph

/**
 * Return the Krackhardt Kite Social Network.
 *
 * A 10 actor social network introduced by David Krackhardt
 * to illustrate: degree, betweenness, centrality, closeness, etc.
 * The traditional labeling is:
 * Andre=1, Beverley=2, Carol=3, Diane=4,
 * Ed=5, Fernando=6, Garth=7, Heather=8, Ike=9, Jane=10.
 *
 * @param {Graph=} opt_create_using Graph instance to empty and add nodes to.
 * @return {Graph}
 */
exports.krackhardtKiteGraph = krackhardtKiteGraph;

var JSNetworkXError = _babelHelpers.interopRequire(require("../exceptions/JSNetworkXError"));

var emptyGraph = require("./classic").emptyGraph;

var forEach = require("../_internals").forEach;

function makeSmallUndirectedGraph(graphDescription, optCreateUsing) {
  if (optCreateUsing != null && optCreateUsing.isDirected()) {
    throw new JSNetworkXError("Directed Graph not supported");
  }
  return makeSmallGraph(graphDescription, optCreateUsing);
}

function makeSmallGraph(_ref, optCreateUsing) {
  var type = _ref.type;
  var name = _ref.name;
  var n = _ref.n;
  var list = _ref.list;

  var G = emptyGraph(n, optCreateUsing);
  var nodes = G.nodes();

  if (type === "adjacencylist") {
    if (list.length !== n) {
      throw new JSNetworkXError("invalid graphDescription");
    }
    nodes.forEach(function (v) {
      forEach(list[v], function (u) {
        return G.addEdge(u - 1, v);
      });
    });
  } else if (type === "edgelist") {
    forEach(list, function (_ref2) {
      var _ref22 = _babelHelpers.slicedToArray(_ref2, 2);

      var v = _ref22[0];
      var u = _ref22[1];

      v -= 1;
      u -= 1;
      if (v < 0 || v > n - 1 || u < 0 || u > n - 1) {
        throw new JSNetworkXError("invalid graphDescription");
      } else {
        G.addEdge(v, u);
      }
    });
  }
  G.name = name;
  return G;
}

function bullGraph(optCreateUsing) {
  var type = "adjacencylist";
  var name = "Bull Graph";
  var n = 5;
  var list = [[2, 3], [1, 3, 4], [1, 2, 5], [2], [3]];

  return makeSmallUndirectedGraph({ type: type, name: name, n: n, list: list }, optCreateUsing);
}

function krackhardtKiteGraph(optCreateUsing) {
  var type = "adjacencylist";
  var name = "Krackhardt Kite Social Network";
  var n = 10;
  var list = [[2, 3, 4, 6], [1, 4, 5, 7], [1, 4, 6], [1, 2, 3, 5, 6, 7], [2, 4, 7], [1, 3, 4, 7, 8], [2, 4, 5, 6, 8], [6, 7, 9], [8, 10], [9]];

  return makeSmallUndirectedGraph({ type: type, name: name, n: n, list: list }, optCreateUsing);
}

// TODO: moebius_kantor_graph
// TODO: octahedral_graph
// TODO: pappus_graph
// TODO: petersen_graph
// TODO: sedgewick_maze_graph
// TODO: tetrahedral_graph
// TODO: truncated_cube_graph
// TODO: truncated_tetrahedron_graph
// TODO: tutte_graph

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"../_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","../exceptions/JSNetworkXError":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/JSNetworkXError.js","./classic":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/classic.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/social.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

/**
 * Return Zachary's Karate club graph.
 *
 * @return {Graph}
 */
exports.karateClubGraph = karateClubGraph;

/**
 * Return Davis Saouthern women social network.
 *
 * This is a bipartite graph.
 *
 * @return {Graph}
 */
exports.davisSouthernWomenGraph = davisSouthernWomenGraph;

/**
 * Return Florentine families graph.
 *
 * @return {Graph}
 */
exports.florentineFamiliesGraph = florentineFamiliesGraph;

/**
 * @fileoverview Famous social networkx
 */

var Graph = _babelHelpers.interopRequire(require("../classes/Graph"));

var range = _babelHelpers.interopRequire(require("../_internals/range"));

function karateClubGraph() {
  var G = new Graph();
  G.addNodesFrom(range(34));
  G.name = "Zachary's Karate Club";

  var zacharyData = ["0 1 1 1 1 1 1 1 1 0 1 1 1 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0", "1 0 1 1 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0", "1 1 0 1 0 0 0 1 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0", "1 1 1 0 0 0 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1", "0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1", "1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1", "0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1", "1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1", "1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 1", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1", "0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1", "0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1", "0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1", "1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 1", "0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 1 0 1 0 1 1 0 0 0 0 0 1 1 1 0 1", "0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 1 0 0 1 1 1 0 1 1 0 0 1 1 1 1 1 1 1 0"];

  zacharyData.forEach(function (line, row) {
    var thisrow = line.split(" ");
    thisrow.forEach(function (val, col) {
      if (val === "1") {
        G.addEdge(row, col); // col goes from 0,33
      }
    });
  });

  G.addNodesFrom([0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 16, 17, 19, 21], { club: "Mr. Hi" });
  G.addNodesFrom([9, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], { club: "Officer" });

  return G;
}

function davisSouthernWomenGraph() {
  var G = new Graph();
  // top nodes
  G.addNodesFrom(["Evelyn Jefferson", "Laura Mandeville", "Theresa Anderson", "Brenda Rogers", "Charlotte McDowd", "Frances Anderson", "Eleanor Nye", "Pearl Oglethorpe", "Ruth DeSand", "Verne Sanderson", "Myra Liddel", "Katherina Rogers", "Sylvia Avondale", "Nora Fayette", "Helen Lloyd", "Dorothy Murchison", "Olivia Carleton", "Flora Price"], { bipartite: 0 });

  // bottom nodes
  G.addNodesFrom(["E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "E10", "E11", "E12", "E13", "E14"], { bipartite: 1 });

  G.add_edges_from([["Evelyn Jefferson", "E1"], ["Evelyn Jefferson", "E2"], ["Evelyn Jefferson", "E3"], ["Evelyn Jefferson", "E4"], ["Evelyn Jefferson", "E5"], ["Evelyn Jefferson", "E6"], ["Evelyn Jefferson", "E8"], ["Evelyn Jefferson", "E9"], ["Laura Mandeville", "E1"], ["Laura Mandeville", "E2"], ["Laura Mandeville", "E3"], ["Laura Mandeville", "E5"], ["Laura Mandeville", "E6"], ["Laura Mandeville", "E7"], ["Laura Mandeville", "E8"], ["Theresa Anderson", "E2"], ["Theresa Anderson", "E3"], ["Theresa Anderson", "E4"], ["Theresa Anderson", "E5"], ["Theresa Anderson", "E6"], ["Theresa Anderson", "E7"], ["Theresa Anderson", "E8"], ["Theresa Anderson", "E9"], ["Brenda Rogers", "E1"], ["Brenda Rogers", "E3"], ["Brenda Rogers", "E4"], ["Brenda Rogers", "E5"], ["Brenda Rogers", "E6"], ["Brenda Rogers", "E7"], ["Brenda Rogers", "E8"], ["Charlotte McDowd", "E3"], ["Charlotte McDowd", "E4"], ["Charlotte McDowd", "E5"], ["Charlotte McDowd", "E7"], ["Frances Anderson", "E3"], ["Frances Anderson", "E5"], ["Frances Anderson", "E6"], ["Frances Anderson", "E8"], ["Eleanor Nye", "E5"], ["Eleanor Nye", "E6"], ["Eleanor Nye", "E7"], ["Eleanor Nye", "E8"], ["Pearl Oglethorpe", "E6"], ["Pearl Oglethorpe", "E8"], ["Pearl Oglethorpe", "E9"], ["Ruth DeSand", "E5"], ["Ruth DeSand", "E7"], ["Ruth DeSand", "E8"], ["Ruth DeSand", "E9"], ["Verne Sanderson", "E7"], ["Verne Sanderson", "E8"], ["Verne Sanderson", "E9"], ["Verne Sanderson", "E12"], ["Myra Liddel", "E8"], ["Myra Liddel", "E9"], ["Myra Liddel", "E10"], ["Myra Liddel", "E12"], ["Katherina Rogers", "E8"], ["Katherina Rogers", "E9"], ["Katherina Rogers", "E10"], ["Katherina Rogers", "E12"], ["Katherina Rogers", "E13"], ["Katherina Rogers", "E14"], ["Sylvia Avondale", "E7"], ["Sylvia Avondale", "E8"], ["Sylvia Avondale", "E9"], ["Sylvia Avondale", "E10"], ["Sylvia Avondale", "E12"], ["Sylvia Avondale", "E13"], ["Sylvia Avondale", "E14"], ["Nora Fayette", "E6"], ["Nora Fayette", "E7"], ["Nora Fayette", "E9"], ["Nora Fayette", "E10"], ["Nora Fayette", "E11"], ["Nora Fayette", "E12"], ["Nora Fayette", "E13"], ["Nora Fayette", "E14"], ["Helen Lloyd", "E7"], ["Helen Lloyd", "E8"], ["Helen Lloyd", "E10"], ["Helen Lloyd", "E11"], ["Helen Lloyd", "E12"], ["Dorothy Murchison", "E8"], ["Dorothy Murchison", "E9"], ["Olivia Carleton", "E9"], ["Olivia Carleton", "E11"], ["Flora Price", "E9"], ["Flora Price", "E11"]]);

  return G;
}

function florentineFamiliesGraph() {
  var G = new Graph();
  G.addEdge("Acciaiuoli", "Medici");
  G.addEdge("Castellani", "Peruzzi");
  G.addEdge("Castellani", "Strozzi");
  G.addEdge("Castellani", "Barbadori");
  G.addEdge("Medici", "Barbadori");
  G.addEdge("Medici", "Ridolfi");
  G.addEdge("Medici", "Tornabuoni");
  G.addEdge("Medici", "Albizzi");
  G.addEdge("Medici", "Salviati");
  G.addEdge("Salviati", "Pazzi");
  G.addEdge("Peruzzi", "Strozzi");
  G.addEdge("Peruzzi", "Bischeri");
  G.addEdge("Strozzi", "Ridolfi");
  G.addEdge("Strozzi", "Bischeri");
  G.addEdge("Ridolfi", "Tornabuoni");
  G.addEdge("Tornabuoni", "Guadagni");
  G.addEdge("Albizzi", "Ginori");
  G.addEdge("Albizzi", "Guadagni");
  G.addEdge("Bischeri", "Guadagni");
  G.addEdge("Guadagni", "Lamberteschi");
  return G;
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"../_internals/range":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/range.js","../classes/Graph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/Graph.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/index.js":[function(require,module,exports){
"use strict";

var _babelHelpers = require("babel-runtime/helpers")["default"];

var _algorithms = require("./algorithms");

var algorithms = _babelHelpers.interopRequireWildcard(_algorithms);

var _classes = require("./classes");

var classes = _babelHelpers.interopRequireWildcard(_classes);

var _convert = require("./convert");

var convert = _babelHelpers.interopRequireWildcard(_convert);

var _drawing = require("./drawing");

var drawing = _babelHelpers.interopRequireWildcard(_drawing);

var _exceptions = require("./exceptions");

var exceptions = _babelHelpers.interopRequireWildcard(_exceptions);

var _generators = require("./generators");

var generators = _babelHelpers.interopRequireWildcard(_generators);

var _relabel = require("./relabel");

var relabel = _babelHelpers.interopRequireWildcard(_relabel);

var Map = _babelHelpers.interopRequire(require("./_internals/Map"));

var Set = _babelHelpers.interopRequire(require("./_internals/Set"));

exports.Map = Map;
exports.Set = Set;
exports.algorithms = algorithms;
exports.classes = classes;
exports.convert = convert;
exports.drawing = drawing;
exports.exceptions = exceptions;
exports.generators = generators;
exports.relabel = relabel;

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_algorithms));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_classes));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_convert));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_drawing));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(require("./contrib/observer")));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_exceptions));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_generators));

_babelHelpers.defaults(exports, _babelHelpers.interopRequireWildcard(_relabel));

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{"./_internals/Map":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Map.js","./_internals/Set":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Set.js","./algorithms":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/algorithms/index.js","./classes":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/index.js","./contrib/observer":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/contrib/observer.js","./convert":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/convert.js","./drawing":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/drawing/index.js","./exceptions":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/index.js","./generators":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/generators/index.js","./relabel":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/relabel.js","babel-runtime/helpers":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/relabel.js":[function(require,module,exports){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var DiGraph = require("./classes/DiGraph");
/*jshint ignore:start*/
var Map = require("./_internals/Map");
var Set = require("./_internals/Set");
/*jshint ignore:end*/

var _require = require("./exceptions");

var JSNetworkXError = _require.JSNetworkXError;
var JSNetworkXUnfeasible = _require.JSNetworkXUnfeasible;

var _require2 = require("./_internals");

var clone = _require2.clone;
var forEach = _require2.forEach;
var isMap = _require2.isMap;
var mapIterator = _require2.mapIterator;
var someIterator = _require2.someIterator;
var sprintf = _require2.sprintf;
var topologicalSort = _require2.topologicalSort;
var tuple2 = _require2.tuple2;
var tuple3c = _require2.tuple3c;
var tuple4c = _require2.tuple4c;

/**
 * Relabel the nodes of the graph G.
 *
 * Notes
 * -----
 * Only the nodes specified in the mapping will be relabeled.
 *
 * The setting copy=false modifies the graph in place.
 * This is not always possible if the mapping is circular.
 * In that case use copy=true.
 *
 * @see #convertNodeLabelsTo_integers
 *
 * @param {Graph} G A JSNetworkX graph
 * @param {(Object|Map|function(Node):Node)} mapping
 *      A dictionary with the old labels as keys and new labels as values.
 *      A partial mapping is allowed.
 * @param {boolean=} optCopy (default: true)
 *      If True return a copy or if False relabel the nodes in place.
 *
 * @return {Graph}
 * @export
 */
function relabelNodes(G, mapping) {
  var optCopy = arguments[2] === undefined ? true : arguments[2];

  // you can pass a function f(oldLabel)->newLabel
  // but we'll just make a dictionary here regardless
  var m = mapping;
  if (typeof mapping !== "function") {
    if (!isMap(m)) {
      m = new Map(m);
    }
  } else {
    m = new Map(mapIterator(G.nodesIter(), function (n) {
      return tuple2(n, mapping(n));
    }));
  }

  return optCopy ? relabelCopy(G, m) : relabelInplace(G, m);
}

/**
 * @param {Graph} G A JSNetworkX graph
 * @param {Map} mapping
 *      A dictionary with the old labels as keys and new labels as values.
 *      A partial mapping is allowed.
 *
 * @return .Graph}
 * @private
 */
function relabelInplace(G, mapping) {
  var oldLabels = new Set(mapping.keys());
  var nodes;

  if (someIterator(mapping.values(), function (v) {
    return oldLabels.has(v);
  })) {
    // labels sets overlap
    // can we topological sort and still do the relabeling?
    var D = new DiGraph(mapping);
    D.removeEdgesFrom(D.selfloopEdges());
    try {
      nodes = topologicalSort(D);
    } catch (e) {
      if (e instanceof JSNetworkXUnfeasible) {
        throw new JSNetworkXUnfeasible("The node label sets are overlapping and" + " no ordering can resolve the mapping." + " Use copy=True.");
      }
    }
    nodes.reverse(); // reverse topological order
  } else {
    // non-overlapping label sets
    nodes = oldLabels.values();
  }
  var multigraph = G.isMultigraph();
  var directed = G.isDirected();
  var newEdges;

  forEach(nodes, function (old) {
    var new_;
    if (mapping.has(old)) {
      new_ = mapping.get(old);
    } else {
      return; // continue
    }

    if (!G.hasNode(old)) {
      throw new JSNetworkXError(sprintf("Node %j is not in the graph.", old));
    }
    G.addNode(new_, G.node.get(old));
    if (multigraph) {
      newEdges = G.edges(old, true, true).map(function (d) {
        return tuple4c(new_, d[1], d[2], d[3], d);
      });

      if (directed) {
        newEdges = newEdges.concat(G.inEdges(old, true, true).map(function (d) {
          return tuple4c(d[0], new_, d[2], d[3], d);
        }));
      }
    } else {
      newEdges = G.edges(old, true).map(function (d) {
        return tuple3c(new_, d[1], d[2], d);
      });

      if (directed) {
        newEdges = newEdges.concat(G.inEdges(old, true).map(function (d) {
          return tuple3c(d[0], new_, d[2], d);
        }));
      }
    }
    G.removeNode(old);
    G.addEdgesFrom(newEdges);
  });
  return G;
}

/**
 * @param {Graph} G A JSNetworkX graph
 * @param {Map} mapping
 *      A dictionary with the old labels as keys and new labels as values.
 *      A partial mapping is allowed.
 *
 * @return {Graph}
 * @private
 */
function relabelCopy(G, mapping) {
  var H = new G.constructor();
  H.name = "(" + G.name + ")";
  if (G.isMultigraph()) {
    H.addEdgesFrom(mapIterator(G.edgesIter(null, true, true), function (d) {
      return tuple4c(mapping.has(d[0]) ? mapping.get(d[0]) : d[0], mapping.has(d[1]) ? mapping.get(d[1]) : d[1], d[2], clone(d[3]), d);
    }));
  } else {
    H.addEdgesFrom(mapIterator(G.edgesIter(null, true), function (d) {
      return tuple3c(mapping.has(d[0]) ? mapping.get(d[0]) : d[0], mapping.has(d[1]) ? mapping.get(d[1]) : d[1], clone(d[3]), d);
    }));
  }
  G.node.forEach(function (data, n) {
    return H.addNode(mapping.has(n) ? mapping.get(n) : n, clone(data));
  });
  _core.Object.assign(H.graph, clone(G.graph));

  return H;
}

/**
 * Return a copy of G node labels replaced with integers.
 *
 * @param {Graph} G A JSNetworkX graph
 * @param {?number=} optFirstLabel (default=0)
 *      An integer specifying the offset in numbering nodes.
 *      The n new integer labels are numbered firstLabel, ..., n-1+firstLabel.
 * @param {?string=} optOrdering (default="default")
 *      "default" : inherit node ordering from G.nodes()
 *      "sorted"  : inherit node ordering from sorted(G.nodes())
 *      "increasing degree" : nodes are sorted by increasing degree
 *      "decreasing degree" : nodes are sorted by decreasing degree
 * @param {?boolean=} optDiscardOldLabels (default=true)
 *      If true discard old labels. If false, create a node attribute
 *      'oldLabel' to hold the old labels.
 *
 * @return {Graph}
 * @export
 */
function convertNodeLabelsToIntegers(G) {
  var optFirstLabel = arguments[1] === undefined ? 0 : arguments[1];
  var optOrdering = arguments[2] === undefined ? "default" : arguments[2];
  var optDiscardOldLabels = arguments[3] === undefined ? true : arguments[3];

  //   This function strips information attached to the nodes and/or
  //   edges of a graph, and returns a graph with appropriate integer
  //   labels. One can view this as a re-labeling of the nodes. Be
  //   warned that the term "labeled graph" has a loaded meaning
  //   in graph theory. The fundamental issue is whether the names
  //   (labels) of the nodes (and edges) matter in deciding when two
  //   graphs are the same. For example, in problems of graph enumeration
  //   there is a distinct difference in techniques required when
  //   counting labeled vs. unlabeled graphs.
  //
  //   When implementing graph
  //   algorithms it is often convenient to strip off the original node
  //   and edge information and appropriately relabel the n nodes with
  //   the integer values 1,..,n. This is the purpose of this function,
  //   and it provides the option (see discardOldLabels variable) to either
  //   preserve the original labels in separate dicts (these are not
  //   returned but made an attribute of the new graph.

  if (typeof optOrdering === "boolean") {
    optDiscardOldLabels = optOrdering;
    optOrdering = "default";
  }

  switch (typeof optFirstLabel) {
    case "string":
      optOrdering = optFirstLabel;
      optFirstLabel = 0;
      break;
    case "boolean":
      optDiscardOldLabels = optFirstLabel;
      optFirstLabel = 0;
      break;
  }

  var mapping = new Map();
  var nodes;
  var dvPairs;
  var i;
  var j;
  var l;

  switch (optOrdering) {
    case "default":
      nodes = G.nodes();
      for (i = 0, j = optFirstLabel, l = nodes.length; i < l; i++, j++) {
        mapping.set(nodes[i], j);
      }
      break;
    case "sorted":
      nodes = G.nodes();
      nodes.sort();
      for (i = 0, j = optFirstLabel, l = nodes.length; i < l; i++, j++) {
        mapping.set(nodes[i], j);
      }
      break;
    case "increasing degree":
      dvPairs = _core.Array.from(G.degreeIter());
      dvPairs.sort(function (a, b) {
        return a[1] - b[1];
      });
      for (i = 0, j = optFirstLabel, l = dvPairs.length; i < l; i++, j++) {
        mapping.set(dvPairs[i][0], j);
      }
      break;
    case "decreasing degree":
      dvPairs = _core.Array.from(G.degreeIter());
      dvPairs.sort(function (a, b) {
        return b[1] - a[1];
      });
      for (i = 0, j = optFirstLabel, l = dvPairs.length; i < l; i++, j++) {
        mapping.set(dvPairs[i][0], j);
      }
      break;
    default:
      throw new JSNetworkXError(sprintf("Unkown node ordering: \"%s\"", optOrdering));
  }

  var H = relabelNodes(G, mapping);
  H.name = "(" + G.name + ")WithIntLabels";
  if (!optDiscardOldLabels) {
    H.nodeLabels = mapping;
  }
  return H;
}

module.exports = {
  relabelNodes: relabelNodes,
  convertNodeLabelsToIntegers: convertNodeLabelsToIntegers };

},{"./_internals":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/index.js","./_internals/Map":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Map.js","./_internals/Set":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/_internals/Set.js","./classes/DiGraph":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/classes/DiGraph.js","./exceptions":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/exceptions/index.js","babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js":[function(require,module,exports){
/**
 * Core.js 0.6.1
 * https://github.com/zloirock/core-js
 * License: http://rock.mit-license.org
 * © 2015 Denis Pushkarev
 */
!function(global, framework, undefined){
'use strict';

/******************************************************************************
 * Module : common                                                            *
 ******************************************************************************/

  // Shortcuts for [[Class]] & property names
var OBJECT          = 'Object'
  , FUNCTION        = 'Function'
  , ARRAY           = 'Array'
  , STRING          = 'String'
  , NUMBER          = 'Number'
  , REGEXP          = 'RegExp'
  , DATE            = 'Date'
  , MAP             = 'Map'
  , SET             = 'Set'
  , WEAKMAP         = 'WeakMap'
  , WEAKSET         = 'WeakSet'
  , SYMBOL          = 'Symbol'
  , PROMISE         = 'Promise'
  , MATH            = 'Math'
  , ARGUMENTS       = 'Arguments'
  , PROTOTYPE       = 'prototype'
  , CONSTRUCTOR     = 'constructor'
  , TO_STRING       = 'toString'
  , TO_STRING_TAG   = TO_STRING + 'Tag'
  , TO_LOCALE       = 'toLocaleString'
  , HAS_OWN         = 'hasOwnProperty'
  , FOR_EACH        = 'forEach'
  , ITERATOR        = 'iterator'
  , FF_ITERATOR     = '@@' + ITERATOR
  , PROCESS         = 'process'
  , CREATE_ELEMENT  = 'createElement'
  // Aliases global objects and prototypes
  , Function        = global[FUNCTION]
  , Object          = global[OBJECT]
  , Array           = global[ARRAY]
  , String          = global[STRING]
  , Number          = global[NUMBER]
  , RegExp          = global[REGEXP]
  , Date            = global[DATE]
  , Map             = global[MAP]
  , Set             = global[SET]
  , WeakMap         = global[WEAKMAP]
  , WeakSet         = global[WEAKSET]
  , Symbol          = global[SYMBOL]
  , Math            = global[MATH]
  , TypeError       = global.TypeError
  , RangeError      = global.RangeError
  , setTimeout      = global.setTimeout
  , setImmediate    = global.setImmediate
  , clearImmediate  = global.clearImmediate
  , parseInt        = global.parseInt
  , isFinite        = global.isFinite
  , process         = global[PROCESS]
  , nextTick        = process && process.nextTick
  , document        = global.document
  , html            = document && document.documentElement
  , navigator       = global.navigator
  , define          = global.define
  , console         = global.console || {}
  , ArrayProto      = Array[PROTOTYPE]
  , ObjectProto     = Object[PROTOTYPE]
  , FunctionProto   = Function[PROTOTYPE]
  , Infinity        = 1 / 0
  , DOT             = '.';

// http://jsperf.com/core-js-isobject
function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
// Native function?
var isNative = ctx(/./.test, /\[native code\]\s*\}\s*$/, 1);

// Object internal [[Class]] or toStringTag
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring
var toString = ObjectProto[TO_STRING];
function setToStringTag(it, tag, stat){
  if(it && !has(it = stat ? it : it[PROTOTYPE], SYMBOL_TAG))hidden(it, SYMBOL_TAG, tag);
}
function cof(it){
  return toString.call(it).slice(8, -1);
}
function classof(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[SYMBOL_TAG]) == 'string' ? T : cof(O);
}

// Function
var call  = FunctionProto.call
  , apply = FunctionProto.apply
  , REFERENCE_GET;
// Partial apply
function part(/* ...args */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , args   = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((args[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , i = 0, j = 0, _args;
    if(!holder && !_length)return invoke(fn, args, that);
    _args = args.slice();
    if(holder)for(;length > i; i++)if(_args[i] === _)_args[i] = arguments[j++];
    while(_length > j)_args.push(arguments[j++]);
    return invoke(fn, _args, that);
  }
}
// Optional / simple context binding
function ctx(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    }
    case 2: return function(a, b){
      return fn.call(that, a, b);
    }
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    }
  } return function(/* ...args */){
      return fn.apply(that, arguments);
  }
}
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
function invoke(fn, args, that){
  var un = that === undefined;
  switch(args.length | 0){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
}

// Object:
var create           = Object.create
  , getPrototypeOf   = Object.getPrototypeOf
  , setPrototypeOf   = Object.setPrototypeOf
  , defineProperty   = Object.defineProperty
  , defineProperties = Object.defineProperties
  , getOwnDescriptor = Object.getOwnPropertyDescriptor
  , getKeys          = Object.keys
  , getNames         = Object.getOwnPropertyNames
  , getSymbols       = Object.getOwnPropertySymbols
  , isFrozen         = Object.isFrozen
  , has              = ctx(call, ObjectProto[HAS_OWN], 2)
  // Dummy, fix for not array-like ES3 string in es5 module
  , ES5Object        = Object
  , Dict;
function toObject(it){
  return ES5Object(assertDefined(it));
}
function returnIt(it){
  return it;
}
function returnThis(){
  return this;
}
function get(object, key){
  if(has(object, key))return object[key];
}
function ownKeys(it){
  assertObject(it);
  return getSymbols ? getNames(it).concat(getSymbols(it)) : getNames(it);
}
// 19.1.2.1 Object.assign(target, source, ...)
var assign = Object.assign || function(target, source){
  var T = Object(assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = ES5Object(arguments[i++])
      , keys   = getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
}
function keyOf(object, el){
  var O      = toObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
}

// Array
// array('str1,str2,str3') => ['str1', 'str2', 'str3']
function array(it){
  return String(it).split(',');
}
var push    = ArrayProto.push
  , unshift = ArrayProto.unshift
  , slice   = ArrayProto.slice
  , splice  = ArrayProto.splice
  , indexOf = ArrayProto.indexOf
  , forEach = ArrayProto[FOR_EACH];
/*
 * 0 -> forEach
 * 1 -> map
 * 2 -> filter
 * 3 -> some
 * 4 -> every
 * 5 -> find
 * 6 -> findIndex
 */
function createArrayMethod(type){
  var isMap       = type == 1
    , isFilter    = type == 2
    , isSome      = type == 3
    , isEvery     = type == 4
    , isFindIndex = type == 6
    , noholes     = type == 5 || isFindIndex;
  return function(callbackfn/*, that = undefined */){
    var O      = Object(assertDefined(this))
      , that   = arguments[1]
      , self   = ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = isMap ? Array(length) : isFilter ? [] : undefined
      , val, res;
    for(;length > index; index++)if(noholes || index in self){
      val = self[index];
      res = f(val, index, O);
      if(type){
        if(isMap)result[index] = res;             // map
        else if(res)switch(type){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(isEvery)return false;           // every
      }
    }
    return isFindIndex ? -1 : isSome || isEvery ? isEvery : result;
  }
}
function createArrayContains(isContains){
  return function(el /*, fromIndex = 0 */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = toIndex(arguments[1], length);
    if(isContains && el != el){
      for(;length > index; index++)if(sameNaN(O[index]))return isContains || index;
    } else for(;length > index; index++)if(isContains || index in O){
      if(O[index] === el)return isContains || index;
    } return !isContains && -1;
  }
}
function generic(A, B){
  // strange IE quirks mode bug -> use typeof vs isFunction
  return typeof A == 'function' ? A : B;
}

// Math
var MAX_SAFE_INTEGER = 0x1fffffffffffff // pow(2, 53) - 1 == 9007199254740991
  , pow    = Math.pow
  , abs    = Math.abs
  , ceil   = Math.ceil
  , floor  = Math.floor
  , max    = Math.max
  , min    = Math.min
  , random = Math.random
  , trunc  = Math.trunc || function(it){
      return (it > 0 ? floor : ceil)(it);
    }
// 20.1.2.4 Number.isNaN(number)
function sameNaN(number){
  return number != number;
}
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it) ? 0 : trunc(it);
}
// 7.1.15 ToLength
function toLength(it){
  return it > 0 ? min(toInteger(it), MAX_SAFE_INTEGER) : 0;
}
function toIndex(index, length){
  var index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
}
function lz(num){
  return num > 9 ? num : '0' + num;
}

function createReplacer(regExp, replace, isStatic){
  var replacer = isObject(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  }
}
function createPointAt(toString){
  return function(pos){
    var s = String(assertDefined(this))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return toString ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? toString ? s.charAt(i) : a
      : toString ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  }
}

// Assertion & errors
var REDUCE_ERROR = 'Reduce of empty object with no initial value';
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
function assertDefined(it){
  if(it == undefined)throw TypeError('Function called on null or undefined');
  return it;
}
function assertFunction(it){
  assert(isFunction(it), it, ' is not a function!');
  return it;
}
function assertObject(it){
  assert(isObject(it), it, ' is not an object!');
  return it;
}
function assertInstance(it, Constructor, name){
  assert(it instanceof Constructor, name, ": use the 'new' operator!");
}

// Property descriptors & Symbol
function descriptor(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  }
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return defineProperty(object, key, descriptor(bitmap, value));
  } : simpleSet;
}
function uid(key){
  return SYMBOL + '(' + key + ')_' + (++sid + random())[TO_STRING](36);
}
function getWellKnownSymbol(name, setter){
  return (Symbol && Symbol[name]) || (setter ? Symbol : safeSymbol)(SYMBOL + DOT + name);
}
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
      try {
        return defineProperty({}, 'a', {get: function(){ return 2 }}).a == 2;
      } catch(e){}
    }()
  , sid    = 0
  , hidden = createDefiner(1)
  , set    = Symbol ? simpleSet : hidden
  , safeSymbol = Symbol || uid;
function assignHidden(target, src){
  for(var key in src)hidden(target, key, src[key]);
  return target;
}

var SYMBOL_UNSCOPABLES = getWellKnownSymbol('unscopables')
  , ArrayUnscopables   = ArrayProto[SYMBOL_UNSCOPABLES] || {}
  , SYMBOL_TAG         = getWellKnownSymbol(TO_STRING_TAG)
  , SYMBOL_SPECIES     = getWellKnownSymbol('species')
  , SYMBOL_ITERATOR;
function setSpecies(C){
  if(DESC && (framework || !isNative(C)))defineProperty(C, SYMBOL_SPECIES, {
    configurable: true,
    get: returnThis
  });
}

/******************************************************************************
 * Module : common.export                                                     *
 ******************************************************************************/

var NODE = cof(process) == PROCESS
  , core = {}
  , path = framework ? global : core
  , old  = global.core
  , exportGlobal
  // type bitmap
  , FORCED = 1
  , GLOBAL = 2
  , STATIC = 4
  , PROTO  = 8
  , BIND   = 16
  , WRAP   = 32;
function $define(type, name, source){
  var key, own, out, exp
    , isGlobal = type & GLOBAL
    , target   = isGlobal ? global : (type & STATIC)
        ? global[name] : (global[name] || ObjectProto)[PROTOTYPE]
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // there is a similar native
    own = !(type & FORCED) && target && key in target
      && (!isFunction(target[key]) || isNative(target[key]));
    // export native or passed
    out = (own ? target : source)[key];
    // prevent global pollution for namespaces
    if(!framework && isGlobal && !isFunction(target[key]))exp = source[key];
    // bind timers to global for call from export context
    else if(type & BIND && own)exp = ctx(out, global);
    // wrap global constructors for prevent change them in library
    else if(type & WRAP && !framework && target[key] == out){
      exp = function(param){
        return this instanceof out ? new out(param) : out(param);
      }
      exp[PROTOTYPE] = out[PROTOTYPE];
    } else exp = type & PROTO && isFunction(out) ? ctx(call, out) : out;
    // extend global
    if(framework && target && !own){
      if(isGlobal)target[key] = out;
      else delete target[key] && hidden(target, key, out);
    }
    // export
    if(exports[key] != out)hidden(exports, key, exp);
  }
}
// CommonJS export
if(typeof module != 'undefined' && module.exports)module.exports = core;
// RequireJS export
else if(isFunction(define) && define.amd)define(function(){return core});
// Export to global object
else exportGlobal = true;
if(exportGlobal || framework){
  core.noConflict = function(){
    global.core = old;
    return core;
  }
  global.core = core;
}

/******************************************************************************
 * Module : common.iterators                                                  *
 ******************************************************************************/

SYMBOL_ITERATOR = getWellKnownSymbol(ITERATOR);
var ITER  = safeSymbol('iter')
  , KEY   = 1
  , VALUE = 2
  , Iterators = {}
  , IteratorPrototype = {}
    // Safari has byggy iterators w/o `next`
  , BUGGY_ITERATORS = 'keys' in ArrayProto && !('next' in [].keys());
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, returnThis);
function setIterator(O, value){
  hidden(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  FF_ITERATOR in ArrayProto && hidden(O, FF_ITERATOR, value);
}
function createIterator(Constructor, NAME, next, proto){
  Constructor[PROTOTYPE] = create(proto || IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
}
function defineIterator(Constructor, NAME, value, DEFAULT){
  var proto = Constructor[PROTOTYPE]
    , iter  = get(proto, SYMBOL_ITERATOR) || get(proto, FF_ITERATOR) || (DEFAULT && get(proto, DEFAULT)) || value;
  if(framework){
    // Define iterator
    setIterator(proto, iter);
    if(iter !== value){
      var iterProto = getPrototypeOf(iter.call(new Constructor));
      // Set @@toStringTag to native iterators
      setToStringTag(iterProto, NAME + ' Iterator', true);
      // FF fix
      has(proto, FF_ITERATOR) && setIterator(iterProto, returnThis);
    }
  }
  // Plug for library
  Iterators[NAME] = iter;
  // FF & v8 fix
  Iterators[NAME + ' Iterator'] = returnThis;
  return iter;
}
function defineStdIterators(Base, NAME, Constructor, next, DEFAULT, IS_SET){
  function createIter(kind){
    return function(){
      return new Constructor(this, kind);
    }
  }
  createIterator(Constructor, NAME, next);
  var entries = createIter(KEY+VALUE)
    , values  = createIter(VALUE);
  if(DEFAULT == VALUE)values = defineIterator(Base, NAME, values, 'values');
  else entries = defineIterator(Base, NAME, entries, 'entries');
  if(DEFAULT){
    $define(PROTO + FORCED * BUGGY_ITERATORS, NAME, {
      entries: entries,
      keys: IS_SET ? values : createIter(KEY),
      values: values
    });
  }
}
function iterResult(done, value){
  return {value: value, done: !!done};
}
function isIterable(it){
  var O      = Object(it)
    , Symbol = global[SYMBOL]
    , hasExt = (Symbol && Symbol[ITERATOR] || FF_ITERATOR) in O;
  return hasExt || SYMBOL_ITERATOR in O || has(Iterators, classof(O));
}
function getIterator(it){
  var Symbol  = global[SYMBOL]
    , ext     = it[Symbol && Symbol[ITERATOR] || FF_ITERATOR]
    , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[classof(it)];
  return assertObject(getIter.call(it));
}
function stepCall(fn, value, entries){
  return entries ? invoke(fn, value) : fn(value);
}
function checkDangerIterClosing(fn){
  var danger = true;
  var O = {
    next: function(){ throw 1 },
    'return': function(){ danger = false }
  };
  O[SYMBOL_ITERATOR] = returnThis;
  try {
    fn(O);
  } catch(e){}
  return danger;
}
function closeIterator(iterator){
  var ret = iterator['return'];
  if(ret !== undefined)ret.call(iterator);
}
function safeIterClose(exec, iterator){
  try {
    exec(iterator);
  } catch(e){
    closeIterator(iterator);
    throw e;
  }
}
function forOf(iterable, entries, fn, that){
  safeIterClose(function(iterator){
    var f = ctx(fn, that, entries ? 2 : 1)
      , step;
    while(!(step = iterator.next()).done)if(stepCall(f, step.value, entries) === false){
      return closeIterator(iterator);
    }
  }, getIterator(iterable));
}

/******************************************************************************
 * Module : es6.symbol                                                        *
 ******************************************************************************/

// ECMAScript 6 symbols shim
!function(TAG, SymbolRegistry, AllSymbols, setter){
  // 19.4.1.1 Symbol([description])
  if(!isNative(Symbol)){
    Symbol = function(description){
      assert(!(this instanceof Symbol), SYMBOL + ' is not a ' + CONSTRUCTOR);
      var tag = uid(description)
        , sym = set(create(Symbol[PROTOTYPE]), TAG, tag);
      AllSymbols[tag] = sym;
      DESC && setter && defineProperty(ObjectProto, tag, {
        configurable: true,
        set: function(value){
          hidden(this, tag, value);
        }
      });
      return sym;
    }
    hidden(Symbol[PROTOTYPE], TO_STRING, function(){
      return this[TAG];
    });
  }
  $define(GLOBAL + WRAP, {Symbol: Symbol});
  
  var symbolStatics = {
    // 19.4.2.1 Symbol.for(key)
    'for': function(key){
      return has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = Symbol(key);
    },
    // 19.4.2.4 Symbol.iterator
    iterator: SYMBOL_ITERATOR || getWellKnownSymbol(ITERATOR),
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: part.call(keyOf, SymbolRegistry),
    // 19.4.2.10 Symbol.species
    species: SYMBOL_SPECIES,
    // 19.4.2.13 Symbol.toStringTag
    toStringTag: SYMBOL_TAG = getWellKnownSymbol(TO_STRING_TAG, true),
    // 19.4.2.14 Symbol.unscopables
    unscopables: SYMBOL_UNSCOPABLES,
    pure: safeSymbol,
    set: set,
    useSetter: function(){setter = true},
    useSimple: function(){setter = false}
  };
  // 19.4.2.2 Symbol.hasInstance
  // 19.4.2.3 Symbol.isConcatSpreadable
  // 19.4.2.6 Symbol.match
  // 19.4.2.8 Symbol.replace
  // 19.4.2.9 Symbol.search
  // 19.4.2.11 Symbol.split
  // 19.4.2.12 Symbol.toPrimitive
  forEach.call(array('hasInstance,isConcatSpreadable,match,replace,search,split,toPrimitive'),
    function(it){
      symbolStatics[it] = getWellKnownSymbol(it);
    }
  );
  $define(STATIC, SYMBOL, symbolStatics);
  
  setToStringTag(Symbol, SYMBOL);
  
  $define(STATIC + FORCED * !isNative(Symbol), OBJECT, {
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) || result.push(key);
      return result;
    },
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) && result.push(AllSymbols[key]);
      return result;
    }
  });
  
  // 20.2.1.9 Math[@@toStringTag]
  setToStringTag(Math, MATH, true);
  // 24.3.3 JSON[@@toStringTag]
  setToStringTag(global.JSON, 'JSON', true);
}(safeSymbol('tag'), {}, {}, true);

/******************************************************************************
 * Module : es6.object.statics                                                *
 ******************************************************************************/

!function(){
  var objectStatic = {
    // 19.1.3.1 Object.assign(target, source)
    assign: assign,
    // 19.1.3.10 Object.is(value1, value2)
    is: function(x, y){
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    }
  };
  // 19.1.3.19 Object.setPrototypeOf(O, proto)
  // Works with __proto__ only. Old v8 can't works with null proto objects.
  '__proto__' in ObjectProto && function(buggy, set){
    try {
      set = ctx(call, getOwnDescriptor(ObjectProto, '__proto__').set, 2);
      set({}, ArrayProto);
    } catch(e){ buggy = true }
    objectStatic.setPrototypeOf = setPrototypeOf = setPrototypeOf || function(O, proto){
      assertObject(O);
      assert(proto === null || isObject(proto), proto, ": can't set as prototype!");
      if(buggy)O.__proto__ = proto;
      else set(O, proto);
      return O;
    }
  }();
  $define(STATIC, OBJECT, objectStatic);
}();

/******************************************************************************
 * Module : es6.object.statics-accept-primitives                              *
 ******************************************************************************/

!function(){
  // Object static methods accept primitives
  function wrapObjectMethod(key, MODE){
    var fn  = Object[key]
      , exp = core[OBJECT][key]
      , f   = 0
      , o   = {};
    if(!exp || isNative(exp)){
      o[key] = MODE == 1 ? function(it){
        return isObject(it) ? fn(it) : it;
      } : MODE == 2 ? function(it){
        return isObject(it) ? fn(it) : true;
      } : MODE == 3 ? function(it){
        return isObject(it) ? fn(it) : false;
      } : MODE == 4 ? function(it, key){
        return fn(toObject(it), key);
      } : function(it){
        return fn(toObject(it));
      };
      try { fn(DOT) }
      catch(e){ f = 1 }
      $define(STATIC + FORCED * f, OBJECT, o);
    }
  }
  wrapObjectMethod('freeze', 1);
  wrapObjectMethod('seal', 1);
  wrapObjectMethod('preventExtensions', 1);
  wrapObjectMethod('isFrozen', 2);
  wrapObjectMethod('isSealed', 2);
  wrapObjectMethod('isExtensible', 3);
  wrapObjectMethod('getOwnPropertyDescriptor', 4);
  wrapObjectMethod('getPrototypeOf');
  wrapObjectMethod('keys');
  wrapObjectMethod('getOwnPropertyNames');
}();

/******************************************************************************
 * Module : es6.number.statics                                                *
 ******************************************************************************/

!function(isInteger){
  $define(STATIC, NUMBER, {
    // 20.1.2.1 Number.EPSILON
    EPSILON: pow(2, -52),
    // 20.1.2.2 Number.isFinite(number)
    isFinite: function(it){
      return typeof it == 'number' && isFinite(it);
    },
    // 20.1.2.3 Number.isInteger(number)
    isInteger: isInteger,
    // 20.1.2.4 Number.isNaN(number)
    isNaN: sameNaN,
    // 20.1.2.5 Number.isSafeInteger(number)
    isSafeInteger: function(number){
      return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
    },
    // 20.1.2.6 Number.MAX_SAFE_INTEGER
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
    // 20.1.2.10 Number.MIN_SAFE_INTEGER
    MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
    // 20.1.2.12 Number.parseFloat(string)
    parseFloat: parseFloat,
    // 20.1.2.13 Number.parseInt(string, radix)
    parseInt: parseInt
  });
// 20.1.2.3 Number.isInteger(number)
}(Number.isInteger || function(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
});

/******************************************************************************
 * Module : es6.math                                                          *
 ******************************************************************************/

// ECMAScript 6 shim
!function(){
  // 20.2.2.28 Math.sign(x)
  var E    = Math.E
    , exp  = Math.exp
    , log  = Math.log
    , sqrt = Math.sqrt
    , sign = Math.sign || function(x){
        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
      };
  
  // 20.2.2.5 Math.asinh(x)
  function asinh(x){
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
  }
  // 20.2.2.14 Math.expm1(x)
  function expm1(x){
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
  }
    
  $define(STATIC, MATH, {
    // 20.2.2.3 Math.acosh(x)
    acosh: function(x){
      return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
    },
    // 20.2.2.5 Math.asinh(x)
    asinh: asinh,
    // 20.2.2.7 Math.atanh(x)
    atanh: function(x){
      return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
    },
    // 20.2.2.9 Math.cbrt(x)
    cbrt: function(x){
      return sign(x = +x) * pow(abs(x), 1 / 3);
    },
    // 20.2.2.11 Math.clz32(x)
    clz32: function(x){
      return (x >>>= 0) ? 32 - x[TO_STRING](2).length : 32;
    },
    // 20.2.2.12 Math.cosh(x)
    cosh: function(x){
      return (exp(x = +x) + exp(-x)) / 2;
    },
    // 20.2.2.14 Math.expm1(x)
    expm1: expm1,
    // 20.2.2.16 Math.fround(x)
    // TODO: fallback for IE9-
    fround: function(x){
      return new Float32Array([x])[0];
    },
    // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
    hypot: function(value1, value2){
      var sum  = 0
        , len1 = arguments.length
        , len2 = len1
        , args = Array(len1)
        , larg = -Infinity
        , arg;
      while(len1--){
        arg = args[len1] = +arguments[len1];
        if(arg == Infinity || arg == -Infinity)return Infinity;
        if(arg > larg)larg = arg;
      }
      larg = arg || 1;
      while(len2--)sum += pow(args[len2] / larg, 2);
      return larg * sqrt(sum);
    },
    // 20.2.2.18 Math.imul(x, y)
    imul: function(x, y){
      var UInt16 = 0xffff
        , xn = +x
        , yn = +y
        , xl = UInt16 & xn
        , yl = UInt16 & yn;
      return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
    },
    // 20.2.2.20 Math.log1p(x)
    log1p: function(x){
      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
    },
    // 20.2.2.21 Math.log10(x)
    log10: function(x){
      return log(x) / Math.LN10;
    },
    // 20.2.2.22 Math.log2(x)
    log2: function(x){
      return log(x) / Math.LN2;
    },
    // 20.2.2.28 Math.sign(x)
    sign: sign,
    // 20.2.2.30 Math.sinh(x)
    sinh: function(x){
      return (abs(x = +x) < 1) ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
    },
    // 20.2.2.33 Math.tanh(x)
    tanh: function(x){
      var a = expm1(x = +x)
        , b = expm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    },
    // 20.2.2.34 Math.trunc(x)
    trunc: trunc
  });
}();

/******************************************************************************
 * Module : es6.string                                                        *
 ******************************************************************************/

!function(fromCharCode){
  function assertNotRegExp(it){
    if(cof(it) == REGEXP)throw TypeError();
  }
  
  $define(STATIC, STRING, {
    // 21.1.2.2 String.fromCodePoint(...codePoints)
    fromCodePoint: function(x){
      var res = []
        , len = arguments.length
        , i   = 0
        , code
      while(len > i){
        code = +arguments[i++];
        if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000
          ? fromCharCode(code)
          : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
        );
      } return res.join('');
    },
    // 21.1.2.4 String.raw(callSite, ...substitutions)
    raw: function(callSite){
      var raw = toObject(callSite.raw)
        , len = toLength(raw.length)
        , sln = arguments.length
        , res = []
        , i   = 0;
      while(len > i){
        res.push(String(raw[i++]));
        if(i < sln)res.push(String(arguments[i]));
      } return res.join('');
    }
  });
  
  $define(PROTO, STRING, {
    // 21.1.3.3 String.prototype.codePointAt(pos)
    codePointAt: createPointAt(false),
    // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
    endsWith: function(searchString /*, endPosition = @length */){
      assertNotRegExp(searchString);
      var that = String(assertDefined(this))
        , endPosition = arguments[1]
        , len = toLength(that.length)
        , end = endPosition === undefined ? len : min(toLength(endPosition), len);
      searchString += '';
      return that.slice(end - searchString.length, end) === searchString;
    },
    // 21.1.3.7 String.prototype.includes(searchString, position = 0)
    includes: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      return !!~String(assertDefined(this)).indexOf(searchString, arguments[1]);
    },
    // 21.1.3.13 String.prototype.repeat(count)
    repeat: function(count){
      var str = String(assertDefined(this))
        , res = ''
        , n   = toInteger(count);
      if(0 > n || n == Infinity)throw RangeError("Count can't be negative");
      for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
      return res;
    },
    // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
    startsWith: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      var that  = String(assertDefined(this))
        , index = toLength(min(arguments[1], that.length));
      searchString += '';
      return that.slice(index, index + searchString.length) === searchString;
    }
  });
}(String.fromCharCode);

/******************************************************************************
 * Module : es6.array.statics                                                 *
 ******************************************************************************/

!function(){
  $define(STATIC + FORCED * checkDangerIterClosing(Array.from), ARRAY, {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
      var O       = Object(assertDefined(arrayLike))
        , mapfn   = arguments[1]
        , mapping = mapfn !== undefined
        , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
        , index   = 0
        , length, result, step;
      if(isIterable(O)){
        result = new (generic(this, Array));
        safeIterClose(function(iterator){
          for(; !(step = iterator.next()).done; index++){
            result[index] = mapping ? f(step.value, index) : step.value;
          }
        }, getIterator(O));
      } else {
        result = new (generic(this, Array))(length = toLength(O.length));
        for(; length > index; index++){
          result[index] = mapping ? f(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }
  });
  
  $define(STATIC, ARRAY, {
    // 22.1.2.3 Array.of( ...items)
    of: function(/* ...args */){
      var index  = 0
        , length = arguments.length
        , result = new (generic(this, Array))(length);
      while(length > index)result[index] = arguments[index++];
      result.length = length;
      return result;
    }
  });
  
  setSpecies(Array);
}();

/******************************************************************************
 * Module : es6.array.prototype                                               *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
    copyWithin: function(target /* = 0 */, start /* = 0, end = @length */){
      var O     = Object(assertDefined(this))
        , len   = toLength(O.length)
        , to    = toIndex(target, len)
        , from  = toIndex(start, len)
        , end   = arguments[2]
        , fin   = end === undefined ? len : toIndex(end, len)
        , count = min(fin - from, len - to)
        , inc   = 1;
      if(from < to && to < from + count){
        inc  = -1;
        from = from + count - 1;
        to   = to + count - 1;
      }
      while(count-- > 0){
        if(from in O)O[to] = O[from];
        else delete O[to];
        to += inc;
        from += inc;
      } return O;
    },
    // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
    fill: function(value /*, start = 0, end = @length */){
      var O      = Object(assertDefined(this))
        , length = toLength(O.length)
        , index  = toIndex(arguments[1], length)
        , end    = arguments[2]
        , endPos = end === undefined ? length : toIndex(end, length);
      while(endPos > index)O[index++] = value;
      return O;
    },
    // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
    find: createArrayMethod(5),
    // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
    findIndex: createArrayMethod(6)
  });
  
  if(framework){
    // 22.1.3.31 Array.prototype[@@unscopables]
    forEach.call(array('find,findIndex,fill,copyWithin,entries,keys,values'), function(it){
      ArrayUnscopables[it] = true;
    });
    SYMBOL_UNSCOPABLES in ArrayProto || hidden(ArrayProto, SYMBOL_UNSCOPABLES, ArrayUnscopables);
  }
}();

/******************************************************************************
 * Module : es6.iterators                                                     *
 ******************************************************************************/

!function(at){
  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  defineStdIterators(Array, ARRAY, function(iterated, kind){
    set(this, ITER, {o: toObject(iterated), i: 0, k: kind});
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , kind  = iter.k
      , index = iter.i++;
    if(!O || index >= O.length){
      iter.o = undefined;
      return iterResult(1);
    }
    if(kind == KEY)  return iterResult(0, index);
    if(kind == VALUE)return iterResult(0, O[index]);
                     return iterResult(0, [index, O[index]]);
  }, VALUE);
  
  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  Iterators[ARGUMENTS] = Iterators[ARRAY];
  
  // 21.1.3.27 String.prototype[@@iterator]()
  defineStdIterators(String, STRING, function(iterated){
    set(this, ITER, {o: String(iterated), i: 0});
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , index = iter.i
      , point;
    if(index >= O.length)return iterResult(1);
    point = at.call(O, index);
    iter.i += point.length;
    return iterResult(0, point);
  });
}(createPointAt(true));

/******************************************************************************
 * Module : web.immediate                                                     *
 ******************************************************************************/

// setImmediate shim
// Node.js 0.9+ & IE10+ has setImmediate, else:
isFunction(setImmediate) && isFunction(clearImmediate) || function(ONREADYSTATECHANGE){
  var postMessage      = global.postMessage
    , addEventListener = global.addEventListener
    , MessageChannel   = global.MessageChannel
    , counter          = 0
    , queue            = {}
    , defer, channel, port;
  setImmediate = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    }
    defer(counter);
    return counter;
  }
  clearImmediate = function(id){
    delete queue[id];
  }
  function run(id){
    if(has(queue, id)){
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  }
  function listner(event){
    run(event.data);
  }
  // Node.js 0.8-
  if(NODE){
    defer = function(id){
      nextTick(part.call(run, id));
    }
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
    defer = function(id){
      postMessage(id, '*');
    }
    addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(document && ONREADYSTATECHANGE in document[CREATE_ELEMENT]('script')){
    defer = function(id){
      html.appendChild(document[CREATE_ELEMENT]('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run(id);
      }
    }
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(run, 0, id);
    }
  }
}('onreadystatechange');
$define(GLOBAL + BIND, {
  setImmediate:   setImmediate,
  clearImmediate: clearImmediate
});

/******************************************************************************
 * Module : es6.promise                                                       *
 ******************************************************************************/

// ES6 promises shim
// Based on https://github.com/getify/native-promise-only/
!function(Promise, test){
  isFunction(Promise) && isFunction(Promise.resolve)
  && Promise.resolve(test = new Promise(function(){})) == test
  || function(asap, RECORD){
    function isThenable(it){
      var then;
      if(isObject(it))then = it.then;
      return isFunction(then) ? then : false;
    }
    function handledRejectionOrHasOnRejected(promise){
      var record = promise[RECORD]
        , chain  = record.c
        , i      = 0
        , react;
      if(record.h)return true;
      while(chain.length > i){
        react = chain[i++];
        if(react.fail || handledRejectionOrHasOnRejected(react.P))return true;
      }
    }
    function notify(record, reject){
      var chain = record.c;
      if(reject || chain.length)asap(function(){
        var promise = record.p
          , value   = record.v
          , ok      = record.s == 1
          , i       = 0;
        if(reject && !handledRejectionOrHasOnRejected(promise)){
          setTimeout(function(){
            if(!handledRejectionOrHasOnRejected(promise)){
              if(NODE){
                if(!process.emit('unhandledRejection', value, promise)){
                  // default node.js behavior
                }
              } else if(isFunction(console.error)){
                console.error('Unhandled promise rejection', value);
              }
            }
          }, 1e3);
        } else while(chain.length > i)!function(react){
          var cb = ok ? react.ok : react.fail
            , ret, then;
          try {
            if(cb){
              if(!ok)record.h = true;
              ret = cb === true ? value : cb(value);
              if(ret === react.P){
                react.rej(TypeError(PROMISE + '-chain cycle'));
              } else if(then = isThenable(ret)){
                then.call(ret, react.res, react.rej);
              } else react.res(ret);
            } else react.rej(value);
          } catch(err){
            react.rej(err);
          }
        }(chain[i++]);
        chain.length = 0;
      });
    }
    function resolve(value){
      var record = this
        , then, wrapper;
      if(record.d)return;
      record.d = true;
      record = record.r || record; // unwrap
      try {
        if(then = isThenable(value)){
          wrapper = {r: record, d: false}; // wrap
          then.call(value, ctx(resolve, wrapper, 1), ctx(reject, wrapper, 1));
        } else {
          record.v = value;
          record.s = 1;
          notify(record);
        }
      } catch(err){
        reject.call(wrapper || {r: record, d: false}, err); // wrap
      }
    }
    function reject(value){
      var record = this;
      if(record.d)return;
      record.d = true;
      record = record.r || record; // unwrap
      record.v = value;
      record.s = 2;
      notify(record, true);
    }
    function getConstructor(C){
      var S = assertObject(C)[SYMBOL_SPECIES];
      return S != undefined ? S : C;
    }
    // 25.4.3.1 Promise(executor)
    Promise = function(executor){
      assertFunction(executor);
      assertInstance(this, Promise, PROMISE);
      var record = {
        p: this,      // promise
        c: [],        // chain
        s: 0,         // state
        d: false,     // done
        v: undefined, // value
        h: false      // handled rejection
      };
      hidden(this, RECORD, record);
      try {
        executor(ctx(resolve, record, 1), ctx(reject, record, 1));
      } catch(err){
        reject.call(record, err);
      }
    }
    assignHidden(Promise[PROTOTYPE], {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function(onFulfilled, onRejected){
        var S = assertObject(assertObject(this)[CONSTRUCTOR])[SYMBOL_SPECIES];
        var react = {
          ok:   isFunction(onFulfilled) ? onFulfilled : true,
          fail: isFunction(onRejected)  ? onRejected  : false
        } , P = react.P = new (S != undefined ? S : Promise)(function(resolve, reject){
          react.res = assertFunction(resolve);
          react.rej = assertFunction(reject);
        }), record = this[RECORD];
        record.c.push(react);
        record.s && notify(record);
        return P;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function(onRejected){
        return this.then(undefined, onRejected);
      }
    });
    assignHidden(Promise, {
      // 25.4.4.1 Promise.all(iterable)
      all: function(iterable){
        var Promise = getConstructor(this)
          , values  = [];
        return new Promise(function(resolve, reject){
          forOf(iterable, false, push, values);
          var remaining = values.length
            , results   = Array(remaining);
          if(remaining)forEach.call(values, function(promise, index){
            Promise.resolve(promise).then(function(value){
              results[index] = value;
              --remaining || resolve(results);
            }, reject);
          });
          else resolve(results);
        });
      },
      // 25.4.4.4 Promise.race(iterable)
      race: function(iterable){
        var Promise = getConstructor(this);
        return new Promise(function(resolve, reject){
          forOf(iterable, false, function(promise){
            Promise.resolve(promise).then(resolve, reject);
          });
        });
      },
      // 25.4.4.5 Promise.reject(r)
      reject: function(r){
        return new (getConstructor(this))(function(resolve, reject){
          reject(r);
        });
      },
      // 25.4.4.6 Promise.resolve(x)
      resolve: function(x){
        return isObject(x) && RECORD in x && getPrototypeOf(x) === this[PROTOTYPE]
          ? x : new (getConstructor(this))(function(resolve, reject){
            resolve(x);
          });
      }
    });
  }(nextTick || setImmediate, safeSymbol('record'));
  setToStringTag(Promise, PROMISE);
  setSpecies(Promise);
  $define(GLOBAL + FORCED * !isNative(Promise), {Promise: Promise});
}(global[PROMISE]);

/******************************************************************************
 * Module : es6.collections                                                   *
 ******************************************************************************/

// ECMAScript 6 collections shim
!function(){
  var UID   = safeSymbol('uid')
    , O1    = safeSymbol('O1')
    , WEAK  = safeSymbol('weak')
    , LEAK  = safeSymbol('leak')
    , LAST  = safeSymbol('last')
    , FIRST = safeSymbol('first')
    , SIZE  = DESC ? safeSymbol('size') : 'size'
    , uid   = 0
    , tmp   = {};
  
  function getCollection(C, NAME, methods, commonMethods, isMap, isWeak){
    var ADDER = isMap ? 'set' : 'add'
      , proto = C && C[PROTOTYPE]
      , O     = {};
    function initFromIterable(that, iterable){
      if(iterable != undefined)forOf(iterable, isMap, that[ADDER], that);
      return that;
    }
    function fixSVZ(key, chain){
      var method = proto[key];
      if(framework)proto[key] = function(a, b){
        var result = method.call(this, a === 0 ? 0 : a, b);
        return chain ? this : result;
      };
    }
    if(!isNative(C) || !(isWeak || (!BUGGY_ITERATORS && has(proto, FOR_EACH) && has(proto, 'entries')))){
      // create collection constructor
      C = isWeak
        ? function(iterable){
            assertInstance(this, C, NAME);
            set(this, UID, uid++);
            initFromIterable(this, iterable);
          }
        : function(iterable){
            var that = this;
            assertInstance(that, C, NAME);
            set(that, O1, create(null));
            set(that, SIZE, 0);
            set(that, LAST, undefined);
            set(that, FIRST, undefined);
            initFromIterable(that, iterable);
          };
      assignHidden(assignHidden(C[PROTOTYPE], methods), commonMethods);
      isWeak || !DESC || defineProperty(C[PROTOTYPE], 'size', {get: function(){
        return assertDefined(this[SIZE]);
      }});
    } else {
      var Native = C
        , inst   = new C
        , chain  = inst[ADDER](isWeak ? {} : -0, 1)
        , buggyZero;
      // wrap to init collections from iterable
      if(checkDangerIterClosing(function(O){ new C(O) })){
        C = function(iterable){
          assertInstance(this, C, NAME);
          return initFromIterable(new Native, iterable);
        }
        C[PROTOTYPE] = proto;
        if(framework)proto[CONSTRUCTOR] = C;
      }
      isWeak || inst[FOR_EACH](function(val, key){
        buggyZero = 1 / key === -Infinity;
      });
      // fix converting -0 key to +0
      if(buggyZero){
        fixSVZ('delete');
        fixSVZ('has');
        isMap && fixSVZ('get');
      }
      // + fix .add & .set for chaining
      if(buggyZero || chain !== inst)fixSVZ(ADDER, true);
    }
    setToStringTag(C, NAME);
    setSpecies(C);
    
    O[NAME] = C;
    $define(GLOBAL + WRAP + FORCED * !isNative(C), O);
    
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    isWeak || defineStdIterators(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return iterResult(1);
      }
      // return step by kind
      if(kind == KEY)  return iterResult(0, entry.k);
      if(kind == VALUE)return iterResult(0, entry.v);
                       return iterResult(0, [entry.k, entry.v]);   
    }, isMap ? KEY+VALUE : VALUE, !isMap);
    
    return C;
  }
  
  function fastKey(it, create){
    // return primitive with prefix
    if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;
    // can't set id to frozen object
    if(isFrozen(it))return 'F';
    if(!has(it, UID)){
      // not necessary to add id
      if(!create)return 'E';
      // add missing object id
      hidden(it, UID, ++uid);
    // return object id with prefix
    } return 'O' + it[UID];
  }
  function getEntry(that, key){
    // fast case
    var index = fastKey(key), entry;
    if(index != 'F')return that[O1][index];
    // frozen object case
    for(entry = that[FIRST]; entry; entry = entry.n){
      if(entry.k == key)return entry;
    }
  }
  function def(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry)entry.v = value;
    // create new entry
    else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index != 'F')that[O1][index] = entry;
    } return that;
  }

  var collectionMethods = {
    // 23.1.3.1 Map.prototype.clear()
    // 23.2.3.2 Set.prototype.clear()
    clear: function(){
      for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
        entry.r = true;
        if(entry.p)entry.p = entry.p.n = undefined;
        delete data[entry.i];
      }
      that[FIRST] = that[LAST] = undefined;
      that[SIZE] = 0;
    },
    // 23.1.3.3 Map.prototype.delete(key)
    // 23.2.3.4 Set.prototype.delete(value)
    'delete': function(key){
      var that  = this
        , entry = getEntry(that, key);
      if(entry){
        var next = entry.n
          , prev = entry.p;
        delete that[O1][entry.i];
        entry.r = true;
        if(prev)prev.n = next;
        if(next)next.p = prev;
        if(that[FIRST] == entry)that[FIRST] = next;
        if(that[LAST] == entry)that[LAST] = prev;
        that[SIZE]--;
      } return !!entry;
    },
    // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
    // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
    forEach: function(callbackfn /*, that = undefined */){
      var f = ctx(callbackfn, arguments[1], 3)
        , entry;
      while(entry = entry ? entry.n : this[FIRST]){
        f(entry.v, entry.k, this);
        // revert to the last existing entry
        while(entry && entry.r)entry = entry.p;
      }
    },
    // 23.1.3.7 Map.prototype.has(key)
    // 23.2.3.7 Set.prototype.has(value)
    has: function(key){
      return !!getEntry(this, key);
    }
  }
  
  // 23.1 Map Objects
  Map = getCollection(Map, MAP, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function(key){
      var entry = getEntry(this, key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function(key, value){
      return def(this, key === 0 ? 0 : key, value);
    }
  }, collectionMethods, true);
  
  // 23.2 Set Objects
  Set = getCollection(Set, SET, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function(value){
      return def(this, value = value === 0 ? 0 : value, value);
    }
  }, collectionMethods);
  
  function defWeak(that, key, value){
    if(isFrozen(assertObject(key)))leakStore(that).set(key, value);
    else {
      has(key, WEAK) || hidden(key, WEAK, {});
      key[WEAK][that[UID]] = value;
    } return that;
  }
  function leakStore(that){
    return that[LEAK] || hidden(that, LEAK, new Map)[LEAK];
  }
  
  var weakMethods = {
    // 23.3.3.2 WeakMap.prototype.delete(key)
    // 23.4.3.3 WeakSet.prototype.delete(value)
    'delete': function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this)['delete'](key);
      return has(key, WEAK) && has(key[WEAK], this[UID]) && delete key[WEAK][this[UID]];
    },
    // 23.3.3.4 WeakMap.prototype.has(key)
    // 23.4.3.4 WeakSet.prototype.has(value)
    has: function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this).has(key);
      return has(key, WEAK) && has(key[WEAK], this[UID]);
    }
  };
  
  // 23.3 WeakMap Objects
  WeakMap = getCollection(WeakMap, WEAKMAP, {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function(key){
      if(isObject(key)){
        if(isFrozen(key))return leakStore(this).get(key);
        if(has(key, WEAK))return key[WEAK][this[UID]];
      }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function(key, value){
      return defWeak(this, key, value);
    }
  }, weakMethods, true, true);
  
  // IE11 WeakMap frozen keys fix
  if(framework && new WeakMap().set(Object.freeze(tmp), 7).get(tmp) != 7){
    forEach.call(array('delete,has,get,set'), function(key){
      var method = WeakMap[PROTOTYPE][key];
      WeakMap[PROTOTYPE][key] = function(a, b){
        // store frozen objects on leaky map
        if(isObject(a) && isFrozen(a)){
          var result = leakStore(this)[key](a, b);
          return key == 'set' ? this : result;
        // store all the rest on native weakmap
        } return method.call(this, a, b);
      };
    });
  }
  
  // 23.4 WeakSet Objects
  WeakSet = getCollection(WeakSet, WEAKSET, {
    // 23.4.3.1 WeakSet.prototype.add(value)
    add: function(value){
      return defWeak(this, value, true);
    }
  }, weakMethods, false, true);
}();

/******************************************************************************
 * Module : es6.reflect                                                       *
 ******************************************************************************/

!function(){
  function Enumerate(iterated){
    var keys = [], key;
    for(key in iterated)keys.push(key);
    set(this, ITER, {o: iterated, a: keys, i: 0});
  }
  createIterator(Enumerate, OBJECT, function(){
    var iter = this[ITER]
      , keys = iter.a
      , key;
    do {
      if(iter.i >= keys.length)return iterResult(1);
    } while(!((key = keys[iter.i++]) in iter.o));
    return iterResult(0, key);
  });
  
  function wrap(fn){
    return function(it){
      assertObject(it);
      try {
        return fn.apply(undefined, arguments), true;
      } catch(e){
        return false;
      }
    }
  }
  
  function reflectGet(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = getOwnDescriptor(assertObject(target), propertyKey), proto;
    if(desc)return has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getPrototypeOf(target))
      ? reflectGet(proto, propertyKey, receiver)
      : undefined;
  }
  function reflectSet(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = getOwnDescriptor(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getPrototypeOf(target))){
        return reflectSet(proto, propertyKey, V, receiver);
      }
      ownDesc = descriptor(0);
    }
    if(has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = getOwnDescriptor(receiver, propertyKey) || descriptor(0);
      existingDescriptor.value = V;
      return defineProperty(receiver, propertyKey, existingDescriptor), true;
    }
    return ownDesc.set === undefined
      ? false
      : (ownDesc.set.call(receiver, V), true);
  }
  var isExtensible = Object.isExtensible || returnIt;
  
  var reflect = {
    // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
    apply: ctx(call, apply, 3),
    // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
    construct: function(target, argumentsList /*, newTarget*/){
      var proto    = assertFunction(arguments.length < 3 ? target : arguments[2])[PROTOTYPE]
        , instance = create(isObject(proto) ? proto : ObjectProto)
        , result   = apply.call(target, instance, argumentsList);
      return isObject(result) ? result : instance;
    },
    // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
    defineProperty: wrap(defineProperty),
    // 26.1.4 Reflect.deleteProperty(target, propertyKey)
    deleteProperty: function(target, propertyKey){
      var desc = getOwnDescriptor(assertObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    },
    // 26.1.5 Reflect.enumerate(target)
    enumerate: function(target){
      return new Enumerate(assertObject(target));
    },
    // 26.1.6 Reflect.get(target, propertyKey [, receiver])
    get: reflectGet,
    // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
    getOwnPropertyDescriptor: function(target, propertyKey){
      return getOwnDescriptor(assertObject(target), propertyKey);
    },
    // 26.1.8 Reflect.getPrototypeOf(target)
    getPrototypeOf: function(target){
      return getPrototypeOf(assertObject(target));
    },
    // 26.1.9 Reflect.has(target, propertyKey)
    has: function(target, propertyKey){
      return propertyKey in target;
    },
    // 26.1.10 Reflect.isExtensible(target)
    isExtensible: function(target){
      return !!isExtensible(assertObject(target));
    },
    // 26.1.11 Reflect.ownKeys(target)
    ownKeys: ownKeys,
    // 26.1.12 Reflect.preventExtensions(target)
    preventExtensions: wrap(Object.preventExtensions || returnIt),
    // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
    set: reflectSet
  }
  // 26.1.14 Reflect.setPrototypeOf(target, proto)
  if(setPrototypeOf)reflect.setPrototypeOf = function(target, proto){
    return setPrototypeOf(assertObject(target), proto), true;
  };
  
  $define(GLOBAL, {Reflect: {}});
  $define(STATIC, 'Reflect', reflect);
}();

/******************************************************************************
 * Module : es7.proposals                                                     *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // https://github.com/domenic/Array.prototype.includes
    includes: createArrayContains(true)
  });
  $define(PROTO, STRING, {
    // https://github.com/mathiasbynens/String.prototype.at
    at: createPointAt(true)
  });
  
  function createObjectToArray(isEntries){
    return function(object){
      var O      = toObject(object)
        , keys   = getKeys(object)
        , length = keys.length
        , i      = 0
        , result = Array(length)
        , key;
      if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
      else while(length > i)result[i] = O[keys[i++]];
      return result;
    }
  }
  $define(STATIC, OBJECT, {
    // https://gist.github.com/WebReflection/9353781
    getOwnPropertyDescriptors: function(object){
      var O      = toObject(object)
        , result = {};
      forEach.call(ownKeys(O), function(key){
        defineProperty(result, key, descriptor(0, getOwnDescriptor(O, key)));
      });
      return result;
    },
    // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-9.md#51-objectentries-objectvalues
    values:  createObjectToArray(false),
    entries: createObjectToArray(true)
  });
  $define(STATIC, REGEXP, {
    // https://gist.github.com/kangax/9698100
    escape: createReplacer(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
  });
}();

/******************************************************************************
 * Module : es7.abstract-refs                                                 *
 ******************************************************************************/

// https://github.com/zenparsing/es-abstract-refs
!function(REFERENCE){
  REFERENCE_GET = getWellKnownSymbol(REFERENCE+'Get', true);
  var REFERENCE_SET = getWellKnownSymbol(REFERENCE+SET, true)
    , REFERENCE_DELETE = getWellKnownSymbol(REFERENCE+'Delete', true);
  
  $define(STATIC, SYMBOL, {
    referenceGet: REFERENCE_GET,
    referenceSet: REFERENCE_SET,
    referenceDelete: REFERENCE_DELETE
  });
  
  hidden(FunctionProto, REFERENCE_GET, returnThis);
  
  function setMapMethods(Constructor){
    if(Constructor){
      var MapProto = Constructor[PROTOTYPE];
      hidden(MapProto, REFERENCE_GET, MapProto.get);
      hidden(MapProto, REFERENCE_SET, MapProto.set);
      hidden(MapProto, REFERENCE_DELETE, MapProto['delete']);
    }
  }
  setMapMethods(Map);
  setMapMethods(WeakMap);
}('reference');

/******************************************************************************
 * Module : core.dict                                                         *
 ******************************************************************************/

!function(DICT){
  Dict = function(iterable){
    var dict = create(null);
    if(iterable != undefined){
      if(isIterable(iterable)){
        forOf(iterable, true, function(key, value){
          dict[key] = value;
        });
      } else assign(dict, iterable);
    }
    return dict;
  }
  Dict[PROTOTYPE] = null;
  
  function DictIterator(iterated, kind){
    set(this, ITER, {o: toObject(iterated), a: getKeys(iterated), i: 0, k: kind});
  }
  createIterator(DictIterator, DICT, function(){
    var iter = this[ITER]
      , O    = iter.o
      , keys = iter.a
      , kind = iter.k
      , key;
    do {
      if(iter.i >= keys.length){
        iter.o = undefined;
        return iterResult(1);
      }
    } while(!has(O, key = keys[iter.i++]));
    if(kind == KEY)  return iterResult(0, key);
    if(kind == VALUE)return iterResult(0, O[key]);
                     return iterResult(0, [key, O[key]]);
  });
  function createDictIter(kind){
    return function(it){
      return new DictIterator(it, kind);
    }
  }
  
  /*
   * 0 -> forEach
   * 1 -> map
   * 2 -> filter
   * 3 -> some
   * 4 -> every
   * 5 -> find
   * 6 -> findKey
   * 7 -> mapPairs
   */
  function createDictMethod(type){
    var isMap    = type == 1
      , isEvery  = type == 4;
    return function(object, callbackfn, that /* = undefined */){
      var f      = ctx(callbackfn, that, 3)
        , O      = toObject(object)
        , result = isMap || type == 7 || type == 2 ? new (generic(this, Dict)) : undefined
        , key, val, res;
      for(key in O)if(has(O, key)){
        val = O[key];
        res = f(val, key, object);
        if(type){
          if(isMap)result[key] = res;             // map
          else if(res)switch(type){
            case 2: result[key] = val; break      // filter
            case 3: return true;                  // some
            case 5: return val;                   // find
            case 6: return key;                   // findKey
            case 7: result[res[0]] = res[1];      // mapPairs
          } else if(isEvery)return false;         // every
        }
      }
      return type == 3 || isEvery ? isEvery : result;
    }
  }
  function createDictReduce(isTurn){
    return function(object, mapfn, init){
      assertFunction(mapfn);
      var O      = toObject(object)
        , keys   = getKeys(O)
        , length = keys.length
        , i      = 0
        , memo, key, result;
      if(isTurn)memo = init == undefined ? new (generic(this, Dict)) : Object(init);
      else if(arguments.length < 3){
        assert(length, REDUCE_ERROR);
        memo = O[keys[i++]];
      } else memo = Object(init);
      while(length > i)if(has(O, key = keys[i++])){
        result = mapfn(memo, O[key], key, object);
        if(isTurn){
          if(result === false)break;
        } else memo = result;
      }
      return memo;
    }
  }
  var findKey = createDictMethod(6);
  function includes(object, el){
    return (el == el ? keyOf(object, el) : findKey(object, sameNaN)) !== undefined;
  }
  
  var dictMethods = {
    keys:    createDictIter(KEY),
    values:  createDictIter(VALUE),
    entries: createDictIter(KEY+VALUE),
    forEach: createDictMethod(0),
    map:     createDictMethod(1),
    filter:  createDictMethod(2),
    some:    createDictMethod(3),
    every:   createDictMethod(4),
    find:    createDictMethod(5),
    findKey: findKey,
    mapPairs:createDictMethod(7),
    reduce:  createDictReduce(false),
    turn:    createDictReduce(true),
    keyOf:   keyOf,
    includes:includes,
    // Has / get / set own property
    has: has,
    get: get,
    set: createDefiner(0),
    isDict: function(it){
      return isObject(it) && getPrototypeOf(it) === Dict[PROTOTYPE];
    }
  };
  
  if(REFERENCE_GET)for(var key in dictMethods)!function(fn){
    function method(){
      for(var args = [this], i = 0; i < arguments.length;)args.push(arguments[i++]);
      return invoke(fn, args);
    }
    fn[REFERENCE_GET] = function(){
      return method;
    }
  }(dictMethods[key]);
  
  $define(GLOBAL + FORCED, {Dict: assignHidden(Dict, dictMethods)});
}('Dict');

/******************************************************************************
 * Module : core.$for                                                         *
 ******************************************************************************/

!function(ENTRIES, FN){  
  function $for(iterable, entries){
    if(!(this instanceof $for))return new $for(iterable, entries);
    this[ITER]    = getIterator(iterable);
    this[ENTRIES] = !!entries;
  }
  
  createIterator($for, 'Wrapper', function(){
    return this[ITER].next();
  });
  var $forProto = $for[PROTOTYPE];
  setIterator($forProto, function(){
    return this[ITER]; // unwrap
  });
  
  function createChainIterator(next){
    function Iter(I, fn, that){
      this[ITER]    = getIterator(I);
      this[ENTRIES] = I[ENTRIES];
      this[FN]      = ctx(fn, that, I[ENTRIES] ? 2 : 1);
    }
    createIterator(Iter, 'Chain', next, $forProto);
    setIterator(Iter[PROTOTYPE], returnThis); // override $forProto iterator
    return Iter;
  }
  
  var MapIter = createChainIterator(function(){
    var step = this[ITER].next();
    return step.done ? step : iterResult(0, stepCall(this[FN], step.value, this[ENTRIES]));
  });
  
  var FilterIter = createChainIterator(function(){
    for(;;){
      var step = this[ITER].next();
      if(step.done || stepCall(this[FN], step.value, this[ENTRIES]))return step;
    }
  });
  
  assignHidden($forProto, {
    of: function(fn, that){
      forOf(this, this[ENTRIES], fn, that);
    },
    array: function(fn, that){
      var result = [];
      forOf(fn != undefined ? this.map(fn, that) : this, false, push, result);
      return result;
    },
    filter: function(fn, that){
      return new FilterIter(this, fn, that);
    },
    map: function(fn, that){
      return new MapIter(this, fn, that);
    }
  });
  
  $for.isIterable  = isIterable;
  $for.getIterator = getIterator;
  
  $define(GLOBAL + FORCED, {$for: $for});
}('entries', safeSymbol('fn'));

/******************************************************************************
 * Module : core.delay                                                        *
 ******************************************************************************/

// https://esdiscuss.org/topic/promise-returning-delay-function
$define(GLOBAL + FORCED, {
  delay: function(time){
    return new Promise(function(resolve){
      setTimeout(resolve, time, true);
    });
  }
});

/******************************************************************************
 * Module : core.binding                                                      *
 ******************************************************************************/

!function(_, toLocaleString){
  // Placeholder
  core._ = path._ = path._ || {};

  $define(PROTO + FORCED, FUNCTION, {
    part: part,
    only: function(numberArguments, that /* = @ */){
      var fn     = assertFunction(this)
        , n      = toLength(numberArguments)
        , isThat = arguments.length > 1;
      return function(/* ...args */){
        var length = min(n, arguments.length)
          , args   = Array(length)
          , i      = 0;
        while(length > i)args[i] = arguments[i++];
        return invoke(fn, args, isThat ? that : this);
      }
    }
  });
  
  function tie(key){
    var that  = this
      , bound = {};
    return hidden(that, _, function(key){
      if(key === undefined || !(key in that))return toLocaleString.call(that);
      return has(bound, key) ? bound[key] : (bound[key] = ctx(that[key], that, -1));
    })[_](key);
  }
  
  hidden(path._, TO_STRING, function(){
    return _;
  });
  
  hidden(ObjectProto, _, tie);
  DESC || hidden(ArrayProto, _, tie);
  // IE8- dirty hack - redefined toLocaleString is not enumerable
}(DESC ? uid('tie') : TO_LOCALE, ObjectProto[TO_LOCALE]);

/******************************************************************************
 * Module : core.object                                                       *
 ******************************************************************************/

!function(){
  function define(target, mixin){
    var keys   = ownKeys(toObject(mixin))
      , length = keys.length
      , i = 0, key;
    while(length > i)defineProperty(target, key = keys[i++], getOwnDescriptor(mixin, key));
    return target;
  };
  $define(STATIC + FORCED, OBJECT, {
    isObject: isObject,
    classof: classof,
    define: define,
    make: function(proto, mixin){
      return define(create(proto), mixin);
    }
  });
}();

/******************************************************************************
 * Module : core.array                                                        *
 ******************************************************************************/

$define(PROTO + FORCED, ARRAY, {
  turn: function(fn, target /* = [] */){
    assertFunction(fn);
    var memo   = target == undefined ? [] : Object(target)
      , O      = ES5Object(this)
      , length = toLength(O.length)
      , index  = 0;
    while(length > index)if(fn(memo, O[index], index++, this) === false)break;
    return memo;
  }
});
if(framework)ArrayUnscopables.turn = true;

/******************************************************************************
 * Module : core.number                                                       *
 ******************************************************************************/

!function(numberMethods){  
  function NumberIterator(iterated){
    set(this, ITER, {l: toLength(iterated), i: 0});
  }
  createIterator(NumberIterator, NUMBER, function(){
    var iter = this[ITER]
      , i    = iter.i++;
    return i < iter.l ? iterResult(0, i) : iterResult(1);
  });
  defineIterator(Number, NUMBER, function(){
    return new NumberIterator(this);
  });
  
  numberMethods.random = function(lim /* = 0 */){
    var a = +this
      , b = lim == undefined ? 0 : +lim
      , m = min(a, b);
    return random() * (max(a, b) - m) + m;
  };

  forEach.call(array(
      // ES3:
      'round,floor,ceil,abs,sin,asin,cos,acos,tan,atan,exp,sqrt,max,min,pow,atan2,' +
      // ES6:
      'acosh,asinh,atanh,cbrt,clz32,cosh,expm1,hypot,imul,log1p,log10,log2,sign,sinh,tanh,trunc'
    ), function(key){
      var fn = Math[key];
      if(fn)numberMethods[key] = function(/* ...args */){
        // ie9- dont support strict mode & convert `this` to object -> convert it to number
        var args = [+this]
          , i    = 0;
        while(arguments.length > i)args.push(arguments[i++]);
        return invoke(fn, args);
      }
    }
  );
  
  $define(PROTO + FORCED, NUMBER, numberMethods);
}({});

/******************************************************************************
 * Module : core.string                                                       *
 ******************************************************************************/

!function(){
  var escapeHTMLDict = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&apos;'
  }, unescapeHTMLDict = {}, key;
  for(key in escapeHTMLDict)unescapeHTMLDict[escapeHTMLDict[key]] = key;
  $define(PROTO + FORCED, STRING, {
    escapeHTML:   createReplacer(/[&<>"']/g, escapeHTMLDict),
    unescapeHTML: createReplacer(/&(?:amp|lt|gt|quot|apos);/g, unescapeHTMLDict)
  });
}();

/******************************************************************************
 * Module : core.date                                                         *
 ******************************************************************************/

!function(formatRegExp, flexioRegExp, locales, current, SECONDS, MINUTES, HOURS, MONTH, YEAR){
  function createFormat(prefix){
    return function(template, locale /* = current */){
      var that = this
        , dict = locales[has(locales, locale) ? locale : current];
      function get(unit){
        return that[prefix + unit]();
      }
      return String(template).replace(formatRegExp, function(part){
        switch(part){
          case 's'  : return get(SECONDS);                  // Seconds : 0-59
          case 'ss' : return lz(get(SECONDS));              // Seconds : 00-59
          case 'm'  : return get(MINUTES);                  // Minutes : 0-59
          case 'mm' : return lz(get(MINUTES));              // Minutes : 00-59
          case 'h'  : return get(HOURS);                    // Hours   : 0-23
          case 'hh' : return lz(get(HOURS));                // Hours   : 00-23
          case 'D'  : return get(DATE);                     // Date    : 1-31
          case 'DD' : return lz(get(DATE));                 // Date    : 01-31
          case 'W'  : return dict[0][get('Day')];           // Day     : Понедельник
          case 'N'  : return get(MONTH) + 1;                // Month   : 1-12
          case 'NN' : return lz(get(MONTH) + 1);            // Month   : 01-12
          case 'M'  : return dict[2][get(MONTH)];           // Month   : Январь
          case 'MM' : return dict[1][get(MONTH)];           // Month   : Января
          case 'Y'  : return get(YEAR);                     // Year    : 2014
          case 'YY' : return lz(get(YEAR) % 100);           // Year    : 14
        } return part;
      });
    }
  }
  function addLocale(lang, locale){
    function split(index){
      var result = [];
      forEach.call(array(locale.months), function(it){
        result.push(it.replace(flexioRegExp, '$' + index));
      });
      return result;
    }
    locales[lang] = [array(locale.weekdays), split(1), split(2)];
    return core;
  }
  $define(PROTO + FORCED, DATE, {
    format:    createFormat('get'),
    formatUTC: createFormat('getUTC')
  });
  addLocale(current, {
    weekdays: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday',
    months: 'January,February,March,April,May,June,July,August,September,October,November,December'
  });
  addLocale('ru', {
    weekdays: 'Воскресенье,Понедельник,Вторник,Среда,Четверг,Пятница,Суббота',
    months: 'Январ:я|ь,Феврал:я|ь,Март:а|,Апрел:я|ь,Ма:я|й,Июн:я|ь,' +
            'Июл:я|ь,Август:а|,Сентябр:я|ь,Октябр:я|ь,Ноябр:я|ь,Декабр:я|ь'
  });
  core.locale = function(locale){
    return has(locales, locale) ? current = locale : current;
  };
  core.addLocale = addLocale;
}(/\b\w\w?\b/g, /:(.*)\|(.*)$/, {}, 'en', 'Seconds', 'Minutes', 'Hours', 'Month', 'FullYear');

/******************************************************************************
 * Module : core.global                                                       *
 ******************************************************************************/

$define(GLOBAL + FORCED, {global: global});

/******************************************************************************
 * Module : js.array.statics                                                  *
 ******************************************************************************/

// JavaScript 1.6 / Strawman array statics shim
!function(arrayStatics){
  function setArrayStatics(keys, length){
    forEach.call(array(keys), function(key){
      if(key in ArrayProto)arrayStatics[key] = ctx(call, ArrayProto[key], length);
    });
  }
  setArrayStatics('pop,reverse,shift,keys,values,entries', 1);
  setArrayStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setArrayStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
                  'reduce,reduceRight,copyWithin,fill,turn');
  $define(STATIC, ARRAY, arrayStatics);
}({});

/******************************************************************************
 * Module : web.dom.itarable                                                  *
 ******************************************************************************/

!function(NodeList){
  if(framework && NodeList && !(SYMBOL_ITERATOR in NodeList[PROTOTYPE])){
    hidden(NodeList[PROTOTYPE], SYMBOL_ITERATOR, Iterators[ARRAY]);
  }
  Iterators.NodeList = Iterators[ARRAY];
}(global.NodeList);

/******************************************************************************
 * Module : core.log                                                          *
 ******************************************************************************/

!function(log, enabled){
  // Methods from https://github.com/DeveloperToolsWG/console-object/blob/master/api.md
  forEach.call(array('assert,clear,count,debug,dir,dirxml,error,exception,' +
      'group,groupCollapsed,groupEnd,info,isIndependentlyComposed,log,' +
      'markTimeline,profile,profileEnd,table,time,timeEnd,timeline,' +
      'timelineEnd,timeStamp,trace,warn'), function(key){
    log[key] = function(){
      if(enabled && key in console)return apply.call(console[key], console, arguments);
    };
  });
  $define(GLOBAL + FORCED, {log: assign(log.log, log, {
    enable: function(){
      enabled = true;
    },
    disable: function(){
      enabled = false;
    }
  })});
}({}, true);
}(typeof self != 'undefined' && self.Math === Math ? self : Function('return this')(), false);
module.exports = { "default": module.exports, __esModule: true };

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/helpers.js":[function(require,module,exports){
(function (global){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

var helpers = exports["default"] = {};
exports.__esModule = true;

helpers.inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

helpers.defaults = function (obj, defaults) {
  var keys = _core.Object.getOwnPropertyNames(defaults);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];

    var value = _core.Object.getOwnPropertyDescriptor(defaults, key);

    if (value && value.configurable && obj[key] === undefined) {
      Object.defineProperty(obj, key, value);
    }
  }

  return obj;
};

helpers.prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

helpers.applyConstructor = function (Constructor, args) {
  var instance = Object.create(Constructor.prototype);
  var result = Constructor.apply(instance, args);
  return result != null && (typeof result == "object" || typeof result == "function") ? result : instance;
};

helpers.taggedTemplateLiteral = function (strings, raw) {
  return _core.Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: _core.Object.freeze(raw)
    }
  }));
};

helpers.taggedTemplateLiteralLoose = function (strings, raw) {
  strings.raw = raw;
  return strings;
};

helpers.interopRequire = function (obj) {
  return obj && obj.__esModule ? obj["default"] : obj;
};

helpers.toArray = function (arr) {
  return Array.isArray(arr) ? arr : _core.Array.from(arr);
};

helpers.toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return _core.Array.from(arr);
  }
};

helpers.slicedToArray = function (arr, i) {
  if (Array.isArray(arr)) {
    return arr;
  } else if (_core.$for.isIterable(Object(arr))) {
    var _arr = [];

    for (var _iterator = _core.$for.getIterator(arr), _step; !(_step = _iterator.next()).done;) {
      _arr.push(_step.value);

      if (i && _arr.length === i) break;
    }

    return _arr;
  } else {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
};

helpers.objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

helpers.hasOwn = Object.prototype.hasOwnProperty;
helpers.slice = Array.prototype.slice;
helpers.bind = Function.prototype.bind;

helpers.defineProperty = function (obj, key, value) {
  return Object.defineProperty(obj, key, {
    value: value,
    enumerable: true,
    configurable: true,
    writable: true
  });
};

helpers.asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _core.Promise(function (resolve, reject) {
      var callNext = step.bind(null, "next");
      var callThrow = step.bind(null, "throw");

      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          _core.Promise.resolve(value).then(callNext, callThrow);
        }
      }

      callNext();
    });
  };
};

helpers.interopRequireWildcard = function (obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
};

helpers._typeof = function (obj) {
  return obj && obj.constructor === _core.Symbol ? "symbol" : typeof obj;
};

helpers._extends = _core.Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

helpers.get = function get(_x, _x2, _x3) {
  var _again = true;

  _function: while (_again) {
    _again = false;
    var object = _x,
        property = _x2,
        receiver = _x3;
    desc = parent = getter = undefined;

    var desc = _core.Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = _core.Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        _x = parent;
        _x2 = property;
        _x3 = receiver;
        _again = true;
        continue _function;
      }
    } else if ("value" in desc && desc.writable) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  }
};

helpers.set = function set(_x, _x2, _x3, _x4) {
  var _again = true;

  _function: while (_again) {
    _again = false;
    var object = _x,
        property = _x2,
        value = _x3,
        receiver = _x4;
    desc = parent = setter = undefined;

    var desc = _core.Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = _core.Object.getPrototypeOf(object);

      if (parent !== null) {
        _x = parent;
        _x2 = property;
        _x3 = value;
        _x4 = receiver;
        _again = true;
        continue _function;
      }
    } else if ("value" in desc && desc.writable) {
      return desc.value = value;
    } else {
      var setter = desc.set;

      if (setter !== undefined) {
        return setter.call(receiver, value);
      }
    }
  }
};

helpers.classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

helpers.objectDestructuringEmpty = function (obj) {
  if (obj == null) throw new TypeError("Cannot destructure undefined");
};

helpers.temporalUndefined = {};

helpers.temporalAssertDefined = function (val, name, undef) {
  if (val === undef) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }

  return true;
};

helpers.selfGlobal = typeof global === "undefined" ? self : global;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/index.js":[function(require,module,exports){
(function (global){
// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window : this;

var hasOwn = Object.prototype.hasOwnProperty;
var hadRuntime = hasOwn.call(g, "regeneratorRuntime");
var oldRuntime = hadRuntime && g.regeneratorRuntime;
delete g.regeneratorRuntime; // Force reevalutation of runtime.js.

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  delete g.regeneratorRuntime;
}

module.exports = { "default": module.exports, __esModule: true };

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./runtime":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/runtime.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/regenerator/runtime.js":[function(require,module,exports){
(function (global){
"use strict";

var _core = require("babel-runtime/core-js")["default"];

/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function (global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol = typeof _core.Symbol === "function" && _core.Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    return new Generator(innerFn, outerFn, self || null, tryLocsList || []);
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    return new _core.Promise(function (resolve, reject) {
      var generator = wrap(innerFn, outerFn, self, tryLocsList);
      var callNext = step.bind(generator.next);
      var callThrow = step.bind(generator["throw"]);

      function step(arg) {
        var record = tryCatch(this, null, arg);
        if (record.type === "throw") {
          reject(record.arg);
          return;
        }

        var info = record.arg;
        if (info.done) {
          resolve(info.value);
        } else {
          _core.Promise.resolve(info.value).then(callNext, callThrow);
        }
      }

      callNext();
    });
  };

  function Generator(innerFn, outerFn, self, tryLocsList) {
    var generator = outerFn ? Object.create(outerFn.prototype) : this;
    var context = new Context(tryLocsList);
    var state = GenStateSuspendedStart;

    function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;

            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedStart && typeof arg !== "undefined") {
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
            throw new TypeError("attempt to send " + JSON.stringify(arg) + " to newborn generator");
          }

          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            delete context.sent;
          }
        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }
        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }
        } else if (record.type === "throw") {
          state = GenStateCompleted;

          if (method === "next") {
            context.dispatchException(record.arg);
          } else {
            arg = record.arg;
          }
        }
      }
    }

    generator.next = invoke.bind(generator, "next");
    generator["throw"] = invoke.bind(generator, "throw");
    generator["return"] = invoke.bind(generator, "return");

    return generator;
  }

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset();
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset() {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      // Pre-initialize at least 20 temporary variables to enable hidden
      // class optimizations for simple generators.
      for (var tempIndex = 0, tempName; hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20; ++tempIndex) {
        this[tempName] = null;
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg < finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          return this.complete(entry.completion, entry.afterLoc);
        }
      }
    },

    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : undefined);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"babel-runtime/core-js":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/babel-runtime/core-js.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/collection/forEach.js":[function(require,module,exports){
var arrayEach = require('../internal/arrayEach'),
    baseEach = require('../internal/baseEach'),
    bindCallback = require('../internal/bindCallback'),
    isArray = require('../lang/isArray');

/**
 * Iterates over elements of `collection` invoking `iteratee` for each element.
 * The `iteratee` is bound to `thisArg` and invoked with three arguments;
 * (value, index|key, collection). Iterator functions may exit iteration early
 * by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a `length` property
 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
 * may be used for object iteration.
 *
 * @static
 * @memberOf _
 * @alias each
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array|Object|string} Returns `collection`.
 * @example
 *
 * _([1, 2]).forEach(function(n) {
 *   console.log(n);
 * }).value();
 * // => logs each value from left to right and returns the array
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
 *   console.log(n, key);
 * });
 * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
 */
function forEach(collection, iteratee, thisArg) {
  return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
    ? arrayEach(collection, iteratee)
    : baseEach(collection, bindCallback(iteratee, thisArg, 3));
}

module.exports = forEach;

},{"../internal/arrayEach":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/arrayEach.js","../internal/baseEach":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseEach.js","../internal/bindCallback":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/bindCallback.js","../lang/isArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isArray.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/collection/sample.js":[function(require,module,exports){
var baseRandom = require('../internal/baseRandom'),
    isIterateeCall = require('../internal/isIterateeCall'),
    shuffle = require('./shuffle'),
    toIterable = require('../internal/toIterable');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Gets a random element or `n` random elements from a collection.
 *
 * @static
 * @memberOf _
 * @category Collection
 * @param {Array|Object|string} collection The collection to sample.
 * @param {number} [n] The number of elements to sample.
 * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
 * @returns {*} Returns the random sample(s).
 * @example
 *
 * _.sample([1, 2, 3, 4]);
 * // => 2
 *
 * _.sample([1, 2, 3, 4], 2);
 * // => [3, 1]
 */
function sample(collection, n, guard) {
  if (guard ? isIterateeCall(collection, n, guard) : n == null) {
    collection = toIterable(collection);
    var length = collection.length;
    return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
  }
  var result = shuffle(collection);
  result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
  return result;
}

module.exports = sample;

},{"../internal/baseRandom":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseRandom.js","../internal/isIterateeCall":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isIterateeCall.js","../internal/toIterable":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/toIterable.js","./shuffle":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/collection/shuffle.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/collection/shuffle.js":[function(require,module,exports){
var baseRandom = require('../internal/baseRandom'),
    toIterable = require('../internal/toIterable');

/**
 * Creates an array of shuffled values, using a version of the Fisher-Yates
 * shuffle. See [Wikipedia](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Collection
 * @param {Array|Object|string} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 * @example
 *
 * _.shuffle([1, 2, 3, 4]);
 * // => [4, 1, 3, 2]
 */
function shuffle(collection) {
  collection = toIterable(collection);

  var index = -1,
      length = collection.length,
      result = Array(length);

  while (++index < length) {
    var rand = baseRandom(0, index);
    if (index != rand) {
      result[index] = result[rand];
    }
    result[rand] = collection[index];
  }
  return result;
}

module.exports = shuffle;

},{"../internal/baseRandom":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseRandom.js","../internal/toIterable":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/toIterable.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/collection/size.js":[function(require,module,exports){
var isLength = require('../internal/isLength'),
    keys = require('../object/keys');

/**
 * Gets the size of `collection` by returning `collection.length` for
 * array-like values or the number of own enumerable properties for objects.
 *
 * @static
 * @memberOf _
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @returns {number} Returns the size of `collection`.
 * @example
 *
 * _.size([1, 2, 3]);
 * // => 3
 *
 * _.size({ 'a': 1, 'b': 2 });
 * // => 2
 *
 * _.size('pebbles');
 * // => 7
 */
function size(collection) {
  var length = collection ? collection.length : 0;
  return isLength(length) ? length : keys(collection).length;
}

module.exports = size;

},{"../internal/isLength":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js","../object/keys":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/keys.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/arrayCopy.js":[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function arrayCopy(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = arrayCopy;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/arrayEach.js":[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseCallback.js":[function(require,module,exports){
var baseMatches = require('./baseMatches'),
    baseMatchesProperty = require('./baseMatchesProperty'),
    baseProperty = require('./baseProperty'),
    bindCallback = require('./bindCallback'),
    identity = require('../utility/identity'),
    isBindable = require('./isBindable');

/**
 * The base implementation of `_.callback` which supports specifying the
 * number of arguments to provide to `func`.
 *
 * @private
 * @param {*} [func=_.identity] The value to convert to a callback.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function baseCallback(func, thisArg, argCount) {
  var type = typeof func;
  if (type == 'function') {
    return (typeof thisArg != 'undefined' && isBindable(func))
      ? bindCallback(func, thisArg, argCount)
      : func;
  }
  if (func == null) {
    return identity;
  }
  if (type == 'object') {
    return baseMatches(func);
  }
  return typeof thisArg == 'undefined'
    ? baseProperty(func + '')
    : baseMatchesProperty(func + '', thisArg);
}

module.exports = baseCallback;

},{"../utility/identity":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/utility/identity.js","./baseMatches":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseMatches.js","./baseMatchesProperty":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseMatchesProperty.js","./baseProperty":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseProperty.js","./bindCallback":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/bindCallback.js","./isBindable":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isBindable.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseClone.js":[function(require,module,exports){
var arrayCopy = require('./arrayCopy'),
    arrayEach = require('./arrayEach'),
    baseCopy = require('./baseCopy'),
    baseForOwn = require('./baseForOwn'),
    initCloneArray = require('./initCloneArray'),
    initCloneByTag = require('./initCloneByTag'),
    initCloneObject = require('./initCloneObject'),
    isArray = require('../lang/isArray'),
    isObject = require('../lang/isObject'),
    keys = require('../object/keys');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
cloneableTags[dateTag] = cloneableTags[float32Tag] =
cloneableTags[float64Tag] = cloneableTags[int8Tag] =
cloneableTags[int16Tag] = cloneableTags[int32Tag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[stringTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[mapTag] = cloneableTags[setTag] =
cloneableTags[weakMapTag] = false;

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * The base implementation of `_.clone` without support for argument juggling
 * and `this` binding `customizer` functions.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {Function} [customizer] The function to customize cloning values.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The object `value` belongs to.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates clones with source counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object) : customizer(value);
  }
  if (typeof result != 'undefined') {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return arrayCopy(value, result);
    }
  } else {
    var tag = objToString.call(value),
        isFunc = tag == funcTag;

    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return baseCopy(value, result, keys(value));
      }
    } else {
      return cloneableTags[tag]
        ? initCloneByTag(value, tag, isDeep)
        : (object ? value : {});
    }
  }
  // Check for circular references and return corresponding clone.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == value) {
      return stackB[length];
    }
  }
  // Add the source value to the stack of traversed objects and associate it with its clone.
  stackA.push(value);
  stackB.push(result);

  // Recursively populate clone (susceptible to call stack limits).
  (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
    result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
  });
  return result;
}

module.exports = baseClone;

},{"../lang/isArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isArray.js","../lang/isObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isObject.js","../object/keys":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/keys.js","./arrayCopy":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/arrayCopy.js","./arrayEach":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/arrayEach.js","./baseCopy":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseCopy.js","./baseForOwn":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseForOwn.js","./initCloneArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/initCloneArray.js","./initCloneByTag":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/initCloneByTag.js","./initCloneObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/initCloneObject.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseCopy.js":[function(require,module,exports){
/**
 * Copies the properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Array} props The property names to copy.
 * @returns {Object} Returns `object`.
 */
function baseCopy(source, object, props) {
  if (!props) {
    props = object;
    object = {};
  }
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseEach.js":[function(require,module,exports){
var baseForOwn = require('./baseForOwn'),
    isLength = require('./isLength'),
    toObject = require('./toObject');

/**
 * The base implementation of `_.forEach` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object|string} Returns `collection`.
 */
function baseEach(collection, iteratee) {
  var length = collection ? collection.length : 0;
  if (!isLength(length)) {
    return baseForOwn(collection, iteratee);
  }
  var index = -1,
      iterable = toObject(collection);

  while (++index < length) {
    if (iteratee(iterable[index], index, iterable) === false) {
      break;
    }
  }
  return collection;
}

module.exports = baseEach;

},{"./baseForOwn":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseForOwn.js","./isLength":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js","./toObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/toObject.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseFor.js":[function(require,module,exports){
var toObject = require('./toObject');

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iterator functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
function baseFor(object, iteratee, keysFunc) {
  var index = -1,
      iterable = toObject(object),
      props = keysFunc(object),
      length = props.length;

  while (++index < length) {
    var key = props[index];
    if (iteratee(iterable[key], key, iterable) === false) {
      break;
    }
  }
  return object;
}

module.exports = baseFor;

},{"./toObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/toObject.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseForIn.js":[function(require,module,exports){
var baseFor = require('./baseFor'),
    keysIn = require('../object/keysIn');

/**
 * The base implementation of `_.forIn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForIn(object, iteratee) {
  return baseFor(object, iteratee, keysIn);
}

module.exports = baseForIn;

},{"../object/keysIn":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/keysIn.js","./baseFor":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseFor.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseForOwn.js":[function(require,module,exports){
var baseFor = require('./baseFor'),
    keys = require('../object/keys');

/**
 * The base implementation of `_.forOwn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"../object/keys":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/keys.js","./baseFor":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseFor.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseIsEqual.js":[function(require,module,exports){
var baseIsEqualDeep = require('./baseIsEqualDeep');

/**
 * The base implementation of `_.isEqual` without support for `this` binding
 * `customizer` functions.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isWhere] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
  // Exit early for identical values.
  if (value === other) {
    // Treat `+0` vs. `-0` as not equal.
    return value !== 0 || (1 / value == 1 / other);
  }
  var valType = typeof value,
      othType = typeof other;

  // Exit early for unlike primitive values.
  if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
      value == null || other == null) {
    // Return `false` unless both values are `NaN`.
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
}

module.exports = baseIsEqual;

},{"./baseIsEqualDeep":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseIsEqualDeep.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseIsEqualDeep.js":[function(require,module,exports){
var equalArrays = require('./equalArrays'),
    equalByTag = require('./equalByTag'),
    equalObjects = require('./equalObjects'),
    isArray = require('../lang/isArray'),
    isTypedArray = require('../lang/isTypedArray');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @param {boolean} [isWhere] Specify performing partial comparisons.
 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = objToString.call(object);
    if (objTag == argsTag) {
      objTag = objectTag;
    } else if (objTag != objectTag) {
      objIsArr = isTypedArray(object);
    }
  }
  if (!othIsArr) {
    othTag = objToString.call(other);
    if (othTag == argsTag) {
      othTag = objectTag;
    } else if (othTag != objectTag) {
      othIsArr = isTypedArray(other);
    }
  }
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && !(objIsArr || objIsObj)) {
    return equalByTag(object, other, objTag);
  }
  var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
      othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

  if (valWrapped || othWrapped) {
    return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
  }
  if (!isSameTag) {
    return false;
  }
  // Assume cyclic values are equal.
  // For more information on detecting circular references see https://es5.github.io/#JO.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == object) {
      return stackB[length] == other;
    }
  }
  // Add `object` and `other` to the stack of traversed objects.
  stackA.push(object);
  stackB.push(other);

  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

  stackA.pop();
  stackB.pop();

  return result;
}

module.exports = baseIsEqualDeep;

},{"../lang/isArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isArray.js","../lang/isTypedArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isTypedArray.js","./equalArrays":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/equalArrays.js","./equalByTag":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/equalByTag.js","./equalObjects":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/equalObjects.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseIsFunction.js":[function(require,module,exports){
/**
 * The base implementation of `_.isFunction` without support for environments
 * with incorrect `typeof` results.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 */
function baseIsFunction(value) {
  // Avoid a Chakra JIT bug in compatibility modes of IE 11.
  // See https://github.com/jashkenas/underscore/issues/1621 for more details.
  return typeof value == 'function' || false;
}

module.exports = baseIsFunction;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseIsMatch.js":[function(require,module,exports){
var baseIsEqual = require('./baseIsEqual');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.isMatch` without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Array} props The source property names to match.
 * @param {Array} values The source values to match.
 * @param {Array} strictCompareFlags Strict comparison flags for source values.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
  var length = props.length;
  if (object == null) {
    return !length;
  }
  var index = -1,
      noCustomizer = !customizer;

  while (++index < length) {
    if ((noCustomizer && strictCompareFlags[index])
          ? values[index] !== object[props[index]]
          : !hasOwnProperty.call(object, props[index])
        ) {
      return false;
    }
  }
  index = -1;
  while (++index < length) {
    var key = props[index];
    if (noCustomizer && strictCompareFlags[index]) {
      var result = hasOwnProperty.call(object, key);
    } else {
      var objValue = object[key],
          srcValue = values[index];

      result = customizer ? customizer(objValue, srcValue, key) : undefined;
      if (typeof result == 'undefined') {
        result = baseIsEqual(srcValue, objValue, customizer, true);
      }
    }
    if (!result) {
      return false;
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./baseIsEqual":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseIsEqual.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseMatches.js":[function(require,module,exports){
var baseIsMatch = require('./baseIsMatch'),
    isStrictComparable = require('./isStrictComparable'),
    keys = require('../object/keys');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.matches` which does not clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new function.
 */
function baseMatches(source) {
  var props = keys(source),
      length = props.length;

  if (length == 1) {
    var key = props[0],
        value = source[key];

    if (isStrictComparable(value)) {
      return function(object) {
        return object != null && object[key] === value && hasOwnProperty.call(object, key);
      };
    }
  }
  var values = Array(length),
      strictCompareFlags = Array(length);

  while (length--) {
    value = source[props[length]];
    values[length] = value;
    strictCompareFlags[length] = isStrictComparable(value);
  }
  return function(object) {
    return baseIsMatch(object, props, values, strictCompareFlags);
  };
}

module.exports = baseMatches;

},{"../object/keys":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/keys.js","./baseIsMatch":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseIsMatch.js","./isStrictComparable":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isStrictComparable.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseMatchesProperty.js":[function(require,module,exports){
var baseIsEqual = require('./baseIsEqual'),
    isStrictComparable = require('./isStrictComparable');

/**
 * The base implementation of `_.matchesProperty` which does not coerce `key`
 * to a string.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} value The value to compare.
 * @returns {Function} Returns the new function.
 */
function baseMatchesProperty(key, value) {
  if (isStrictComparable(value)) {
    return function(object) {
      return object != null && object[key] === value;
    };
  }
  return function(object) {
    return object != null && baseIsEqual(value, object[key], null, true);
  };
}

module.exports = baseMatchesProperty;

},{"./baseIsEqual":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseIsEqual.js","./isStrictComparable":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isStrictComparable.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseMerge.js":[function(require,module,exports){
var arrayEach = require('./arrayEach'),
    baseForOwn = require('./baseForOwn'),
    baseMergeDeep = require('./baseMergeDeep'),
    isArray = require('../lang/isArray'),
    isLength = require('./isLength'),
    isObject = require('../lang/isObject'),
    isObjectLike = require('./isObjectLike'),
    isTypedArray = require('../lang/isTypedArray');

/**
 * The base implementation of `_.merge` without support for argument juggling,
 * multiple sources, and `this` binding `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} [customizer] The function to customize merging properties.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates values with source counterparts.
 * @returns {Object} Returns the destination object.
 */
function baseMerge(object, source, customizer, stackA, stackB) {
  if (!isObject(object)) {
    return object;
  }
  var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
  (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
    if (isObjectLike(srcValue)) {
      stackA || (stackA = []);
      stackB || (stackB = []);
      return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
    }
    var value = object[key],
        result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
        isCommon = typeof result == 'undefined';

    if (isCommon) {
      result = srcValue;
    }
    if ((isSrcArr || typeof result != 'undefined') &&
        (isCommon || (result === result ? result !== value : value === value))) {
      object[key] = result;
    }
  });
  return object;
}

module.exports = baseMerge;

},{"../lang/isArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isArray.js","../lang/isObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isObject.js","../lang/isTypedArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isTypedArray.js","./arrayEach":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/arrayEach.js","./baseForOwn":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseForOwn.js","./baseMergeDeep":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseMergeDeep.js","./isLength":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js","./isObjectLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isObjectLike.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseMergeDeep.js":[function(require,module,exports){
var arrayCopy = require('./arrayCopy'),
    isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isLength = require('./isLength'),
    isPlainObject = require('../lang/isPlainObject'),
    isTypedArray = require('../lang/isTypedArray'),
    toPlainObject = require('../lang/toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize merging properties.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates values with source counterparts.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
  var length = stackA.length,
      srcValue = source[key];

  while (length--) {
    if (stackA[length] == srcValue) {
      object[key] = stackB[length];
      return;
    }
  }
  var value = object[key],
      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
      isCommon = typeof result == 'undefined';

  if (isCommon) {
    result = srcValue;
    if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
      result = isArray(value)
        ? value
        : (value ? arrayCopy(value) : []);
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      result = isArguments(value)
        ? toPlainObject(value)
        : (isPlainObject(value) ? value : {});
    }
    else {
      isCommon = false;
    }
  }
  // Add the source value to the stack of traversed objects and associate
  // it with its merged value.
  stackA.push(srcValue);
  stackB.push(result);

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
  } else if (result === result ? result !== value : value === value) {
    object[key] = result;
  }
}

module.exports = baseMergeDeep;

},{"../lang/isArguments":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isArguments.js","../lang/isArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isArray.js","../lang/isPlainObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isPlainObject.js","../lang/isTypedArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isTypedArray.js","../lang/toPlainObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/toPlainObject.js","./arrayCopy":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/arrayCopy.js","./isLength":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseProperty.js":[function(require,module,exports){
/**
 * The base implementation of `_.property` which does not coerce `key` to a string.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseRandom.js":[function(require,module,exports){
/** Native method references. */
var floor = Math.floor;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeRandom = Math.random;

/**
 * The base implementation of `_.random` without support for argument juggling
 * and returning floating-point numbers.
 *
 * @private
 * @param {number} min The minimum possible value.
 * @param {number} max The maximum possible value.
 * @returns {number} Returns the random number.
 */
function baseRandom(min, max) {
  return min + floor(nativeRandom() * (max - min + 1));
}

module.exports = baseRandom;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseSetData.js":[function(require,module,exports){
var identity = require('../utility/identity'),
    metaMap = require('./metaMap');

/**
 * The base implementation of `setData` without support for hot loop detection.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var baseSetData = !metaMap ? identity : function(func, data) {
  metaMap.set(func, data);
  return func;
};

module.exports = baseSetData;

},{"../utility/identity":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/utility/identity.js","./metaMap":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/metaMap.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseToString.js":[function(require,module,exports){
/**
 * Converts `value` to a string if it is not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }
  return value == null ? '' : (value + '');
}

module.exports = baseToString;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseValues.js":[function(require,module,exports){
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * returned by `keysFunc`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  var index = -1,
      length = props.length,
      result = Array(length);

  while (++index < length) {
    result[index] = object[props[index]];
  }
  return result;
}

module.exports = baseValues;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/bindCallback.js":[function(require,module,exports){
var identity = require('../utility/identity');

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (typeof thisArg == 'undefined') {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

module.exports = bindCallback;

},{"../utility/identity":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/utility/identity.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/bufferClone.js":[function(require,module,exports){
(function (global){
var constant = require('../utility/constant'),
    isNative = require('../lang/isNative');

/** Native method references. */
var ArrayBuffer = isNative(ArrayBuffer = global.ArrayBuffer) && ArrayBuffer,
    bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
    floor = Math.floor,
    Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;

/** Used to clone array buffers. */
var Float64Array = (function() {
  // Safari 5 errors when using an array buffer to initialize a typed array
  // where the array buffer's `byteLength` is not a multiple of the typed
  // array's `BYTES_PER_ELEMENT`.
  try {
    var func = isNative(func = global.Float64Array) && func,
        result = new func(new ArrayBuffer(10), 0, 1) && func;
  } catch(e) {}
  return result;
}());

/** Used as the size, in bytes, of each `Float64Array` element. */
var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

/**
 * Creates a clone of the given array buffer.
 *
 * @private
 * @param {ArrayBuffer} buffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function bufferClone(buffer) {
  return bufferSlice.call(buffer, 0);
}
if (!bufferSlice) {
  // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
  bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
    var byteLength = buffer.byteLength,
        floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
        offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
        result = new ArrayBuffer(byteLength);

    if (floatLength) {
      var view = new Float64Array(result, 0, floatLength);
      view.set(new Float64Array(buffer, 0, floatLength));
    }
    if (byteLength != offset) {
      view = new Uint8Array(result, offset);
      view.set(new Uint8Array(buffer, offset));
    }
    return result;
  };
}

module.exports = bufferClone;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../lang/isNative":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isNative.js","../utility/constant":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/utility/constant.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/createAssigner.js":[function(require,module,exports){
var bindCallback = require('./bindCallback'),
    isIterateeCall = require('./isIterateeCall');

/**
 * Creates a function that assigns properties of source object(s) to a given
 * destination object.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return function() {
    var length = arguments.length,
        object = arguments[0];

    if (length < 2 || object == null) {
      return object;
    }
    if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {
      length = 2;
    }
    // Juggle arguments.
    if (length > 3 && typeof arguments[length - 2] == 'function') {
      var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);
    } else if (length > 2 && typeof arguments[length - 1] == 'function') {
      customizer = arguments[--length];
    }
    var index = 0;
    while (++index < length) {
      var source = arguments[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  };
}

module.exports = createAssigner;

},{"./bindCallback":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/bindCallback.js","./isIterateeCall":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isIterateeCall.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/equalArrays.js":[function(require,module,exports){
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing arrays.
 * @param {boolean} [isWhere] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
  var index = -1,
      arrLength = array.length,
      othLength = other.length,
      result = true;

  if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
    return false;
  }
  // Deep compare the contents, ignoring non-numeric properties.
  while (result && ++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    result = undefined;
    if (customizer) {
      result = isWhere
        ? customizer(othValue, arrValue, index)
        : customizer(arrValue, othValue, index);
    }
    if (typeof result == 'undefined') {
      // Recursively compare arrays (susceptible to call stack limits).
      if (isWhere) {
        var othIndex = othLength;
        while (othIndex--) {
          othValue = other[othIndex];
          result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
          if (result) {
            break;
          }
        }
      } else {
        result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
      }
    }
  }
  return !!result;
}

module.exports = equalArrays;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/equalByTag.js":[function(require,module,exports){
/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} value The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag) {
  switch (tag) {
    case boolTag:
    case dateTag:
      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      // Treat `NaN` vs. `NaN` as equal.
      return (object != +object)
        ? other != +other
        // But, treat `-0` vs. `+0` as not equal.
        : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings primitives and string
      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
      return object == (other + '');
  }
  return false;
}

module.exports = equalByTag;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/equalObjects.js":[function(require,module,exports){
var keys = require('../object/keys');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isWhere] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
  var objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isWhere) {
    return false;
  }
  var hasCtor,
      index = -1;

  while (++index < objLength) {
    var key = objProps[index],
        result = hasOwnProperty.call(other, key);

    if (result) {
      var objValue = object[key],
          othValue = other[key];

      result = undefined;
      if (customizer) {
        result = isWhere
          ? customizer(othValue, objValue, key)
          : customizer(objValue, othValue, key);
      }
      if (typeof result == 'undefined') {
        // Recursively compare objects (susceptible to call stack limits).
        result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
      }
    }
    if (!result) {
      return false;
    }
    hasCtor || (hasCtor = key == 'constructor');
  }
  if (!hasCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      return false;
    }
  }
  return true;
}

module.exports = equalObjects;

},{"../object/keys":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/keys.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/initCloneArray.js":[function(require,module,exports){
/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add array properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/initCloneByTag.js":[function(require,module,exports){
var bufferClone = require('./bufferClone');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return bufferClone(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      var buffer = object.buffer;
      return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      var result = new Ctor(object.source, reFlags.exec(object));
      result.lastIndex = object.lastIndex;
  }
  return result;
}

module.exports = initCloneByTag;

},{"./bufferClone":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/bufferClone.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/initCloneObject.js":[function(require,module,exports){
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  var Ctor = object.constructor;
  if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
    Ctor = Object;
  }
  return new Ctor;
}

module.exports = initCloneObject;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isBindable.js":[function(require,module,exports){
var baseSetData = require('./baseSetData'),
    isNative = require('../lang/isNative'),
    support = require('../support');

/** Used to detect named functions. */
var reFuncName = /^\s*function[ \n\r\t]+\w/;

/** Used to detect functions containing a `this` reference. */
var reThis = /\bthis\b/;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/**
 * Checks if `func` is eligible for `this` binding.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
 */
function isBindable(func) {
  var result = !(support.funcNames ? func.name : support.funcDecomp);

  if (!result) {
    var source = fnToString.call(func);
    if (!support.funcNames) {
      result = !reFuncName.test(source);
    }
    if (!result) {
      // Check if `func` references the `this` keyword and store the result.
      result = reThis.test(source) || isNative(func);
      baseSetData(func, result);
    }
  }
  return result;
}

module.exports = isBindable;

},{"../lang/isNative":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isNative.js","../support":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/support.js","./baseSetData":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseSetData.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isIndex.js":[function(require,module,exports){
/**
 * Used as the maximum length of an array-like value.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * for more details.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = +value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isIterateeCall.js":[function(require,module,exports){
var isIndex = require('./isIndex'),
    isLength = require('./isLength'),
    isObject = require('../lang/isObject');

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number') {
    var length = object.length,
        prereq = isLength(length) && isIndex(index, length);
  } else {
    prereq = type == 'string' && index in object;
  }
  if (prereq) {
    var other = object[index];
    return value === value ? value === other : other !== other;
  }
  return false;
}

module.exports = isIterateeCall;

},{"../lang/isObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isObject.js","./isIndex":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isIndex.js","./isLength":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js":[function(require,module,exports){
/**
 * Used as the maximum length of an array-like value.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * for more details.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on ES `ToLength`. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
 * for more details.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isObjectLike.js":[function(require,module,exports){
/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return (value && typeof value == 'object') || false;
}

module.exports = isObjectLike;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isStrictComparable.js":[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
}

module.exports = isStrictComparable;

},{"../lang/isObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isObject.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/metaMap.js":[function(require,module,exports){
(function (global){
var isNative = require('../lang/isNative');

/** Native method references. */
var WeakMap = isNative(WeakMap = global.WeakMap) && WeakMap;

/** Used to store function metadata. */
var metaMap = WeakMap && new WeakMap;

module.exports = metaMap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../lang/isNative":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isNative.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/shimIsPlainObject.js":[function(require,module,exports){
var baseForIn = require('./baseForIn'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * A fallback implementation of `_.isPlainObject` which checks if `value`
 * is an object created by the `Object` constructor or has a `[[Prototype]]`
 * of `null`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 */
function shimIsPlainObject(value) {
  var Ctor;

  // Exit early for non `Object` objects.
  if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
      (!hasOwnProperty.call(value, 'constructor') &&
        (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
    return false;
  }
  // IE < 9 iterates inherited properties before own properties. If the first
  // iterated property is an object's own property then there are no inherited
  // enumerable properties.
  var result;
  // In most environments an object's own properties are iterated before
  // its inherited properties. If the last iterated property is an object's
  // own property then there are no inherited enumerable properties.
  baseForIn(value, function(subValue, key) {
    result = key;
  });
  return typeof result == 'undefined' || hasOwnProperty.call(value, result);
}

module.exports = shimIsPlainObject;

},{"./baseForIn":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseForIn.js","./isObjectLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isObjectLike.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/shimKeys.js":[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isIndex = require('./isIndex'),
    isLength = require('./isLength'),
    keysIn = require('../object/keysIn'),
    support = require('../support');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = length && isLength(length) &&
    (isArray(object) || (support.nonEnumArgs && isArguments(object)));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = shimKeys;

},{"../lang/isArguments":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isArguments.js","../lang/isArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isArray.js","../object/keysIn":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/keysIn.js","../support":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/support.js","./isIndex":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isIndex.js","./isLength":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/toIterable.js":[function(require,module,exports){
var isLength = require('./isLength'),
    isObject = require('../lang/isObject'),
    values = require('../object/values');

/**
 * Converts `value` to an array-like object if it is not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Array|Object} Returns the array-like object.
 */
function toIterable(value) {
  if (value == null) {
    return [];
  }
  if (!isLength(value.length)) {
    return values(value);
  }
  return isObject(value) ? value : Object(value);
}

module.exports = toIterable;

},{"../lang/isObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isObject.js","../object/values":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/values.js","./isLength":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/toObject.js":[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Converts `value` to an object if it is not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

module.exports = toObject;

},{"../lang/isObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isObject.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/clone.js":[function(require,module,exports){
var baseClone = require('../internal/baseClone'),
    bindCallback = require('../internal/bindCallback'),
    isIterateeCall = require('../internal/isIterateeCall');

/**
 * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
 * otherwise they are assigned by reference. If `customizer` is provided it is
 * invoked to produce the cloned values. If `customizer` returns `undefined`
 * cloning is handled by the method instead. The `customizer` is bound to
 * `thisArg` and invoked with two argument; (value [, index|key, object]).
 *
 * **Note:** This method is loosely based on the structured clone algorithm.
 * The enumerable properties of `arguments` objects and objects created by
 * constructors other than `Object` are cloned to plain `Object` objects. An
 * empty object is returned for uncloneable values such as functions, DOM nodes,
 * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {Function} [customizer] The function to customize cloning values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {*} Returns the cloned value.
 * @example
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * var shallow = _.clone(users);
 * shallow[0] === users[0];
 * // => true
 *
 * var deep = _.clone(users, true);
 * deep[0] === users[0];
 * // => false
 *
 * // using a customizer callback
 * var el = _.clone(document.body, function(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(false);
 *   }
 * });
 *
 * el === document.body
 * // => false
 * el.nodeName
 * // => BODY
 * el.childNodes.length;
 * // => 0
 */
function clone(value, isDeep, customizer, thisArg) {
  if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
    isDeep = false;
  }
  else if (typeof isDeep == 'function') {
    thisArg = customizer;
    customizer = isDeep;
    isDeep = false;
  }
  customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
  return baseClone(value, isDeep, customizer);
}

module.exports = clone;

},{"../internal/baseClone":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseClone.js","../internal/bindCallback":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/bindCallback.js","../internal/isIterateeCall":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isIterateeCall.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isArguments.js":[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  var length = isObjectLike(value) ? value.length : undefined;
  return (isLength(length) && objToString.call(value) == argsTag) || false;
}

module.exports = isArguments;

},{"../internal/isLength":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js","../internal/isObjectLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isObjectLike.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isArray.js":[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isNative = require('./isNative'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var arrayTag = '[object Array]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
};

module.exports = isArray;

},{"../internal/isLength":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js","../internal/isObjectLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isObjectLike.js","./isNative":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isNative.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isBoolean.js":[function(require,module,exports){
var isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
}

module.exports = isBoolean;

},{"../internal/isObjectLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isObjectLike.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isFunction.js":[function(require,module,exports){
(function (global){
var baseIsFunction = require('../internal/baseIsFunction'),
    isNative = require('./isNative');

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/** Native method references. */
var Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return objToString.call(value) == funcTag;
};

module.exports = isFunction;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../internal/baseIsFunction":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseIsFunction.js","./isNative":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isNative.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isNative.js":[function(require,module,exports){
var escapeRegExp = require('../string/escapeRegExp'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reHostCtor = /^\[object .+?Constructor\]$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reNative = RegExp('^' +
  escapeRegExp(objToString)
  .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (objToString.call(value) == funcTag) {
    return reNative.test(fnToString.call(value));
  }
  return (isObjectLike(value) && reHostCtor.test(value)) || false;
}

module.exports = isNative;

},{"../internal/isObjectLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isObjectLike.js","../string/escapeRegExp":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/string/escapeRegExp.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isObject.js":[function(require,module,exports){
/**
 * Checks if `value` is the language type of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type == 'function' || (value && type == 'object') || false;
}

module.exports = isObject;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isPlainObject.js":[function(require,module,exports){
var isNative = require('./isNative'),
    shimIsPlainObject = require('../internal/shimIsPlainObject');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/** Native method references. */
var getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf;

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * **Note:** This method assumes objects created by the `Object` constructor
 * have no inherited enumerable properties.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
  if (!(value && objToString.call(value) == objectTag)) {
    return false;
  }
  var valueOf = value.valueOf,
      objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

  return objProto
    ? (value == objProto || getPrototypeOf(value) == objProto)
    : shimIsPlainObject(value);
};

module.exports = isPlainObject;

},{"../internal/shimIsPlainObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/shimIsPlainObject.js","./isNative":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isNative.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isString.js":[function(require,module,exports){
var isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
}

module.exports = isString;

},{"../internal/isObjectLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isObjectLike.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isTypedArray.js":[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dateTag] = typedArrayTags[errorTag] =
typedArrayTags[funcTag] = typedArrayTags[mapTag] =
typedArrayTags[numberTag] = typedArrayTags[objectTag] =
typedArrayTags[regexpTag] = typedArrayTags[setTag] =
typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
}

module.exports = isTypedArray;

},{"../internal/isLength":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js","../internal/isObjectLike":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isObjectLike.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/toPlainObject.js":[function(require,module,exports){
var baseCopy = require('../internal/baseCopy'),
    keysIn = require('../object/keysIn');

/**
 * Converts `value` to a plain object flattening inherited enumerable
 * properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return baseCopy(value, keysIn(value));
}

module.exports = toPlainObject;

},{"../internal/baseCopy":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseCopy.js","../object/keysIn":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/keysIn.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/keys.js":[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isNative = require('../lang/isNative'),
    isObject = require('../lang/isObject'),
    shimKeys = require('../internal/shimKeys');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  if (object) {
    var Ctor = object.constructor,
        length = object.length;
  }
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
     (typeof object != 'function' && (length && isLength(length)))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

module.exports = keys;

},{"../internal/isLength":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js","../internal/shimKeys":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/shimKeys.js","../lang/isNative":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isNative.js","../lang/isObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isObject.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/keysIn.js":[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isIndex = require('../internal/isIndex'),
    isLength = require('../internal/isLength'),
    isObject = require('../lang/isObject'),
    support = require('../support');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keysIn;

},{"../internal/isIndex":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isIndex.js","../internal/isLength":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/isLength.js","../lang/isArguments":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isArguments.js","../lang/isArray":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isArray.js","../lang/isObject":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isObject.js","../support":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/support.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/mapValues.js":[function(require,module,exports){
var baseCallback = require('../internal/baseCallback'),
    baseForOwn = require('../internal/baseForOwn');

/**
 * Creates an object with the same keys as `object` and values generated by
 * running each own enumerable property of `object` through `iteratee`. The
 * iteratee function is bound to `thisArg` and invoked with three arguments;
 * (value, key, object).
 *
 * If a property name is provided for `iteratee` the created `_.property`
 * style callback returns the property value of the given element.
 *
 * If a value is also provided for `thisArg` the created `_.matchesProperty`
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `iteratee` the created `_.matches` style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function|Object|string} [iteratee=_.identity] The function invoked
 *  per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Object} Returns the new mapped object.
 * @example
 *
 * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
 *   return n * 3;
 * });
 * // => { 'a': 3, 'b': 6 }
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * // using the `_.property` callback shorthand
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee, thisArg) {
  var result = {};
  iteratee = baseCallback(iteratee, thisArg, 3);

  baseForOwn(object, function(value, key, object) {
    result[key] = iteratee(value, key, object);
  });
  return result;
}

module.exports = mapValues;

},{"../internal/baseCallback":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseCallback.js","../internal/baseForOwn":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseForOwn.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/merge.js":[function(require,module,exports){
var baseMerge = require('../internal/baseMerge'),
    createAssigner = require('../internal/createAssigner');

/**
 * Recursively merges own enumerable properties of the source object(s), that
 * don't resolve to `undefined` into the destination object. Subsequent sources
 * overwrite property assignments of previous sources. If `customizer` is
 * provided it is invoked to produce the merged values of the destination and
 * source properties. If `customizer` returns `undefined` merging is handled
 * by the method instead. The `customizer` is bound to `thisArg` and invoked
 * with five arguments; (objectValue, sourceValue, key, object, source).
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize merging properties.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var users = {
 *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
 * };
 *
 * var ages = {
 *   'data': [{ 'age': 36 }, { 'age': 40 }]
 * };
 *
 * _.merge(users, ages);
 * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
 *
 * // using a customizer callback
 * var object = {
 *   'fruits': ['apple'],
 *   'vegetables': ['beet']
 * };
 *
 * var other = {
 *   'fruits': ['banana'],
 *   'vegetables': ['carrot']
 * };
 *
 * _.merge(object, other, function(a, b) {
 *   if (_.isArray(a)) {
 *     return a.concat(b);
 *   }
 * });
 * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
 */
var merge = createAssigner(baseMerge);

module.exports = merge;

},{"../internal/baseMerge":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseMerge.js","../internal/createAssigner":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/createAssigner.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/values.js":[function(require,module,exports){
var baseValues = require('../internal/baseValues'),
    keys = require('./keys');

/**
 * Creates an array of the own enumerable property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return baseValues(object, keys(object));
}

module.exports = values;

},{"../internal/baseValues":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseValues.js","./keys":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/object/keys.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/string/escapeRegExp.js":[function(require,module,exports){
var baseToString = require('../internal/baseToString');

/**
 * Used to match `RegExp` special characters.
 * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
 * for more details.
 */
var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
    reHasRegExpChars = RegExp(reRegExpChars.source);

/**
 * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
 * "+", "(", ")", "[", "]", "{" and "}" in `string`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function escapeRegExp(string) {
  string = baseToString(string);
  return (string && reHasRegExpChars.test(string))
    ? string.replace(reRegExpChars, '\\$&')
    : string;
}

module.exports = escapeRegExp;

},{"../internal/baseToString":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/internal/baseToString.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/support.js":[function(require,module,exports){
(function (global){
var isNative = require('./lang/isNative');

/** Used to detect functions containing a `this` reference. */
var reThis = /\bthis\b/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to detect DOM support. */
var document = (document = global.window) && document.document;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * An object environment feature flags.
 *
 * @static
 * @memberOf _
 * @type Object
 */
var support = {};

(function(x) {

  /**
   * Detect if functions can be decompiled by `Function#toString`
   * (all but Firefox OS certified apps, older Opera mobile browsers, and
   * the PlayStation 3; forced `false` for Windows 8 apps).
   *
   * @memberOf _.support
   * @type boolean
   */
  support.funcDecomp = !isNative(global.WinRTError) && reThis.test(function() { return this; });

  /**
   * Detect if `Function#name` is supported (all but IE).
   *
   * @memberOf _.support
   * @type boolean
   */
  support.funcNames = typeof Function.name == 'string';

  /**
   * Detect if the DOM is supported.
   *
   * @memberOf _.support
   * @type boolean
   */
  try {
    support.dom = document.createDocumentFragment().nodeType === 11;
  } catch(e) {
    support.dom = false;
  }

  /**
   * Detect if `arguments` object indexes are non-enumerable.
   *
   * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
   * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
   * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
   * checks for indexes that exceed their function's formal parameters with
   * associated values of `0`.
   *
   * @memberOf _.support
   * @type boolean
   */
  try {
    support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
  } catch(e) {
    support.nonEnumArgs = true;
  }
}(0, 0));

module.exports = support;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lang/isNative":"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/lang/isNative.js"}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/utility/constant.js":[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var getter = _.constant(object);
 *
 * getter() === object;
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/lodash/utility/identity.js":[function(require,module,exports){
/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],"/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/node_modules/tiny-sprintf/dist/sprintf.js":[function(require,module,exports){
/**
 * sprintf implementation. Get pretty indented monospace strings.
 * @param {String} str - the string to parse
 * @param {...*} args - arguments, used in order, or referenced by n$
 * @returns {String}
 * @example
 * // Type casting...
 * sprintf('%s', 10); // '10'
 * sprintf('%s', 'abc'); // 'abc'
 *
 * // Escape anything else
 * sprintf('%%', 1); // '%'
 * sprintf('%T', 'abc'); // 'T'
 *
 * // Limit length
 * sprintf("%.5s", 'abcdef'); // 'bcdef'
 * sprintf("%-.5s", 'abcdef'); // 'abcde'
 *
 * // Indent to length
 * sprintf("%5s", 'a'); // '    a'
 * sprintf("%-5s", 'a'); // 'a    '
 * sprintf("%5.4s", 'abc'); // ' abc'
 * sprintf("%-5.4s", 'abc'); // 'abc '
 *
 * // Use pad chars
 * sprintf("%04s", 10); // "0010"
 * sprintf("%'#4s", 10); // "##10"
 *
 * // Use arguments in order
 * sprintf("%1$s, %2$s, %2$s, %1$s!", 'left', 'right'); // 'left, right, right, left!'
 */

var undefined,
	/* method vars */
	r = /%(\+)?(\d+\$)?(0|'.)?(-)?(\d+)?(\.\d+)?(.)/g,
	s = function(str) {
		var value,
			index = 1,
			execMatch,
			tempVar1,
			tempVar2,
			tempVar3;
		while (execMatch = r.exec(str)) {
			value = execMatch[7];

			// arg from index
			if ((tempVar2 = execMatch[2]) && tempVar2[(tempVar1 = tempVar2.length - 1)] == "$") {
				tempVar2 = tempVar2.substr(0, tempVar1);
			}

			if (s[tempVar1 = value.toLowerCase()] &&
				(tempVar3 = s[tempVar1](arguments[tempVar2 || index], /[A-Z]/.test(value), execMatch[1])) !== undefined) {

				value=''+tempVar3;

				// pad char
				if (tempVar1 = execMatch[3]) {
					if (tempVar1[0] == "'") {
						tempVar1 = tempVar1[1];
					}
				} else {
					tempVar1 = ' ';
				}
				if (tempVar2 = execMatch[5]) while (value.length < tempVar2) {
					value = execMatch[4] ? (value + tempVar1) : (tempVar1 + value);
				}

				if ((tempVar1 = execMatch[6] && execMatch[6].substr(1)) && value.length > tempVar1) {
					value = execMatch[4] ? value.substr(0, tempVar1) : value.substr(value.length - tempVar1);
				}
				index++;
			}
			str = str.substr(0, tempVar1 = execMatch.index) + value + str.substr(r.lastIndex);
			r.lastIndex = value.length + tempVar1;
		}
		return str;
	};

/**
 * Returns string value only if lowercase s.
 * @param {*} value
 * @param {Boolean} caps
 * @returns {String|undefined}
 */
s.s=function(value, caps) {
	return caps ? undefined : value+'';
};

module.exports = s;
},{}]},{},["/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/browser.js"])("/Users/fkling/Dropbox (Personal)/projects/jsnetworkx/jsnx/browser.js")
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqc254L19pbnRlcm5hbHMvQXJyYXlzLmpzIiwianNueC9faW50ZXJuYWxzL01hcC5qcyIsImpzbngvX2ludGVybmFscy9Qcmlvcml0eVF1ZXVlLmpzIiwianNueC9faW50ZXJuYWxzL1NldC5qcyIsImpzbngvX2ludGVybmFscy9jbGVhci5qcyIsImpzbngvX2ludGVybmFscy9jbG9uZS5qcyIsImpzbngvX2ludGVybmFscy9kZWVwY29weS5qcyIsImpzbngvX2ludGVybmFscy9kZWVwbWVyZ2UuanMiLCJqc254L19pbnRlcm5hbHMvZGVsZWdhdGVUb1dvcmtlci5qcyIsImpzbngvX2ludGVybmFscy9maWxsQXJyYXkuanMiLCJqc254L19pbnRlcm5hbHMvZm9yRWFjaC5qcyIsImpzbngvX2ludGVybmFscy9nY2QuanMiLCJqc254L19pbnRlcm5hbHMvZ2VuQ29tYmluYXRpb25zLmpzIiwianNueC9faW50ZXJuYWxzL2dlblBlcm11dGF0aW9ucy5qcyIsImpzbngvX2ludGVybmFscy9nZW5SYW5nZS5qcyIsImpzbngvX2ludGVybmFscy9nZXREZWZhdWx0LmpzIiwianNueC9faW50ZXJuYWxzL2luZGV4LmpzIiwianNueC9faW50ZXJuYWxzL2lzQXJyYXlMaWtlLmpzIiwianNueC9faW50ZXJuYWxzL2lzQm9vbGVhbi5qcyIsImpzbngvX2ludGVybmFscy9pc0dyYXBoLmpzIiwianNueC9faW50ZXJuYWxzL2lzSXRlcmFibGUuanMiLCJqc254L19pbnRlcm5hbHMvaXNJdGVyYXRvci5qcyIsImpzbngvX2ludGVybmFscy9pc01hcC5qcyIsImpzbngvX2ludGVybmFscy9pc1BsYWluT2JqZWN0LmpzIiwianNueC9faW50ZXJuYWxzL2lzU2V0LmpzIiwianNueC9faW50ZXJuYWxzL21hcEl0ZXJhdG9yLmpzIiwianNueC9faW50ZXJuYWxzL21hcFNlcXVlbmNlLmpzIiwianNueC9faW50ZXJuYWxzL21heC5qcyIsImpzbngvX2ludGVybmFscy9tZXNzYWdlLmpzIiwianNueC9faW50ZXJuYWxzL25leHQuanMiLCJqc254L19pbnRlcm5hbHMvbm9kZXNBcmVFcXVhbC5qcyIsImpzbngvX2ludGVybmFscy9yYW5nZS5qcyIsImpzbngvX2ludGVybmFscy9zaXplLmpzIiwianNueC9faW50ZXJuYWxzL3NvbWVJdGVyYXRvci5qcyIsImpzbngvX2ludGVybmFscy9zcHJpbnRmLmpzIiwianNueC9faW50ZXJuYWxzL3RvSXRlcmF0b3IuanMiLCJqc254L19pbnRlcm5hbHMvdHVwbGUuanMiLCJqc254L19pbnRlcm5hbHMvemlwSXRlcmF0b3IuanMiLCJqc254L19pbnRlcm5hbHMvemlwU2VxdWVuY2UuanMiLCJqc254L2FsZ29yaXRobXMvY2VudHJhbGl0eS9iZXR3ZWVubmVzcy5qcyIsImpzbngvYWxnb3JpdGhtcy9jZW50cmFsaXR5L2luZGV4LmpzIiwianNueC9hbGdvcml0aG1zL2NsaXF1ZS5qcyIsImpzbngvYWxnb3JpdGhtcy9jbHVzdGVyLmpzIiwianNueC9hbGdvcml0aG1zL2RhZy5qcyIsImpzbngvYWxnb3JpdGhtcy9ncmFwaGljYWwuanMiLCJqc254L2FsZ29yaXRobXMvaW5kZXguanMiLCJqc254L2FsZ29yaXRobXMvaXNvbW9ycGhpc20vaW5kZXguanMiLCJqc254L2FsZ29yaXRobXMvaXNvbW9ycGhpc20vaXNvbW9ycGguanMiLCJqc254L2FsZ29yaXRobXMvc2hvcnRlc3RQYXRocy9pbmRleC5qcyIsImpzbngvYWxnb3JpdGhtcy9zaG9ydGVzdFBhdGhzL3Vud2VpZ2h0ZWQuanMiLCJqc254L2Jyb3dzZXIuanMiLCJqc254L2NsYXNzZXMvRGlHcmFwaC5qcyIsImpzbngvY2xhc3Nlcy9HcmFwaC5qcyIsImpzbngvY2xhc3Nlcy9NdWx0aURpR3JhcGguanMiLCJqc254L2NsYXNzZXMvTXVsdGlHcmFwaC5qcyIsImpzbngvY2xhc3Nlcy9mdW5jdGlvbnMuanMiLCJqc254L2NsYXNzZXMvaW5kZXguanMiLCJqc254L2NvbnRyaWIvY29udmVydC5qcyIsImpzbngvY29udHJpYi9vYnNlcnZlci5qcyIsImpzbngvY29udHJpYi9wcmVwQ3JlYXRlVXNpbmcuanMiLCJqc254L2NvbnZlcnQuanMiLCJqc254L2RyYXdpbmcvaW5kZXguanMiLCJqc254L2RyYXdpbmcvc3ZnLmpzIiwianNueC9leGNlcHRpb25zL0pTTmV0d29ya1hBbGdvcml0aG1FcnJvci5qcyIsImpzbngvZXhjZXB0aW9ucy9KU05ldHdvcmtYRXJyb3IuanMiLCJqc254L2V4Y2VwdGlvbnMvSlNOZXR3b3JrWEV4Y2VwdGlvbi5qcyIsImpzbngvZXhjZXB0aW9ucy9KU05ldHdvcmtYTm9QYXRoLmpzIiwianNueC9leGNlcHRpb25zL0pTTmV0d29ya1hVbmZlYXNpYmxlLmpzIiwianNueC9leGNlcHRpb25zL0tleUVycm9yLmpzIiwianNueC9leGNlcHRpb25zL2luZGV4LmpzIiwianNueC9nZW5lcmF0b3JzL2NsYXNzaWMuanMiLCJqc254L2dlbmVyYXRvcnMvZGVncmVlU2VxdWVuY2UuanMiLCJqc254L2dlbmVyYXRvcnMvaW5kZXguanMiLCJqc254L2dlbmVyYXRvcnMvcmFuZG9tR3JhcGhzLmpzIiwianNueC9nZW5lcmF0b3JzL3NtYWxsLmpzIiwianNueC9nZW5lcmF0b3JzL3NvY2lhbC5qcyIsImpzbngvaW5kZXguanMiLCJqc254L3JlbGFiZWwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY29sbGVjdGlvbi9mb3JFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9jb2xsZWN0aW9uL3NhbXBsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY29sbGVjdGlvbi9zaHVmZmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9jb2xsZWN0aW9uL3NpemUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2FycmF5Q29weS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYXJyYXlFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlQ2FsbGJhY2suanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VDbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUNvcHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlRm9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlRm9ySW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VGb3JPd24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VJc0VxdWFsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlSXNFcXVhbERlZXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VJc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlSXNNYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZU1hdGNoZXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VNZXJnZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZU1lcmdlRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlUmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlU2V0RGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZVRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlVmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iaW5kQ2FsbGJhY2suanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2J1ZmZlckNsb25lLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9jcmVhdGVBc3NpZ25lci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvZXF1YWxBcnJheXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2VxdWFsQnlUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2VxdWFsT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvaW5pdENsb25lQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2luaXRDbG9uZUJ5VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9pbml0Q2xvbmVPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2lzQmluZGFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2lzSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2lzSXRlcmF0ZWVDYWxsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9pc0xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9pc1N0cmljdENvbXBhcmFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL21ldGFNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL3NoaW1Jc1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9zaGltS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvdG9JdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvdG9PYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2xhbmcvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2xhbmcvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2xhbmcvaXNBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc0Jvb2xlYW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2xhbmcvaXNGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc05hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9sYW5nL2lzU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9sYW5nL2lzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy90b1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9vYmplY3Qva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvb2JqZWN0L2tleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvb2JqZWN0L21hcFZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvb2JqZWN0L21lcmdlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9vYmplY3QvdmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9zdHJpbmcvZXNjYXBlUmVnRXhwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9zdXBwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC91dGlsaXR5L2NvbnN0YW50LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC91dGlsaXR5L2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL3Rpbnktc3ByaW50Zi9kaXN0L3NwcmludGYuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0lDRU8sT0FBTyx3Q0FBTSwyQkFBMkI7O0lBQ3hDLE1BQU0sd0NBQU0sMEJBQTBCOztpQkFFOUIsRUFBQyxPQUFPLEVBQVAsT0FBTyxFQUFFLE1BQU0sRUFBTixNQUFNLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDRXpCLEtBQUssd0NBQU0sU0FBUzs7SUFDcEIsVUFBVSx3Q0FBTSxjQUFjOztJQUM5QixVQUFVLHdDQUFNLHdCQUF3Qjs7SUFDeEMsUUFBUSx3Q0FBTSxzQkFBc0I7O0lBQ3BDLFdBQVcsd0NBQU0sZUFBZTs7SUFDaEMsSUFBSSx3Q0FBTSx3QkFBd0I7O0lBRXBCLEdBQUc7Ozs7Ozs7Ozs7QUFTWCxXQVRRLEdBQUcsQ0FTVixPQUFPO3VDQVRBLEdBQUc7OztBQVdwQixRQUFJLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDekMsUUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pDLFFBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNuQyxRQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRWpDLFFBQUksR0FBRyxFQUFFLEtBQUssQ0FBQzs7QUFFZixRQUFJLE9BQU8sSUFBSSxJQUFJLEVBQUU7QUFDbkIsVUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLEVB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QSxDQUFDOztBQUVLLFNBQVMscUJBQXFCLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRTs7QUFFNUMsTUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFO0FBQzdCLFdBQU8sS0FBSyxDQUFDO0dBQ2Q7OztBQUdELE1BQUksT0FBTyxHQUFHLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUMxQixNQUFJLFVBQVUsR0FBRyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDL0IsTUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ2hCLFNBQU8sQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQyxFQUFLO0FBQ3hCLFVBQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ2xELENBQUMsQ0FBQztBQUNILFFBQU0sQ0FBQyxJQUFJLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQztXQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FBQSxDQUFDLENBQUM7O0FBRWxELE1BQUksT0FBTyxHQUFHLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUMxQixNQUFJLFVBQVUsR0FBRyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDL0IsTUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ2hCLFNBQU8sQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQyxFQUFLO0FBQ3hCLFVBQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ2xELENBQUMsQ0FB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QUksRUFDSixLQUFLLEVBQ0wsS0FBSyxFQUNMLEtBQUssRUFDTCxLQUFLLEVBQ0wsS0FBSyxDQUNOLEVBQ0QsRUFBQyxTQUFTLEVBQUUsQ0FBQyxFQUFDLENBQ2YsQ0FBQzs7QUFFRixHQUFDLENBQUMsY0FBYyxDQUFDLENBQ2YsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxrQkFBa0IsRUFBQyxJQUFJLENBQUMsRUFDekIsQ0FBQyxlQUFlLEVBQUMsSUFBSSxDQUFDLEVBQ3RCLENBQUMsZUFBZSxFQUFDLElBQUksQ0FBQyxFQUN0QixDQUFDLGVBQWUsRUFBQyxJQUFJLENBQUMsRUFDdEIsQ0FBQyxlQUFlLEVBQUMsSUFBSSxDQUFDLEVBQ3RCLENBQUMsZUFBZSxFQUFDLElBQUksQ0FBQyxFQUN0QixDQUFDLGVBQWUsRUFBQyxJQUFJLENBQUMsRUFDdEIsQ0FBQyxlQUFlLEVBQUMsSUFBSSxDQUFDLEVBQ3RCLENBQUMsa0JBQWtCLEVBQUMsSUFBSSxDQUFDLEVBQ3pCLENBQUMsa0JBQWtCLEVBQUMsSUFBSSxDQUFDLEVBQ3pCLENBQUMsa0JBQWtCLEVBQUMsSUFBSSxDQUFDLEVBQ3pCLENBQUMsa0JBQWtCLEVBQUMsSUFBSSxDQUFDLEVBQ3pCLENBQUMsa0JBQWtCLEVBQUMsSUFBSSxDQUFDLEVBQ3pCLENBQUMsa0JBQWtCLEVBQUMsSUFBSSxDQUFDLEVBQ3pCLENBQUMsa0JBQWtCLEVBQUMsSUFBSSxDQUFDLEVBQ3pCLENBQUMsa0JBQWtCLEVBQUMsSUFBSSxDQUFDLEVBQ3pCLENBQUMsYUFBYSxFQUFDLElBQUksQ0FBQyxFQUNwQixDQUFDLGFBQWEsRUFBQyxJQUFJLENBQUMsRUFDcEIsQ0FBQyxhQUFhLEVBQUMsSUFBSSxDQUFDLEVBQ3BCLENBQUMsYUFBYSxFQUFDLElBQUksQ0FBQyxFQUNwQixDQUFDLGtCQUFrQixFQUFDLElBQUksQ0FBQyxFQUN6QixDQUFDLGtCQUFrQixFQUFDLElBQUksQ0FBQyxFQUN6QixDQUFDLGtCQUFrQixFQUFDLElBQUksQ0FBQyxFQUN6QixDQUFDLGFBQWEsRUFBQyxJQUFJLENBQUMsRUFDcEIsQ0FBQyxhQUFhLEVBQUMsSUFBSSxDQUFDLEVBQ3BCLENBQUMsYUFBYSxFQUFDLElBQUksQ0FBQyxFQUNwQixDQUFDLGFBQWEsRUFBQyxJQUFJLENBQUMsRUFDcEIsQ0FBQyxpQkFBaUIsRUFBQyxJQUFJLENBQUMsRUFDeEIsQ0FBQyxpQkFBaUIsRUFBQyxJQUFJLENBQUMsRUFDeEIsQ0FBQyxpQkFBaUIsRUFBQyxJQUFJLENBQUMsRUFDeEIsQ0FBQyxpQkFBaUIsRUFBQyxLQUFLLENBQUMsRUFDekIsQ0FBQyxhQUFhLEVBQUMsSUFBSSxDQUFDLEVBQ3BCLENBQUMsYUFBYSxFQUFDLElBQUksQ0FBQyxFQUNwQixDQUFDLGFBQWEsRUFBQyxLQUFLLENBQUMsRUFDckIsQ0FBQyxhQUFhLEVBQUMsS0FBSyxDQUFDLEVBQ3JCLENBQUMsa0JBQWtCLEVBQUMsSUFBSSxDQUFDLEVBQ3pCLENBQUMsa0JBQWtCLEVBQUMsSUFBSSxDQUFDLEVBQ3pCLENBQUMsa0JBQWtCLEVBQUMsS0FBSyxDQUFDLEVBQzFCLENBQUMsa0JBQWtCLEVBQUMsS0FBSyxDQUFDLEVBQzFCLENBQUMsa0JBQWtCLEVBQUMsS0FBSyxDQUFDLEVBQzFCLENBQUMsa0JBQWtCLEVBQUMsS0FBSyxDQUFDLEVBQzFCLENBQUMsaUJBQWlCLEVBQUMsSUFBSSxDQUFDLEVBQ3hCLENBQUMsaUJBQWlCLEVBQUMsSUFBSSxDQUFDLEVBQ3hCLENBQUMsaUJBQWlCLEVBQUMsSUFBSSxDQUFDLEVBQ3hCLENBQUMsaUJBQWlCLEVBQUMsS0FBSyxDQUFDLEVBQ3pCLENBQUMsaUJBQWlCLEVBQUMsS0FBSyxDQUFDLEVBQ3pCLENBQUMsaUJBQWlCLEVBQUMsS0FBSyxDQUFDLEVBQ3pCLENBQUMsaUJBQWlCLEVBQUMsS0FBSyxDQUFDLEVBQ3pCLENBQUMsY0FBYyxFQUFDLElBQUksQ0FBQyxFQUNyQixDQUFDLGNBQWMsRUFBQyxJQUFJLENBQUMsRUFDckIsQ0FBQyxjQUFjLEVBQUMsSUFBSSxDQUFDLEVBQ3JCLENBQUMsY0FBYyxFQUFDLEtBQUssQ0FBQyxFQUN0QixDQUFDLGNBQWMsRUFBQyxLQUFLLENBQUMsRUFDdEIsQ0FBQyxjQUFjLEVBQUMsS0FBSyxDQUFDLEVBQ3RCLENBQUMsY0FBYyxFQUFDLEtBQUssQ0FBQyxFQUN0QixDQUFDLGNBQWMsRUFBQyxLQUFLLENBQUMsRUFDdEIsQ0FBQyxhQUFhLEVBQUMsSUFBSSxDQUFDLEVBQ3BCLENBQUMsYUFBYSxFQUFDLElBQUks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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3B5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgc2h1ZmZsZSBmcm9tICdsb2Rhc2gvY29sbGVjdGlvbi9zaHVmZmxlJztcbmltcG9ydCBzYW1wbGUgZnJvbSAnbG9kYXNoL2NvbGxlY3Rpb24vc2FtcGxlJztcblxuZXhwb3J0IGRlZmF1bHQge3NodWZmbGUsIHNhbXBsZX07XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlld1xuICogQSBzaGltIGZvciBFUzYgbWFwcyBhbmQgc3VwcG9ydCBmb3IgY3VzdG9tIGhhc2ggZnVuY3Rpb25zIHZpYSB0b1N0cmluZygpXG4gKiBhbmQgZG9lcyBub3QgYWNjZXB0IGFycmF5cyBhcyBrZXlzIChqdXN0IGxpa2UgUHl0aG9uIGRvZXMgbm90IGFjY2VwdCBsaXN0cykuXG4gKi9cblxuaW1wb3J0IGNsZWFyIGZyb20gJy4vY2xlYXInO1xuaW1wb3J0IGlzSXRlcmF0b3IgZnJvbSAnLi9pc0l0ZXJhdG9yJztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJ2xvZGFzaC9sYW5nL2lzRnVuY3Rpb24nO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJ2xvZGFzaC9sYW5nL2lzT2JqZWN0JztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlJztcbmltcG9ydCBzaXplIGZyb20gJ2xvZGFzaC9jb2xsZWN0aW9uL3NpemUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXAge1xuICAvKipcbiAgICogQHBhcmFtIHtJdGVyYWJsZT19IG9wdF9kYXRhIEFuIG9iamVjdCwgYXJyYXkgb3IgaXRlcmF0b3IgdG9cbiAgICogIHBvcHVsYXRlIHRoZSBtYXAgd2l0aC4gSWYgJ2RhdGEnIGlzIGFuIGFycmF5IG9yIGl0ZXJhYmxlLCBlYWNoIGVsZW1lbnQgaXNcbiAgICogIGV4cGVjdGVkIHRvIGJlIGEgMi10dXBsZS4gVGhlIGZpcnN0IGVsZW1lbnQgd2lsbCBiZSB0aGUga2V5IGFuZCBzZWNvbmQgdGhlXG4gICAqICB2YWx1ZS5cbiAgICogIElmIGl0IGlzIGFuIG9iamVjdCwgdGhlIHByb3BlcnR5IG5hbWVzIHdpbGwgYmUgdGhlIGtleXMgYW5kIHRoZSB2YWx1ZSB0aGVcbiAgICogIHZhbHVlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdERhdGEpIHtcbiAgICAvLyBDYW4ndCB1c2UgY2xhc3Mgc3ludGF4IGJlY2F1c2Ugb2YgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuICAgIHRoaXMuX3N0cmluZ1ZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIHN0cmluZ3NcbiAgICB0aGlzLl9udW1iZXJWYWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAvLyBudW1iZXJzXG4gICAgdGhpcy5fdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gZXZlcnkgb3RoZXIgdmFsdWVcbiAgICB0aGlzLl9rZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHZhciBrZXksIHZhbHVlO1xuXG4gICAgaWYgKG9wdERhdGEgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzSXRlcmF0b3Iob3B0RGF0YSkpIHtcbiAgICAgICAgZm9yICh2YXIgW2tleSwgdmFsdWVdIG9mIG9wdERhdGEpIHtcbiAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZihpc0FycmF5TGlrZShvcHREYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBba2V5LCB2YWx1ZV0gPSBvcHREYXRhW2ldO1xuICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc09iamVjdChvcHREYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0RGF0YSkge1xuICAgICAgICAgIHRoaXMuc2V0KGlzTmFOKCtrZXkpID8ga2V5IDogK2tleSwgb3B0RGF0YVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSBzdG9yYWdlIG9iamVjdCBmb3IgYSBnaXZlbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRTdG9yYWdlKGtleSkge1xuICAgIHN3aXRjaCAodHlwZW9mIGtleSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX251bWJlclZhbHVlcztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJpbmdWYWx1ZXM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzO1xuICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgKlxuICAgKiBVbmxpa2UgbmF0aXZlIEVTNiBtYXBzLCB0aGlzIGFsc28gYWNjZXB0cyBhIGRlZmF1bHQgdmFsdWUgd2hpY2ggaXMgcmV0dXJuZWRcbiAgICogaWYgdGhlIG1hcCBkb2VzIG5vdCBjb250YWluIHRoZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBrZXlcbiAgICogQHBhcmFtIHsqPX0gb3B0RGVmYXVsdFZhbHVlXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqIEBleHBvcnRcbiAgICovXG4gIGdldChrZXksIG9wdERlZmF1bHRWYWx1ZSkge1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fZ2V0U3RvcmFnZShrZXkpO1xuICAgIHJldHVybiBrZXkgaW4gc3RvcmFnZSA/IHN0b3JhZ2Vba2V5XSA6IG9wdERlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGtleSBpcyBpbiB0aGUgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGtleVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiB0aGlzLl9nZXRTdG9yYWdlKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgdmFsdWUgYW5kIGtleSB0byB0aGUgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGtleVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqXG4gICAqIEByZXR1cm4ge01hcH0gdGhlIG1hcCBvYmplY3QgaXRzZWxmXG4gICAqIEBleHBvcnRcbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX2dldFN0b3JhZ2Uoa2V5KTtcbiAgICB2YWx1ZXNba2V5XSA9IHZhbHVlO1xuXG4gICAgLy8gc2F2ZSBhY3R1YWwga2V5IHZhbHVlXG4gICAgaWYgKHZhbHVlcyA9PT0gdGhpcy5fdmFsdWVzKSB7XG4gICAgICB0aGlzLl9rZXlzW2tleV0gPSBrZXk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHZhbHVlIHdpdGggZ2l2ZW4ga2V5LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGtleVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBkZWxldGUoa2V5KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX2dldFN0b3JhZ2Uoa2V5KTtcbiAgICBpZiAoa2V5IGluIHZhbHVlcykge1xuICAgICAgZGVsZXRlIHZhbHVlc1trZXldO1xuICAgICAgaWYgKHZhbHVlcyA9PT0gdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9rZXlzW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgKGtleSwgdmFsdWUpIHR1cGxlcy5cbiAgICpcbiAgICogQHJldHVybiB7IUl0ZXJhdG9yfVxuICAgKiBAZXhwb3J0XG4gICovXG4gICplbnRyaWVzKCkge1xuICAgIHZhciBrZXk7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fbnVtYmVyVmFsdWVzKSB7XG4gICAgICB5aWVsZCBbK2tleSwgdGhpcy5fbnVtYmVyVmFsdWVzW2tleV1dO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiB0aGlzLl9zdHJpbmdWYWx1ZXMpIHtcbiAgICAgIHlpZWxkIFtrZXksIHRoaXMuX3N0cmluZ1ZhbHVlc1trZXldXTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fdmFsdWVzKSB7XG4gICAgICB5aWVsZCBbdGhpcy5fa2V5c1trZXldLCB0aGlzLl92YWx1ZXNba2V5XV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciBrZXlzLlxuICAgKlxuICAgKiBAcmV0dXJuIHshSXRlcmF0b3J9XG4gICAqIEBleHBvcnRcbiAgKi9cbiAgKmtleXMoKSB7XG4gICAgdmFyIGtleTtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9udW1iZXJWYWx1ZXMpIHtcbiAgICAgIHlpZWxkICtrZXk7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIHRoaXMuX3N0cmluZ1ZhbHVlcykge1xuICAgICAgeWllbGQga2V5O1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiB0aGlzLl92YWx1ZXMpIHtcbiAgICAgIHlpZWxkIHRoaXMuX2tleXNba2V5XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAqXG4gICAqIEByZXR1cm4geyFBcnJheX1cbiAgICogQGV4cG9ydFxuICAqL1xuICAqdmFsdWVzKCkge1xuICAgIHZhciBrZXk7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fbnVtYmVyVmFsdWVzKSB7XG4gICAgICB5aWVsZCB0aGlzLl9udW1iZXJWYWx1ZXNba2V5XTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fc3RyaW5nVmFsdWVzKSB7XG4gICAgICB5aWVsZCB0aGlzLl9zdHJpbmdWYWx1ZXNba2V5XTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fdmFsdWVzKSB7XG4gICAgICB5aWVsZCB0aGlzLl92YWx1ZXNba2V5XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnQgaW4gdGhlIG1hcC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAZXhwb3J0XG4gICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiBzaXplKHRoaXMuX3ZhbHVlcykgK1xuICAgICAgc2l6ZSh0aGlzLl9udW1iZXJWYWx1ZXMpICtcbiAgICAgIHNpemUodGhpcy5fc3RyaW5nVmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbXB0aWVzIHRoZSBtYXAuXG4gICAqXG4gICAqIEBleHBvcnRcbiAgKi9cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXIodGhpcy5fc3RyaW5nVmFsdWVzKTtcbiAgICBjbGVhcih0aGlzLl9udW1iZXJWYWx1ZXMpO1xuICAgIGNsZWFyKHRoaXMuX3ZhbHVlcyk7XG4gICAgY2xlYXIodGhpcy5fa2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZvciBlYWNoIGl0ZW0gaW4gdGhlIG1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbigqLCopfSBjYWxsYmFjayBBIGZ1bmN0aW9uIHdoaWNoIGdldHMgdGhlIGtleSBhcyBmaXJzdFxuICAgKiAgYXJndW1lbnQgYW5kIHZhbHVlIGFzIHNlY29uZCBhcmd1bWVudC5cbiAgICogQHBhcmFtIHsqPX0gb3B0X3RoaXMgT2JqZWN0L3ZhbHVlIHRvIHNldCB0aGlzIHRvIGluc2lkZSB0aGUgY2FsbGJhY2tcbiAgICogQGV4cG9ydFxuICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrLCBvcHRUaGlzKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIGZvciAodmFyIHYgb2YgdGhpcy5lbnRyaWVzKCkpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwob3B0VGhpcywgdlsxXSwgdlswXSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICogUmV0dXJucyBhbiBpdGVyYXRvciBmb3IgdGhlIG1hcCBvYmplY3QuXG4gICpcbiAgKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGJbMF0gLSBhWzBdO1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIHByaW9yaXR5IHF1ZXVlIGltcGxlbWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmlvcml0eVF1ZXVlIHtcblxuICAvKipcbiAgICogQWNjZXB0cyBhbiBpdGVyYWJsZSB0aGF0IGVtaXRzIGBbcHJpb3JpdHksIHZhbHVlXWAgcGFpcnMuIEl0ZXJhdGVzIG92ZXIgdGhlXG4gICAqIGl0ZXJhYmxlIG9ubHkgb25jZS5cbiAgICpcbiAgICogYHByaW9yaXR5YCBtdXN0IGJlIGEgbnVtYmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZXJhYmxlfSBpdGVyYWJsZVxuICAgKi9cbiAgY29uc3RydWN0b3IoaXRlcmFibGUpIHtcbiAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICBpZiAoaXRlcmFibGUgIT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgW3ByaW9yaXR5LCB2YWx1ZV0gb2YgaXRlcmFibGUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2goW3ByaW9yaXR5LCB2YWx1ZV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fdmFsdWVzLnNvcnQoc29ydGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHZhbHVlIHRvIHRoZSBxdWV1ZS4gSXQgd2lsbCBiZSBpbnNlcnRlZCBpbnRvIHRoZSBxdWV1ZSBhY2NvcmRpbmcgdG9cbiAgICogYHByaW9yaXR5YC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByaW9yaXR5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIGVucXVldWUocHJpb3JpdHksIHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWVzLnB1c2goW3ByaW9yaXR5LCB2YWx1ZV0pO1xuICAgIHRoaXMuX3ZhbHVlcy5zb3J0KHNvcnRlcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbmQgcmV0dXJucyB0aGUgc21hbGxlc3QgW3ByaW9yaXR5LCB2YWx1ZV0gdHVwbGUgZnJvbSB0aGUgcXVldWUuXG4gICAqXG4gICAqIEByZXR1cm4gez99XG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMucG9wKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGg7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBBIHNoaW0gZm9yIEVTNiBtYXBzIGFuZCBzdXBwb3J0IGZvciBjdXN0b20gaGFzaCBmdW5jdGlvbnMgdmlhIHRvU3RyaW5nKCkuXG4gKi9cblxuLypqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5pbXBvcnQgTWFwIGZyb20gJy4vTWFwJztcbi8qanNoaW50IGlnbm9yZTplbmQgKi9cblxudmFyIHRvSXRlcmF0b3IgPSByZXF1aXJlKCcuL3RvSXRlcmF0b3InKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0IHtcblxuICAvKipcbiAgICogQHBhcmFtIHtJdGVyYWJsZX0gb3B0X2RhdGEgQW4gb2JqZWN0LCBhcnJheSBvciBpdGVyYXRvciB0byBwb3B1bGF0ZSB0aGUgc2V0XG4gICAqIHdpdGguXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHREYXRhKSB7XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuXG4gICAgaWYgKG9wdERhdGEgIT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgdiBvZiB0b0l0ZXJhdG9yKG9wdERhdGEpKSB7XG4gICAgICAgIHRoaXMuYWRkKHYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGtleSBpcyBpbiB0aGUgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXModmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgdmFsdWUgYW5kIGtleSB0byB0aGUgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGFkZCh2YWx1ZSkge1xuICAgIHRoaXMuX21hcC5zZXQodmFsdWUsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB2YWx1ZSB3aXRoIGdpdmVuIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBkZWxldGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmRlbGV0ZSh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAqXG4gICAqIEByZXR1cm4geyFJdGVyYXRvcn1cbiAgICogQGV4cG9ydFxuICAgKi9cbiAgdmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAua2V5cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHshSXRlcmF0b3J9XG4gICAqIEBleHBvcnRcbiAgICovXG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAqXG4gICAqIEByZXR1cm4geyFJdGVyYXRvcn1cbiAgICogQGV4cG9ydFxuICAgKi9cbiAgKmVudHJpZXMoKSB7XG4gICAgZm9yICh2YXIgdiBvZiB0aGlzLnZhbHVlcygpKSB7XG4gICAgICB5aWVsZCBbdiwgdl07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQGV4cG9ydFxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5zaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtcHRpZXMgdGhlIHNldC5cbiAgICpcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZvciBlYWNoIGl0ZW0gaW4gdGhlIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbigqKX0gY2FsbGJhY2sgQSBmdW5jdGlvbiB3aGljaCBnZXRzIHRoZSBrZXkgYXMgZmlyc3RcbiAgICogIGFyZ3VtZW50IGFuZCB2YWx1ZSBhcyBzZWNvbmQgYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7Kj19IG9wdF90aGlzIE9iamVjdC92YWx1ZSB0byBzZXQgdGhpcyB0byBpbnNpZGUgdGhlIGNhbGxiYWNrXG4gICAqIEBleHBvcnRcbiAgKi9cbiAgZm9yRWFjaChjYWxsYmFjaywgb3B0VGhpcykge1xuICAgIGZvciAodmFyIHYgb2YgdGhpcy52YWx1ZXMoKSkge1xuICAgICAgY2FsbGJhY2suY2FsbChvcHRUaGlzLCB2LCB2LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKiBFWFRFTlNJT05TICoqL1xuICAvKipcbiAgICogVGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSBub3QgcGFydCBvZiB0aGUgRVM2IFNldCBjbGFzcyBidXQgYXJlIHByb3ZpZGVkXG4gICAqIGZvciBjb252ZW5pZW5jZS4gT25jZSBTZXRzIGJlY29tZSBtb3JlIHdpZGVseSBhdmFpbGFibGUsIHdlIGNvdWxkIHNpbXBseVxuICAgKiBleHRlbmQgdGhlIG5hdGl2ZSBTZXQgY2xhc3MuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHNldCB3aXRoIHRoZSB2YWx1ZXMgb2YgdGhpcyBzZXQsIG5vdCBmb3VuZCBpbiB0aGUgb3RoZXJcbiAgICogc2V0cy5cbiAgICpcbiAgICogQHBhcmFtIHsuLi4oU2V0fEFycmF5KX0gb3RoZXJzXG4gICAqL1xuICBkaWZmZXJlbmNlKC4uLm90aGVycykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgU2V0KHRoaXMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3RoZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm9yICh2YXIgdiBvZiBvdGhlcnNbaV0pIHtcbiAgICAgICAgcmVzdWx0LmRlbGV0ZSh2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHNldCBjb250YWluaW5nIG9ubHkgZWxlbWVudHMgZm91bmQgaW4gdGhpcyBhbmQgZXZlcnlcbiAgICogb3RoZXIgc2V0L2FycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gey4uLihTZXR8QXJyYXkpfSBvdGhlcnNcbiAgICovXG4gIGludGVyc2VjdGlvbiguLi5vdGhlcnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgIGZvciAodmFyIHYgb2YgdGhpcykge1xuICAgICAgaWYgKG90aGVycy5ldmVyeShvdGhlciA9PiBvdGhlci5oYXModikpKSB7XG4gICAgICAgIHJlc3VsdC5hZGQodik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbmQgcmV0dXJucyBhbiBlbGVtZW50IGZyb20gdGhlIHNldC5cbiAgICpcbiAgICogQHJldHVybiB7P31cbiAgICovXG4gIHBvcCgpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICB0aGlzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBjYXRjaCAoZXgpIHt9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBpdGVyYXRvciBmb3IgdGhlIHNldCBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFJlbW92ZXMgZXZlcnkgcHJvcGVydHkgb2YgdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsZWFyKG9iaikge1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGRlbGV0ZSBvYmpbcHJvcF07XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IGNsb25lIGZyb20gJ2xvZGFzaC9sYW5nL2Nsb25lJztcbmV4cG9ydCBkZWZhdWx0IGNsb25lO1xuIiwiLypqc2hpbnQgbGF0ZWRlZjpmYWxzZSovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IGJhc2VDbG9uZSBmcm9tICdsb2Rhc2gvaW50ZXJuYWwvYmFzZUNsb25lJztcbmltcG9ydCBpc0dyYXBoIGZyb20gJy4vaXNHcmFwaCc7XG5pbXBvcnQgaXNNYXAgZnJvbSAnLi9pc01hcCc7XG5pbXBvcnQgaXNTZXQgZnJvbSAnLi9pc1NldCc7XG5cbmZ1bmN0aW9uIGRlZXBjb3B5SW5zdGFuY2Uob2JqLCBzdGFja0EsIHN0YWNrQikge1xuICAvLyB0ZW1wb3JhcnkgY29uc3RydWN0b3IsIHdlIGRvbid0IGtub3cgaWYgdGhlIG9yaWdpbmFsIGV4cGVjdHNcbiAgLy8gcGFyYW1ldGVyXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHZhciBUXyA9IGZ1bmN0aW9uKCkge307XG4gIFRfLnByb3RvdHlwZSA9IG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIHZhciBvd25Qcm9wcyA9IHt9O1xuICB2YXIgcHJvcDtcbiAgdmFyIGluc3RhbmNlO1xuXG4gIC8vIGNvbGxlY3QgaW5zdGFuY2UgcHJvcGVydGllc1xuICBmb3IocHJvcCBpbiBvYmopIHtcbiAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIG93blByb3BzW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgfVxuICB9XG5cbiAgLy8gZGVlcGNvcHkgdGhlbVxuICBvd25Qcm9wcyA9IGRlZXBjb3B5SW1wbGVtZW50YXRpb24ob3duUHJvcHMsIHN0YWNrQSwgc3RhY2tCKTtcblxuICAvLyBjcmVhdGUgYSBuZXcgaW5zdGFuY2UgYW5kIGFzc2lnbiBwcm9wZXJ0aWVzXG4gIGluc3RhbmNlID0gbmV3IFRfKCk7XG4gIGZvcihwcm9wIGluIG93blByb3BzKSB7XG4gICAgICBpbnN0YW5jZVtwcm9wXSA9IG93blByb3BzW3Byb3BdO1xuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBkZWVwY29weUltcGxlbWVudGF0aW9uKHZhbHVlLCBzdGFja0EsIHN0YWNrQikge1xuICByZXR1cm4gYmFzZUNsb25lKFxuICAgIHZhbHVlLFxuICAgIHRydWUsXG4gICAgZnVuY3Rpb24odikge1xuICAgICAgaWYgKGlzTWFwKHYpIHx8IGlzU2V0KHYpIHx8IGlzR3JhcGgodikpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBkZWVwY29weUluc3RhbmNlKHYsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgc3RhY2tBLnB1c2godik7XG4gICAgICAgIHN0YWNrQi5wdXNoKGNvcHkpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG51bGwsXG4gICAgbnVsbCxcbiAgICBzdGFja0EsXG4gICAgc3RhY2tCXG4gICk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiB0aGUgdmFsdWUsIGFsc28gb2YgbWFwcyBhbmQgc2V0cy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjbG9uZWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZXBjb3B5KHZhbHVlKSB7XG4gIHJldHVybiBkZWVwY29weUltcGxlbWVudGF0aW9uKHZhbHVlLCBbXSwgW10pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvb2JqZWN0L21lcmdlJztcbmV4cG9ydCBkZWZhdWx0IG1lcmdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBkZWxlZ2F0ZSBmcm9tICcuL2RlbGVnYXRlJztcbmltcG9ydCB7aXNTdXBwb3J0ZWQsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemV9IGZyb20gJy4vbWVzc2FnZSc7XG5cbnZhciBkZWxlZ2F0ZUltcGxlbWVudGF0aW9uO1xuaWYgKHR5cGVvZiBnbG9iYWwuV29ya2VyID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIFdvcmtlcnMgYXJlIHN1cHBvcnRlZFxuICBkZWxlZ2F0ZUltcGxlbWVudGF0aW9uID0gZnVuY3Rpb24obWV0aG9kLCBhcmdzKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWRBcmdzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgc2VyaWFsaXphYmxlID0gIGFyZ3MuZXZlcnkoKGFyZywgaSkgPT4ge1xuICAgICAgdmFyIHN1cHBvcnRlZCA9IGlzU3VwcG9ydGVkKGFyZyk7XG4gICAgICBpZiAoc3VwcG9ydGVkKSB7XG4gICAgICAgIHNlcmlhbGl6ZWRBcmdzW2ldID0gc2VyaWFsaXplKGFyZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwcG9ydGVkO1xuICAgIH0pO1xuXG4gICAgaWYgKCFzZXJpYWxpemFibGUpIHtcbiAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgYEF0IGxlYXN0IG9uZSBhcmd1bWVudCBjYW4ndCBiZSBzZXJpYWxpemVkIGFuZCBzZW50IHRvIHRoZSB3b3JrZXIuIGAgK1xuICAgICAgICBgV2Ugd2lsbCBydW4gJHttZXRob2R9IGluIHRoZSBzYW1lIHRocmVhZCBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgICBkZWxlZ2F0ZShtZXRob2QsIGFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciB3b3JrZXIgPSBuZXcgZ2xvYmFsLldvcmtlcigne3tCVU5ETEV9fScpO1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIChvRXZlbnQpIHtcbiAgICAgICAgcmVzb2x2ZShkZXNlcmlhbGl6ZShvRXZlbnQuZGF0YSkpO1xuICAgICAgfSwgZmFsc2UpO1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QsIGZhbHNlKTtcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7bWV0aG9kLCBhcmdzOiBzZXJpYWxpemVkQXJnc30pO1xuICAgIH0pO1xuICB9O1xufVxuZWxzZSB7XG4gIGRlbGVnYXRlSW1wbGVtZW50YXRpb24gPSBmdW5jdGlvbihtZXRob2QsIGFyZ3MpIHtcbiAgICBjb25zb2xlLmluZm8oXG4gICAgICBgV29ya2VycyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LCBzbyBcIiR7bWV0aG9kfVwiIHdpbGwgYCArXG4gICAgICBgcnVuIGluIHRoZSBzYW1lIHRocmVhZCBpbnN0ZWFkLiBUaGlzIG1pZ2h0IGJsb2NrIHRoZSBlbnZpcm9ubWVudC5gXG4gICAgKTtcbiAgICBkZWxlZ2F0ZShtZXRob2QsIGFyZ3MpO1xuICB9O1xufVxuXG4vKipcbiAqIERPTidUIENBTEwgVEhJUyBGVU5DVElPTiBFWFBMSUNJVExZLiBJdCdzIGluc2VydGVkIGJ5IGEgdHJhbnNmb3JtLlxuICpcbiAqIFRyaWVzIHRvIGNyZWF0ZSBhIHdvcmtlciBhbmQgcGFzcyB0aGUgYXJndW1lbnRzIHRvIGl0LiBDb3B5aW5nIGxhcmdlIGdyYXBoc1xuICogaXMgbm90IHZlcnkgZmFzdCwgYnV0IHN0aWxsIGZhc3RlciB0aGFuIHJ1bm5pbmcgbW9zdCBhbGdvcml0aG1zXG4gKiBzeW5jaHJvbm91c2x5LlxuICpcbiAqIEZhbGxzIGJhY2sgdG8gc3luY2hyb25vdXMgZXhlY3V0aW9uIGlmIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHdvcmtlcnMuXG4gKlxuICogVGhpcyByZXR1cm5zIGEgcHJvbWlzZSB3aGljaCBnZXRzIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdCBzZW50IGZyb20gdGhlXG4gKiB3b3JrZXIgb3IgdGhlIHN5bmNocm9ub3VzIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFRoZSBuYW1lIG9uIHRoZSByb290IGpzbnggb2JqZWN0IHRvIGV4ZWN1dGUuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBzZW5kIHRvIHRoZSB3b3JrZXIuXG4gKiAgICBTb21lIHR5cGVzLCBzdWNoIGFzIGdyYXBocywgYXJlIGNvbnZlcnRlZCB0byBhIGRpZmZlcmVudCBmb3JtYXQgZmlyc3QuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWxlZ2F0ZVRvV29ya2VyKG1ldGhvZCwgYXJncykge1xuICByZXR1cm4gZGVsZWdhdGVJbXBsZW1lbnRhdGlvbihtZXRob2QsIGFyZ3MpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgbmAgZWxlbWVudHMsIGVhY2ggYmVpbmcgYHZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiBOdW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0gez99IHZhbHVlIFRoZSB2YWx1ZSB0byBwdXQgaW4gZWFjaCBsb2NhdGlvblxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbGxBcnJheShuLCB2YWx1ZSkge1xuICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IF9mb3JFYWNoIGZyb20gJ2xvZGFzaC9jb2xsZWN0aW9uL2ZvckVhY2gnO1xuaW1wb3J0IGlzSXRlcmFibGUgZnJvbSAnLi9pc0l0ZXJhYmxlJztcbmltcG9ydCBpc0l0ZXJhdG9yIGZyb20gJy4vaXNJdGVyYXRvcic7XG5cbi8qKlxuICogSGVscGVyIHRvIGl0ZXJhdGUgb3ZlciBzZXF1ZW5jZSB0eXBlcyAoYXJyYXlzLCBhcnJheS1saWtlIG9iamVjdHMsXG4gKiBvYmplY3RzLCBldGMpXG4gKlxuICogQHBhcmFtIHtJdGVyYWJsZX0gc2VxXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VCwgLi4uKX0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7VD19IG9wdFRoaXNPYmpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvckVhY2goc2VxLCBjYWxsYmFjaywgb3B0VGhpc09iaikge1xuICBpZiAoQXJyYXkuaXNBcnJheShzZXEpKSB7XG4gICAgc2VxLmZvckVhY2goY2FsbGJhY2ssIG9wdFRoaXNPYmopO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNJdGVyYWJsZShzZXEpKSB7XG4gICAgc2VxID0gc2VxW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuICBpZihpc0l0ZXJhdG9yKHNlcSkpIHtcbiAgICB2YXIgdjtcbiAgICB2YXIgaTtcbiAgICAvLyBBdm9pZGluZyBjYWxsIGlmIGl0IGlzIG5vdCBuZWNlc3NhcnkgaXMgZmFzdGVyIGluIHNvbWUgYnJvd3NlcnNcbiAgICBpZiAob3B0VGhpc09iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKHYgb2Ygc2VxKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgY2FsbGJhY2suY2FsbChvcHRUaGlzT2JqLCB2LCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2IG9mIHNlcSkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGNhbGxiYWNrKHYsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIGlmKHNlcSAmJiB0eXBlb2Ygc2VxID09PSAnb2JqZWN0Jykge1xuICAgIF9mb3JFYWNoKHNlcSwgY2FsbGJhY2ssIG9wdFRoaXNPYmopO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3Igb2YgdHdvIG51bWJlcnMgdXNpbmcgRXVjbGlkJ3MgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnY2QoYSwgYikge1xuICB3aGlsZSAoYiAhPT0gMCkge1xuICAgIHZhciBfID0gYTtcbiAgICBhID0gYjtcbiAgICBiID0gXyAlIGI7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHJhbmdlIGZyb20gJy4vcmFuZ2UnO1xuXG5mdW5jdGlvbiByZXZlcnNlZChhcnJheSkge1xuICByZXR1cm4gYXJyYXkuc2xpY2UoKS5yZXZlcnNlKCk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBQeXRob24ncyBpdGVydG9vbHMuY29tYmluYXRpb25zXG4gKlxuICogUmV0dXJuIHIgbGVuZ3RoIHN1YnNlcXVlbmNlcyBvZiBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBpdGVyYWJsZS5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBpdGVyYWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IHJcbiAqXG4gKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKmdlbkNvbWJpbmF0aW9ucyhpdGVyYWJsZSwgcikge1xuICAvLyBnZW5Db21iaW5hdGlvbnMoJ0FCQ0QnLCAyKSAtLT4gQUIgQUMgQUQgQkMgQkQgQ0RcbiAgLy8gZ2VuQ29tYmluYXRpb25zKHJhbmdlKDQpLCAzKSAtLT4gMDEyIDAxMyAwMjMgMTIzXG4gIHZhciBwb29sID0gQXJyYXkuZnJvbShpdGVyYWJsZSk7XG4gIHZhciBuID0gcG9vbC5sZW5ndGg7XG4gIGlmIChyID4gbikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5kaWNpZXMgPSByYW5nZShyKTtcbiAgdmFyIHJldmVyc2VkSW5kaWNpZXMgPSByZXZlcnNlZChpbmRpY2llcyk7XG4gIHlpZWxkIGluZGljaWVzLm1hcChpID0+IHBvb2xbaV0pO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBpO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmV2ZXJzZWRJbmRpY2llcy5sZW5ndGg7IGsrKykge1xuICAgICAgaSA9IHJldmVyc2VkSW5kaWNpZXNba107XG4gICAgICBpZiAoaW5kaWNpZXNbaV0gIT09IGkgKyBuIC0gcikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldmVyc2VkSW5kaWNpZXMubGVuZ3RoID09PSBrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluZGljaWVzW2ldICs9IDE7XG4gICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgcjsgaisrKSB7XG4gICAgICBpbmRpY2llc1tqXSA9IGluZGljaWVzW2otMV0gKyAxO1xuICAgIH1cbiAgICB5aWVsZCBpbmRpY2llcy5tYXAoaSA9PiBwb29sW2ldKTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCByYW5nZSBmcm9tICcuL3JhbmdlJztcblxuLyoqXG4gKiBJbXBsZW1lbnRzIFB5dGhvbidzIGl0ZXJ0b29scy5wZXJtdXRhdGlvbnNcbiAqXG4gKiBSZXR1cm4gc3VjY2Vzc2l2ZSByIGxlbmd0aCBwZXJtdXRhdGlvbnMgb2YgZWxlbWVudHMgaW4gdGhlIGl0ZXJhYmxlLlxuICogKlxuICogQHBhcmFtIHtJdGVyYWJsZX0gaXRlcmFibGVcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3JcbiAqXG4gKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKmdlblBlcm11dGF0aW9ucyhpdGVyYWJsZSwgcikge1xuICAvLyBnZW5QZXJtdXRhdGlvbnMoJ0FCQ0QnLCAyKSAtLT4gQUIgQUMgQUQgQkEgQkMgQkQgQ0EgQ0IgQ0QgREEgREIgRENcbiAgLy8gZ2VuUGVybXV0YXRpb25zKHJhbmdlKDMpKSAtLT4gMDEyIDAyMSAxMDIgMTIwIDIwMSAyMTBcbiAgdmFyIHBvb2wgPSBBcnJheS5mcm9tKGl0ZXJhYmxlKTtcbiAgdmFyIG4gPSBwb29sLmxlbmd0aDtcbiAgciA9IHIgPT0gbnVsbCA/IG4gOiByO1xuICBpZiAociA+IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGluZGljaWVzID0gcmFuZ2Uobik7XG4gIHZhciBjeWNsZXMgPSByYW5nZShuLCBuIC0gciwgLTEpO1xuICB2YXIgcmFuZ2VSID0gcmFuZ2Uoci0xLCAtMSAsIC0xKTtcbiAgeWllbGQgaW5kaWNpZXMuc2xpY2UoMCwgcikubWFwKGkgPT4gcG9vbFtpXSk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCByYW5nZVIubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBpID0gcmFuZ2VSW2tdO1xuICAgICAgY3ljbGVzW2ldIC09IDE7XG4gICAgICB2YXIgaW5kZXggPSBpbmRpY2llc1tpXTtcbiAgICAgIGlmIChjeWNsZXNbaV0gPT09IDApIHtcbiAgICAgICAgaW5kaWNpZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBpbmRpY2llcy5wdXNoKGluZGV4KTtcbiAgICAgICAgY3ljbGVzW2ldID0gbiAtIGk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGogPSBjeWNsZXNbaV07XG4gICAgICAgIGluZGljaWVzW2ldID0gaW5kaWNpZXNbaW5kaWNpZXMubGVuZ3RoIC0gal07XG4gICAgICAgIGluZGljaWVzW2luZGljaWVzLmxlbmd0aCAtIGpdID0gaW5kZXg7XG4gICAgICAgIHlpZWxkIGluZGljaWVzLnNsaWNlKDAsIHIpLm1hcChpID0+IHBvb2xbaV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhbmdlUi5sZW5ndGggPT09IGspIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEltcGxlbWVudHMgUHl0aG9uJ3MgcmFuZ2UgZnVuY3Rpb24sIHJldHVybnMgYW4gaXRlcmF0b3IuXG4gKlxuICogSWYgb25lIGFyZ3VtZW50IG4gaXMgcGFzc2VkLCBpdGVyYXRlcyBvdmVyIDAuLi5uLlxuICogSWYgdHdvIGFyZ3VtZW50cyBpLGogYXJlIHBhc3NlZCwgaXRlcmF0ZXMgb3ZlciBpLi4uai5cbiAqIElmIHRocmVlIGFyZ3VtZW50cyBpLGosayBhcmUgcGFzc2VkLCBpdGVyYXRlcyBvdmVyIGksIGkraywgaSsyaywgLi4ualxuICpcbiAqIEBwYXJhbSB7P251bWJlcj19IG9wdF9zdGFydCBOdW1iZXIgdG8gc3RhcnQgZnJvbVxuICogQHBhcmFtIHs/bnVtYmVyPX0gb3B0X2VuZCBOdW1iZXIgdG8gY291bnQgdG9cbiAqIEBwYXJhbSB7P251bWJlcj19IG9wdF9zdGVwIFN0ZXAgc2l6ZVxuICogQHJldHVybiB7IUl0ZXJhdG9yfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiogZ2VuUmFuZ2Uob3B0U3RhcnQsIG9wdEVuZCwgb3B0U3RlcCkge1xuXG4gIGlmIChvcHRTdGFydCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsc2UgaWYgKG9wdEVuZCA9PSBudWxsKSB7XG4gICAgb3B0RW5kID0gb3B0U3RhcnQ7XG4gICAgb3B0U3RhcnQgPSAwO1xuICAgIG9wdFN0ZXAgPSAxO1xuICB9XG4gIGVsc2UgaWYgKG9wdFN0ZXAgPT0gbnVsbCkge1xuICAgIG9wdFN0ZXAgPSAxO1xuICB9XG4gIGVsc2UgaWYgKG9wdFN0ZXAgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9wdF9zdGVwIGNhbid0IGJlIDBcIik7XG4gIH1cblxuICB2YXIgbmVnYXRpdmUgPSBvcHRTdGVwIDwgMDtcbiAgZm9yIChcbiAgICB2YXIgaSA9IG9wdFN0YXJ0O1xuICAgIG5lZ2F0aXZlICYmIGkgPiBvcHRFbmQgfHwgIW5lZ2F0aXZlICYmIGkgPCBvcHRFbmQ7XG4gICAgaSArPSBvcHRTdGVwKSB7XG4gICAgeWllbGQgaTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Vjb25kIGFyZ3VtZW50IGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQXJyYXlzIGZyb20gJy4vQXJyYXlzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9NYXAnO1xuaW1wb3J0IFByaW9yaXR5UXVldWUgZnJvbSAnLi9Qcmlvcml0eVF1ZXVlJztcbmltcG9ydCBTZXQgZnJvbSAnLi9TZXQnO1xuaW1wb3J0IGNsb25lIGZyb20gJy4vY2xvbmUnO1xuaW1wb3J0IGNsZWFyIGZyb20gJy4vY2xlYXInO1xuaW1wb3J0IGRlZXBjb3B5IGZyb20gJy4vZGVlcGNvcHknO1xuaW1wb3J0IGRlZXBtZXJnZSBmcm9tICcuL2RlZXBtZXJnZSc7XG5pbXBvcnQgZ2NkIGZyb20gJy4vZ2NkJztcbmltcG9ydCBnZW5Db21iaW5hdGlvbnMgZnJvbSAnLi9nZW5Db21iaW5hdGlvbnMnO1xuaW1wb3J0IGdlblBlcm11dGF0aW9ucyBmcm9tICcuL2dlblBlcm11dGF0aW9ucyc7XG5pbXBvcnQgZ2VuUmFuZ2UgZnJvbSAnLi9nZW5SYW5nZSc7XG5pbXBvcnQgZ2V0RGVmYXVsdCBmcm9tICcuL2dldERlZmF1bHQnO1xuaW1wb3J0IGZpbGxBcnJheSBmcm9tICcuL2ZpbGxBcnJheSc7XG5pbXBvcnQgZm9yRWFjaCBmcm9tICcuL2ZvckVhY2gnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UnO1xuaW1wb3J0IGlzQm9vbGVhbiBmcm9tICcuL2lzQm9vbGVhbic7XG5pbXBvcnQgaXNHcmFwaCBmcm9tICcuL2lzR3JhcGgnO1xuaW1wb3J0IGlzSXRlcmFibGUgZnJvbSAnLi9pc0l0ZXJhYmxlJztcbmltcG9ydCBpc0l0ZXJhdG9yIGZyb20gJy4vaXNJdGVyYXRvcic7XG5pbXBvcnQgaXNNYXAgZnJvbSAnLi9pc01hcCc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IG1hcEl0ZXJhdG9yIGZyb20gJy4vbWFwSXRlcmF0b3InO1xuaW1wb3J0IG1hcFNlcXVlbmNlIGZyb20gJy4vbWFwU2VxdWVuY2UnO1xuaW1wb3J0IG1heCBmcm9tICcuL21heCc7XG5pbXBvcnQgbmV4dCBmcm9tICcuL25leHQnO1xuaW1wb3J0IG5vZGVzQXJlRXF1YWwgZnJvbSAnLi9ub2Rlc0FyZUVxdWFsJztcbmltcG9ydCByYW5nZSBmcm9tICcuL3JhbmdlJztcbmltcG9ydCBzb21lSXRlcmF0b3IgZnJvbSAnLi9zb21lSXRlcmF0b3InO1xuaW1wb3J0IHRvSXRlcmF0b3IgZnJvbSAnLi90b0l0ZXJhdG9yJztcbmltcG9ydCAqIGFzIHR1cGxlIGZyb20gJy4vdHVwbGUnO1xuaW1wb3J0IHNpemUgZnJvbSAnLi9zaXplJztcbmltcG9ydCBzcHJpbnRmIGZyb20gJy4vc3ByaW50Zic7XG5pbXBvcnQgemlwSXRlcmF0b3IgZnJvbSAnLi96aXBJdGVyYXRvcic7XG5pbXBvcnQgemlwU2VxdWVuY2UgZnJvbSAnLi96aXBTZXF1ZW5jZSc7XG5cbmV4cG9ydCB7XG4gIEFycmF5cyxcbiAgTWFwLFxuICBQcmlvcml0eVF1ZXVlLFxuICBTZXQsXG4gIGNsb25lLFxuICBjbGVhcixcbiAgZGVlcGNvcHksXG4gIGRlZXBtZXJnZSxcbiAgZ2NkLFxuICBnZW5Db21iaW5hdGlvbnMsXG4gIGdlblBlcm11dGF0aW9ucyxcbiAgZ2VuUmFuZ2UsXG4gIGdldERlZmF1bHQsXG4gIGZpbGxBcnJheSxcbiAgZm9yRWFjaCxcbiAgaXNBcnJheUxpa2UsXG4gIGlzQm9vbGVhbixcbiAgaXNHcmFwaCxcbiAgaXNJdGVyYWJsZSxcbiAgaXNJdGVyYXRvcixcbiAgaXNNYXAsXG4gIGlzUGxhaW5PYmplY3QsXG4gIG1hcEl0ZXJhdG9yLFxuICBtYXBTZXF1ZW5jZSxcbiAgbWF4LFxuICBuZXh0LFxuICBub2Rlc0FyZUVxdWFsLFxuICByYW5nZSxcbiAgc29tZUl0ZXJhdG9yLFxuICB0b0l0ZXJhdG9yLFxuICB0dXBsZSxcbiAgc2l6ZSxcbiAgc3ByaW50ZixcbiAgemlwSXRlcmF0b3IsXG4gIHppcFNlcXVlbmNlXG59O1xuXG5leHBvcnQgKiBmcm9tICcuL3R1cGxlJztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBvZiB0aGUgYXJyYXkgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYSBudW1lcmljYWwgbGVuZ3RoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7P30gdlxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBcnJheUxpa2Uodikge1xuICByZXR1cm4gdiAmJlxuICAgIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB2Lmxlbmd0aCA9PT0gJ251bWJlcicgJiZcbiAgICB0eXBlb2YgdiAhPT0gJ2Z1bmN0aW9uJztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IGlzQm9vbGVhbiBmcm9tICdsb2Rhc2gvbGFuZy9pc0Jvb2xlYW4nO1xuZXhwb3J0IGRlZmF1bHQgaXNCb29sZWFuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgR3JhcGhcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0dyYXBoKHZhbHVlKSB7XG4gIC8vIFdlIGFyZSBub3QgdXNpbmcgaW5zdGFuY2VvZiB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5hZGROb2RlID09PSAnZnVuY3Rpb24nO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpbXBsZW1lbnQgdGhlIEBAaXRlcmF0b3IgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzSXRlcmFibGUob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGFuIGl0ZXJhdG9yXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0l0ZXJhdG9yKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5uZXh0ID09PSAnZnVuY3Rpb24nO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBNYXAgZnJvbSAnLi9NYXAnO1xuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgTWFwLlxuICpcbiAqIEBwYXJhbSB7Kn0gdiBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNNYXAodikge1xuICByZXR1cm4gdiBpbnN0YW5jZW9mIE1hcDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoL2xhbmcvaXNQbGFpbk9iamVjdCc7XG5leHBvcnQgZGVmYXVsdCBpc1BsYWluT2JqZWN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBTZXQgZnJvbSAnLi9TZXQnO1xuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgTWFwLlxuICpcbiAqIEBwYXJhbSB7Kn0gdiBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTZXQodikge1xuICByZXR1cm4gdiBpbnN0YW5jZW9mIFNldDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgaXRlcmF0b3Igd2hpY2ggbWFwcyBldmVyeSB2YWx1ZSBmcm9tIHRoZSBwcm92aWRlZCBpdGVyYXRvciB2aWFcbiAqIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhdG9yfSBpdGVyYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWFwXG4gKiBAcGFyYW0gez89fSBvcHRfdGhpc19vYmpcbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiogbWFwSXRlcmF0b3IoaXRlcmF0b3IsIG1hcCwgb3B0VGhpc09iaikge1xuICBmb3IgKHZhciB2IG9mIGl0ZXJhdG9yKSB7XG4gICAgeWllbGQgbWFwLmNhbGwob3B0VGhpc09iaiwgdik7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICdsb2Rhc2gvbGFuZy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCBtYXBWYWx1ZXMgZnJvbSAnbG9kYXNoL29iamVjdC9tYXBWYWx1ZXMnO1xuXG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZSc7XG5pbXBvcnQgaXNJdGVyYWJsZSBmcm9tICcuL2lzSXRlcmFibGUnO1xuaW1wb3J0IGlzSXRlcmF0b3IgZnJvbSAnLi9pc0l0ZXJhdG9yJztcbmltcG9ydCBtYXBJdGVyYXRvciBmcm9tICcuL21hcEl0ZXJhdG9yJztcblxudmFyIG5hdGl2ZU1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXA7XG5cbi8qKlxuICogSGVscGVyIHRvIG1hcCBzZXF1ZW5jZSB0eXBlcyAoYXJyYXlzLCBhcnJheS1saWtlIG9iamVjdHMsIG9iamVjdHMsIGV0YykuXG4gKiBOb3RlIHRoYXQgaWYgYW4gYXJyYXktbGlrZSBvYmplY3QgaXMgcGFzc2VkLCBhbiBhcnJheSBpcyByZXR1cm5lZDpcbiAqXG4gKiBBcnJheSAtPiBBcnJheVxuICogQXJyYXlMaWtlIC0+IEFycmF5XG4gKiBJdGVyYXRvciAtPiBJdGVyYXRvclxuICogSXRlcmFibGUgLT4gSXRlcmF0b3JcbiAqIE9iamVjdCAtPiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBzZXF1ZW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlQsLi4uKX0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7VD19IHRoaXNfb2JqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEByZXR1cm4geyhBcnJheXxPYmplY3R8SXRlcmF0b3IpfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXBTZXF1ZW5jZShzZXF1ZW5jZSwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgaWYgKGlzQXJyYXlMaWtlKHNlcXVlbmNlKSkge1xuICAgIHJldHVybiBuYXRpdmVNYXAuY2FsbChzZXF1ZW5jZSwgY2FsbGJhY2ssIHRoaXNPYmopO1xuICB9XG4gIGVsc2UgaWYgKGlzSXRlcmFibGUoc2VxdWVuY2UpKSB7XG4gICAgc2VxdWVuY2UgPSBzZXF1ZW5jZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgaWYgKGlzSXRlcmF0b3Ioc2VxdWVuY2UpKSB7XG4gICAgcmV0dXJuIG1hcEl0ZXJhdG9yKHNlcXVlbmNlLCBjYWxsYmFjaywgdGhpc09iaik7XG4gIH1cbiAgZWxzZSBpZihpc1BsYWluT2JqZWN0KHNlcXVlbmNlKSkge1xuICAgIHJldHVybiBtYXBWYWx1ZXMoc2VxdWVuY2UsIGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJDYW4ndCBtYXAgdmFsdWUgb2YgdHlwZSAlc1wiLFxuICAgICAgdHlwZW9mIHNlcXVlbmNlXG4gICAgKTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBmb3JFYWNoIGZyb20gJy4vZm9yRWFjaCc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBmcm9tIGFuIGl0ZXJhYmxlLiBJdCB1c2VzIHRoZSBvcHRpb25hbCBjYWxsYmFja1xuICogZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICpcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGl0ZXJhYmxlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKD8pOiA/fSBtYXBcbiAqIEByZXR1cm4gez99XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1heChpdGVyYWJsZSwgbWFwKSB7XG4gIHZhciBtYXhDb21wYXJpc29uVmFsdWUgPSAtSW5maW5pdHk7XG4gIHZhciBtYXhWYWx1ZTtcblxuICBmb3JFYWNoKGl0ZXJhYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBjb21wYXJpc29uVmFsdWUgPSBtYXAgPyBtYXAodmFsdWUpIDogdmFsdWU7XG4gICAgaWYgKGNvbXBhcmlzb25WYWx1ZSA+IG1heENvbXBhcmlzb25WYWx1ZSkge1xuICAgICAgbWF4Q29tcGFyaXNvblZhbHVlID0gY29tcGFyaXNvblZhbHVlO1xuICAgICAgbWF4VmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBtYXhWYWx1ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgaXNJdGVyYWJsZSBmcm9tICcuL2lzSXRlcmFibGUnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0JztcbmltcG9ydCBNYXAgZnJvbSAnLi9NYXAnO1xuaW1wb3J0IFNldCBmcm9tICcuL1NldCc7XG5pbXBvcnQgKiBhcyBjbGFzc2VzIGZyb20gJy4uL2NsYXNzZXMnO1xuXG5jb25zdCBLRVkgPSAnX190eXBlLWpzbnhfXyc7XG5cbi8qKlxuICogQGZpbGVvdmVydmlld1xuICogSGVscGVyIG1ldGhvZHMgdG8gc2VyaWFsaXplIGFuZCB1bnNlcmlhbGl6ZSBkYXRhIGZvciBjb21tdW5pY2F0aW5nIHdpdGhcbiAqIHdvcmtlcnMuXG4gKi9cblxuZnVuY3Rpb24gc2VyaWFsaXplU2V0KHZhbHVlKSB7XG4gIC8vIFRPRE86IHNlcmlhbGl6ZSBuZXN0ZWQgdmFsdWVzXG4gIHJldHVybiB7XG4gICAgW0tFWV06ICdTZXQnLFxuICAgIGRhdGE6IEFycmF5LmZyb20odmFsdWUudmFsdWVzKCkpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplU2V0KHZhbHVlKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlLmRhdGEpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVNYXAodmFsdWUpIHtcbiAgLy8gVE9ETzogc2VyaWFsaXplIG5lc3RlZCB2YWx1ZXNcbiAgcmV0dXJuIHtcbiAgICBbS0VZXTogJ01hcCcsXG4gICAgZGF0YTogW2ZvciAoW2ssdl0gb2YgdmFsdWUpIFtrLCBzZXJpYWxpemUodildXVxuICB9O1xufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZU1hcCh2YWx1ZSkge1xuICByZXR1cm4gbmV3IE1hcCh2YWx1ZS5kYXRhLm1hcChrdiA9PiAoa3ZbMV0gPSBkZXNlcmlhbGl6ZShrdlsxXSksIGt2KSkpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVHcmFwaCh2YWx1ZSkge1xuICAvLyBUT0RPOiBzZXJpYWxpemUgY29tcGxleCBlZGdlIGFuZCBub2RlIGRhdGFcbiAgcmV0dXJuIHtcbiAgICBbS0VZXTogdmFsdWUuY29uc3RydWN0b3IuX19uYW1lX18sXG4gICAgZGF0YTogdmFsdWUuZ3JhcGgsXG4gICAgbm9kZXM6IEFycmF5LmZyb20odmFsdWUubm9kZSksXG4gICAgZWRnZXM6IHZhbHVlLmVkZ2VzKG51bGwsIHRydWUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplR3JhcGgodmFsdWUpIHtcbiAgdmFyIEcgPSBuZXcgY2xhc3Nlc1t2YWx1ZVtLRVldXSh2YWx1ZS5lZGdlcywgdmFsdWUuZGF0YSk7XG4gIEcuYWRkTm9kZXNGcm9tKHZhbHVlLm5vZGVzKTtcbiAgcmV0dXJuIEc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBjYW4gYmUgcHJvcGVybHkgc2VyaWFsaXplZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N1cHBvcnRlZCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIChcbiAgICAvLyBQcmltaXRpdmVzXG4gICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgIHR5cGUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZSA9PT0gJ251bWJlcicgfHxcbiAgICB0eXBlID09PSAnYm9vbGVhbicgfHxcblxuICAgIC8vIE9iamVjdHMgYW5kIGFycmF5cyAod2UganVzdCBhc3N1bWUgdGhleSBjb250YWluIG9ubHkgcHJpbWl0aXZlcylcbiAgICBpc1BsYWluT2JqZWN0KHZhbHVlKSB8fFxuICAgIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG5cbiAgICAvLyBPdXIgY3VzdG9tIGNvbGxlY3Rpb25zIChzaGFsbG93KVxuICAgIHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8XG4gICAgdmFsdWUgaW5zdGFuY2VvZiBTZXQgfHxcblxuICAgIC8vIEdyYXBoc1xuICAgIHZhbHVlLmNvbnN0cnVjdG9yLl9fbmFtZV9fID09PSAnR3JhcGgnIHx8XG4gICAgdmFsdWUuY29uc3RydWN0b3IuX19uYW1lX18gPT09ICdEaUdyYXBoJyB8fFxuXG4gICAgLy8gR2VuZXJpYyBpdGVyYWJsZXNcbiAgICBpc0l0ZXJhYmxlKHZhbHVlKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlKSB7XG4gIC8vIHByaW1pdGl2ZXNcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICghdmFsdWUgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIC8vIENvbGxlY3Rpb25zXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgIHJldHVybiBzZXJpYWxpemVTZXQodmFsdWUpO1xuICB9XG4gIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZU1hcCh2YWx1ZSk7XG4gIH1cbiAgLy8gR3JhcGhzXG4gIGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yLl9fbmFtZV9fID09PSAnR3JhcGgnIHx8XG4gICAgdmFsdWUuY29uc3RydWN0b3IuX19uYW1lX18gPT09ICdEaUdyYXBoJykge1xuICAgIHJldHVybiBzZXJpYWxpemVHcmFwaCh2YWx1ZSk7XG4gIH1cbiAgLy8gSXRlcmFibGVzXG4gIGVsc2UgaWYgKGlzSXRlcmFibGUodmFsdWUpKSB7XG4gICAgLy8gV2Uga2VlcCBpdCBzaW1wbGUgZm9yIG5vdyBhbmQgZG9uJ3Qgc2VyaWFsaXplIHRoZSB2YWx1ZXMgb2YgdGhlIGl0ZXJhYmxlXG4gICAgLy8gaXRzZWxmXG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xuICB9XG4gIC8vIFRPRE86IEhhbmRsZSBhcnJheXMgYW5kIG9iamVjdHMgYmV0dGVyXG5cbiAgLy8gZGVmYXVsdFxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZSh2YWx1ZSkge1xuICAvLyBwcmltaXRpdmVzXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAoIXZhbHVlIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvLyBjdXN0b20gc2VyaWFsaXp0aW9uP1xuICBpZiAodmFsdWVbS0VZXSkge1xuICAgIHN3aXRjaCh2YWx1ZVtLRVldKSB7XG4gICAgICBjYXNlICdNYXAnOlxuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVNYXAodmFsdWUpO1xuICAgICAgY2FzZSAnU2V0JzpcbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplU2V0KHZhbHVlKTtcbiAgICAgIGNhc2UgJ0dyYXBoJzpcbiAgICAgIGNhc2UgJ0RpR3JhcGgnOlxuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVHcmFwaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIC8vIFRPRE86IEhhbmRsZSBhcnJheXMgYW5kIG9iamVjdHMgYmV0dGVyXG5cbiAgLy8gZGVmYXVsdFxuICByZXR1cm4gdmFsdWU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IHZhbHVlIG9mIGFuIGl0ZXJhdG9yIG9yIHRocm93cyBhbiBlcnJvciBpZiB0aGUgaXRlcmF0b3Igd2FzXG4gKiBhbHJlYWR5IGNvbnN1bWVkLlxuICpcbiAqIEBwYXJhbSB7SXRlcmF0b3J9IGl0ZXJhdG9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuZXh0KGl0ZXJhdG9yKSB7XG4gIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gIGlmIChyZXN1bHQuZG9uZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSXRlcmF0b3IgaXMgYWxyZWFkeSBleGhhdXN0ZWQnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gdmFsdWVzIGFyZSBlcXVhbCBub2RlIHZhbHVlcy4gSWYgdGhlIHZhbHVlcyBhcmVcbiAqIHByaW1pdGl2ZXMsIHRoZXkgYXJlIGNvbXBhcmVkIGRpcmVjdGx5LiBJZiB0aGV5IGFyZSBvYmplY3RzLCB0aGVpciBzdHJpbmdcbiAqIHJlcHJlc2VudGF0aW9uIGlzIGNvbXBhcmVkLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gYVxuICogQHBhcmFtIHtOb2RlfSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub2Rlc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGIgfHwgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBnZW5SYW5nZSBmcm9tICcuL2dlblJhbmdlJztcblxuLyoqXG4gKiBJbXBsZW1lbnRzIFB5dGhvbidzIHJhbmdlIGZ1bmN0aW9uLCByZXR1cm5zIGFuIGFycmF5LlxuICpcbiAqIElmIG9uZSBhcmd1bWVudCBuIGlzIHBhc3NlZCwgaXRlcmF0ZXMgb3ZlciAwLi4ubi5cbiAqIElmIHR3byBhcmd1bWVudHMgaSxqIGFyZSBwYXNzZWQsIGl0ZXJhdGVzIG92ZXIgaS4uLmouXG4gKiBJZiB0aHJlZSBhcmd1bWVudHMgaSxqLGsgYXJlIHBhc3NlZCwgaXRlcmF0ZXMgb3ZlciBpLCBpK2ssIGkrMmssIC4uLmpcbiAqXG4gKiBAcGFyYW0gez9udW1iZXI9fSBvcHRTdGFydCBOdW1iZXIgdG8gc3RhcnQgZnJvbVxuICogQHBhcmFtIHs/bnVtYmVyPX0gb3B0RW5kIE51bWJlciB0byBjb3VudCB0b1xuICogQHBhcmFtIHs/bnVtYmVyPX0gb3B0U3RlcCBTdGVwIHNpemVcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmFuZ2Uob3B0U3RhcnQsIG9wdEVuZCwgb3B0U3RlcCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShnZW5SYW5nZShvcHRTdGFydCwgb3B0RW5kLCBvcHRTdGVwKSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UnO1xuaW1wb3J0IGlzR3JhcGggZnJvbSAnLi9pc0dyYXBoJztcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJ2xvZGFzaC9sYW5nL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IG9iamVjdFNpemUgZnJvbSAnbG9kYXNoL2NvbGxlY3Rpb24vc2l6ZSc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBjb250YWluZXIuIFRoYXQgaXNcbiAqIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5IG9yIG9iamVjdCBvciB0aGUgbGVuZ3RoXG4gKiBvZiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0geyhzdHJpbmd8T2JqZWN0fEFycmF5TGlrZXxHcmFwaCl9IG9ialxuICogICAgT2JqZWN0IHRvIGRldGVybWluZSB0aGUgbGVuZ3RoIG9mXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IFdoZW4gbGVuZ3RoIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNpemUob2JqKSB7XG4gIGlmIChpc0dyYXBoKG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm51bWJlck9mTm9kZXMoKTtcbiAgfVxuICBlbHNlIGlmKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmxlbmd0aDtcbiAgfVxuICBlbHNlIGlmKGlzUGxhaW5PYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmplY3RTaXplKG9iaik7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdFeHBlY3RlZCBhIGdyYXBoIG9iamVjdCwgYXJyYXksIHN0cmluZyBvciBvYmplY3QsIGJ1dCBnb3QgJXMgaW5zdGVhZCcsXG4gICAgICB0eXBlb2Ygb2JqXG4gICAgKTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRydWUgZm9yIGFueSBvZiB0aGUgZWxlbWVudHNcbiAqIG9mIHRoZSBpdGVyYXRvci5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhdG9yfSBpdGVyYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNvbWVJdGVyYXRvcihpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgdmFsdWUgb2YgaXRlcmF0b3IpIHtcbiAgICBpZiAoY2FsbGJhY2sodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgc3ByaW50ZiBmcm9tICd0aW55LXNwcmludGYnO1xuXG5zcHJpbnRmLmogPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH1cbiAgY2F0Y2goZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgc3ByaW50ZjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZSc7XG5pbXBvcnQgaXNJdGVyYXRvciBmcm9tICcuL2lzSXRlcmF0b3InO1xuaW1wb3J0IGlzSXRlcmFibGUgZnJvbSAnLi9pc0l0ZXJhYmxlJztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG9iamVjdCBmb3IgdGhlIGdpdmVuIGFycmF5LCBhcnJheS1saWtlIG9iamVjdFxuICogb3Igb2JqZWN0LiBTaG91bGQgYmVoYXZlIGxpa2UgUHl0aG9uJ3MgaXRlcjpcbiAqIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNpdGVyXG4gKlxuICpcbiAqIFRoZSBpdGVyYXRvciBvYmplY3QgaW1wbGVtZW50cyB0aGUgZ29vZy5pdGVyLkl0ZXJhdG9yIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBzZXFcbiAqIEByZXR1cm4geyFJdGVyYXRvcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9JdGVyYXRvcihzZXEpIHtcbiAgLypqc2hpbnQgZXhwcjp0cnVlKi9cbiAgaWYgKGlzSXRlcmF0b3Ioc2VxKSkge1xuICAgIHJldHVybiBzZXE7XG4gIH1cbiAgZWxzZSBpZiAoaXNJdGVyYWJsZShzZXEpKSB7XG4gICAgcmV0dXJuIHNlcVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZXEpIHx8IGlzQXJyYXlMaWtlKHNlcSkpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uKihzZXEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB5aWVsZCBzZXFbaV07XG4gICAgICB9XG4gICAgfShzZXEpKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmFibGUgdG8gY29udmVydCAnICsgc2VxICsgJyB0byBhbiBpdGVyYXRvcicpO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHQyID0gbmV3IEFycmF5KDIpO1xudmFyIHQzID0gbmV3IEFycmF5KDMpO1xudmFyIHQ0ID0gbmV3IEFycmF5KDQpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgaW5zdGFuY2Ugb2YgYW4gYXJyYXkgZm9yIGEgZ2l2ZW4gbnVtYmVyXG4gKiBvZiBhcmd1bWVudHMuXG4gKiBJdCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIGNyZWF0aW5nIHRlbXBvcmFyeSBhcnJheXMsIGlmIHRoZSBhcnJheXMgYXJlXG4gKiBjb25zdW1lZCBpbW1lZGlhdGVseSBhbnl3YXlzLlxuICpcbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGVsZW1lbnMgb2YgdGhlIHR1cGxlXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlMih4LCB5KSB7XG4gIHQyWzBdID0geDtcbiAgdDJbMV0gPSB5O1xuICByZXR1cm4gdDI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0dXBsZTMoeCwgeSwgeikge1xuICB0M1swXSA9IHg7XG4gIHQzWzFdID0geTtcbiAgdDNbMl0gPSB6O1xuICByZXR1cm4gdDM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0dXBsZTQoYSwgYiwgYywgZCkge1xuICB0NFswXSA9IGE7XG4gIHQ0WzFdID0gYjtcbiAgdDRbMl0gPSBjO1xuICB0NFszXSA9IGQ7XG4gIHJldHVybiB0NDtcbn1cblxuLyoqXG4gKiBTYW1lIGFzIHR1cGxlMiwgYnV0IHNldHMgdGhlIHZhbHVlcyBvbiBjb250YWluZXIgaW5zdGVhZCBvZiB0aGUgYWxsb2NhdGVkXG4gKiBhcnJheSBoZXJlLiBVc2VmdWwgdG8gcmV1c2UgYW4gZXhpc3RpbmcgYXJyYXkuXG4gKlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgZWxlbWVucyBvZiB0aGUgdHVwbGVcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdF9jb250YWluZXIgSWYgcHJlc2VudCwgc2V0IHZhbHVlcyB0aGVyZSBpbnN0ZWFkXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlMmMoeCwgeSwgY29udGFpbmVyKSB7XG4gIGNvbnRhaW5lci5sZW5ndGggPSAyO1xuICBjb250YWluZXJbMF0gPSB4O1xuICBjb250YWluZXJbMV0gPSB5O1xuICByZXR1cm4gY29udGFpbmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHVwbGUzYyh4LCB5LCB6LCBjb250YWluZXIpIHtcbiAgY29udGFpbmVyLmxlbmd0aCA9IDM7XG4gIGNvbnRhaW5lclswXSA9IHg7XG4gIGNvbnRhaW5lclsxXSA9IHk7XG4gIGNvbnRhaW5lclsyXSA9IHo7XG4gIHJldHVybiBjb250YWluZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0dXBsZTRjKGEsIGIsIGMsIGQsIGNvbnRhaW5lcikge1xuICBjb250YWluZXIubGVuZ3RoID0gNDtcbiAgY29udGFpbmVyWzBdID0gYTtcbiAgY29udGFpbmVyWzFdID0gYjtcbiAgY29udGFpbmVyWzJdID0gYztcbiAgY29udGFpbmVyWzNdID0gZDtcbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVR1cGxlRmFjdG9yeShjb3VudCkge1xuICB2YXIgdCA9IG5ldyBBcnJheShjb3VudCk7XG4gIHN3aXRjaCAoY291bnQpIHtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICB0WzBdID0gYTtcbiAgICAgICAgdFsxXSA9IGI7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICB0WzBdID0gYTtcbiAgICAgICAgdFsxXSA9IGI7XG4gICAgICAgIHRbMl0gPSBjO1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHlwbGUgc2l6ZSBub3Qgc3VwcG9ydGVkLicpO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUYWtlcyBhIG51bWJlciBvZiBpdGVyYXRvcnMgYW5kIHJldHVybnMgYSBuZXcgaXRlcmF0b3Igd2hpY2ggZW1pdHMgYW4gYXJyYXlcbiAqIG9mIGVhY2ggb2YgdGhlIGl0ZXJhdG9ycyBuZXh0IHZhbHVlcy4gU3RvcHMgd2hlbiB0aGUgc2hvcnRlc3QgaXRlcmF0b3IgaXNcbiAqIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0gey4uLkl0ZXJhdG9yfSB2YXJfYXJnc1xuICogQHJldHVybiB7SXRlcmF0b3J9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKiB6aXBJdGVyYXRvcigpIHtcbiAgLy8gVE9ETzogVXNlIHJlc3QgcGFyYW1ldGVyIG9uY2UgNnRvNSBpcyBmaXhlZCAoMi4wKVxuICB2YXIgdmFyQXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbmd0aCA9IHZhckFyZ3MubGVuZ3RoO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB2YXIgbmV4dFppcCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gdmFyQXJnc1tpXS5uZXh0KCk7XG4gICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5leHRaaXBbaV0gPSBuZXh0LnZhbHVlO1xuICAgIH1cbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHlpZWxkIG5leHRaaXA7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZSc7XG5pbXBvcnQgaXNJdGVyYXRvciBmcm9tICcuL2lzSXRlcmF0b3InO1xuaW1wb3J0IHppcEl0ZXJhdG9yIGZyb20gJy4vemlwSXRlcmF0b3InO1xuXG5mdW5jdGlvbiB6aXBBcnJheSguLi52YXJBcmdzKSB7XG4gIC8vIFByZS1hbGxvY2F0aW9uIGFycmF5cyBzcGVlZHMgdXAgYXNzaWdubWVudCBkcmFzdGljYWxseSwgc28gd2Ugd2FudCB0b1xuICAvLyBvcHRpbWl6ZSBmb3IgdGhhdCBjYXNlXG4gIHZhciBsZW5ndGggPSB2YXJBcmdzLmxlbmd0aDtcbiAgdmFyIG1pbiA9IEluZmluaXR5O1xuICB2YXIgaTtcbiAgdmFyIHJlc3VsdDtcbiAgdmFyIG5leHRaaXAgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAvLyBmaXJzdCBwYXNzXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBhcnJheSA9IHZhckFyZ3NbaV07XG4gICAgdmFyIGFycmF5TGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChhcnJheUxlbmd0aCA8IG1pbikge1xuICAgICAgbWluID0gYXJyYXlMZW5ndGg7XG4gICAgICBpZiAobWluID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTsgLy8gYmFja291dCBlYXJseVxuICAgICAgfVxuICAgIH1cbiAgICBuZXh0WmlwW2ldID0gYXJyYXlbMF07XG4gIH1cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG1pbik7XG4gIHJlc3VsdFswXSA9IG5leHRaaXA7XG5cbiAgZm9yIChpID0gMTsgaSA8IG1pbjsgaSsrKSB7XG4gICAgbmV4dFppcCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgIG5leHRaaXBbal0gPSB2YXJBcmdzW2pdW2ldO1xuICAgIH1cbiAgICByZXN1bHRbaV0gPSBuZXh0WmlwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIHppcCBzZXF1ZW5jZSB0eXBlcyAoYXJyYXlzLCBhcnJheS1saWtlIG9iamVjdHMsIG9iamVjdHMsIGV0YykuXG4gKiBBbGwgYXJndW1lbnRzIG11c3QgYmUgdGhlIHNhbWUgdHlwZS4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgdHlwZS5cbiAqIFRoaXMgYmVoYXZlcyB0aGUgc2FtZSBhcyBQeXRob24ncyB6aXAgZnVuY3Rpb24sIGkuZS4gdGhlIHJlc3VsdCBoYXMgdGhlXG4gKiBsZW5ndGggb2YgdGhlIHNob3J0ZXN0IGlucHV0LlxuICpcbiAqIEFycmF5IC0+IEFycmF5XG4gKiBBcnJheS1saWtlIC0+IEFycmF5XG4gKiBJdGVyYXRvciAtPiBJdGVyYXRvclxuICpcbiAqIEBwYXJhbSB7Li4uKEl0ZXJhYmxlKX0gdmFyX2FyZ3NcbiAqXG4gKiBAcmV0dXJuIHshKEFycmF5fEl0ZXJhdG9yKX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gemlwU2VxdWVuY2UoLi4udmFyQXJncykge1xuICB2YXIgZmlyc3QgPSB2YXJBcmdzWzBdO1xuXG4gIGlmIChpc0FycmF5TGlrZShmaXJzdCkpIHtcbiAgICByZXR1cm4gemlwQXJyYXkuYXBwbHkobnVsbCwgdmFyQXJncyk7XG4gIH1cbiAgZWxzZSBpZihpc0l0ZXJhdG9yKGZpcnN0KSkge1xuICAgIHJldHVybiB6aXBJdGVyYXRvci5hcHBseShudWxsLCB2YXJBcmdzKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0V4cGVjdGVkIGFuIGl0ZXJhdG9yLCBhcnJheS1saWtlIG9iamVjdCBvciBvYmplY3QsIGJ1dCBnb3QgJXMgaW5zdGVhZCcsXG4gICAgICBmaXJzdFxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCBkZWxlZ2F0ZSBmcm9tIFwiLi4vLi4vX2ludGVybmFscy9kZWxlZ2F0ZVwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7XG4gIEFycmF5cyxcbiAgTWFwLFxuICBQcmlvcml0eVF1ZXVlLFxuICBnZXREZWZhdWx0LFxuICB0dXBsZTJcbn0gZnJvbSAnLi4vLi4vX2ludGVybmFscyc7XG5cbnZhciBiZXR3ZWVubmVzc0NlbnRyYWxpdHlBcmdzO1xuXG5leHBvcnQgZnVuY3Rpb24gYmV0d2Vlbm5lc3NDZW50cmFsaXR5KEcsIG9wdEFyZ0RpY3Q9e30pIHtcbiAgLy8gVE9ETzogVXNlIGRlc3RydWN0dXJpbmcgZGVmYXVsdHMgb25jZSA2dG81IHN1cHBvcnRzIGl0XG4gIC8vIHtrPW51bGwsIG5vcm1hbGl6ZWQ9dHJ1ZSwgd2VpZ2h0PW51bGwsIGVuZHBvaW50cz1mYWxzZX1cbiAgdmFyIHtrLCBub3JtYWxpemVkLCB3ZWlnaHQsIGVuZHBvaW50c30gPSBvcHRBcmdEaWN0O1xuXG4gIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkID09IG51bGwgPyB0cnVlIDogbm9ybWFsaXplZDtcbiAgZW5kcG9pbnRzID0gZW5kcG9pbnRzID09IG51bGwgPyBmYWxzZSA6IGVuZHBvaW50cztcblxuICB2YXIgYmV0d2Vlbm5lc3MgPSBuZXcgTWFwKChmb3IgKHYgb2YgRykgdHVwbGUyKHYsIDApKSk7XG5cbiAgdmFyIG5vZGVzID0gRy5ub2RlcygpO1xuICBpZiAoayAhPSBudWxsKSB7XG4gICAgbm9kZXMgPSBBcnJheXMuc2FtcGxlKG5vZGVzLCBrKTtcbiAgfVxuXG4gIG5vZGVzLmZvckVhY2gocyA9PiB7XG4gICAgLy8gc2luZ2xlIHNvdXJjZSBzaG9ydGVzdCBwYXRoc1xuICAgIHZhciBbUywgUCwgc2lnbWFdID0gd2VpZ2h0ID09IG51bGwgP1xuICAgICAgc2luZ2xlU291cmNlU2hvcnRlc3RQYXRoQmFzaWMoRywgcykgOiAvLyB1c2UgQkZTXG4gICAgICBzaW5nbGVTb3VyY2VEaWprc3RyYVBhdGhCYXNpYyhHLCBzLCB3ZWlnaHQpOyAvLyB1c2UgRGlqa3N0cmEncyBhbGdvcml0aG1cbiAgICAvLyBhY2N1bXVsYXRpb25cbiAgICBiZXR3ZWVubmVzcyA9IGVuZHBvaW50cyA/XG4gICAgICBhY2N1bXVsYXRlRW5kcG9pbnRzKGJldHdlZW5uZXNzLCBTLCBQLCBzaWdtYSwgcykgOlxuICAgICAgYWNjdW11bGF0ZUJhc2ljKGJldHdlZW5uZXNzLCBTLCBQLCBzaWdtYSwgcyk7XG4gIH0pO1xuICAvLyByZXNjYWxpbmdcbiAgcmV0dXJuIHJlc2NhbGUoYmV0d2Vlbm5lc3MsIEcub3JkZXIoKSwgbm9ybWFsaXplZCwgRy5pc0RpcmVjdGVkKCksIGspO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuQmV0d2Vlbm5lc3NDZW50cmFsaXR5KEcsIG9wdEFyZ0RpY3QpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwiYmV0d2Vlbm5lc3NDZW50cmFsaXR5XCIsIFtHLCBvcHRBcmdEaWN0XSk7XG59O1xuXG52YXIgZWRnZUJldHdlZW5uZXNzQ2VudHJhbGl0eUFyZ3M7XG5cbmV4cG9ydCBmdW5jdGlvbiBlZGdlQmV0d2Vlbm5lc3NDZW50cmFsaXR5KEcsIG9wdEFyZ0RpY3Q9e30pIHtcbiAgLy8gVE9ETzogVXNlIGRlc3RydWN0dXJpbmcgZGVmYXVsdHMgb25jZSA2dG81IHN1cHBvcnRzIGl0XG4gIHZhciB7bm9ybWFsaXplZCwgd2VpZ2h0fSA9IG9wdEFyZ0RpY3Q7XG4gIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkID09IG51bGwgPyB0cnVlIDogbm9ybWFsaXplZDtcblxuICB2YXIgYmV0d2Vlbm5lc3MgPSBuZXcgTWFwKChmb3IgKHYgb2YgRykgdHVwbGUyKHYsIDApKSk7XG4gIGZvciAodmFyIGVkZ2Ugb2YgRy5lZGdlc0l0ZXIoKSkge1xuICAgIGJldHdlZW5uZXNzLnNldChlZGdlLCAwKTtcbiAgfVxuXG4gIHZhciBub2RlcyA9IEcubm9kZXMoKTtcbiAgZm9yICh2YXIgcyBvZiBHKSB7XG4gICAgLy8gc2luZ2xlIHNvdXJjZSBzaG9ydGVzdCBwYXRoc1xuICAgIHZhciBbUywgUCwgc2lnbWFdID0gd2VpZ2h0ID09IG51bGwgP1xuICAgICAgc2luZ2xlU291cmNlU2hvcnRlc3RQYXRoQmFzaWMoRywgcykgOiAvLyB1c2UgQkZTXG4gICAgICBzaW5nbGVTb3VyY2VEaWprc3RyYVBhdGhCYXNpYyhHLCBzLCB3ZWlnaHQpOyAvLyB1c2UgRGlqa3N0cmEncyBhbGdvcml0aG1cbiAgICAvLyBhY2N1bXVsYXRpb25cbiAgICBiZXR3ZWVubmVzcyA9IGFjY3VtdWxhdGVFZGdlcyhiZXR3ZWVubmVzcywgUywgUCwgc2lnbWEsIHMpO1xuICB9XG4gIC8vIHJlc2NhbGluZ1xuICBmb3IgKHZhciBuIG9mIEcpIHtcbiAgICBiZXR3ZWVubmVzcy5kZWxldGUobik7XG4gIH1cbiAgcmV0dXJuIHJlc2NhbGVFKGJldHdlZW5uZXNzLCBHLm9yZGVyKCksIG5vcm1hbGl6ZWQsIEcuaXNEaXJlY3RlZCgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbkVkZ2VCZXR3ZWVubmVzc0NlbnRyYWxpdHkoRywgb3B0QXJnRGljdCkge1xuICByZXR1cm4gZGVsZWdhdGUoXCJlZGdlQmV0d2Vlbm5lc3NDZW50cmFsaXR5XCIsIFtHLCBvcHRBcmdEaWN0XSk7XG59O1xuXG5mdW5jdGlvbiBzaW5nbGVTb3VyY2VTaG9ydGVzdFBhdGhCYXNpYyhHLCBzKSB7XG4gIHZhciBTID0gW107XG4gIHZhciBQID0gbmV3IE1hcCgoZm9yICh2IG9mIEcpIHR1cGxlMih2LCBbXSkpKTtcbiAgdmFyIHNpZ21hID0gbmV3IE1hcCgoZm9yICh2IG9mIEcpIHR1cGxlMih2LCAwKSkpO1xuICB2YXIgRCA9IG5ldyBNYXAoKTtcblxuICBzaWdtYS5zZXQocywgMSk7XG4gIEQuc2V0KHMsIDApO1xuICB2YXIgUSA9IFtzXTtcbiAgd2hpbGUgKFEubGVuZ3RoID4gMCkgeyAgLy8gdXNlIEJGUyB0byBmaW5kIHNob3J0ZXN0IHBhdGhzXG4gICAgdmFyIHYgPSBRLnNoaWZ0KCk7XG4gICAgUy5wdXNoKHYpO1xuICAgIHZhciBEdiA9IEQuZ2V0KHYpO1xuICAgIHZhciBzaWdtYXYgPSBzaWdtYS5nZXQodik7XG4gICAgRy5uZWlnaGJvcnModikuZm9yRWFjaCh3ID0+IHtcbiAgICAgIGlmICghRC5oYXModykpIHtcbiAgICAgICAgUS5wdXNoKHcpO1xuICAgICAgICBELnNldCh3LCBEdiArIDEpO1xuICAgICAgfVxuICAgICAgaWYgKEQuZ2V0KHcpID09PSBEdiArIDEpIHsgICAvLyB0aGlzIGlzIGEgc2hvcnRlc3QgcGF0aCwgY291bnQgcGF0aHNcbiAgICAgICAgc2lnbWEuc2V0KHcsIHNpZ21hLmdldCh3KSArIHNpZ21hdik7XG4gICAgICAgIFAuZ2V0KHcpLnB1c2godik7ICAgIC8vIHByZWRlY2Vzc29yc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBbUywgUCwgc2lnbWFdO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVTb3VyY2VEaWprc3RyYVBhdGhCYXNpYyhHLCBzLCB3ZWlnaHQ9J3dlaWdodCcpIHtcbiAgLy8gbW9kaWZpZWQgZnJvbSBFcHBzdGVpblxuICB2YXIgUyA9IFtdO1xuICB2YXIgUCA9IG5ldyBNYXAoKGZvciAodiBvZiBHKSB0dXBsZTIodiwgW10pKSk7XG4gIHZhciBzaWdtYSA9IG5ldyBNYXAoKGZvciAodiBvZiBHKSB0dXBsZTIodiwgMCkpKTtcbiAgdmFyIEQgPSBuZXcgTWFwKCk7XG5cbiAgc2lnbWEuc2V0KHMsIDEpO1xuICB2YXIgc2VlbiA9IG5ldyBNYXAoW3R1cGxlMihzLCAwKV0pO1xuICAvLyB1c2UgUSBhcyBoZWFwIHdpdGggKGRpc3RhbmNlLG5vZGUgaWQpIHR1cGxlc1xuICB2YXIgUSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG4gIFEuZW5xdWV1ZSgwLCBbcywgc10pO1xuICB3aGlsZSAoUS5zaXplID4gMCkge1xuICAgIHZhciBbZGlzdCwgW3ByZWQsIHZdXSA9IFEuZGVxdWV1ZSgpO1xuICAgIGlmIChELmhhcyh2KSkge1xuICAgICAgY29udGludWU7ICAgLy8gYWxyZWFkeSBzZWFyY2hlZCB0aGlzIG5vZGUuXG4gICAgfVxuICAgIHNpZ21hLnNldCh2LCBzaWdtYS5nZXQodikgKyBzaWdtYS5nZXQocHJlZCkpOyAgICAvLyBjb3VudCBwYXRoc1xuICAgIFMucHVzaCh2KTtcbiAgICBELnNldCh2LCBkaXN0KTtcblxuICAgIGZvciAodmFyIFt3LCBlZGdlZGF0YV0gb2YgRy5nZXQodikpIHtcbiAgICAgIHZhciB2d19kaXN0ID0gZGlzdCArIGdldERlZmF1bHQoZWRnZWRhdGFbd2VpZ2h0XSwgMSk7XG4gICAgICBpZiAoIUQuaGFzKHcpICYmICghc2Vlbi5oYXModykgfHwgdndfZGlzdCA8IHNlZW4uZ2V0KHcpKSkge1xuICAgICAgICBzZWVuLnNldCh3LCB2d19kaXN0KTtcbiAgICAgICAgUS5lbnF1ZXVlKHZ3X2Rpc3QsIFt2LCB3XSk7XG4gICAgICAgIHNpZ21hLnNldCh3LCAwKTtcbiAgICAgICAgUC5zZXQodywgW3ZdKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZ3X2Rpc3QgPT09IHNlZW4uZ2V0KHcpKSB7ICAvLyBoYW5kbGUgZXF1YWwgcGF0aHNcbiAgICAgICAgc2lnbWEuc2V0KHcsIHNpZ21hLmdldCh3KSArIHNpZ21hLmdldCh2KSk7XG4gICAgICAgIFAuZ2V0KHcpLnB1c2godik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbUywgUCwgc2lnbWFdO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlQmFzaWMoYmV0d2Vlbm5lc3MsIFMsIFAsIHNpZ21hLCBzKSB7XG4gIHZhciBkZWx0YSA9IG5ldyBNYXAoKGZvciAocyBvZiBTKSB0dXBsZTIocywgMCkpKTtcblxuICB3aGlsZSAoUy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHcgPSBTLnBvcCgpO1xuICAgIHZhciBjb2VmZiA9ICgxICsgZGVsdGEuZ2V0KHcpKSAvIHNpZ21hLmdldCh3KTtcbiAgICBQLmdldCh3KS5mb3JFYWNoKHYgPT4ge1xuICAgICAgZGVsdGEuc2V0KHYsIGRlbHRhLmdldCh2KSArIHNpZ21hLmdldCh2KSAqIGNvZWZmKTtcbiAgICB9KTtcbiAgICAvLyBoYW5kbGUgb2JqZWN0IG5vZGVzXG4gICAgaWYgKHcgIT09IHMgfHwgdHlwZW9mIHcgPT09ICdvYmplY3QnICYmIHcudG9TdHJpbmcoKSAhPT0gcy50b1N0cmluZygpKSB7XG4gICAgICBiZXR3ZWVubmVzcy5zZXQodywgYmV0d2Vlbm5lc3MuZ2V0KHcpICsgZGVsdGEuZ2V0KHcpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJldHdlZW5uZXNzO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW5kcG9pbnRzKGJldHdlZW5uZXNzLCBTLCBQLCBzaWdtYSwgcykge1xuICBiZXR3ZWVubmVzcy5zZXQocywgYmV0d2Vlbm5lc3MuZ2V0KHMpICsgUy5sZW5ndGggLSAxKTtcbiAgdmFyIGRlbHRhID0gbmV3IE1hcCgoZm9yIChzIG9mIFMpIHR1cGxlMihzLCAwKSkpO1xuXG4gIHdoaWxlIChTLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgdyA9IFMucG9wKCk7XG4gICAgdmFyIGNvZWZmID0gKDEgKyBkZWx0YS5nZXQodykpIC8gc2lnbWEuZ2V0KHcpO1xuICAgIFAuZ2V0KHcpLmZvckVhY2godiA9PiB7XG4gICAgICBkZWx0YS5zZXQodiwgZGVsdGEuZ2V0KHYpICsgc2lnbWEuZ2V0KHYpICogY29lZmYpO1xuICAgIH0pO1xuICAgIC8vIGhhbmRsZSBvYmplY3Qgbm9kZXNcbiAgICBpZiAodyAhPT0gcyB8fCB0eXBlb2YgdyA9PT0gJ29iamVjdCcgJiYgdy50b1N0cmluZygpICE9PSBzLnRvU3RyaW5nKCkpIHtcbiAgICAgIGJldHdlZW5uZXNzLnNldCh3LCBiZXR3ZWVubmVzcy5nZXQodykgKyBkZWx0YS5nZXQodykgKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJldHdlZW5uZXNzO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRWRnZXMoYmV0d2Vlbm5lc3MsIFMsIFAsIHNpZ21hLCBzKSB7XG4gIHZhciBkZWx0YSA9IG5ldyBNYXAoKGZvciAocyBvZiBTKSB0dXBsZTIocywgMCkpKTtcblxuICB3aGlsZSAoUy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHcgPSBTLnBvcCgpO1xuICAgIHZhciBjb2VmZiA9ICgxICsgZGVsdGEuZ2V0KHcpKSAvIHNpZ21hLmdldCh3KTtcbiAgICBQLmdldCh3KS5mb3JFYWNoKHYgPT4ge1xuICAgICAgdmFyIGMgPSBzaWdtYS5nZXQodikgKiBjb2VmZjtcbiAgICAgIHZhciBlZGdlID0gW3YsIHddO1xuICAgICAgaWYgKCFiZXR3ZWVubmVzcy5oYXMoZWRnZSkpIHtcbiAgICAgICAgZWRnZSA9IFt3LCB2XTtcbiAgICAgIH1cbiAgICAgIGJldHdlZW5uZXNzLnNldChlZGdlLCBiZXR3ZWVubmVzcy5nZXQoZWRnZSkgKyBjKTtcbiAgICAgIGRlbHRhLnNldCh2LCBkZWx0YS5nZXQodikgKyBjKTtcbiAgICB9KTtcbiAgICAvLyBoYW5kbGUgb2JqZWN0IG5vZGVzXG4gICAgaWYgKHcgIT09IHMgfHwgdHlwZW9mIHcgPT09ICdvYmplY3QnICYmIHcudG9TdHJpbmcoKSAhPT0gcy50b1N0cmluZygpKSB7XG4gICAgICBiZXR3ZWVubmVzcy5zZXQodywgYmV0d2Vlbm5lc3MuZ2V0KHcpICsgZGVsdGEuZ2V0KHcpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJldHdlZW5uZXNzO1xufVxuXG5mdW5jdGlvbiByZXNjYWxlKGJldHdlZW5uZXNzLCBuLCBvcHROb3JtYWxpemVkLCBvcHREaXJlY3RlZD1mYWxzZSwgb3B0Sykge1xuICB2YXIgc2NhbGU7XG4gIGlmIChvcHROb3JtYWxpemVkKSB7XG4gICAgICBzY2FsZSA9IG4gPD0gMiA/IG51bGwgOiAxIC8gKChuIC0gMSkgKiAobiAtIDIpKTtcbiAgfVxuICBlbHNlIHsgIC8vIHJlc2NhbGUgYnkgMiBmb3IgdW5kaXJlY3RlZCBncmFwaHNcbiAgICBzY2FsZSA9ICFvcHREaXJlY3RlZCA/IDEgLyAyIDogbnVsbDtcbiAgfVxuICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgIGlmIChvcHRLICE9IG51bGwpIHtcbiAgICAgIHNjYWxlID0gc2NhbGUgKiBuIC8gb3B0SztcbiAgICB9XG4gICAgYmV0d2Vlbm5lc3MuZm9yRWFjaCgodiwgaykgPT4gYmV0d2Vlbm5lc3Muc2V0KGssIHYgKiBzY2FsZSkpO1xuICB9XG4gIHJldHVybiBiZXR3ZWVubmVzcztcbn1cblxuZnVuY3Rpb24gcmVzY2FsZUUoYmV0d2Vlbm5lc3MsIG4sIG9wdE5vcm1hbGl6ZWQsIG9wdERpcmVjdGVkKSB7XG4gIHZhciBzY2FsZTtcbiAgaWYgKG9wdE5vcm1hbGl6ZWQpIHtcbiAgICAgIHNjYWxlID0gbiA8PSAxID8gbnVsbCA6IDEgLyAobiAqIChuIC0gMSkpO1xuICB9XG4gIGVsc2UgeyAgLy8gcmVzY2FsZSBieSAyIGZvciB1bmRpcmVjdGVkIGdyYXBoc1xuICAgIHNjYWxlID0gIW9wdERpcmVjdGVkID8gMSAvIDIgOiBudWxsO1xuICB9XG4gIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgYmV0d2Vlbm5lc3MuZm9yRWFjaCgodiwgaykgPT4gYmV0d2Vlbm5lc3Muc2V0KGssIHYgKiBzY2FsZSkpO1xuICB9XG4gIHJldHVybiBiZXR3ZWVubmVzcztcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0ICogYXMgYmV0d2Vlbm5lc3MgZnJvbSAnLi9iZXR3ZWVubmVzcyc7XG5cbmV4cG9ydCB7XG4gIGJldHdlZW5uZXNzXG59O1xuXG5leHBvcnQgKiBmcm9tICcuL2JldHdlZW5uZXNzJztcbiIsImltcG9ydCBkZWxlZ2F0ZSBmcm9tIFwiLi4vX2ludGVybmFscy9kZWxlZ2F0ZVwiO1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1xuLypqc2hpbnQgaWdub3JlOnN0YXJ0Ki9cbiAgTWFwLFxuICBTZXQsXG4vKmpzaGludCBpZ25vcmU6ZW5kKi9cblxuICBtYXBJdGVyYXRvcixcbiAgbWF4LFxuICB0dXBsZTJcbn0gZnJvbSAnLi4vX2ludGVybmFscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiogZmluZENsaXF1ZXMoRykge1xuICBpZiAoRy5udW1iZXJPZk5vZGVzKCkgPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgYWRqID0gbmV3IE1hcChtYXBJdGVyYXRvcihHLCB1ID0+IHtcbiAgICB2YXIgbmVpZ2hib3JzID0gbmV3IFNldChHLm5laWdoYm9yc0l0ZXIodSkpO1xuICAgIG5laWdoYm9ycy5kZWxldGUodSk7XG4gICAgcmV0dXJuIHR1cGxlMih1LCBuZWlnaGJvcnMpO1xuICB9KSk7XG5cbiAgdmFyIHN1YmdyYXBoID0gbmV3IFNldChHKTtcbiAgdmFyIGNhbmRpZGF0ZXMgPSBuZXcgU2V0KEcpO1xuICB2YXIgUSA9IFtudWxsXTtcblxuICB2YXIgdSA9IG1heChzdWJncmFwaCwgdSA9PiBjYW5kaWRhdGVzLmludGVyc2VjdGlvbihhZGouZ2V0KHUpKS5zaXplKTtcbiAgdmFyIGV4dF91ID0gY2FuZGlkYXRlcy5kaWZmZXJlbmNlKGFkai5nZXQodSkpO1xuICB2YXIgc3RhY2sgPSBbXTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChleHRfdS5zaXplID4gMCkge1xuICAgICAgdmFyIHEgPSBleHRfdS5wb3AoKTtcbiAgICAgIGNhbmRpZGF0ZXMuZGVsZXRlKHEpO1xuICAgICAgUVtRLmxlbmd0aCAtIDFdID0gcTtcbiAgICAgIHZhciBhZGpfcSA9IGFkai5nZXQocSk7XG4gICAgICB2YXIgc3ViZ3JhcGhfcSA9IHN1YmdyYXBoLmludGVyc2VjdGlvbihhZGpfcSk7XG4gICAgICBpZiAoc3ViZ3JhcGhfcS5zaXplID09PSAwKSB7XG4gICAgICAgIHlpZWxkIFEuc2xpY2UoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgY2FuZGlkYXRlc19xID0gY2FuZGlkYXRlcy5pbnRlcnNlY3Rpb24oYWRqX3EpO1xuICAgICAgICBpZiAoY2FuZGlkYXRlc19xLnNpemUgPiAwKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChbc3ViZ3JhcGgsIGNhbmRpZGF0ZXMsIGV4dF91XSk7XG4gICAgICAgICAgUS5wdXNoKG51bGwpO1xuICAgICAgICAgIHN1YmdyYXBoID0gc3ViZ3JhcGhfcTtcbiAgICAgICAgICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlc19xO1xuICAgICAgICAgIHUgPSBtYXgoc3ViZ3JhcGgsIHUgPT4gY2FuZGlkYXRlcy5pbnRlcnNlY3Rpb24oYWRqLmdldCh1KSkuc2l6ZSk7XG4gICAgICAgICAgZXh0X3UgPSBjYW5kaWRhdGVzLmRpZmZlcmVuY2UoYWRqLmdldCh1KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoUS5sZW5ndGggPT09IDAgfHwgc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgUS5wb3AoKTtcbiAgICAgIFtzdWJncmFwaCwgY2FuZGlkYXRlcywgZXh0X3VdID0gc3RhY2sucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5GaW5kQ2xpcXVlcyhHKSB7XG4gIHJldHVybiBkZWxlZ2F0ZShcImZpbmRDbGlxdWVzXCIsIFtHXSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24qIGZpbmRDbGlxdWVzUmVjdXJzaXZlKEcpIHtcbiAgaWYgKEcuc2l6ZSA9PT0gMCkge1xuICAgIHlpZWxkIFtdO1xuICB9XG5cbiAgdmFyIGFkaiA9IG5ldyBNYXAobWFwSXRlcmF0b3IoRywgdSA9PiB7XG4gICAgdmFyIG5laWdoYm9ycyA9IG5ldyBTZXQoRy5uZWlnaGJvcnNJdGVyKHUpKTtcbiAgICBuZWlnaGJvcnMuZGVsZXRlKHUpO1xuICAgIHJldHVybiB0dXBsZTIodSwgbmVpZ2hib3JzKTtcbiAgfSkpO1xuICB2YXIgUSA9IFtdO1xuXG4gIGZ1bmN0aW9uKiBleHBhbmQoc3ViZ3JhcGgsIGNhbmRpZGF0ZXMpIHtcbiAgICB2YXIgdSA9IG1heChzdWJncmFwaCwgdSA9PiBjYW5kaWRhdGVzLmludGVyc2VjdGlvbihhZGouZ2V0KHUpKS5zaXplKTtcbiAgICBmb3IgKHZhciBxIG9mIGNhbmRpZGF0ZXMuZGlmZmVyZW5jZShhZGouZ2V0KHUpKSkge1xuICAgICAgY2FuZGlkYXRlcy5kZWxldGUocSk7XG4gICAgICBRLnB1c2gocSk7XG4gICAgICB2YXIgYWRqX3EgPSBhZGouZ2V0KHEpO1xuICAgICAgdmFyIHN1YmdyYXBoX3EgPSBzdWJncmFwaC5pbnRlcnNlY3Rpb24oYWRqX3EpO1xuICAgICAgaWYgKHN1YmdyYXBoX3Euc2l6ZSA9PT0gMCkge1xuICAgICAgICB5aWVsZCBRLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZXNfcSA9IGNhbmRpZGF0ZXMuaW50ZXJzZWN0aW9uKGFkal9xKTtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZXNfcS5zaXplID4gMCkge1xuICAgICAgICAgIHlpZWxkKiBleHBhbmQoc3ViZ3JhcGhfcSwgY2FuZGlkYXRlc19xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUS5wb3AoKTtcbiAgICB9XG4gIH1cblxuICB5aWVsZCogZXhwYW5kKG5ldyBTZXQoRyksIG5ldyBTZXQoRykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuRmluZENsaXF1ZXNSZWN1cnNpdmUoRykge1xuICByZXR1cm4gZGVsZWdhdGUoXCJmaW5kQ2xpcXVlc1JlY3Vyc2l2ZVwiLCBbR10pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXBoQ2xpcXVlTnVtYmVyKEcsIG9wdENsaXF1ZXMpIHtcbiAgaWYgKG9wdENsaXF1ZXMgPT0gbnVsbCkge1xuICAgIG9wdENsaXF1ZXMgPSBmaW5kQ2xpcXVlcyhHKTtcbiAgfVxuICByZXR1cm4gbWF4KG9wdENsaXF1ZXMsIGMgPT4gYy5sZW5ndGgpLmxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbkdyYXBoQ2xpcXVlTnVtYmVyKEcsIG9wdENsaXF1ZXMpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwiZ3JhcGhDbGlxdWVOdW1iZXJcIiwgW0csIG9wdENsaXF1ZXNdKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBncmFwaE51bWJlck9mQ2xpcXVlcyhHLCBvcHRDbGlxdWVzKSB7XG4gIGlmIChvcHRDbGlxdWVzID09IG51bGwpIHtcbiAgICBvcHRDbGlxdWVzID0gZmluZENsaXF1ZXMoRyk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20ob3B0Q2xpcXVlcykubGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuR3JhcGhOdW1iZXJPZkNsaXF1ZXMoRywgb3B0Q2xpcXVlcykge1xuICByZXR1cm4gZGVsZWdhdGUoXCJncmFwaE51bWJlck9mQ2xpcXVlc1wiLCBbRywgb3B0Q2xpcXVlc10pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlck9mQ2xpcXVlcyhHLCBvcHROb2Rlcywgb3B0Q2xpcXVlcykge1xuICBvcHRDbGlxdWVzID0gQXJyYXkuZnJvbShvcHRDbGlxdWVzIHx8IGZpbmRDbGlxdWVzKEcpKTtcblxuICBpZiAob3B0Tm9kZXMgPT0gbnVsbCkge1xuICAgIG9wdE5vZGVzID0gRy5ub2RlcygpOyAvLyBub25lLCBnZXQgZW50aXJlIGdyYXBoXG4gIH1cblxuICB2YXIgbnVtY2xpcTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG9wdE5vZGVzKSkge1xuICAgIHZhciB2ID0gb3B0Tm9kZXM7XG4gICAgbnVtY2xpcSA9IG9wdENsaXF1ZXMuZmlsdGVyKGMgPT4gKG5ldyBTZXQoYykpLmhhcyh2KSkubGVuZ3RoO1xuICB9XG4gIGVsc2Uge1xuICAgIG9wdENsaXF1ZXMgPSBvcHRDbGlxdWVzLm1hcChjID0+IG5ldyBTZXQoYykpO1xuICAgIG51bWNsaXEgPSBuZXcgTWFwKCk7XG4gICAgb3B0Tm9kZXMuZm9yRWFjaCh2ID0+IHtcbiAgICAgIG51bWNsaXEuc2V0KHYsIG9wdENsaXF1ZXMuZmlsdGVyKGMgPT4gYy5oYXModikpLmxlbmd0aCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG51bWNsaXE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5OdW1iZXJPZkNsaXF1ZXMoRywgb3B0Tm9kZXMsIG9wdENsaXF1ZXMpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwibnVtYmVyT2ZDbGlxdWVzXCIsIFtHLCBvcHROb2Rlcywgb3B0Q2xpcXVlc10pO1xufTsiLCJpbXBvcnQgZGVsZWdhdGUgZnJvbSBcIi4uL19pbnRlcm5hbHMvZGVsZWdhdGVcIjtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgSlNOZXR3b3JrWEVycm9yID0gcmVxdWlyZSgnLi4vZXhjZXB0aW9ucy9KU05ldHdvcmtYRXJyb3InKTtcblxuaW1wb3J0IHtcbi8qanNoaW50IGlnbm9yZTpzdGFydCovXG4gIE1hcCxcbiAgU2V0LFxuLypqc2hpbnQgaWdub3JlOmVuZCovXG5cbiAgZ2VuQ29tYmluYXRpb25zLFxuICBnZXREZWZhdWx0LFxuICBtYXBJdGVyYXRvcixcbiAgbWF4LFxuICBuZXh0LFxuICB0dXBsZTIsXG4gIHR1cGxlM1xufSBmcm9tICcuLi9faW50ZXJuYWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRyaWFuZ2xlcyhHLCBvcHROb2Rlcykge1xuICBpZiAoRy5pc0RpcmVjdGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKFxuICAgICAgJ3RyaWFuZ2xlcygpIGlzIG5vdCBkZWZpbmVkIGZvciBkaXJlY3RlZCBncmFwaHMuJ1xuICAgICk7XG4gIH1cblxuICBpZiAob3B0Tm9kZXMgIT0gbnVsbCAmJiBHLmhhc05vZGUob3B0Tm9kZXMpKSB7XG4gICAgLy8gcmV0dXJuIHNpbmdsZSB2YWx1ZVxuICAgIHJldHVybiBNYXRoLmZsb29yKG5leHQodHJpYW5nbGVzQW5kRGVncmVlSXRlcihHLCBvcHROb2RlcykpWzJdIC8gMik7XG4gIH1cblxuICByZXR1cm4gbmV3IE1hcChtYXBJdGVyYXRvcihcbiAgICB0cmlhbmdsZXNBbmREZWdyZWVJdGVyKEcsIG9wdE5vZGVzKSxcbiAgICAoW3YsIF8sIHRyaWFuZ2xlc10pID0+IHR1cGxlMih2LCBNYXRoLmZsb29yKHRyaWFuZ2xlcy8yKSwgdilcbiAgKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5UcmlhbmdsZXMoRywgb3B0Tm9kZXMpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwidHJpYW5nbGVzXCIsIFtHLCBvcHROb2Rlc10pO1xufTtcblxuZnVuY3Rpb24qIHRyaWFuZ2xlc0FuZERlZ3JlZUl0ZXIoRywgb3B0Tm9kZXMpIHtcbiAgaWYgKEcuaXNNdWx0aWdyYXBoKCkpIHtcbiAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKCdOb3QgZGVmaW5lZCBmb3IgbXVsdGlncmFwaHMuJyk7XG4gIH1cblxuICB2YXIgbm9kZXNOYnJzID0gbWFwSXRlcmF0b3IoXG4gICAgb3B0Tm9kZXMgPT0gbnVsbCA/IEcgOiBHLm5idW5jaEl0ZXIob3B0Tm9kZXMpLFxuICAgIG4gPT4gdHVwbGUyKG4sIEcuZ2V0KG4pKVxuICApO1xuXG4gIGZvciAodmFyIFt2LCB2TmJyc10gb2Ygbm9kZXNOYnJzKSB7XG4gICAgdmFyIHZzZXQgPSBuZXcgU2V0KHZOYnJzLmtleXMoKSk7XG4gICAgdnNldC5kZWxldGUodik7XG4gICAgdmFyIG50cmlhbmdsZXMgPSAwO1xuICAgIGZvciAodmFyIHcgb2YgdnNldCkge1xuICAgICAgdmFyIHdzZXQgPSBuZXcgU2V0KEcuZ2V0KHcpLmtleXMoKSk7XG4gICAgICB3c2V0LmRlbGV0ZSh3KTtcbiAgICAgIG50cmlhbmdsZXMgKz0gdnNldC5pbnRlcnNlY3Rpb24od3NldCkuc2l6ZTtcbiAgICB9XG4gICAgeWllbGQgdHVwbGUzKHYsIHZzZXQuc2l6ZSwgbnRyaWFuZ2xlcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24qIHdlaWdodGVkVHJpYW5nbGVzQW5kRGVncmVlSXRlcihHLCBvcHROb2Rlcywgb3B0V2VpZ2h0PSd3ZWlnaHQnKSB7XG4gIGlmIChHLmlzTXVsdGlncmFwaCgpKSB7XG4gICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcignTm90IGRlZmluZWQgZm9yIG11bHRpZ3JhcGhzLicpO1xuICB9XG5cbiAgdmFyIG1heFdlaWdodCA9IG9wdFdlaWdodCA9PSBudWxsIHx8IEcuZWRnZXMoKS5sZW5ndGggPT09IDAgP1xuICAgIDEgOlxuICAgIG1heChtYXBJdGVyYXRvcihcbiAgICAgIEcuZWRnZXNJdGVyKHRydWUpLFxuICAgICAgKFt1LCB2LCBkYXRhXSkgPT4gZ2V0RGVmYXVsdChkYXRhW29wdFdlaWdodF0sIDEpXG4gICAgKSk7XG5cbiAgdmFyIG5vZGVzTmJycyA9IG1hcEl0ZXJhdG9yKFxuICAgIG9wdE5vZGVzID09IG51bGwgPyBHIDogRy5uYnVuY2hJdGVyKG9wdE5vZGVzKSxcbiAgICBuID0+IHR1cGxlMihuLCBHLmdldChuKSlcbiAgKTtcblxuICBmb3IgKHZhciBbaSwgbmJyc10gb2Ygbm9kZXNOYnJzKSB7XG4gICAgdmFyIGluYnJzID0gbmV3IFNldChuYnJzLmtleXMoKSkuZGlmZmVyZW5jZShbaV0pO1xuXG4gICAgdmFyIHdlaWdodGVkVHJpYW5nbGVzID0gMDtcbiAgICB2YXIgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKHZhciBqIG9mIGluYnJzKSB7XG4gICAgICB2YXIgd2VpZ2h0aWogPSBnZXREZWZhdWx0KG5icnMuZ2V0KGopW29wdFdlaWdodF0sIDEpIC8gbWF4V2VpZ2h0O1xuICAgICAgc2Vlbi5hZGQoaik7XG4gICAgICB2YXIgam5icnMgPSBuZXcgU2V0KEcuZ2V0KGopLmtleXMoKSkuZGlmZmVyZW5jZShzZWVuKTtcbiAgICAgIGZvciAodmFyIGsgb2YgaW5icnMuaW50ZXJzZWN0aW9uKGpuYnJzKSkge1xuICAgICAgICB2YXIgd2VpZ2h0amsgPSBnZXREZWZhdWx0KEcuZ2V0KGopLmdldChrKVtvcHRXZWlnaHRdLCAxKSAvIG1heFdlaWdodDtcbiAgICAgICAgdmFyIHdlaWdodGtpID0gZ2V0RGVmYXVsdChuYnJzLmdldChrKVtvcHRXZWlnaHRdLCAxKSAvIG1heFdlaWdodDtcbiAgICAgICAgd2VpZ2h0ZWRUcmlhbmdsZXMgKz0gTWF0aC5wb3cod2VpZ2h0aWogKiB3ZWlnaHRqayAqIHdlaWdodGtpLCAxLzMpO1xuICAgICAgfVxuICAgIH1cbiAgICB5aWVsZCB0dXBsZTMoaSwgaW5icnMuc2l6ZSwgd2VpZ2h0ZWRUcmlhbmdsZXMgKiAyKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXZlcmFnZUNsdXN0ZXJpbmcoRywgb3B0Tm9kZXMsIG9wdFdlaWdodCwgb3B0Q291bnRaZXJvcz10cnVlKSB7XG4gIHZhciBjbHVzdGVycyA9IEFycmF5LmZyb20oY2x1c3RlcmluZyhHLCBvcHROb2Rlcywgb3B0V2VpZ2h0KS52YWx1ZXMoKSk7XG5cbiAgaWYgKCFvcHRDb3VudFplcm9zKSB7XG4gICAgY2x1c3RlcnMgPSBjbHVzdGVycy5maWx0ZXIodiA9PiB2ID4gMCk7XG4gIH1cbiAgcmV0dXJuIGNsdXN0ZXJzLnJlZHVjZSgocywgeCkgPT4gcyArIHgsIDApIC8gY2x1c3RlcnMubGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuQXZlcmFnZUNsdXN0ZXJpbmcoRywgb3B0Tm9kZXMsIG9wdFdlaWdodCwgb3B0Q291bnRaZXJvcykge1xuICByZXR1cm4gZGVsZWdhdGUoXCJhdmVyYWdlQ2x1c3RlcmluZ1wiLCBbRywgb3B0Tm9kZXMsIG9wdFdlaWdodCwgb3B0Q291bnRaZXJvc10pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNsdXN0ZXJpbmcoRywgb3B0Tm9kZXMsIG9wdFdlaWdodCkge1xuICBpZiAoRy5pc0RpcmVjdGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKFxuICAgICAgJ0NsdXN0ZXJpbmcgYWxnb3JpdGhtcyBhcmUgbm90IGRlZmluZWQgZm9yIGRpcmVjdGVkIGdyYXBocy4nXG4gICAgKTtcbiAgfVxuXG5cbiAgdmFyIHRyaWFuZ2xlc0l0ZXIgPSBvcHRXZWlnaHQgPT0gbnVsbCA/XG4gICAgdHJpYW5nbGVzQW5kRGVncmVlSXRlcihHLCBvcHROb2RlcykgOlxuICAgIHdlaWdodGVkVHJpYW5nbGVzQW5kRGVncmVlSXRlcihHLCBvcHROb2Rlcywgb3B0V2VpZ2h0KTtcblxuICB2YXIgY2x1c3RlcnMgPSBuZXcgTWFwKG1hcEl0ZXJhdG9yKFxuICAgIHRyaWFuZ2xlc0l0ZXIsXG4gICAgKFtub2RlLCBkZWdyZWUsIHRyaWFuZ2xlc10pID0+IHtcbiAgICAgIHJldHVybiB0dXBsZTIoXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHRyaWFuZ2xlcyA9PT0gMCA/IDAgOiB0cmlhbmdsZXMvKGRlZ3JlZSAqIChkZWdyZWUgLSAxKSlcbiAgICAgICk7XG4gICAgfVxuICApKTtcblxuICByZXR1cm4gRy5oYXNOb2RlKG9wdE5vZGVzKSA/ICBuZXh0KGNsdXN0ZXJzLnZhbHVlcygpKSA6IGNsdXN0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuQ2x1c3RlcmluZyhHLCBvcHROb2Rlcywgb3B0V2VpZ2h0KSB7XG4gIHJldHVybiBkZWxlZ2F0ZShcImNsdXN0ZXJpbmdcIiwgW0csIG9wdE5vZGVzLCBvcHRXZWlnaHRdKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2l0aXZpdHkoRykge1xuICB2YXIgdHJpYW5nbGVzID0gMDsgLy8gNiB0aW1lcyBudW1iZXIgb2YgdHJpYW5nbGVzXG4gIHZhciB0cmlwbGVzID0gMDsgIC8vIDIgdGltZXMgbnVtYmVyIG9mIGNvbm5lY3RlZCB0cmlwbGVzXG5cbiAgZm9yICh2YXIgW25vZGUsIGRlZ3JlZSwgdHJpYW5nbGVzX10gb2YgdHJpYW5nbGVzQW5kRGVncmVlSXRlcihHKSkge1xuICAgIHRyaXBsZXMgKz0gZGVncmVlICogKGRlZ3JlZSAtIDEpO1xuICAgIHRyaWFuZ2xlcyArPSB0cmlhbmdsZXNfO1xuICB9XG5cbiAgcmV0dXJuIHRyaWFuZ2xlcyA9PT0gMCA/IDAgOiB0cmlhbmdsZXMgLyB0cmlwbGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuVHJhbnNpdGl2aXR5KEcpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwidHJhbnNpdGl2aXR5XCIsIFtHXSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlQ2x1c3RlcmluZyhHLCBvcHROb2Rlcykge1xuICB2YXIgbm9kZXNJdGVyID0gb3B0Tm9kZXMgPT0gbnVsbCA/IEcgOiBHLm5idW5jaEl0ZXIob3B0Tm9kZXMpO1xuICB2YXIgY2x1c3RlcmluZyA9IG5ldyBNYXAoKTtcblxuICBmb3IgKHZhciB2IG9mIG5vZGVzSXRlcikge1xuICAgIGNsdXN0ZXJpbmcuc2V0KHYsIDApO1xuICAgIHZhciBwb3RlbnRpYWwgPSAwO1xuXG4gICAgZm9yICh2YXIgW3UsIHddIG9mIGdlbkNvbWJpbmF0aW9ucyhHLmdldCh2KS5rZXlzKCksIDIpKSB7XG4gICAgICB2YXIgc3F1YXJlcyA9XG4gICAgICAgIChuZXcgU2V0KEcuZ2V0KHUpLmtleXMoKSkpLmludGVyc2VjdGlvbihuZXcgU2V0KEcuZ2V0KHcpLmtleXMoKSkpO1xuICAgICAgc3F1YXJlcy5kZWxldGUodik7XG4gICAgICBzcXVhcmVzID0gc3F1YXJlcy5zaXplO1xuXG4gICAgICBjbHVzdGVyaW5nLnNldCh2LCBjbHVzdGVyaW5nLmdldCh2KSArIHNxdWFyZXMpO1xuICAgICAgdmFyIGRlZ20gPSBzcXVhcmVzICsgMTtcbiAgICAgIGlmIChHLmdldCh1KS5oYXModykpIHtcbiAgICAgICAgZGVnbSArPSAxO1xuICAgICAgfVxuICAgICAgcG90ZW50aWFsICs9IChHLmdldCh1KS5zaXplIC0gZGVnbSkgKiAoRy5nZXQodykuc2l6ZSAtIGRlZ20pICsgc3F1YXJlcztcbiAgICB9XG4gICAgaWYocG90ZW50aWFsID4gMCkge1xuICAgICAgY2x1c3RlcmluZy5zZXQodiwgY2x1c3RlcmluZy5nZXQodikgLyBwb3RlbnRpYWwpO1xuICAgIH1cbiAgfVxuICBpZiAoRy5oYXNOb2RlKG9wdE5vZGVzKSkge1xuICAgIHJldHVybiBuZXh0KGNsdXN0ZXJpbmcudmFsdWVzKCkpOyAvLyByZXR1cm4gc2luZ2xlIHZhbHVlXG4gIH1cbiAgcmV0dXJuIGNsdXN0ZXJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5TcXVhcmVDbHVzdGVyaW5nKEcsIG9wdE5vZGVzKSB7XG4gIHJldHVybiBkZWxlZ2F0ZShcInNxdWFyZUNsdXN0ZXJpbmdcIiwgW0csIG9wdE5vZGVzXSk7XG59OyIsImltcG9ydCBkZWxlZ2F0ZSBmcm9tIFwiLi4vX2ludGVybmFscy9kZWxlZ2F0ZVwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBKU05ldHdvcmtYRXJyb3IgZnJvbSAnLi4vZXhjZXB0aW9ucy9KU05ldHdvcmtYRXJyb3InO1xuaW1wb3J0IEpTTmV0d29ya1hVbmZlYXNpYmxlIGZyb20gJy4uL2V4Y2VwdGlvbnMvSlNOZXR3b3JrWFVuZmVhc2libGUnO1xuXG5pbXBvcnQge1xuLypqc2hpbnQgaWdub3JlOnN0YXJ0Ki9cbiAgTWFwLFxuICBTZXQsXG4vKmpzaGludCBpZ25vcmU6ZW5kKi9cbiAgZm9yRWFjaCxcbiAgZ2NkXG59IGZyb20gJy4uL19pbnRlcm5hbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEaXJlY3RlZEFjeWNsaWNHcmFwaChHKSB7XG4gIHRyeSB7XG4gICAgdG9wb2xvZ2ljYWxTb3J0KEcpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNhdGNoKGV4KSB7XG4gICAgaWYgKGV4IGluc3RhbmNlb2YgSlNOZXR3b3JrWFVuZmVhc2libGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhyb3cgZXg7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbklzRGlyZWN0ZWRBY3ljbGljR3JhcGgoRykge1xuICByZXR1cm4gZGVsZWdhdGUoXCJpc0RpcmVjdGVkQWN5Y2xpY0dyYXBoXCIsIFtHXSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdG9wb2xvZ2ljYWxTb3J0KEcsIG9wdE5idW5jaCkge1xuICBpZiAoIUcuaXNEaXJlY3RlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcihcbiAgICAgICdUb3BvbG9naWNhbCBzb3J0IG5vdCBkZWZpbmVkIG9uIHVuZGlyZWN0ZWQgZ3JhcGhzLidcbiAgICApO1xuICB9XG5cbiAgLy8gbm9ucmVjdXJzaXZlIHZlcnNpb25cbiAgdmFyIHNlZW4gPSBuZXcgU2V0KCk7XG4gIHZhciBvcmRlckV4cGxvcmVkID0gW107IC8vIHByb3ZpZGUgb3JkZXIgYW5kXG4gIC8vIGZhc3Qgc2VhcmNoIHdpdGhvdXQgbW9yZSBnZW5lcmFsIHByaW9yaXR5RGljdGlvbmFyeVxuICB2YXIgZXhwbG9yZWQgPSBuZXcgU2V0KCk7XG5cbiAgaWYgKG9wdE5idW5jaCA9PSBudWxsKSB7XG4gICAgb3B0TmJ1bmNoID0gRy5ub2Rlc0l0ZXIoKTtcbiAgfVxuXG4gIGZvckVhY2gob3B0TmJ1bmNoLCBmdW5jdGlvbih2KSB7IC8vIHByb2Nlc3MgYWxsIHZlcnRpY2VzIGluIEdcbiAgICBpZiAoZXhwbG9yZWQuaGFzKHYpKSB7XG4gICAgICByZXR1cm47IC8vIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIGZyaW5nZSA9IFt2XTsgLy8gbm9kZXMgeWV0IHRvIGxvb2sgYXRcbiAgICB3aGlsZSAoZnJpbmdlLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB3ID0gZnJpbmdlW2ZyaW5nZS5sZW5ndGggLSAxXTsgLy8gZGVwdGggZmlyc3Qgc2VhcmNoXG4gICAgICBpZiAoZXhwbG9yZWQuaGFzKHcpKSB7IC8vIGFscmVhZHkgbG9va2VkIGRvd24gdGhpcyBicmFuY2hcbiAgICAgICAgZnJpbmdlLnBvcCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNlZW4uYWRkKHcpOyAvLyBtYXJrIGFzIHNlZW5cbiAgICAgIC8vIENoZWNrIHN1Y2Nlc3NvcnMgZm9yIGN5Y2xlcyBmb3IgbmV3IG5vZGVzXG4gICAgICB2YXIgbmV3Tm9kZXMgPSBbXTtcbiAgICAgIC8qanNoaW50IGxvb3BmdW5jOnRydWUqL1xuICAgICAgRy5nZXQodykuZm9yRWFjaChmdW5jdGlvbihfLCBuKSB7XG4gICAgICAgIGlmICghZXhwbG9yZWQuaGFzKG4pKSB7XG4gICAgICAgICAgaWYgKHNlZW4uaGFzKG4pKSB7IC8vIENZQ0xFICEhXG4gICAgICAgICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWFVuZmVhc2libGUoJ0dyYXBoIGNvbnRhaW5zIGEgY3ljbGUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld05vZGVzLnB1c2gobik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG5ld05vZGVzLmxlbmd0aCA+IDApIHsgLy8gYWRkIG5ldyBub2RlcyB0byBmcmluZ2VcbiAgICAgICAgZnJpbmdlLnB1c2guYXBwbHkoZnJpbmdlLCBuZXdOb2Rlcyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZXhwbG9yZWQuYWRkKHcpO1xuICAgICAgICBvcmRlckV4cGxvcmVkLnVuc2hpZnQodyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3JkZXJFeHBsb3JlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlblRvcG9sb2dpY2FsU29ydChHLCBvcHROYnVuY2gpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwidG9wb2xvZ2ljYWxTb3J0XCIsIFtHLCBvcHROYnVuY2hdKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0b3BvbG9naWNhbFNvcnRSZWN1cnNpdmUoRywgb3B0TmJ1bmNoKSB7XG4gIGlmICghRy5pc0RpcmVjdGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKFxuICAgICAgJ1RvcG9sb2dpY2FsIHNvcnQgbm90IGRlZmluZWQgb24gdW5kaXJlY3RlZCBncmFwaHMuJ1xuICAgICk7XG4gIH1cblxuICAvLyBmdW5jdGlvbiBmb3IgcmVjdXJzaXZlIGRmc1xuICAvKipcbiAgICogQHBhcmFtIHtHcmFwaH0gRyBncmFwaFxuICAgKiBAcGFyYW0ge1NldH0gc2VlblxuICAgKiBAcGFyYW0ge0FycmF5fSBleHBsb3JlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gX2RmcyhHLCBzZWVuLCBleHBsb3JlZCwgdikge1xuICAgIHNlZW4uYWRkKHYpO1xuICAgIEcuZ2V0KHYpLmZvckVhY2goZnVuY3Rpb24oXywgdykge1xuICAgICAgaWYgKCFzZWVuLmhhcyh3KSkge1xuICAgICAgICBpZiAoIV9kZnMoRywgc2VlbiwgZXhwbG9yZWQsIHcpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWVuLmhhcyh3KSAmJiBleHBsb3JlZC5pbmRleE9mKHcpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWFVuZmVhc2libGUoJ0dyYXBoIGNvbnRhaW5zIGEgY3ljbGUuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZXhwbG9yZWQudW5zaGlmdCh2KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzZWVuID0gbmV3IFNldCgpO1xuICB2YXIgZXhwbG9yZWQgPSBbXTtcblxuICBpZiAob3B0TmJ1bmNoID09IG51bGwpIHtcbiAgICBvcHROYnVuY2ggPSBHLm5vZGVzSXRlcigpO1xuICB9XG5cbiAgZm9yRWFjaChvcHROYnVuY2gsIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoZXhwbG9yZWQuaW5kZXhPZih2KSA9PT0gLTEpIHtcbiAgICAgIGlmICghX2RmcyhHLCBzZWVuLCBleHBsb3JlZCwgdikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpTTmV0d29ya1hVbmZlYXNpYmxlKCdHcmFwaCBjb250YWlucyBhIGN5Y2xlLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGV4cGxvcmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuVG9wb2xvZ2ljYWxTb3J0UmVjdXJzaXZlKEcsIG9wdE5idW5jaCkge1xuICByZXR1cm4gZGVsZWdhdGUoXCJ0b3BvbG9naWNhbFNvcnRSZWN1cnNpdmVcIiwgW0csIG9wdE5idW5jaF0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXBlcmlvZGljKEcpIHtcbiAgaWYgKCFHLmlzRGlyZWN0ZWQoKSkge1xuICAgIHRocm93IG5ldyBKU05ldHdvcmtYRXJyb3IoXG4gICAgICAnaXNfYXBlcmlvZGljIG5vdCBkZWZpbmVkIGZvciB1bmRpcmVjdGVkIGdyYXBocy4nXG4gICAgKTtcbiAgfVxuXG4gIHZhciBuZXh0ID0gRy5ub2Rlc0l0ZXIoKS5uZXh0KCk7XG4gIGlmIChuZXh0LmRvbmUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgbGV2ZWxzID0gbmV3IE1hcCgpO1xuICBsZXZlbHMuc2V0KG5leHQudmFsdWUsIDApO1xuICB2YXIgdGhpc0xldmVsID0gW25leHQudmFsdWVdO1xuICB2YXIgZyA9IDA7XG4gIHZhciBsID0gMTtcblxuICB3aGlsZSAodGhpc0xldmVsLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbmV4dExldmVsID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzTGV2ZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB1ID0gdGhpc0xldmVsW2ldO1xuICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSovXG4gICAgICBHLmdldCh1KS5mb3JFYWNoKGZ1bmN0aW9uKF8sIHYpIHtcbiAgICAgICAgaWYgKGxldmVscy5oYXModikpIHsgLy8gbm9uLXRyZWUgZWRnZVxuICAgICAgICAgIGcgPSBnY2QoZywgbGV2ZWxzLmdldCh1KSAtIGxldmVscy5nZXQodikgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gdHJlZSBlZGdlXG4gICAgICAgICAgbmV4dExldmVsLnB1c2godik7XG4gICAgICAgICAgbGV2ZWxzLnNldCh2LCBsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXNMZXZlbCA9IG5leHRMZXZlbDtcbiAgICBsICs9IDE7XG4gIH1cblxuICBpZiAobGV2ZWxzLnNpemUgPT09IEcubnVtYmVyT2ZOb2RlcygpKSB7XG4gICAgcmV0dXJuIGcgPT09IDE7XG4gIH1cbiAgcmV0dXJuIGcgPT09IDEgJiYgaXNBcGVyaW9kaWMoXG4gICAgRy5zdWJncmFwaChuZXcgU2V0KEcubm9kZXMoKSkuZGlmZmVyZW5jZShsZXZlbHMua2V5cygpKSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbklzQXBlcmlvZGljKEcpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwiaXNBcGVyaW9kaWNcIiwgW0ddKTtcbn07IiwiaW1wb3J0IGRlbGVnYXRlIGZyb20gXCIuLi9faW50ZXJuYWxzL2RlbGVnYXRlXCI7XG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHtKU05ldHdvcmtYRXhjZXB0aW9uLCBKU05ldHdvcmtYVW5mZWFzaWJsZX0gZnJvbSAnLi4vZXhjZXB0aW9ucyc7XG5cbmltcG9ydCBmaWxsQXJyYXkgZnJvbSAnLi4vX2ludGVybmFscy9maWxsQXJyYXknO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNHcmFwaGljYWwoc2VxdWVuY2UsIG9wdE1ldGhvZD0naGgnKSB7XG4gIHN3aXRjaCAob3B0TWV0aG9kKSB7XG4gICAgY2FzZSAnZWcnOlxuICAgICAgcmV0dXJuIGlzVmFsaWREZWdyZWVTZXF1ZW5jZUVyZG9zR2FsbGFpKEFycmF5LmZyb20oc2VxdWVuY2UpKTtcbiAgICBjYXNlICdoaCc6XG4gICAgICByZXR1cm4gaXNWYWxpZERlZ3JlZVNlcXVlbmNlSGF2ZWxIYWtpbWkoQXJyYXkuZnJvbShzZXF1ZW5jZSkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEV4Y2VwdGlvbihcImBvcHRfbWV0aG9kYCBtdXN0IGJlICdlZycgb3IgJ2hoJ1wiKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuSXNHcmFwaGljYWwoc2VxdWVuY2UsIG9wdE1ldGhvZCkge1xuICByZXR1cm4gZGVsZWdhdGUoXCJpc0dyYXBoaWNhbFwiLCBbc2VxdWVuY2UsIG9wdE1ldGhvZF0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWREZWdyZWVTZXF1ZW5jZShzZXF1ZW5jZSwgb3B0TWV0aG9kKSB7XG4gIHJldHVybiBpc0dyYXBoaWNhbChzZXF1ZW5jZSwgb3B0TWV0aG9kKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbklzVmFsaWREZWdyZWVTZXF1ZW5jZShzZXF1ZW5jZSwgb3B0TWV0aG9kKSB7XG4gIHJldHVybiBkZWxlZ2F0ZShcImlzVmFsaWREZWdyZWVTZXF1ZW5jZVwiLCBbc2VxdWVuY2UsIG9wdE1ldGhvZF0pO1xufTtcblxuZnVuY3Rpb24gYmFzaWNHcmFwaGljYWxUZXN0cyhzZXF1ZW5jZSkge1xuICAvLyBzb3J0IGFuZCBwZXJmb3JtIHNvbWUgc2ltcGxlIHRlc3RzIG9uIHRoZSBzZXF1ZW5jZVxuICBpZiAoIXNlcXVlbmNlLmV2ZXJ5KHggPT4gTWF0aC5mbG9vcih4KSA9PT0geCkpIHsgLy8gbGlzdCBvZiBwb3NpdGl2ZSBpbnRlbmdlcnNcbiAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWFVuZmVhc2libGUoKTtcbiAgfVxuXG4gIHZhciBudW1iZXJPZk5vZGVzID0gc2VxdWVuY2UubGVuZ3RoO1xuICB2YXIgbnVtRGVncmVzcyA9IGZpbGxBcnJheShudW1iZXJPZk5vZGVzLCAwKTtcbiAgdmFyIG1heERlZ3JlZSA9IDA7XG4gIHZhciBtaW5EZWdyZWUgPSBudW1iZXJPZk5vZGVzO1xuICB2YXIgZGVncmVlU3VtID0gMDtcbiAgdmFyIG4gPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZOb2RlczsgaSsrKSB7XG4gICAgdmFyIGRlZ3JlZSA9IHNlcXVlbmNlW2ldO1xuICAgIC8vIFJlamVjdCBpZiBkZWdyZWUgaXMgbmVnYXRpdmUgb3IgbGFyZ2VyIHRoYW4gdGhlIHNlcXVlbmNlIGxlbmd0aFxuICAgIGlmIChkZWdyZWUgPCAwIHx8IGRlZ3JlZSA+PSBudW1iZXJPZk5vZGVzKSB7XG4gICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWFVuZmVhc2libGUoKTtcbiAgICB9XG4gICAgLy8gcHJvY2VzcyBvbmx5IHRoZSBub24temVybyBpbnRlZ2Vyc1xuICAgIGVsc2UgaWYgKGRlZ3JlZSA+IDApIHtcbiAgICAgIG1heERlZ3JlZSA9IE1hdGgubWF4KG1heERlZ3JlZSwgZGVncmVlKTtcbiAgICAgIG1pbkRlZ3JlZSA9IE1hdGgubWluKG1pbkRlZ3JlZSwgZGVncmVlKTtcbiAgICAgIGRlZ3JlZVN1bSArPSBkZWdyZWU7XG4gICAgICBuICs9IDE7XG4gICAgICBudW1EZWdyZXNzW2RlZ3JlZV0gKz0gMTtcbiAgICB9XG4gIH1cbiAgLy8gUmVqZWN0IHNlcXVlbmNlIGlmIGl0IGhhcyBvZGQgc3VtIG9yIGlzIG92ZXItc2F0dXJhdGVkXG4gIGlmIChkZWdyZWVTdW0gJSAyID09PSAxIHx8IGRlZ3JlZVN1bSA+IG4gKiAobiAtIDEpKSB7XG4gICAgdGhyb3cgbmV3IEpTTmV0d29ya1hVbmZlYXNpYmxlKCk7XG4gIH1cbiAgcmV0dXJuIFttYXhEZWdyZWUsIG1pbkRlZ3JlZSwgZGVncmVlU3VtLCBuLCBudW1EZWdyZXNzXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWREZWdyZWVTZXF1ZW5jZUhhdmVsSGFraW1pKGRlZ3JlZVNlcXVlbmNlKSB7XG4gIHZhciBfO1xuICB2YXIgbWF4RGVncmVlO1xuICB2YXIgbWluRGVncmVlO1xuICB2YXIgbjtcbiAgdmFyIG51bURlZ3JlZXM7XG5cbiAgdHJ5IHtcbiAgICBbbWF4RGVncmVlLCBtaW5EZWdyZWUsIF8sIG4sIG51bURlZ3JlZXNdID1cbiAgICAgIGJhc2ljR3JhcGhpY2FsVGVzdHMoZGVncmVlU2VxdWVuY2UpO1xuICB9XG4gIGNhdGNoKGV4KSB7XG4gICAgaWYgKGV4IGluc3RhbmNlb2YgSlNOZXR3b3JrWFVuZmVhc2libGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBleDtcbiAgICB9XG4gIH1cbiAgLy8gQWNjZXB0IGlmIHNlcXVlbmNlIGhhcyBubyBub24temVybyBkZWdyZWVzIG9yIHBhc3NlcyB0aGUgWlogY29uZGl0aW9uXG4gIGlmIChuID09PSAwIHx8IDQgKiBtaW5EZWdyZWUgKiBuID49IE1hdGgucG93KG1heERlZ3JlZSArIG1pbkRlZ3JlZSArIDEsIDIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbW9kc3R1YnMgPSBmaWxsQXJyYXkobWF4RGVncmVlICsgMSwgMCk7XG4gIC8vIHN1Y2Nlc3NpdmVseSByZWR1Y2UgZGVncmVlIHNlcXVlbmNlIGJ5IHJlbW92aW5nIG5vZGUgb2YgbWF4aW11bSBkZWdyZWVcbiAgd2hpbGUgKG4gPiAwKSB7XG4gICAgLy8gUmV0cmlldmUgdGhlIG1heGltdW0gZGVncmVlIGluIHRoZSBzZXF1ZW5jZVxuICAgIHdoaWxlIChudW1EZWdyZWVzW21heERlZ3JlZV0gPT09IDApIHtcbiAgICAgIG1heERlZ3JlZSAtPSAxO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm90IGVub3VnaCBzdHVicyB0byBjb25uZWN0IHRvLCB0aGVuIHRoZSBzZXF1ZW5jZSBpcyBub3RcbiAgICAvLyBncmFwaGljYWxcbiAgICBpZiAobWF4RGVncmVlID4gbiAtIDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgbGFyZ2VzdCBzdHViIGluIGxpc3RcbiAgICBudW1EZWdyZWVzW21heERlZ3JlZV0gLT0gMTtcbiAgICBuIC09IDE7XG4gICAgLy8gUmVkdWNlIHRoZSBuZXh0IG1heERlZ3JlZSBsYXJnZXN0IHN0dWJzXG4gICAgdmFyIG1zbGVuID0gMDtcbiAgICB2YXIgayA9IG1heERlZ3JlZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heERlZ3JlZTsgaSsrKSB7XG4gICAgICB3aGlsZSAobnVtRGVncmVlc1trXSA9PT0gMCkge1xuICAgICAgICBrIC09IDE7XG4gICAgICB9XG4gICAgICBudW1EZWdyZWVzW2tdIC09IDE7XG4gICAgICBuIC09IDE7XG4gICAgICBpZiAoayA+IDEpIHtcbiAgICAgICAgbW9kc3R1YnNbbXNsZW5dID0gayAtIDE7XG4gICAgICAgIG1zbGVuICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCBiYWNrIHRvIHRoZSBsaXN0IGFueSBub24temVybyBzdHVicyB0aGF0IHdlcmUgcmVtb3ZlZFxuICAgIGZvciAoaSA9IDA7IGkgPCBtc2xlbjsgaSsrKSB7XG4gICAgICB2YXIgc3R1YiA9IG1vZHN0dWJzW2ldO1xuICAgICAgbnVtRGVncmVlc1tzdHViXSArPSAxO1xuICAgICAgbiArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbklzVmFsaWREZWdyZWVTZXF1ZW5jZUhhdmVsSGFraW1pKGRlZ3JlZVNlcXVlbmNlKSB7XG4gIHJldHVybiBkZWxlZ2F0ZShcImlzVmFsaWREZWdyZWVTZXF1ZW5jZUhhdmVsSGFraW1pXCIsIFtkZWdyZWVTZXF1ZW5jZV0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWREZWdyZWVTZXF1ZW5jZUVyZG9zR2FsbGFpKGRlZ3JlZVNlcXVlbmNlKSB7XG4gIHZhciBtYXhEZWdyZWU7XG4gIHZhciBtaW5EZWdyZWU7XG4gIHZhciBfO1xuICB2YXIgbjtcbiAgdmFyIG51bURlZ3JlZXM7XG5cbiAgdHJ5IHtcbiAgICBbbWF4RGVncmVlLCBtaW5EZWdyZWUsIF8sIG4sIG51bURlZ3JlZXNdID1cbiAgICAgIGJhc2ljR3JhcGhpY2FsVGVzdHMoZGVncmVlU2VxdWVuY2UpO1xuICB9XG4gIGNhdGNoKGV4KSB7XG4gICAgaWYgKGV4IGluc3RhbmNlb2YgSlNOZXR3b3JrWFVuZmVhc2libGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBleDtcbiAgICB9XG4gIH1cbiAgLy8gQWNjZXB0IGlmIHNlcXVlbmNlIGhhcyBubyBub24temVybyBkZWdyZWVzIG9yIHBhc3NlcyB0aGUgWlogY29uZGl0aW9uXG4gIGlmIChuID09PSAwIHx8IDQgKiBtaW5EZWdyZWUgKiBuID49IE1hdGgucG93KG1heERlZ3JlZSArIG1pbkRlZ3JlZSArIDEsIDIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBQZXJmb3JtIHRoZSBFRyBjaGVja3MgdXNpbmcgdGhlIHJlZm9ybXVsYXRpb24gb2YgWnZlcm92aWNoIGFuZCBadmVyb3ZpY2hcbiAgdmFyIGsgPSAwO1xuICB2YXIgZGVncmVlU3VtID0gMDtcbiAgdmFyIHN1bW5qID0gMDtcbiAgdmFyIHN1bWpuaiA9IDA7XG5cbiAgZm9yICh2YXIgZGsgPSBtYXhEZWdyZWU7IGRrID49IG1pbkRlZ3JlZTsgZGsgLT0gMSkge1xuICAgIGlmIChkayA8IGsgKyAxKSB7IC8vIENoZWNrIGlmIGFscmVhZHkgcGFzdCBEdXJmZWUgaW5kZXhcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobnVtRGVncmVlc1tka10gPiAwKSB7XG4gICAgICB2YXIgcnVuU2l6ZSA9IG51bURlZ3JlZXNbZGtdOyAvLyBQcm9jZXNzIGEgcnVuIG9mIGlkZW50aWNhbC12YWx1ZWQgZGVncmVlc1xuICAgICAgaWYgKGRrIDwgayArIHJ1blNpemUpIHsgLy8gQ2hlY2sgaWYgZW5kIG9mIHJ1biBpcyBwYXN0IER1cmZlZSBpbmRleFxuICAgICAgICBydW5TaXplID0gZGsgLSBrOyAvLyBBZGp1c3QgYmFjayB0byBEdXJmZWUgaW5kZXhcbiAgICAgIH1cbiAgICAgIGRlZ3JlZVN1bSArPSBydW5TaXplICogZGs7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IHJ1blNpemU7IHYrKykge1xuICAgICAgICBzdW1uaiArPSBudW1EZWdyZWVzW2sgKyB2XTtcbiAgICAgICAgc3Vtam5qICs9IChrICsgdikgKiBudW1EZWdyZWVzW2sgKyB2XTtcbiAgICAgIH1cbiAgICAgIGsgKz0gcnVuU2l6ZTtcbiAgICAgIGlmIChkZWdyZWVTdW0gPiBrICogKG4tMSkgLSBrICogc3VtbmogKyBzdW1qbmopIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbklzVmFsaWREZWdyZWVTZXF1ZW5jZUVyZG9zR2FsbGFpKGRlZ3JlZVNlcXVlbmNlKSB7XG4gIHJldHVybiBkZWxlZ2F0ZShcImlzVmFsaWREZWdyZWVTZXF1ZW5jZUVyZG9zR2FsbGFpXCIsIFtkZWdyZWVTZXF1ZW5jZV0pO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0ICogYXMgY2VudHJhbGl0eSBmcm9tICcuL2NlbnRyYWxpdHknO1xuaW1wb3J0ICogYXMgY2xpcXVlIGZyb20gJy4vY2xpcXVlJztcbmltcG9ydCAqIGFzIGNsdXN0ZXIgZnJvbSAnLi9jbHVzdGVyJztcbmltcG9ydCAqIGFzIGRhZyBmcm9tICcuL2RhZyc7XG5pbXBvcnQgKiBhcyBncmFwaGljYWwgZnJvbSAnLi9ncmFwaGljYWwnO1xuaW1wb3J0ICogYXMgaXNvbW9ycGhpc20gZnJvbSAnLi9pc29tb3JwaGlzbSc7XG5pbXBvcnQgKiBhcyBzaG9ydGVzdFBhdGhzIGZyb20gJy4vc2hvcnRlc3RQYXRocyc7XG5cbmV4cG9ydCB7XG4gIGNlbnRyYWxpdHksXG4gIGNsaXF1ZSxcbiAgY2x1c3RlcixcbiAgZGFnLFxuICBncmFwaGljYWwsXG4gIGlzb21vcnBoaXNtLFxuICBzaG9ydGVzdFBhdGhzXG59O1xuXG5leHBvcnQgKiBmcm9tICcuL2NlbnRyYWxpdHknO1xuZXhwb3J0ICogZnJvbSAnLi9jbGlxdWUnO1xuZXhwb3J0ICogZnJvbSAnLi9jbHVzdGVyJztcbmV4cG9ydCAqIGZyb20gJy4vZGFnJztcbmV4cG9ydCAqIGZyb20gJy4vZ3JhcGhpY2FsJztcbmV4cG9ydCAqIGZyb20gJy4vaXNvbW9ycGhpc20nO1xuZXhwb3J0ICogZnJvbSAnLi9zaG9ydGVzdFBhdGhzJztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgKiBmcm9tICcuL2lzb21vcnBoJztcbiIsImltcG9ydCBkZWxlZ2F0ZSBmcm9tIFwiLi4vLi4vX2ludGVybmFscy9kZWxlZ2F0ZVwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7bnVtYmVyT2ZDbGlxdWVzfSBmcm9tICcuLi9jbGlxdWUnO1xuaW1wb3J0IHt0cmlhbmdsZXN9IGZyb20gJy4uL2NsdXN0ZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gY291bGRCZUlzb21vcnBoaWMoRzEsIEcyKSB7XG4gIC8vIENoZWNrIGdsb2JhbCBwcm9wZXJ0aWVzXG4gIGlmIChHMS5vcmRlcigpICE9PSBHMi5vcmRlcigpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gQ2hlY2sgbG9jYWwgcHJvcGVydGllc1xuICB2YXIgZGVncmVlMSA9IEcxLmRlZ3JlZSgpO1xuICB2YXIgdHJpYW5nbGVzMSA9IHRyaWFuZ2xlcyhHMSk7XG4gIHZhciBjbGlxdWVzMSA9IG51bWJlck9mQ2xpcXVlcyhHMSk7XG4gIHZhciBwcm9wczEgPSBbXTtcbiAgZGVncmVlMS5mb3JFYWNoKChfLCB2KSA9PiB7XG4gICAgcHJvcHMxLnB1c2goW2RlZ3JlZTEuZ2V0KHYpLCB0cmlhbmdsZXMxLmdldCh2KSwgY2xpcXVlczEuZ2V0KHYpXSk7XG4gIH0pO1xuICBwcm9wczEuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV0gfHwgYVsyXSAtIGJbMl0pO1xuXG4gIHZhciBkZWdyZWUyID0gRzIuZGVncmVlKCk7XG4gIHZhciB0cmlhbmdsZXMyID0gdHJpYW5nbGVzKEcyKTtcbiAgdmFyIGNsaXF1ZXMyID0gbnVtYmVyT2ZDbGlxdWVzKEcyKTtcbiAgdmFyIHByb3BzMiA9IFtdO1xuICBkZWdyZWUyLmZvckVhY2goKF8sIHYpID0+IHtcbiAgICBwcm9wczIucHVzaChbZGVncmVlMi5nZXQodiksIHRyaWFuZ2xlczIuZ2V0KHYpLCBjbGlxdWVzMi5nZXQodildKTtcbiAgfSk7XG4gIHByb3BzMi5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXSB8fCBhWzJdIC0gYlsyXSk7XG5cbiAgcmV0dXJuIHByb3BzMS5ldmVyeSgoYSwgaSkgPT4ge1xuICAgIHZhciBiID0gcHJvcHMyW2ldO1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5Db3VsZEJlSXNvbW9ycGhpYyhHMSwgRzIpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwiY291bGRCZUlzb21vcnBoaWNcIiwgW0cxLCBHMl0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZhc3RDb3VsZEJlSXNvbW9ycGhpYyhHMSwgRzIpIHtcbiAgLy8gQ2hlY2sgZ2xvYmFsIHByb3BlcnRpZXNcbiAgaWYgKEcxLm9yZGVyKCkgIT09IEcyLm9yZGVyKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayBsb2NhbCBwcm9wZXJ0aWVzXG4gIHZhciBkZWdyZWUxID0gRzEuZGVncmVlKCk7XG4gIHZhciB0cmlhbmdsZXMxID0gdHJpYW5nbGVzKEcxKTtcbiAgdmFyIHByb3BzMSA9IFtdO1xuICBkZWdyZWUxLmZvckVhY2goKF8sIHYpID0+IHtcbiAgICBwcm9wczEucHVzaChbZGVncmVlMS5nZXQodiksIHRyaWFuZ2xlczEuZ2V0KHYpXSk7XG4gIH0pO1xuICBwcm9wczEuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV0pO1xuXG4gIHZhciBkZWdyZWUyID0gRzIuZGVncmVlKCk7XG4gIHZhciB0cmlhbmdsZXMyID0gdHJpYW5nbGVzKEcyKTtcbiAgdmFyIHByb3BzMiA9IFtdO1xuICBkZWdyZWUyLmZvckVhY2goKF8sIHYpID0+IHtcbiAgICBwcm9wczIucHVzaChbZGVncmVlMi5nZXQodiksIHRyaWFuZ2xlczIuZ2V0KHYpXSk7XG4gIH0pO1xuICBwcm9wczIuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV0pO1xuXG4gIHJldHVybiBwcm9wczEuZXZlcnkoKGEsIGkpID0+IHtcbiAgICB2YXIgYiA9IHByb3BzMltpXTtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbkZhc3RDb3VsZEJlSXNvbW9ycGhpYyhHMSwgRzIpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwiZmFzdENvdWxkQmVJc29tb3JwaGljXCIsIFtHMSwgRzJdKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBmYXN0ZXJDb3VsZEJlSXNvbW9ycGhpYyhHMSwgRzIpIHtcbiAgLy8gQ2hlY2sgZ2xvYmFsIHByb3BlcnRpZXNcbiAgaWYgKEcxLm9yZGVyKCkgIT09IEcyLm9yZGVyKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayBsb2NhbCBwcm9wZXJ0aWVzXG4gIHZhciBkZWdyZWUxID0gQXJyYXkuZnJvbShHMS5kZWdyZWUoKS52YWx1ZXMoKSk7XG4gIGRlZ3JlZTEuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuXG4gIHZhciBkZWdyZWUyID0gQXJyYXkuZnJvbShHMi5kZWdyZWUoKS52YWx1ZXMoKSk7XG4gIGRlZ3JlZTIuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuXG4gIHJldHVybiBkZWdyZWUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBkZWdyZWUyW2ldKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbkZhc3RlckNvdWxkQmVJc29tb3JwaGljKEcxLCBHMikge1xuICByZXR1cm4gZGVsZWdhdGUoXCJmYXN0ZXJDb3VsZEJlSXNvbW9ycGhpY1wiLCBbRzEsIEcyXSk7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyB1bndlaWdodGVkIGZyb20gJy4vdW53ZWlnaHRlZCc7XG5cbmV4cG9ydCB7XG4gIHVud2VpZ2h0ZWRcbn07XG5cbmV4cG9ydCAqIGZyb20gJy4vdW53ZWlnaHRlZCc7XG4iLCJpbXBvcnQgZGVsZWdhdGUgZnJvbSBcIi4uLy4uL19pbnRlcm5hbHMvZGVsZWdhdGVcIjtcblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQge0pTTmV0d29ya1hOb1BhdGh9IGZyb20gJy4uLy4uL2V4Y2VwdGlvbnMnO1xuXG5pbXBvcnQge1xuICBNYXAsXG4gIGdldERlZmF1bHQsXG4gIG5vZGVzQXJlRXF1YWwsXG4gIHNwcmludGZcbn0gZnJvbSAnLi4vLi4vX2ludGVybmFscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGVTb3VyY2VTaG9ydGVzdFBhdGhMZW5ndGgoRywgc291cmNlLCBvcHRDdXRvZmYpIHtcbiAgdmFyIHNlZW4gPSBuZXcgTWFwKCk7IC8vIGxldmVsIChudW1iZXIgb2YgaG9wcykgd2hlbiBzZWVuIG4gQkZTXG4gIHZhciBsZXZlbCA9IDA7IC8vIHRoZSBjdXJyZW50IGxldmVsXG4gIC8vIG1hcCBvZiBub2RlcyB0byBjaGVjayBhdCBuZXh0IGxldmVsXG4gIHZhciBuZXh0bGV2ZWwgPSBuZXcgTWFwKFtbc291cmNlLCAxXV0pO1xuXG4gIHdoaWxlIChuZXh0bGV2ZWwuc2l6ZSA+IDApIHtcbiAgICB2YXIgdGhpc2xldmVsID0gbmV4dGxldmVsO1xuICAgIG5leHRsZXZlbCA9IG5ldyBNYXAoKTtcbiAgICAvKmpzaGludCBsb29wZnVuYzp0cnVlKi9cbiAgICBmb3IgKHZhciB2IG9mIHRoaXNsZXZlbC5rZXlzKCkpIHtcbiAgICAgIGlmICghc2Vlbi5oYXModikpIHtcbiAgICAgICAgc2Vlbi5zZXQodiwgbGV2ZWwpO1xuICAgICAgICBHLmdldCh2KS5mb3JFYWNoKChfLCBuKSA9PiBuZXh0bGV2ZWwuc2V0KG4sIDEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdEN1dG9mZiAhPSBudWxsICYmIG9wdEN1dG9mZiA8PSBsZXZlbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldmVsICs9IDE7XG4gIH1cbiAgcmV0dXJuIHNlZW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5TaW5nbGVTb3VyY2VTaG9ydGVzdFBhdGhMZW5ndGgoRywgc291cmNlLCBvcHRDdXRvZmYpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwic2luZ2xlU291cmNlU2hvcnRlc3RQYXRoTGVuZ3RoXCIsIFtHLCBzb3VyY2UsIG9wdEN1dG9mZl0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFsbFBhaXJzU2hvcnRlc3RQYXRoTGVuZ3RoKEcsIG9wdEN1dG9mZikge1xuICAgIHZhciBwYXRocyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKHZhciBuIG9mIEcpIHtcbiAgICAgIHBhdGhzLnNldChuLCBzaW5nbGVTb3VyY2VTaG9ydGVzdFBhdGhMZW5ndGgoRywgbiwgb3B0Q3V0b2ZmKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRocztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbkFsbFBhaXJzU2hvcnRlc3RQYXRoTGVuZ3RoKEcsIG9wdEN1dG9mZikge1xuICByZXR1cm4gZGVsZWdhdGUoXCJhbGxQYWlyc1Nob3J0ZXN0UGF0aExlbmd0aFwiLCBbRywgb3B0Q3V0b2ZmXSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYmlkaXJlY3Rpb25hbFNob3J0ZXN0UGF0aChHLCBzb3VyY2UsIHRhcmdldCkge1xuICAgIC8vIGNhbGwgaGVscGVyIHRvIGRvIHRoZSByZWFsIHdvcmtcbiAgICB2YXIgW3ByZWQsIHN1Y2MsIHddID0gYmlkaXJlY3Rpb25hbFByZWRTdWNjKEcsIHNvdXJjZSwgdGFyZ2V0KTtcblxuICAgIC8vIGJ1aWxkIHBhdGggZnJvbSBwcmVkK3crc3VjY1xuICAgIHZhciBwYXRoID0gW107XG4gICAgLy8gZnJvbSBzb3VyY2UgdG8gd1xuICAgIHdoaWxlICh3ICE9IG51bGwpIHtcbiAgICAgIHBhdGgucHVzaCh3KTtcbiAgICAgIHcgPSBwcmVkLmdldCh3KTtcbiAgICB9XG4gICAgdyA9IHN1Y2MuZ2V0KHBhdGhbMF0pO1xuICAgIHBhdGgucmV2ZXJzZSgpO1xuICAgIC8vIGZyb20gdyB0byB0YXJnZXRcbiAgICB3aGlsZSAodyAhPSBudWxsKSB7XG4gICAgICBwYXRoLnB1c2godyk7XG4gICAgICB3ID0gc3VjYy5nZXQodyk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuQmlkaXJlY3Rpb25hbFNob3J0ZXN0UGF0aChHLCBzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gZGVsZWdhdGUoXCJiaWRpcmVjdGlvbmFsU2hvcnRlc3RQYXRoXCIsIFtHLCBzb3VyY2UsIHRhcmdldF0pO1xufTtcblxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbFByZWRTdWNjKEcsIHNvdXJjZSwgdGFyZ2V0KSB7XG4gIC8vIGRvZXMgQkZTIGZyb20gYm90aCBzb3VyY2UgYW5kIHRhcmdldCBhbmQgbWVldHMgaW4gdGhlIG1pZGRsZVxuICBpZiAobm9kZXNBcmVFcXVhbChzb3VyY2UsIHRhcmdldCkpIHtcbiAgICByZXR1cm4gW25ldyBNYXAoW1tzb3VyY2UsIG51bGxdXSksIG5ldyBNYXAoW1t0YXJnZXQsIG51bGxdXSksIHNvdXJjZV07XG4gIH1cblxuICAvLyBoYW5kbGUgZWl0aGVyIGRpcmVjdGVkIG9yIHVuZGlyZWN0ZWRcbiAgdmFyIEdwcmVkLCBHc3VjYztcbiAgaWYgKEcuaXNEaXJlY3RlZCgpKSB7XG4gICAgR3ByZWQgPSBHLnByZWRlY2Vzc29yc0l0ZXIuYmluZChHKTtcbiAgICBHc3VjYyA9IEcuc3VjY2Vzc29yc0l0ZXIuYmluZChHKTtcbiAgfVxuICBlbHNlIHtcbiAgICBHcHJlZCA9IEcubmVpZ2hib3JzSXRlci5iaW5kKEcpO1xuICAgIEdzdWNjID0gRy5uZWlnaGJvcnNJdGVyLmJpbmQoRyk7XG4gIH1cblxuICAvLyBwcmVkZWNlc3Nzb3IgYW5kIHN1Y2Nlc3NvcnMgaW4gc2VhcmNoXG4gIHZhciBwcmVkID0gbmV3IE1hcChbW3NvdXJjZSwgbnVsbF1dKTtcbiAgdmFyIHN1Y2MgPSBuZXcgTWFwKFtbdGFyZ2V0LCBudWxsXV0pO1xuICAvL1xuICAvLyBpbml0aWFsaXplIGZyaW5nZXMsIHN0YXJ0IHdpdGggZm9yd2FyZFxuICB2YXIgZm9yd2FyZEZyaW5nZSA9IFtzb3VyY2VdO1xuICB2YXIgcmV2ZXJzZUZyaW5nZSA9IFt0YXJnZXRdO1xuICB2YXIgdGhpc0xldmVsO1xuICB2YXIgdiwgdztcblxuICAvKmpzaGludCBuZXdjYXA6ZmFsc2UqL1xuICB3aGlsZSAoZm9yd2FyZEZyaW5nZS5sZW5ndGggPiAwICYmIHJldmVyc2VGcmluZ2UubGVuZ3RoID4gMCkge1xuICAgIGlmIChmb3J3YXJkRnJpbmdlLmxlbmd0aCA8PSByZXZlcnNlRnJpbmdlLmxlbmd0aCkge1xuICAgICAgdGhpc0xldmVsID0gZm9yd2FyZEZyaW5nZTtcbiAgICAgIGZvcndhcmRGcmluZ2UgPSBbXTtcbiAgICAgIGZvciAodiBvZiB0aGlzTGV2ZWwpIHtcbiAgICAgICAgZm9yICh3IG9mIEdzdWNjKHYpKSB7XG4gICAgICAgICAgaWYgKCFwcmVkLmhhcyh3KSkge1xuICAgICAgICAgICAgZm9yd2FyZEZyaW5nZS5wdXNoKHcpO1xuICAgICAgICAgICAgcHJlZC5zZXQodywgdik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdWNjLmhhcyh3KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtwcmVkLCBzdWNjLCB3XTsgLy8gZm91bmQgcGF0aFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXNMZXZlbCA9IHJldmVyc2VGcmluZ2U7XG4gICAgICByZXZlcnNlRnJpbmdlID0gW107XG4gICAgICBmb3IgKHYgb2YgdGhpc0xldmVsKSB7XG4gICAgICAgIGZvciAodyBvZiBHcHJlZCh2KSkge1xuICAgICAgICAgIGlmICghc3VjYy5oYXModykpIHtcbiAgICAgICAgICAgIHJldmVyc2VGcmluZ2UucHVzaCh3KTtcbiAgICAgICAgICAgIHN1Y2Muc2V0KHcsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlZC5oYXModykpIHtcbiAgICAgICAgICAgIHJldHVybiBbcHJlZCwgc3VjYywgd107IC8vIGZvdW5kIHBhdGhcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEpTTmV0d29ya1hOb1BhdGgoc3ByaW50ZihcbiAgICAnTm8gcGF0aCBiZXR3ZWVuIGAlamAgYW5kIGAlamAuJyxcbiAgICBzb3VyY2UsXG4gICAgdGFyZ2V0XG4gICkpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGVTb3VyY2VTaG9ydGVzdFBhdGgoRywgc291cmNlLCBvcHRDdXRvZmYpIHtcbiAgICB2YXIgbGV2ZWwgPSAwO1xuICAgIHZhciBuZXh0bGV2ZWwgPSBuZXcgTWFwKFtbc291cmNlLCAxXV0pO1xuICAgIHZhciBwYXRocyA9IG5ldyBNYXAoW1tzb3VyY2UsIFtzb3VyY2VdXV0pO1xuICAgIGlmIChvcHRDdXRvZmYgPT09IDApIHtcbiAgICAgIHJldHVybiBwYXRocztcbiAgICB9XG4gICAgLypqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSovXG4gICAgd2hpbGUgKG5leHRsZXZlbC5zaXplID4gMCkge1xuICAgICAgdmFyIHRoaXNsZXZlbCA9IG5leHRsZXZlbDtcbiAgICAgIG5leHRsZXZlbCA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAodmFyIHYgb2YgdGhpc2xldmVsLmtleXMoKSkge1xuICAgICAgICBmb3IgKHZhciB3IG9mIEcuZ2V0KHYpLmtleXMoKSkge1xuICAgICAgICAgIGlmICghcGF0aHMuaGFzKHcpKSB7XG4gICAgICAgICAgICBwYXRocy5zZXQodywgcGF0aHMuZ2V0KHYpLmNvbmNhdChbd10pKTtcbiAgICAgICAgICAgIG5leHRsZXZlbC5zZXQodywgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXZlbCArPSAxO1xuICAgICAgaWYgKG9wdEN1dG9mZiAhPSBudWxsICYmIG9wdEN1dG9mZiA8PSBsZXZlbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGhzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuU2luZ2xlU291cmNlU2hvcnRlc3RQYXRoKEcsIHNvdXJjZSwgb3B0Q3V0b2ZmKSB7XG4gIHJldHVybiBkZWxlZ2F0ZShcInNpbmdsZVNvdXJjZVNob3J0ZXN0UGF0aFwiLCBbRywgc291cmNlLCBvcHRDdXRvZmZdKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBhbGxQYWlyc1Nob3J0ZXN0UGF0aChHLCBvcHRDdXRvZmYpIHtcbiAgICB2YXIgcGF0aHMgPSBuZXcgTWFwKCk7XG4gICAgZm9yICh2YXIgbiBvZiBHKSB7XG4gICAgICBwYXRocy5zZXQobiwgc2luZ2xlU291cmNlU2hvcnRlc3RQYXRoKEcsIG4sIG9wdEN1dG9mZikpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5BbGxQYWlyc1Nob3J0ZXN0UGF0aChHLCBvcHRDdXRvZmYpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwiYWxsUGFpcnNTaG9ydGVzdFBhdGhcIiwgW0csIG9wdEN1dG9mZl0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByZWRlY2Vzc29yKEcsIHNvdXJjZSwgb3B0QXJncz17fSkge1xuICAvLyBUT0RPOiB1c2UgcGFyYW1ldGVyIGRlc3RydWN0dXJpbmdcbiAgLy8ge3RhcmdldCwgY3V0b2ZmLCByZXR1cm5TZWVufVxuICB2YXIge3RhcmdldCwgY3V0b2ZmLCByZXR1cm5TZWVufSA9IG9wdEFyZ3M7XG5cbiAgdmFyIGxldmVsID0gMDtcbiAgdmFyIG5leHRsZXZlbCA9IFtzb3VyY2VdO1xuICB2YXIgc2VlbiA9IG5ldyBNYXAoW1tzb3VyY2UsIGxldmVsXV0pO1xuICB2YXIgcHJlZCA9IG5ldyBNYXAoW1tzb3VyY2UsIFtdXV0pO1xuXG4gIC8qanNoaW50IGxvb3BmdW5jOnRydWUqL1xuICB3aGlsZSAobmV4dGxldmVsLmxlbmd0aCA+IDApIHtcbiAgICBsZXZlbCArPSAxO1xuICAgIHZhciB0aGlzbGV2ZWwgPSBuZXh0bGV2ZWw7XG4gICAgbmV4dGxldmVsID0gW107XG4gICAgdGhpc2xldmVsLmZvckVhY2godiA9PiB7XG4gICAgICBHLmdldCh2KS5mb3JFYWNoKChfLCB3KSA9PiB7XG4gICAgICAgIGlmICghc2Vlbi5oYXModykpIHtcbiAgICAgICAgICBwcmVkLnNldCh3LCBbdl0pO1xuICAgICAgICAgIHNlZW4uc2V0KHcsIGxldmVsKTtcbiAgICAgICAgICBuZXh0bGV2ZWwucHVzaCh3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWVuLmdldCh3KSA9PT0gbGV2ZWwpIHsgLy8gYWRkIHYgdG8gcHJlZGVjZXNzc29yIGxpc3QgaWYgaXRcbiAgICAgICAgICBwcmVkLmdldCh3KS5wdXNoKHYpOyAgICAgICAgICAgIC8vIGlzIGF0IHRoZSBjb3JyZWN0IGxldmVsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChjdXRvZmYgIT0gbnVsbCAmJiBjdXRvZmYgPD0gbGV2ZWwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgIGlmIChyZXR1cm5TZWVuKSB7XG4gICAgICByZXR1cm4gcHJlZC5oYXModGFyZ2V0KSA/IFtwcmVkLmdldCh0YXJnZXQpLCBzZWVuLmdldCh0YXJnZXQpXSA6IFtbXSwgLTFdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBnZXREZWZhdWx0KHByZWQuZ2V0KHRhcmdldCksIFtdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldHVyblNlZW4gPyBbcHJlZCwgc2Vlbl0gOiBwcmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuUHJlZGVjZXNzb3IoRywgc291cmNlLCBvcHRBcmdzKSB7XG4gIHJldHVybiBkZWxlZ2F0ZShcInByZWRlY2Vzc29yXCIsIFtHLCBzb3VyY2UsIG9wdEFyZ3NdKTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7c2VyaWFsaXplLCBkZXNlcmlhbGl6ZX0gZnJvbSAnLi9faW50ZXJuYWxzL21lc3NhZ2UnO1xuZXhwb3J0ICogZnJvbSAnLi8nO1xuXG5pZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAvLyBpbnNpZGUgd29ya2VyXG4gIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBhcmdzID0gZXZlbnQuZGF0YS5hcmdzLm1hcChkZXNlcmlhbGl6ZSk7XG4gICAgdmFyIHJlc3VsdCA9IGV4cG9ydHNbZXZlbnQuZGF0YS5tZXRob2RdLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIGdsb2JhbC5wb3N0TWVzc2FnZShzZXJpYWxpemUocmVzdWx0KSk7XG4gICAgZ2xvYmFsLmNsb3NlKCk7XG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBHcmFwaCBmcm9tICcuL0dyYXBoJztcbi8qanNoaW50IGlnbm9yZTpzdGFydCovXG5pbXBvcnQgTWFwIGZyb20gJy4uL19pbnRlcm5hbHMvTWFwJztcbi8qanNoaW50IGlnbm9yZTplbmQqL1xuaW1wb3J0IEpTTmV0d29ya1hFcnJvciBmcm9tICcuLi9leGNlcHRpb25zL0pTTmV0d29ya1hFcnJvcic7XG5cbmltcG9ydCBjb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuaW1wb3J0IHtcbiAgY2xlYXIsXG4gIGNsb25lLFxuICBjcmVhdGVUdXBsZUZhY3RvcnksXG4gIGRlZXBjb3B5LFxuICBmb3JFYWNoLFxuICBpc0Jvb2xlYW4sXG4gIGlzUGxhaW5PYmplY3QsXG4gIG1hcEl0ZXJhdG9yLFxuICBuZXh0LFxuICBzaXplLFxuICBzcHJpbnRmLFxuICB0dXBsZTIsXG4gIHR1cGxlMyxcbiAgdHVwbGUzYyxcbiAgemlwSXRlcmF0b3Jcbn0gZnJvbSAnLi4vX2ludGVybmFscyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgZGlyZWN0ZWQgZ3JhcGhzLlxuICpcbiAqIEEgRGlHcmFwaCBzdG9yZXMgbm9kZXMgYW5kIGVkZ2VzIHdpdGggb3B0aW9uYWwgZGF0YSwgb3IgYXR0cmlidXRlcy5cbiAqXG4gKiBEaUdyYXBocyBob2xkIGRpcmVjdGVkIGVkZ2VzLiAgU2VsZiBsb29wcyBhcmUgYWxsb3dlZCBidXQgbXVsdGlwbGVcbiAqIChwYXJhbGxlbCkgZWRnZXMgYXJlIG5vdC5cbiAqXG4gKiBOb2RlcyBjYW4gYmUgYXJiaXRyYXJ5IChoYXNoYWJsZSkgUHl0aG9uIG9iamVjdHMgd2l0aCBvcHRpb25hbFxuICoga2V5L3ZhbHVlIGF0dHJpYnV0ZXMuXG4gKlxuICogRWRnZXMgYXJlIHJlcHJlc2VudGVkIGFzIGxpbmtzIGJldHdlZW4gbm9kZXMgd2l0aCBvcHRpb25hbFxuICoga2V5L3ZhbHVlIGF0dHJpYnV0ZXMuXG4gKlxuICogQHNlZSBHcmFwaFxuICogQHNlZSBNdWx0aUdyYXBoXG4gKiBAc2VlIE11bHRpRGlHcmFwaFxuICpcbiAqIEBwYXJhbSB7Pz19IG9wdERhdGFcbiAqICAgICAgRGF0YSB0byBpbml0aWFsaXplIGdyYXBoLiAgSWYgZGF0YT1Ob25lIChkZWZhdWx0KSBhbiBlbXB0eVxuICogICAgICBncmFwaCBpcyBjcmVhdGVkLiAgVGhlIGRhdGEgY2FuIGJlIGFuIGVkZ2UgbGlzdCwgb3IgYW55XG4gKiAgICAgIE5ldHdvcmtYIGdyYXBoIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdEF0dHJcbiAqICAgICAgIEF0dHJpYnV0ZXMgdG8gYWRkIHRvIGdyYXBoIGFzIGtleT12YWx1ZSBwYWlycy5cbiAqXG4gKiBAZXh0ZW5kcyBHcmFwaFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpR3JhcGggZXh0ZW5kcyBHcmFwaCB7XG5cbiAgY29uc3RydWN0b3Iob3B0RGF0YSwgb3B0QXR0cikge1xuICAgIC8vIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNhbGwgRGlHcmFwaCB3aXRob3V0IG5ld1xuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIERpR3JhcGgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGlHcmFwaChvcHREYXRhLCBvcHRBdHRyKTtcbiAgICB9XG5cbiAgICB0aGlzLmdyYXBoID0ge307IC8vIGRpY3Rpb25hcnkgZm9yIGdyYXBoIGF0dHJpYnV0ZXNcbiAgICB0aGlzLm5vZGUgPSBuZXcgTWFwKCk7IC8vIGRpY3Rpb25hcnkgZm9yIG5vZGUgYXR0cmlidXRlc1xuICAgIC8vIFdlIHN0b3JlIHR3byBhZGphY2VuY3kgbGlzdHM6XG4gICAgLy8gdGhlICBwcmVkZWNlc3NvcnMgb2Ygbm9kZSBuIGFyZSBzdG9yZWQgaW4gdGhlIGRpY3Qgc2VsZi5wcmVkXG4gICAgLy8gdGhlIHN1Y2Nlc3NvcnMgb2Ygbm9kZSBuIGFyZSBzdG9yZWQgaW4gdGhlIGRpY3Qgc2VsZi5zdWNjPXNlbGYuYWRqXG4gICAgdGhpcy5hZGogPSBuZXcgTWFwKCk7IC8vIGVtcHR5IGFkamFjZW5jeSBkaWN0aW9uYXJ5XG4gICAgdGhpcy5wcmVkID0gbmV3IE1hcCgpOyAvLyBwcmVkZWNlc3NvclxuICAgIHRoaXMuc3VjYyA9IHRoaXMuYWRqOyAvLyBzdWNjZXNzb3JcblxuICAgIC8vYXR0ZW1wdCB0byBsb2FkIGdyYXBoIHdpdGggZGF0YVxuICAgIGlmKG9wdERhdGEgIT0gbnVsbCkge1xuICAgICAgICBjb252ZXJ0LnRvTmV0d29ya3hHcmFwaChvcHREYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgLy8gbG9hZCBncmFwaCBhdHRyaWJ1dGVzIChtdXN0IGJlIGFmdGUgY29udmVydClcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuZ3JhcGgsIG9wdEF0dHIgfHwge30pO1xuICAgIHRoaXMuZWRnZSA9IHRoaXMuYWRqO1xuICB9XG5cbiAgLyoqXG4gICAqIEhvbGRzIHRoZSBncmFwaCB0eXBlIChjbGFzcykgbmFtZSBmb3IgaW5mb3JtYXRpb24uXG4gICAqIFRoaXMgaXMgY29tcGF0aWJsZSB0byBQeXRob25zIF9fbmFtZV9fIHByb3BlcnR5LlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBfX25hbWVfXygpIHtcbiAgICByZXR1cm4gJ0RpR3JhcGgnO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBub2RlIG4gYW5kIHVwZGF0ZSBub2RlIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBzZWUgI2FkZF9ub2Rlc19mcm9tXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbiBOb2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2F0dHJfZGljdCBEaWN0aW9uYXJ5IG9mIG5vZGUgYXR0cmlidXRlcy5cbiAgICogICAgICBLZXkvdmFsdWUgcGFpcnMgd2lsbCB1cGRhdGUgZXhpc3RpbmcgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGUuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBhZGROb2RlKG4sIG9wdEF0dHJEaWN0PXt9KSB7XG4gICAgaWYoIWlzUGxhaW5PYmplY3Qob3B0QXR0ckRpY3QpKSB7XG4gICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKFxuICAgICAgICAnVGhlIG9wdF9hdHRyX2RpY3QgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZighdGhpcy5zdWNjLmhhcyhuKSkge1xuICAgICAgdGhpcy5zdWNjLnNldChuLCBuZXcgTWFwKCkpO1xuICAgICAgdGhpcy5wcmVkLnNldChuLCBuZXcgTWFwKCkpO1xuICAgICAgdGhpcy5ub2RlLnNldChuLCBvcHRBdHRyRGljdCk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyB1cGRhdGUgYXR0ciBldmVuIGlmIG5vZGUgYWxyZWFkeSBleGlzdHNcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5ub2RlLmdldChuKSwgb3B0QXR0ckRpY3QpO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFkZCBtdWx0aXBsZSBub2Rlcy5cbiAgICpcbiAgICogQHNlZSAjYWRkX25vZGVcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlQ29udGFpbmVyfSBub2Rlc1xuICAgKiAgICAgIEEgY29udGFpbmVyIG9mIG5vZGVzIChsaXN0LCBkaWN0LCBzZXQsIGV0Yy4pLlxuICAgKiAgICAgIE9SXG4gICAqICAgICAgQSBjb250YWluZXIgb2YgKG5vZGUsIGF0dHJpYnV0ZSBkaWN0KSB0dXBsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2F0dHIgIFVwZGF0ZSBhdHRyaWJ1dGVzIGZvciBhbGwgbm9kZXMgaW4gbm9kZXMuXG4gICAqICAgICAgIE5vZGUgYXR0cmlidXRlcyBzcGVjaWZpZWQgaW4gbm9kZXMgYXMgYSB0dXBsZVxuICAgKiAgICAgICB0YWtlIHByZWNlZGVuY2Ugb3ZlciBhdHRyaWJ1dGVzIHNwZWNpZmllZCBnZW5lcmFsbHkuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBhZGROb2Rlc0Zyb20obm9kZXMsIG9wdEF0dHI9e30pIHtcbiAgICAvLyBpZiBhbiBvYmplY3QsIG9ubHkgaXRlcmF0ZSBvdmVyIHRoZSBrZXlzXG4gICAgZm9yRWFjaChub2RlcywgZnVuY3Rpb24obikge1xuICAgICAgdmFyIG5ld25vZGUgPSAhdGhpcy5zdWNjLmhhcyhuKTtcblxuICAgICAgLy8gdGVzdCB3aGV0aGVyIG4gaXMgYSAobm9kZSwgYXR0cikgdHVwbGVcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG4pICYmIG4ubGVuZ3RoID09PSAyICYmIGlzUGxhaW5PYmplY3QoblsxXSkpIHtcbiAgICAgICAgdmFyIG5uID0gblswXTtcbiAgICAgICAgdmFyIG5kaWN0ID0gblsxXTtcblxuICAgICAgICBpZiAoIXRoaXMuc3VjYy5oYXMobm4pKSB7XG4gICAgICAgICAgdGhpcy5zdWNjLnNldChubiwgbmV3IE1hcCgpKTtcbiAgICAgICAgICB0aGlzLnByZWQuc2V0KG5uLCBuZXcgTWFwKCkpO1xuICAgICAgICAgIHZhciBuZXdkaWN0ID0gY2xvbmUob3B0QXR0cik7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdkaWN0LCBuZGljdCk7XG4gICAgICAgICAgdGhpcy5ub2RlLnNldChubiwgbmV3ZGljdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG9sZGRpY3QgPSB0aGlzLm5vZGUuZ2V0KG5uKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG9sZGRpY3QsIG9wdEF0dHIsIG5kaWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXdub2RlKSB7XG4gICAgICAgIHRoaXMuc3VjYy5zZXQobiwgbmV3IE1hcCgpKTtcbiAgICAgICAgdGhpcy5wcmVkLnNldChuLCBuZXcgTWFwKCkpO1xuICAgICAgICB0aGlzLm5vZGUuc2V0KG4sIGNsb25lKG9wdEF0dHIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMubm9kZS5nZXQobiksIG9wdEF0dHIpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBub2RlIG4uXG4gICAqXG4gICAqIFJlbW92ZXMgdGhlIG5vZGUgbiBhbmQgYWxsIGFkamFjZW50IGVkZ2VzLlxuICAgKiBBdHRlbXB0aW5nIHRvIHJlbW92ZSBhIG5vbi1leGlzdGVudCBub2RlIHdpbGwgcmFpc2UgYW4gZXhjZXB0aW9uLlxuICAgKlxuICAgKiBAc2VlICNyZW1vdmVfbm9kZXNfZnJvbVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG4gIEEgbm9kZSBpbiB0aGUgZ3JhcGhcbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqIEBleHBvcnRcbiAgICovXG4gIHJlbW92ZU5vZGUobikge1xuICAgIGlmICh0aGlzLm5vZGUuZGVsZXRlKG4pKSB7XG4gICAgICB2YXIgbmJycyA9IHRoaXMuc3VjYy5nZXQobik7XG4gICAgICBuYnJzLmZvckVhY2goZnVuY3Rpb24oXywgdSkge1xuICAgICAgICB0aGlzLnByZWQuZ2V0KHUpLmRlbGV0ZShuKTsgLy8gcmVtb3ZlIGFsbCBlZGdlcyBuLXUgaW4gZGlncmFwaFxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLnN1Y2MuZGVsZXRlKG4pOyAvLyByZW1vdmUgbm9kZSBmcm9tIHN1Y2NcbiAgICAgIHRoaXMucHJlZC5nZXQobikuZm9yRWFjaChmdW5jdGlvbihfLCB1KSB7XG4gICAgICAgIHRoaXMuc3VjYy5nZXQodSkuZGVsZXRlKG4pOyAvLyByZW1vdmUgYWxsIGVkZ2VzIG4tdSBpbiBkaWdyYXBoXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMucHJlZC5kZWxldGUobik7IC8vIHJlbW92ZSBub2RlIGZyb20gcHJlZFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBKU05ldHdvcmtYRXJyb3IoXG4gICAgICAgIHNwcmludGYoJ1RoZSBub2RlIFwiJWpcIiBpcyBub3QgaW4gdGhlIGdyYXBoJywgbilcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBtdWx0aXBsZSBub2Rlcy5cbiAgICpcbiAgICogQHNlZSAjcmVtb3ZlX25vZGVcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlQ29udGFpbmVyfSBub2RlcyAgQSBjb250YWluZXIgb2Ygbm9kZXMuXG4gICAqICAgICAgSWYgYSBub2RlIGluIHRoZSBjb250YWluZXIgaXMgbm90IGluIHRoZSBncmFwaCBpdCBpcyBzaWxlbnRseSBpZ25vcmVkLlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgcmVtb3ZlTm9kZXNGcm9tKG5vZGVzKSB7XG4gICAgZm9yRWFjaChub2RlcywgZnVuY3Rpb24obikge1xuICAgICAgaWYgKHRoaXMuc3VjYy5oYXMobikpIHtcbiAgICAgICAgdmFyIHN1Y2NzID0gdGhpcy5zdWNjLmdldChuKTtcblxuICAgICAgICB0aGlzLm5vZGUuZGVsZXRlKG4pO1xuICAgICAgICBzdWNjcy5mb3JFYWNoKGZ1bmN0aW9uKF8sIHUpIHtcbiAgICAgICAgICAvLyByZW1vdmUgYWxsIGVkZ2VzIG4tdSBpbiBkaWdyYXBoXG4gICAgICAgICAgdGhpcy5wcmVkLmdldCh1KS5kZWxldGUobik7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLnN1Y2MuZGVsZXRlKG4pOyAvLyByZW1vdmUgbm9kZSBmcm9tIHN1Y2NcbiAgICAgICAgdGhpcy5wcmVkLmdldChuKS5mb3JFYWNoKGZ1bmN0aW9uKF8sIHUpIHtcbiAgICAgICAgICAvLyByZW1vdmUgYWxsIGVkZ2VzIG4tdSBpbiBkaWdyYXBoXG4gICAgICAgICAgdGhpcy5zdWNjLmdldCh1KS5kZWxldGUobik7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLnByZWQuZGVsZXRlKG4pOyAvLyByZW1vdmUgbm9kZSBmcm9tIHByZWRcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFkZCBhbiBlZGdlIGJldHdlZW4gdSBhbmQgdi5cbiAgICpcbiAgICogVGhlIG5vZGVzIHUgYW5kIHYgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGlmIHRoZXkgYXJlXG4gICAqIG5vdCBhbHJlYWR5IGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogRWRnZSBhdHRyaWJ1dGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aCBrZXl3b3JkcyBvciBieSBwcm92aWRpbmdcbiAgICogYSBkaWN0aW9uYXJ5IHdpdGgga2V5L3ZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAc2VlICNhZGRfZWRnZXNfZnJvbVxuICAgKlxuICAgKiBOb3RlOiBBZGRpbmcgYW4gZWRnZSB0aGF0IGFscmVhZHkgZXhpc3RzIHVwZGF0ZXMgdGhlIGVkZ2UgZGF0YS5cbiAgICpcbiAgICogICAgICAgTWFueSBOZXR3b3JrWCBhbGdvcml0aG1zIGRlc2lnbmVkIGZvciB3ZWlnaHRlZCBncmFwaHMgdXNlIGFzXG4gICAqICAgICAgIHRoZSBlZGdlIHdlaWdodCBhIG51bWVyaWNhbCB2YWx1ZSBhc3NpZ25lZCB0byBhIGtleXdvcmRcbiAgICogICAgICAgd2hpY2ggYnkgZGVmYXVsdCBpcyAnd2VpZ2h0Jy5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB1IE5vZGVcbiAgICogQHBhcmFtIHtOb2RlfSB2IE5vZGVcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfYXR0cl9kaWN0IERpY3Rpb25hcnkgb2YgZWRnZSBhdHRyaWJ1dGVzLlxuICAgKiAgICAgIEtleS92YWx1ZSBwYWlycyB3aWxsIHVwZGF0ZSBleGlzdGluZyBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWRnZS5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGFkZEVkZ2UodSwgdiwgb3B0QXR0ckRpY3Q9e30pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qob3B0QXR0ckRpY3QpKSB7XG4gICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKFxuICAgICAgICAnVGhlIG9wdEF0dHJEaWN0IGFyZ3VtZW50IG11c3QgYmUgYSBwbGFpbiBvYmplY3QuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgbm9kZXNcbiAgICBpZiAoIXRoaXMuc3VjYy5oYXModSkpIHtcbiAgICAgIHRoaXMuc3VjYy5zZXQodSwgbmV3IE1hcCgpKTtcbiAgICAgIHRoaXMucHJlZC5zZXQodSwgbmV3IE1hcCgpKTtcbiAgICAgIHRoaXMubm9kZS5zZXQodSwge30pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdWNjLmhhcyh2KSkge1xuICAgICAgdGhpcy5zdWNjLnNldCh2LCBuZXcgTWFwKCkpO1xuICAgICAgdGhpcy5wcmVkLnNldCh2LCBuZXcgTWFwKCkpO1xuICAgICAgdGhpcy5ub2RlLnNldCh2LCB7fSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHRoZSBlZGdlXG4gICAgdmFyIGRhdGFkaWN0ID0gdGhpcy5hZGouZ2V0KHUpLmdldCh2KSB8fCB7fTtcbiAgICBPYmplY3QuYXNzaWduKGRhdGFkaWN0LCBvcHRBdHRyRGljdCk7XG4gICAgdGhpcy5zdWNjLmdldCh1KS5zZXQodiwgZGF0YWRpY3QpO1xuICAgIHRoaXMucHJlZC5nZXQodikuc2V0KHUsIGRhdGFkaWN0KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFkZCBhbGwgdGhlIGVkZ2VzIGluIGVidW5jaC5cbiAgICpcbiAgICogTm90ZXM6XG4gICAqIEFkZGluZyB0aGUgc2FtZSBlZGdlIHR3aWNlIGhhcyBubyBlZmZlY3QgYnV0IGFueSBlZGdlIGRhdGFcbiAgICogd2lsbCBiZSB1cGRhdGVkIHdoZW4gZWFjaCBkdXBsaWNhdGUgZWRnZSBpcyBhZGRlZC5cbiAgICpcbiAgICogQHNlZSAjYWRkX2VkZ2VcbiAgICogQHNlZSAjYWRkX3dlaWdodGVkX2VkZ2VzX2Zyb21cbiAgICpcbiAgICogQHBhcmFtIHs/fSBlYnVuY2ggY29udGFpbmVyIG9mIGVkZ2VzXG4gICAqICAgICAgRWFjaCBlZGdlIGdpdmVuIGluIHRoZSBjb250YWluZXIgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgICogICAgICBncmFwaC4gVGhlIGVkZ2VzIG11c3QgYmUgZ2l2ZW4gYXMgYXMgMi10dXBsZXMgKHUsdikgb3JcbiAgICogICAgICAzLXR1cGxlcyAodSx2LGQpIHdoZXJlIGQgaXMgYSBkaWN0aW9uYXJ5IGNvbnRhaW5pbmcgZWRnZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdF9hdHRyX2RpY3QgRGljdGlvbmFyeSBvZiBlZGdlIGF0dHJpYnV0ZXMuXG4gICAqICAgICAgRGljdGlvbmFyeSBvZiBlZGdlIGF0dHJpYnV0ZXMuICBLZXkvdmFsdWUgcGFpcnMgd2lsbFxuICAgKiAgICAgIHVwZGF0ZSBleGlzdGluZyBkYXRhIGFzc29jaWF0ZWQgd2l0aCBlYWNoIGVkZ2UuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBhZGRFZGdlc0Zyb20oZWJ1bmNoLCBvcHRBdHRyRGljdD17fSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChvcHRBdHRyRGljdCkpIHtcbiAgICAgIHRocm93IG5ldyBKU05ldHdvcmtYRXJyb3IoXG4gICAgICAgICdUaGUgb3B0X2F0dHJfZGljdCBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHByb2Nlc3MgZWJ1bmNoXG4gICAgZm9yRWFjaChlYnVuY2gsIGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHZhciBsZW5ndGggPSBzaXplKGVkZ2UpO1xuICAgICAgdmFyIHUsIHYsIGVkZ2VEYXRhO1xuICAgICAgaWYgKGxlbmd0aCA9PT0gMykge1xuICAgICAgICB1ID0gZWRnZVswXTtcbiAgICAgICAgdiA9IGVkZ2VbMV07XG4gICAgICAgIGVkZ2VEYXRhID0gZWRnZVsyXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA9PT0gMikge1xuICAgICAgICB1ID0gZWRnZVswXTtcbiAgICAgICAgdiA9IGVkZ2VbMV07XG4gICAgICAgIGVkZ2VEYXRhID0ge307XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcihcbiAgICAgICAgICBzcHJpbnRmKCdFZGdlIHR1cGxlIFwiJWpcIiBtdXN0IGJlIGEgMi10dXBsZSBvciAzLXR1cGxlLicsIGVkZ2UpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5zdWNjLmhhcyh1KSkge1xuICAgICAgICB0aGlzLnN1Y2Muc2V0KHUsIG5ldyBNYXAoKSk7XG4gICAgICAgIHRoaXMucHJlZC5zZXQodSwgbmV3IE1hcCgpKTtcbiAgICAgICAgdGhpcy5ub2RlLnNldCh1LCB7fSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3VjYy5oYXModikpIHtcbiAgICAgICAgdGhpcy5zdWNjLnNldCh2LCBuZXcgTWFwKCkpO1xuICAgICAgICB0aGlzLnByZWQuc2V0KHYsIG5ldyBNYXAoKSk7XG4gICAgICAgIHRoaXMubm9kZS5zZXQodiwge30pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YWRpY3QgPSB0aGlzLmFkai5nZXQodSkuZ2V0KHYpIHx8IHt9O1xuICAgICAgT2JqZWN0LmFzc2lnbihkYXRhZGljdCwgb3B0QXR0ckRpY3QsIGVkZ2VEYXRhKTtcbiAgICAgIHRoaXMuc3VjYy5nZXQodSkuc2V0KHYsIGRhdGFkaWN0KTtcbiAgICAgIHRoaXMucHJlZC5nZXQodikuc2V0KHUsIGRhdGFkaWN0KTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGVkZ2UgYmV0d2VlbiB1IGFuZCB2LlxuICAgKlxuICAgKiBAc2VlICNyZW1vdmVfZWRnZXNfZnJvbVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHUgTm9kZVxuICAgKiBAcGFyYW0ge05vZGV9IHYgTm9kZVxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgcmVtb3ZlRWRnZSh1LCB2KSB7XG4gICAgdmFyIGVkZ2UgPSB0aGlzLnN1Y2MuZ2V0KHUpO1xuICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQgJiYgZWRnZS5kZWxldGUodikpIHtcbiAgICAgIHRoaXMucHJlZC5nZXQodikuZGVsZXRlKHUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBKU05ldHdvcmtYRXJyb3IoXG4gICAgICAgIHNwcmludGYoJ1RoZSBlZGdlIFwiJWotJWpcIiBpcyBub3QgaW4gdGhlIGdyYXBoJywgdSwgdilcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgZWRnZXMgc3BlY2lmaWVkIGluIGVidW5jaC5cbiAgICpcbiAgICogTm90ZXM6IFdpbGwgZmFpbCBzaWxlbnRseSBpZiBhbiBlZGdlIGluIGVidW5jaCBpcyBub3QgaW4gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gez99IGVidW5jaCAxbGlzdCBvciBjb250YWluZXIgb2YgZWRnZSB0dXBsZXNcbiAgICogICAgICBFYWNoIGVkZ2UgZ2l2ZW4gaW4gdGhlIGxpc3Qgb3IgY29udGFpbmVyIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiAgICAgIGZyb20gdGhlIGdyYXBoLiBUaGUgZWRnZXMgY2FuIGJlOlxuICAgKiAgICAgICAgICAtIDItdHVwbGVzICh1LHYpIGVkZ2UgYmV0d2VlbiB1IGFuZCB2LlxuICAgKiAgICAgICAgICAtIDMtdHVwbGVzICh1LHYsaykgd2hlcmUgayBpcyBpZ25vcmVkLlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgcmVtb3ZlRWRnZXNGcm9tKGVidW5jaCkge1xuICAgIGZvckVhY2goZWJ1bmNoLCBmdW5jdGlvbihlZGdlKSB7XG4gICAgICB2YXIgdSA9IGVkZ2VbMF07IC8vIGlnbm9yZSBlZGdlIGRhdGEgaWYgcHJlc2VudFxuICAgICAgdmFyIHYgPSBlZGdlWzFdO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnN1Y2MuZ2V0KHUpLmRlbGV0ZSh2KTtcbiAgICAgICAgdGhpcy5wcmVkLmdldCh2KS5kZWxldGUodSk7XG4gICAgICB9XG4gICAgICBjYXRjaChleCl7XG4gICAgICAgIC8vIHBhc3NcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gVHJ1ZSBpZiBub2RlIHUgaGFzIHN1Y2Nlc3NvciB2LlxuICAgKlxuICAgKiBUaGlzIGlzIHRydWUgaWYgZ3JhcGggaGFzIHRoZSBlZGdlIHUtPnYuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdSBOb2RlXG4gICAqIEBwYXJhbSB7Tm9kZX0gdiBOb2RlXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbm9kZSB1IGhhcyBzdWNjZXNzb3IgdlxuICAgKlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBoYXNTdWNjZXNzb3IodSwgdikge1xuICAgIHJldHVybiB0aGlzLnN1Y2MuaGFzKHUpICYmIHRoaXMuc3VjYy5nZXQodSkuaGFzKHYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBUcnVlIGlmIG5vZGUgdSBoYXMgcHJlZGVjZXNzb3Igdi5cbiAgICpcbiAgICogVGhpcyBpcyB0cnVlIGlmIGdyYXBoIGhhcyB0aGUgZWRnZSB1PC12LlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHUgTm9kZVxuICAgKiBAcGFyYW0ge05vZGV9IHYgTm9kZVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG5vZGUgdSBoYXMgcHJlZGVjZXNzb3IgdlxuICAgKlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBoYXNQcmVkZWNlc3Nvcih1LCB2KSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZC5oYXModSkgJiYgdGhpcy5wcmVkLmdldCh1KS5oYXModik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGl0ZXJhdG9yIG92ZXIgc3VjY2Vzc29yIG5vZGVzIG9mIG4uXG4gICAqXG4gICAqIHtAY29kZSBuZWlnaGJvcnNfaXRlcigpfSBhbmQge0Bjb2RlIHN1Y2Nlc3NvcnNfaXRlcigpfSBhcmUgdGhlIHNhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbiBOb2RlXG4gICAqXG4gICAqIEByZXR1cm4geyFJdGVyYXRvcn0gSXRlcmF0b3Igb3ZlciBzdWNjZXNzb3Igbm9kZXMgb2YgblxuICAgKlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBzdWNjZXNzb3JzSXRlcihuKSB7XG4gICAgdmFyIG5icnMgPSB0aGlzLnN1Y2MuZ2V0KG4pO1xuICAgIGlmIChuYnJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuYnJzLmtleXMoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcihcbiAgICAgIHNwcmludGYoJ1RoZSBub2RlIFwiJWpcIiBpcyBub3QgaW4gdGhlIGRpZ3JhcGguJywgbilcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpdGVyYXRvciBvdmVyIHByZWRlY2Vzc29yIG5vZGVzIG9mIG4uXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbiBOb2RlXG4gICAqXG4gICAqIEByZXR1cm4geyFJdGVyYXRvcn0gSXRlcmF0b3Igb3ZlciBwcmVkZWNlc3NvciBub2RlcyBvZiBuXG4gICAqXG4gICAqIEBleHBvcnRcbiAgICovXG4gIHByZWRlY2Vzc29yc0l0ZXIobikge1xuICAgIHZhciBuYnJzID0gdGhpcy5wcmVkLmdldChuKTtcbiAgICBpZiAobmJycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmJycy5rZXlzKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBKU05ldHdvcmtYRXJyb3IoXG4gICAgICBzcHJpbnRmKCdUaGUgbm9kZSBcIiVqXCIgaXMgbm90IGluIHRoZSBkaWdyYXBoLicsIG4pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBsaXN0IG9mIHN1Y2Nlc3NvciBub2RlcyBvZiBuLlxuICAgKlxuICAgKiB7QGNvZGUgbmVpZ2hib3JzKCl9IGFuZCB7QGNvZGUgc3VjY2Vzc29ycygpfSBhcmUgdGhlIHNhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbiBOb2RlXG4gICAqXG4gICAqIEByZXR1cm4geyFBcnJheX0gTGlzdCBvZiBzdWNjZXNzb3Igbm9kZXMgb2YgblxuICAgKlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBzdWNjZXNzb3JzKG4pIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN1Y2Nlc3NvcnNJdGVyKG4pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gbGlzdCBvZiBwcmVkZWNlc3NvciBub2RlcyBvZiBuLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG4gTm9kZVxuICAgKlxuICAgKiBAcmV0dXJuIHshQXJyYXl9IExpc3Qgb2YgcHJlZGVjZXNzb3Igbm9kZXMgb2YgblxuICAgKlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBwcmVkZWNlc3NvcnMobikge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucHJlZGVjZXNzb3JzSXRlcihuKSk7XG4gIH1cblxuXG4gIC8vIGRpZ3JhcGggZGVmaW5pdGlvbnNcbiAgLyoqXG4gICAqIEBzZWUgI3N1Y2Nlc3NvcnNcbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGdldCBuZWlnaGJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VjY2Vzc29ycztcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlICNzdWNjZXNzb3JzX2l0ZXJcbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGdldCBuZWlnaGJvcnNJdGVyKCkge1xuICAgIHJldHVybiB0aGlzLnN1Y2Nlc3NvcnNJdGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpdGVyYXRvciBvdmVyIHRoZSBlZGdlcy5cbiAgICpcbiAgICogRWRnZXMgYXJlIHJldHVybmVkIGFzIHR1cGxlcyB3aXRoIG9wdGlvbmFsIGRhdGFcbiAgICogaW4gdGhlIG9yZGVyIChub2RlLCBuZWlnaGJvciwgZGF0YSkuXG4gICAqXG4gICAqIEBzZWUgI2VkZ2VzXG4gICAqXG4gICAqIE5vdGU6XG4gICAqXG4gICAqICAgICAgTm9kZXMgaW4gbmJ1bmNoIHRoYXQgYXJlIG5vdCBpbiB0aGUgZ3JhcGggd2lsbCBiZSAocXVpZXRseSkgaWdub3JlZC5cbiAgICpcbiAgICogQHBhcmFtIHs/KE5vZGVDb250YWluZXJ8Ym9vbGVhbik9fSBvcHRfbmJ1bmNoIEEgY29udGFpbmVyIG9mIG5vZGVzLlxuICAgKiAgICAgICBUaGUgY29udGFpbmVyIHdpbGwgYmUgaXRlcmF0ZWQgdGhyb3VnaCBvbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gez9ib29sZWFuPX0gb3B0X2RhdGFcbiAgICogICAgICBJZiBUcnVlLCByZXR1cm4gZWRnZSBhdHRyaWJ1dGUgZGljdCBpbiAzLXR1cGxlICh1LHYsZGF0YSkuXG4gICAqXG4gICAqIEByZXR1cm4geyFJdGVyYXRvcn0gQW4gaXRlcmF0b3Igb2YgKHUsdikgb3IgKHUsdixkKSB0dXBsZXMgb2YgZWRnZXMuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAZXhwb3J0XG4gICAqL1xuICAqZWRnZXNJdGVyKG9wdE5idW5jaCwgb3B0RGF0YT1mYWxzZSkge1xuICAgIC8vIGhhbmRsZSBjYWxscyB3aXRoIG9wdF9kYXRhIGJlaW5nIHRoZSBvbmx5IGFyZ3VtZW50XG4gICAgaWYgKGlzQm9vbGVhbihvcHROYnVuY2gpKSB7XG4gICAgICBvcHREYXRhID0gb3B0TmJ1bmNoO1xuICAgICAgb3B0TmJ1bmNoID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBub2Rlc05icnM7XG5cbiAgICBpZiAob3B0TmJ1bmNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGVzTmJycyA9IHRoaXMuYWRqO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5vZGVzTmJycyA9IG1hcEl0ZXJhdG9yKFxuICAgICAgICB0aGlzLm5idW5jaEl0ZXIob3B0TmJ1bmNoKSxcbiAgICAgICAgbiA9PiB0dXBsZTIobiwgdGhpcy5hZGouZ2V0KG4pKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBub2RlTmJycyBvZiBub2Rlc05icnMpIHtcbiAgICAgIGZvciAodmFyIG5ickRhdGEgb2Ygbm9kZU5icnNbMV0pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtub2RlTmJyc1swXSwgbmJyRGF0YVswXV07XG4gICAgICAgIGlmIChvcHREYXRhKSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gbmJyRGF0YVsxXTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWxpYXMgb3V0X2VkZ2VzIHRvIGVkZ2VzXG5cbiAgLyoqXG4gICAqIEBzZWUgI2VkZ2VzX2l0ZXJcbiAgICovXG4gIG91dEVkZ2VzSXRlcihvcHROYnVuY2gsIG9wdERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlc0l0ZXIob3B0TmJ1bmNoLCBvcHREYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIEdyYXBoI2VkZ2VzXG4gICAqL1xuICBvdXRFZGdlcyhvcHROYnVuY2gsIG9wdERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlcyhvcHROYnVuY2gsIG9wdERhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpdGVyYXRvciBvdmVyIHRoZSBpbmNvbWluZyBlZGdlcy5cbiAgICpcbiAgICogQHNlZSAjZWRnZXNfaXRlclxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0geyg/Tm9kZUNvbnRhaW5lcnxib29sZWFuKT19IG9wdF9uYnVuY2ggQSBjb250YWluZXIgb2Ygbm9kZXMuXG4gICAqICAgICAgIFRoZSBjb250YWluZXIgd2lsbCBiZSBpdGVyYXRlZCB0aHJvdWdoIG9uY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7P2Jvb2xlYW49fSBvcHRfZGF0YVxuICAgKiAgICAgIElmIFRydWUsIHJldHVybiBlZGdlIGF0dHJpYnV0ZSBkaWN0IGluIDMtdHVwbGUgKHUsdixkYXRhKS5cbiAgICpcbiAgICogQHJldHVybiB7IUl0ZXJhdG9yfSBBbiBpdGVyYXRvciBvZiAodSx2KSBvciAodSx2LGQpIHR1cGxlcyBvZlxuICAgKiAgICAgIGluY29taW5nIGVkZ2VzLlxuICAgKlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICAqaW5FZGdlc0l0ZXIob3B0TmJ1bmNoLCBvcHREYXRhPWZhbHNlKSB7XG4gICAgLy8gaGFuZGxlIGNhbGxzIHdpdGggb3B0X2RhdGEgYmVpbmcgdGhlIG9ubHkgYXJndW1lbnRcbiAgICBpZiAoaXNCb29sZWFuKG9wdE5idW5jaCkpIHtcbiAgICAgIG9wdERhdGEgPSBvcHROYnVuY2g7XG4gICAgICBvcHROYnVuY2ggPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzTmJycztcblxuICAgIGlmKG9wdE5idW5jaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub2Rlc05icnMgPSB0aGlzLnByZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbm9kZXNOYnJzID0gbWFwSXRlcmF0b3IoXG4gICAgICAgIHRoaXMubmJ1bmNoSXRlcihvcHROYnVuY2gpLFxuICAgICAgICBuID0+IHR1cGxlMihuLCB0aGlzLnByZWQuZ2V0KG4pKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBub2RlTmJycyBvZiBub2Rlc05icnMpIHtcbiAgICAgIGZvcih2YXIgbmJyRGF0YSBvZiBub2RlTmJyc1sxXSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW25ickRhdGFbMF0sIG5vZGVOYnJzWzBdXTtcbiAgICAgICAgaWYgKG9wdERhdGEpIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSBuYnJEYXRhWzFdO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgbGlzdCBvZiB0aGUgaW5jb21pbmcgZWRnZXMuXG4gICAqXG4gICAqIEBzZWUgI2VkZ2VzXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZUNvbnRhaW5lcn0gb3B0X25idW5jaCBBIGNvbnRhaW5lciBvZiBub2Rlcy5cbiAgICogICAgICAgVGhlIGNvbnRhaW5lciB3aWxsIGJlIGl0ZXJhdGVkIHRocm91Z2ggb25jZS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRfZGF0YVxuICAgKiAgICAgIElmIFRydWUsIHJldHVybiBlZGdlIGF0dHJpYnV0ZSBkaWN0IGluIDMtdHVwbGUgKHUsdixkYXRhKS5cbiAgICpcbiAgICogQHJldHVybiB7IUFycmF5fSBBIGxpc3Qgb2YgaW5jb21pbmcgZWRnZXNcbiAgICpcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgaW5FZGdlcyhvcHROYnVuY2gsIG9wdERhdGE9ZmFsc2UpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmluRWRnZXNJdGVyKG9wdE5idW5jaCwgb3B0RGF0YSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpdGVyYXRvciBmb3IgKG5vZGUsIGRlZ3JlZSkuXG4gICAqXG4gICAqIFRoZSBub2RlIGRlZ3JlZSBpcyB0aGUgbnVtYmVyIG9mIGVkZ2VzIGFkamFjZW50IHRvIHRoZSBub2RlLlxuICAgKlxuICAgKiBAc2VlICNkZWdyZWVcbiAgICogQHNlZSAjaW5fZGVncmVlXG4gICAqIEBzZWUgI291dF9kZWdyZWVcbiAgICogQHNlZSAjaW5fZGVncmVlX2l0ZXJcbiAgICogQHNlZSAjb3V0X2RlZ3JlZV9pdGVyXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7KE5vZGV8Tm9kZUNvbnRhaW5lcik9fSBvcHRfbmJ1bmNoICBBIGNvbnRhaW5lciBvZiBub2Rlcy5cbiAgICogICAgICAgVGhlIGNvbnRhaW5lciB3aWxsIGJlIGl0ZXJhdGVkIHRocm91Z2ggb25jZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfd2VpZ2h0XG4gICAqICAgICAgIFRoZSBlZGdlIGF0dHJpYnV0ZSB0aGF0IGhvbGRzIHRoZSBudW1lcmljYWwgdmFsdWUgdXNlZFxuICAgKiAgICAgICBhcyBhIHdlaWdodC4gIElmIE5vbmUsIHRoZW4gZWFjaCBlZGdlIGhhcyB3ZWlnaHQgMS5cbiAgICogICAgICAgVGhlIGRlZ3JlZSBpcyB0aGUgc3VtIG9mIHRoZSBlZGdlIHdlaWdodHMgYWRqYWNlbnQgdG8gdGhlIG5vZGUuXG4gICAqXG4gICAqXG4gICAqIFdBUk5JTkc6IFNpbmNlIGJvdGggcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwsIGFuZCB0aGUgd2VpZ2h0IGF0dHJpYnV0ZVxuICAgKiBuYW1lIGNvdWxkIGJlIGVxdWFsIHRvIGEgbm9kZSBuYW1lLCBuYnVuY2ggYXMgdG8gYmUgc2V0IHRvIG51bGwgZXhwbGljaXRseVxuICAgKiB0byB1c2UgdGhlIHNlY29uZCBhcmd1bWVudCBhcyB3ZWlnaHQgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4geyFJdGVyYXRvcn0gIFRoZSBpdGVyYXRvciByZXR1cm5zIHR3by10dXBsZXMgb2YgKG5vZGUsIGRlZ3JlZSkuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBkZWdyZWVJdGVyKG9wdE5idW5jaCwgb3B0V2VpZ2h0KSB7XG4gICAgdmFyIG5vZGVzTmJycztcblxuICAgIGlmKG9wdE5idW5jaCA9PSBudWxsKSB7XG4gICAgICBub2Rlc05icnMgPSB6aXBJdGVyYXRvcih0aGlzLnN1Y2MuZW50cmllcygpLCB0aGlzLnByZWQuZW50cmllcygpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgdHVwbGUyU3VjYyA9IGNyZWF0ZVR1cGxlRmFjdG9yeSgyKTtcbiAgICAgIHZhciB0dXBsZTJQcmVkID0gY3JlYXRlVHVwbGVGYWN0b3J5KDIpO1xuICAgICAgbm9kZXNOYnJzID0gemlwSXRlcmF0b3IoXG4gICAgICAgIG1hcEl0ZXJhdG9yKFxuICAgICAgICAgIHRoaXMubmJ1bmNoSXRlcihvcHROYnVuY2gpLFxuICAgICAgICAgIG4gPT4gdHVwbGUyU3VjYyhuLCB0aGlzLnN1Y2MuZ2V0KG4pKVxuICAgICAgICApLFxuICAgICAgICBtYXBJdGVyYXRvcihcbiAgICAgICAgICB0aGlzLm5idW5jaEl0ZXIob3B0TmJ1bmNoKSxcbiAgICAgICAgICBuID0+IHR1cGxlMlByZWQobiwgdGhpcy5wcmVkLmdldChuKSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0V2VpZ2h0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBtYXBJdGVyYXRvcihcbiAgICAgICAgbm9kZXNOYnJzLFxuICAgICAgICAoW1tub2RlLCBzdWNjXSwgW3UsIHByZWRdXSkgPT4gW25vZGUsIHByZWQuc2l6ZSArIHN1Y2Muc2l6ZV1cbiAgICAgICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gZWRnZSB3ZWlnaHRlZCBncmFwaCAtIGRlZ3JlZSBpcyBzdW0gb2YgZWRnZSB3ZWlnaHRzXG4gICAgICByZXR1cm4gbWFwSXRlcmF0b3IoXG4gICAgICAgIG5vZGVzTmJycyxcbiAgICAgICAgZnVuY3Rpb24oW1tub2RlLCBzdWNjXSwgW18sIHByZWRdXSkge1xuICAgICAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gc3VtRGF0YShkYXRhKSB7XG4gICAgICAgICAgICB2YXIgd2VpZ2h0ID0gZGF0YVtvcHRXZWlnaHRdO1xuICAgICAgICAgICAgc3VtICs9IHdlaWdodCAhPSBudWxsID8gK3dlaWdodCA6IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3VjYy5mb3JFYWNoKHN1bURhdGEpO1xuICAgICAgICAgIHByZWQuZm9yRWFjaChzdW1EYXRhKTtcblxuICAgICAgICAgIHJldHVybiBbbm9kZSwgc3VtXTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGl0ZXJhdG9yIGZvciAobm9kZSwgaW4tZGVncmVlKS5cbiAgICpcbiAgICogVGhlIG5vZGUgaW4tZGVncmVlIGlzIHRoZSBudW1iZXIgb2YgZWRnZXMgcG9pbnRpbmcgaW4gdG8gdGhlIG5vZGUuXG4gICAqXG4gICAqIEBzZWUgI2RlZ3JlZVxuICAgKiBAc2VlICNpbl9kZWdyZWVcbiAgICogQHNlZSAjb3V0X2RlZ3JlZVxuICAgKiBAc2VlICNvdXRfZGVncmVlX2l0ZXJcbiAgICpcbiAgICogQHBhcmFtIHsoTm9kZXxOb2RlQ29udGFpbmVyKT19IG9wdF9uYnVuY2ggIEEgY29udGFpbmVyIG9mIG5vZGVzLlxuICAgKiAgICAgICBUaGUgY29udGFpbmVyIHdpbGwgYmUgaXRlcmF0ZWQgdGhyb3VnaCBvbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF93ZWlnaHRcbiAgICogICAgICAgVGhlIGVkZ2UgYXR0cmlidXRlIHRoYXQgaG9sZHMgdGhlIG51bWVyaWNhbCB2YWx1ZSB1c2VkXG4gICAqICAgICAgIGFzIGEgd2VpZ2h0LiAgSWYgTm9uZSwgdGhlbiBlYWNoIGVkZ2UgaGFzIHdlaWdodCAxLlxuICAgKiAgICAgICBUaGUgZGVncmVlIGlzIHRoZSBzdW0gb2YgdGhlIGVkZ2Ugd2VpZ2h0cyBhZGphY2VudCB0byB0aGUgbm9kZS5cbiAgICpcbiAgICpcbiAgICogV0FSTklORzogU2luY2UgYm90aCBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbCwgYW5kIHRoZSB3ZWlnaHQgYXR0cmlidXRlXG4gICAqIG5hbWUgY291bGQgYmUgZXF1YWwgdG8gYSBub2RlIG5hbWUsIG5idW5jaCBhcyB0byBiZSBzZXQgdG8gbnVsbCBleHBsaWNpdGx5XG4gICAqIHRvIHVzZSB0aGUgc2Vjb25kIGFyZ3VtZW50IGFzIHdlaWdodCBhdHRyaWJ1dGUgbmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmF0b3J9ICBUaGUgaXRlcmF0b3IgcmV0dXJucyB0d28tdHVwbGVzIG9mIChub2RlLCBpbi1kZWdyZWUpLlxuICAgKlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBpbkRlZ3JlZUl0ZXIob3B0TmJ1bmNoLCBvcHRXZWlnaHQpIHtcbiAgICB2YXIgbm9kZXNOYnJzO1xuXG4gICAgaWYob3B0TmJ1bmNoID09IG51bGwpIHtcbiAgICAgIG5vZGVzTmJycyA9IHRoaXMucHJlZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBub2Rlc05icnMgPSBtYXBJdGVyYXRvcihcbiAgICAgICAgdGhpcy5uYnVuY2hJdGVyKG9wdE5idW5jaCksXG4gICAgICAgIG4gPT4gdHVwbGUyKG4sIHRoaXMucHJlZC5nZXQobikpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRXZWlnaHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yKFxuICAgICAgICBub2Rlc05icnMsXG4gICAgICAgIChbbm9kZSwgcHJlZF0pID0+IFtub2RlLCBwcmVkLnNpemVdXG4gICAgICApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBtYXBJdGVyYXRvcihcbiAgICAgICAgbm9kZXNOYnJzLFxuICAgICAgICBmdW5jdGlvbihbbm9kZSwgcHJlZF0pIHtcbiAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICBwcmVkLmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIHdlaWdodCA9IGRhdGFbb3B0V2VpZ2h0XTtcbiAgICAgICAgICAgIHN1bSArPSB3ZWlnaHQgIT0gbnVsbCA/ICt3ZWlnaHQgOiAgMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gW25vZGUsIHN1bV07XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpdGVyYXRvciBmb3IgKG5vZGUsIG91dC1kZWdyZWUpLlxuICAgKlxuICAgKiBUaGUgbm9kZSBvdXQtZGVncmVlIGlzIHRoZSBudW1iZXIgb2YgZWRnZXMgcG9pbnRpbmcgaW4gdG8gdGhlIG5vZGUuXG4gICAqXG4gICAqIEBzZWUgI2RlZ3JlZVxuICAgKiBAc2VlICNpbl9kZWdyZWVcbiAgICogQHNlZSAjb3V0X2RlZ3JlZVxuICAgKiBAc2VlICNpbl9kZWdyZWVfaXRlclxuICAgKlxuICAgKiBAcGFyYW0ge05vZGVDb250YWluZXI9fSBvcHRfbmJ1bmNoICBBIGNvbnRhaW5lciBvZiBub2Rlcy5cbiAgICogICAgICAgVGhlIGNvbnRhaW5lciB3aWxsIGJlIGl0ZXJhdGVkIHRocm91Z2ggb25jZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfd2VpZ2h0XG4gICAqICAgICAgIFRoZSBlZGdlIGF0dHJpYnV0ZSB0aGF0IGhvbGRzIHRoZSBudW1lcmljYWwgdmFsdWUgdXNlZFxuICAgKiAgICAgICBhcyBhIHdlaWdodC4gIElmIE5vbmUsIHRoZW4gZWFjaCBlZGdlIGhhcyB3ZWlnaHQgMS5cbiAgICogICAgICAgVGhlIGRlZ3JlZSBpcyB0aGUgc3VtIG9mIHRoZSBlZGdlIHdlaWdodHMgYWRqYWNlbnQgdG8gdGhlIG5vZGUuXG4gICAqXG4gICAqXG4gICAqIFdBUk5JTkc6IFNpbmNlIGJvdGggcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwsIGFuZCB0aGUgd2VpZ2h0IGF0dHJpYnV0ZVxuICAgKiBuYW1lIGNvdWxkIGJlIGVxdWFsIHRvIGEgbm9kZSBuYW1lLCBuYnVuY2ggYXMgdG8gYmUgc2V0IHRvIG51bGwgZXhwbGljaXRseVxuICAgKiB0byB1c2UgdGhlIHNlY29uZCBhcmd1bWVudCBhcyB3ZWlnaHQgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhdG9yfSAgVGhlIGl0ZXJhdG9yIHJldHVybnMgdHdvLXR1cGxlcyBvZiAobm9kZSwgb3V0LWRlZ3JlZSkuXG4gICAqIEBleHBvcnRcbiAgICovXG4gIG91dERlZ3JlZUl0ZXIob3B0TmJ1bmNoLCBvcHRXZWlnaHQpIHtcbiAgICB2YXIgbm9kZXNOYnJzO1xuXG4gICAgaWYgKG9wdE5idW5jaCA9PSBudWxsKSB7XG4gICAgICBub2Rlc05icnMgPSB0aGlzLnN1Y2M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbm9kZXNOYnJzID0gbWFwSXRlcmF0b3IoXG4gICAgICAgIHRoaXMubmJ1bmNoSXRlcihvcHROYnVuY2gpLFxuICAgICAgICBuID0+IHR1cGxlMihuLCB0aGlzLnN1Y2MuZ2V0KG4pKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZihvcHRXZWlnaHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yKFxuICAgICAgICBub2Rlc05icnMsXG4gICAgICAgIChbbm9kZSwgc3VjY10pID0+IFtub2RlLCBzdWNjLnNpemVdXG4gICAgICApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBtYXBJdGVyYXRvcihcbiAgICAgICAgbm9kZXNOYnJzLFxuICAgICAgICBmdW5jdGlvbihbbm9kZSwgc3VjY10pIHtcbiAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICBzdWNjLmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIHdlaWdodCA9IGRhdGFbb3B0V2VpZ2h0XTtcbiAgICAgICAgICAgIHN1bSArPSB3ZWlnaHQgIT0gbnVsbCA/ICt3ZWlnaHQgOiAgMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gW25vZGUsIHN1bV07XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaW4tZGVncmVlIG9mIGEgbm9kZSBvciBub2Rlcy5cbiAgICpcbiAgICogVGhlIG5vZGUgaW4tZGVncmVlIGlzIHRoZSBudW1iZXIgb2YgZWRnZXMgcG9pbnRpbmcgaW4gdG8gdGhlIG5vZGUuXG4gICAqXG4gICAqIEBzZWUgI2RlZ3JlZVxuICAgKiBAc2VlICNvdXRfZGVncmVlXG4gICAqIEBzZWUgI2luX2RlZ3JlZV9pdGVyXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZUNvbnRhaW5lcj19IG9wdF9uYnVuY2ggIEEgY29udGFpbmVyIG9mIG5vZGVzLlxuICAgKiAgICAgICBUaGUgY29udGFpbmVyIHdpbGwgYmUgaXRlcmF0ZWQgdGhyb3VnaCBvbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF93ZWlnaHRcbiAgICogICAgICAgVGhlIGVkZ2UgYXR0cmlidXRlIHRoYXQgaG9sZHMgdGhlIG51bWVyaWNhbCB2YWx1ZSB1c2VkXG4gICAqICAgICAgIGFzIGEgd2VpZ2h0LiAgSWYgTm9uZSwgdGhlbiBlYWNoIGVkZ2UgaGFzIHdlaWdodCAxLlxuICAgKiAgICAgICBUaGUgZGVncmVlIGlzIHRoZSBzdW0gb2YgdGhlIGVkZ2Ugd2VpZ2h0cyBhZGphY2VudCB0byB0aGUgbm9kZS5cbiAgICpcbiAgICpcbiAgICogV0FSTklORzogU2luY2UgYm90aCBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbCwgYW5kIHRoZSB3ZWlnaHQgYXR0cmlidXRlXG4gICAqIG5hbWUgY291bGQgYmUgZXF1YWwgdG8gYSBub2RlIG5hbWUsIG5idW5jaCBhcyB0byBiZSBzZXQgdG8gbnVsbCBleHBsaWNpdGx5XG4gICAqIHRvIHVzZSB0aGUgc2Vjb25kIGFyZ3VtZW50IGFzIHdlaWdodCBhdHRyaWJ1dGUgbmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7KG51bWJlcnxNYXApfVxuICAgKiAgICAgICBBIGRpY3Rpb25hcnkgd2l0aCBub2RlcyBhcyBrZXlzIGFuZCBpbi1kZWdyZWUgYXMgdmFsdWVzIG9yXG4gICAqICAgICAgIGEgbnVtYmVyIGlmIGEgc2luZ2xlIG5vZGUgaXMgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBpbkRlZ3JlZShvcHROYnVuY2gsIG9wdFdlaWdodCkge1xuICAgIGlmIChvcHROYnVuY2ggIT0gbnVsbCAmJiB0aGlzLmhhc05vZGUob3B0TmJ1bmNoKSkge1xuICAgICAgLy8gcmV0dXJuIGEgc2luZ2xlIG5vZGVcbiAgICAgIHJldHVybiBuZXh0KHRoaXMuaW5EZWdyZWVJdGVyKG9wdE5idW5jaCwgb3B0V2VpZ2h0KSlbMV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBNYXAodGhpcy5pbkRlZ3JlZUl0ZXIob3B0TmJ1bmNoLCBvcHRXZWlnaHQpKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG91dC1kZWdyZWUgb2YgYSBub2RlIG9yIG5vZGVzLlxuICAgKlxuICAgKiBUaGUgbm9kZSBvdXQtZGVncmVlIGlzIHRoZSBudW1iZXIgb2YgZWRnZXMgcG9pbnRpbmcgb3V0IG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBAc2VlICNkZWdyZWVcbiAgICogQHNlZSAjb3V0X2RlZ3JlZVxuICAgKiBAc2VlICNpbl9kZWdyZWVfaXRlclxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGVDb250YWluZXI9fSBvcHRfbmJ1bmNoICBBIGNvbnRhaW5lciBvZiBub2Rlcy5cbiAgICogICAgICAgVGhlIGNvbnRhaW5lciB3aWxsIGJlIGl0ZXJhdGVkIHRocm91Z2ggb25jZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfd2VpZ2h0XG4gICAqICAgICAgIFRoZSBlZGdlIGF0dHJpYnV0ZSB0aGF0IGhvbGRzIHRoZSBudW1lcmljYWwgdmFsdWUgdXNlZFxuICAgKiAgICAgICBhcyBhIHdlaWdodC4gIElmIE5vbmUsIHRoZW4gZWFjaCBlZGdlIGhhcyB3ZWlnaHQgMS5cbiAgICogICAgICAgVGhlIGRlZ3JlZSBpcyB0aGUgc3VtIG9mIHRoZSBlZGdlIHdlaWdodHMgYWRqYWNlbnQgdG8gdGhlIG5vZGUuXG4gICAqXG4gICAqXG4gICAqIFdBUk5JTkc6IFNpbmNlIGJvdGggcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwsIGFuZCB0aGUgd2VpZ2h0IGF0dHJpYnV0ZVxuICAgKiBuYW1lIGNvdWxkIGJlIGVxdWFsIHRvIGEgbm9kZSBuYW1lLCBuYnVuY2ggYXMgdG8gYmUgc2V0IHRvIG51bGwgZXhwbGljaXRseVxuICAgKiB0byB1c2UgdGhlIHNlY29uZCBhcmd1bWVudCBhcyB3ZWlnaHQgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4geyhudW1iZXJ8TWFwKX1cbiAgICogICAgICAgQSBkaWN0aW9uYXJ5IHdpdGggbm9kZXMgYXMga2V5cyBhbmQgaW4tZGVncmVlIGFzIHZhbHVlcyBvclxuICAgKiAgICAgICBhIG51bWJlciBpZiBhIHNpbmdsZSBub2RlIGlzIHNwZWNpZmllZC5cbiAgICpcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgb3V0RGVncmVlKG9wdE5idW5jaCwgb3B0V2VpZ2h0KSB7XG4gICAgaWYgKG9wdE5idW5jaCAhPSBudWxsICYmIHRoaXMuaGFzTm9kZShvcHROYnVuY2gpKSB7XG4gICAgICAvLyByZXR1cm4gYSBzaW5nbGUgbm9kZVxuICAgICAgcmV0dXJuIG5leHQodGhpcy5vdXREZWdyZWVJdGVyKG9wdE5idW5jaCwgb3B0V2VpZ2h0KSlbMV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBNYXAodGhpcy5vdXREZWdyZWVJdGVyKG9wdE5idW5jaCwgb3B0V2VpZ2h0KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgbm9kZXMgYW5kIGVkZ2VzIGZyb20gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBUaGlzIGFsc28gcmVtb3ZlcyB0aGUgbmFtZSwgYW5kIGFsbCBncmFwaCwgbm9kZSwgYW5kIGVkZ2UgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuc3VjYy5jbGVhcigpO1xuICAgIHRoaXMucHJlZC5jbGVhcigpO1xuICAgIHRoaXMubm9kZS5jbGVhcigpO1xuICAgIGNsZWFyKHRoaXMuZ3JhcGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBUcnVlIGlmIGdyYXBoIGlzIGEgbXVsdGlncmFwaCwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGdyYXBoIGlzIGEgbXVsdGlncmFwaCwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgaXNNdWx0aWdyYXBoKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gVHJ1ZSBpZiBncmFwaCBpcyBkaXJlY3RlZCwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiBncmFwaCBpcyBkaXJlY3RlZCwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgaXNEaXJlY3RlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBkaXJlY3RlZCBjb3B5IG9mIHRoZSBncmFwaC5cbiAgICpcbiAgICogTm90ZXM6XG4gICAqXG4gICAqICAgICAgVGhpcyByZXR1cm5zIGEgXCJkZWVwY29weVwiIG9mIHRoZSBlZGdlLCBub2RlLCBhbmRcbiAgICogICAgICBncmFwaCBhdHRyaWJ1dGVzIHdoaWNoIGF0dGVtcHRzIHRvIGNvbXBsZXRlbHkgY29weVxuICAgKiAgICAgIGFsbCBvZiB0aGUgZGF0YSBhbmQgcmVmZXJlbmNlcy5cbiAgICpcbiAgICogICAgICBUaGlzIGlzIGluIGNvbnRyYXN0IHRvIHRoZSBzaW1pbGFyIEQgPSBuZXcgRGlHcmFwaChHKSB3aGljaCByZXR1cm5zIGFcbiAgICogICAgICBzaGFsbG93IGNvcHkgb2YgdGhlIGRhdGEuXG4gICAqXG4gICAqIEByZXR1cm4geyFEaUdyYXBofSBBIGRlZXBjb3B5IG9mIHRoZSBncmFwaFxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgdG9EaXJlY3RlZCgpIHtcbiAgICByZXR1cm4gZGVlcGNvcHkodGhpcyk7XG4gIH1cblxuICAvKipcbiAgKiBSZXR1cm4gYW4gdW5kaXJlY3RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGlncmFwaC5cbiAgKlxuICAqIE5vdGVzOlxuICAqXG4gICogSWYgZWRnZXMgaW4gYm90aCBkaXJlY3Rpb25zICh1LHYpIGFuZCAodix1KSBleGlzdCBpbiB0aGVcbiAgKiBncmFwaCwgYXR0cmlidXRlcyBmb3IgdGhlIG5ldyB1bmRpcmVjdGVkIGVkZ2Ugd2lsbCBiZSBhIGNvbWJpbmF0aW9uIG9mXG4gICogdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGRpcmVjdGVkIGVkZ2VzLiAgVGhlIGVkZ2UgZGF0YSBpcyB1cGRhdGVkXG4gICogaW4gdGhlIChhcmJpdHJhcnkpIG9yZGVyIHRoYXQgdGhlIGVkZ2VzIGFyZSBlbmNvdW50ZXJlZC4gIEZvclxuICAqIG1vcmUgY3VzdG9taXplZCBjb250cm9sIG9mIHRoZSBlZGdlIGF0dHJpYnV0ZXMgdXNlIGFkZF9lZGdlKCkuXG4gICpcbiAgKiBUaGlzIHJldHVybnMgYSBcImRlZXBjb3B5XCIgb2YgdGhlIGVkZ2UsIG5vZGUsIGFuZFxuICAqIGdyYXBoIGF0dHJpYnV0ZXMgd2hpY2ggYXR0ZW1wdHMgdG8gY29tcGxldGVseSBjb3B5XG4gICogYWxsIG9mIHRoZSBkYXRhIGFuZCByZWZlcmVuY2VzLlxuICAqXG4gICogVGhpcyBpcyBpbiBjb250cmFzdCB0byB0aGUgc2ltaWxhciBHPURpR3JhcGgoRCkgd2hpY2ggcmV0dXJucyBhXG4gICogc2hhbGxvdyBjb3B5IG9mIHRoZSBkYXRhLlxuICAqXG4gICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JlY2lwcm9jYWxcbiAgKiAgICAgIElmIFRydWUgb25seSBrZWVwIGVkZ2VzIHRoYXQgYXBwZWFyIGluIGJvdGggZGlyZWN0aW9uc1xuICAqICAgICAgaW4gdGhlIG9yaWdpbmFsIGRpZ3JhcGguXG4gICpcbiAgKiBAcmV0dXJuIHshR3JhcGh9XG4gICogICAgICBBbiB1bmRpcmVjdGVkIGdyYXBoIHdpdGggdGhlIHNhbWUgbmFtZSBhbmQgbm9kZXMgYW5kXG4gICogICAgICB3aXRoIGVkZ2UgKHUsdixkYXRhKSBpZiBlaXRoZXIgKHUsdixkYXRhKSBvciAodix1LGRhdGEpXG4gICogICAgICBpcyBpbiB0aGUgZGlncmFwaC4gIElmIGJvdGggZWRnZXMgZXhpc3QgaW4gZGlncmFwaCBhbmRcbiAgKiAgICAgIHRoZWlyIGVkZ2UgZGF0YSBpcyBkaWZmZXJlbnQsIG9ubHkgb25lIGVkZ2UgaXMgY3JlYXRlZFxuICAqICAgICAgd2l0aCBhbiBhcmJpdHJhcnkgY2hvaWNlIG9mIHdoaWNoIGVkZ2UgZGF0YSB0byB1c2UuXG4gICogICAgICBZb3UgbXVzdCBjaGVjayBhbmQgY29ycmVjdCBmb3IgdGhpcyBtYW51YWxseSBpZiBkZXNpcmVkLlxuICAqXG4gICogQG92ZXJyaWRlXG4gICogQGV4cG9ydFxuICAqL1xuICB0b1VuZGlyZWN0ZWQob3B0UmVjaXByb2NhbCkge1xuICAgIHZhciBIID0gbmV3IEdyYXBoKCk7XG4gICAgSC5uYW1lID0gdGhpcy5uYW1lO1xuICAgIEguYWRkTm9kZXNGcm9tKHRoaXMpO1xuXG4gICAgdmFyIHRoaXNQcmVkID0gdGhpcy5wcmVkO1xuXG4gICAgaWYob3B0UmVjaXByb2NhbCkge1xuICAgICAgSC5hZGRFZGdlc0Zyb20oKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZURhdGEgb2YgdGhpcy5hZGphY2VuY3lJdGVyKCkpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVEYXRhWzBdO1xuICAgICAgICAgIHZhciBwcmVkZWNlc3NvcnMgPSB0aGlzUHJlZC5nZXQobm9kZSk7XG4gICAgICAgICAgZm9yICh2YXIgbmJyRGF0YSBvZiBub2RlRGF0YVsxXSkge1xuICAgICAgICAgICAgaWYgKHByZWRlY2Vzc29ycy5oYXMobmJyRGF0YVswXSkpIHtcbiAgICAgICAgICAgICAgeWllbGQgdHVwbGUzKG5vZGUsIG5ickRhdGFbMF0sIGRlZXBjb3B5KG5ickRhdGFbMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0uY2FsbCh0aGlzKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIEguYWRkRWRnZXNGcm9tKChmdW5jdGlvbiooKSB7XG4gICAgICAgIGZvciAodmFyIG5vZGVEYXRhIG9mIHRoaXMuYWRqYWNlbmN5SXRlcigpKSB7XG4gICAgICAgICAgZm9yICh2YXIgbmJyRGF0YSBvZiBub2RlRGF0YVsxXSkge1xuICAgICAgICAgICAgeWllbGQgdHVwbGUzKG5vZGVEYXRhWzBdLCBuYnJEYXRhWzBdLCBkZWVwY29weShuYnJEYXRhWzFdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LmNhbGwodGhpcykpKTtcbiAgICB9XG5cbiAgICBILmdyYXBoID0gZGVlcGNvcHkodGhpcy5ncmFwaCk7XG4gICAgSC5ub2RlID0gZGVlcGNvcHkodGhpcy5ub2RlKTtcbiAgICByZXR1cm4gSDtcbiAgfVxuXG4gIC8qKlxuICAqIFJldHVybiB0aGUgcmV2ZXJzZSBvZiB0aGUgZ3JhcGguXG4gICpcbiAgKiBUaGUgcmV2ZXJzZSBpcyBhIGdyYXBoIHdpdGggdGhlIHNhbWUgbm9kZXMgYW5kIGVkZ2VzXG4gICogYnV0IHdpdGggdGhlIGRpcmVjdGlvbnMgb2YgdGhlIGVkZ2VzIHJldmVyc2VkLlxuICAqXG4gICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2NvcHkgKGRlZmF1bHQ9VHJ1ZSlcbiAgKiAgICAgIElmIFRydWUsIHJldHVybiBhIG5ldyBEaUdyYXBoIGhvbGRpbmcgdGhlIHJldmVyc2VkIGVkZ2VzLlxuICAqICAgICAgSWYgRmFsc2UsIHJldmVyc2UgdGhlIHJldmVyc2UgZ3JhcGggaXMgY3JlYXRlZCB1c2luZ1xuICAqICAgICAgdGhlIG9yaWdpbmFsIGdyYXBoICh0aGlzIGNoYW5nZXMgdGhlIG9yaWdpbmFsIGdyYXBoKS5cbiAgKlxuICAqIEByZXR1cm4geyFEaUdyYXBofSBBIGNvcHkgb2YgdGhlIGdyYXBoIG9yIHRoZSBncmFwaCBpdHNlbGZcbiAgKlxuICAqIEBleHBvcnRcbiAgKi9cbiAgcmV2ZXJzZShvcHRDb3B5PXRydWUpIHtcbiAgICB2YXIgSDtcbiAgICBpZihvcHRDb3B5KSB7XG4gICAgICBIID0gbmV3IHRoaXMuY29uc3RydWN0b3IobnVsbCwge25hbWU6ICdSZXZlcnNlIG9mICgnICsgdGhpcy5uYW1lICsgJyknfSk7XG4gICAgICBILmFkZE5vZGVzRnJvbSh0aGlzKTtcbiAgICAgIEguYWRkRWRnZXNGcm9tKG1hcEl0ZXJhdG9yKFxuICAgICAgICB0aGlzLmVkZ2VzSXRlcihudWxsLCB0cnVlKSxcbiAgICAgICAgZWRnZSA9PiB0dXBsZTNjKGVkZ2VbMV0sIGVkZ2VbMF0sIGRlZXBjb3B5KGVkZ2VbMl0pLCBlZGdlKVxuICAgICAgKSk7XG4gICAgICBILmdyYXBoID0gZGVlcGNvcHkodGhpcy5ncmFwaCk7XG4gICAgICBILm5vZGUgPSBkZWVwY29weSh0aGlzLm5vZGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciB0aGlzUHJlZCA9IHRoaXMucHJlZDtcbiAgICAgIHZhciB0aGlzU3VjYyA9IHRoaXMuc3VjYztcblxuICAgICAgdGhpcy5zdWNjID0gdGhpc1ByZWQ7XG4gICAgICB0aGlzLnByZWQgPSB0aGlzU3VjYztcbiAgICAgIHRoaXMuYWRqID0gdGhpcy5zdWNjO1xuICAgICAgSCA9IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBIO1xuICB9XG5cbiAgLyoqXG4gICogUmV0dXJuIHRoZSBzdWJncmFwaCBpbmR1Y2VkIG9uIG5vZGVzIGluIG5idW5jaC5cbiAgKlxuICAqIFRoZSBpbmR1Y2VkIHN1YmdyYXBoIG9mIHRoZSBncmFwaCBjb250YWlucyB0aGUgbm9kZXMgaW4gbmJ1bmNoXG4gICogYW5kIHRoZSBlZGdlcyBiZXR3ZWVuIHRob3NlIG5vZGVzLlxuICAqXG4gICogTm90ZXM6XG4gICpcbiAgKiBUaGUgZ3JhcGgsIGVkZ2Ugb3Igbm9kZSBhdHRyaWJ1dGVzIGp1c3QgcG9pbnQgdG8gdGhlIG9yaWdpbmFsIGdyYXBoLlxuICAqIFNvIGNoYW5nZXMgdG8gdGhlIG5vZGUgb3IgZWRnZSBzdHJ1Y3R1cmUgd2lsbCBub3QgYmUgcmVmbGVjdGVkIGluXG4gICogdGhlIG9yaWdpbmFsIGdyYXBoIHdoaWxlIGNoYW5nZXMgdG8gdGhlIGF0dHJpYnV0ZXMgd2lsbC5cbiAgKlxuICAqIFRvIGNyZWF0ZSBhIHN1YmdyYXBoIHdpdGggaXRzIG93biBjb3B5IG9mIHRoZSBlZGdlL25vZGUgYXR0cmlidXRlcyB1c2U6XG4gICogbnguR3JhcGgoRy5zdWJncmFwaChuYnVuY2gpKVxuICAqXG4gICogSWYgZWRnZSBhdHRyaWJ1dGVzIGFyZSBjb250YWluZXJzLCBhIGRlZXAgY29weSBjYW4gYmUgb2J0YWluZWQgdXNpbmc6XG4gICogRy5zdWJncmFwaChuYnVuY2gpLmNvcHkoKVxuICAqXG4gICogRm9yIGFuIGlucGxhY2UgcmVkdWN0aW9uIG9mIGEgZ3JhcGggdG8gYSBzdWJncmFwaCB5b3UgY2FuIHJlbW92ZSBub2RlczpcbiAgKiBHLnJlbW92ZV9ub2Rlc19mcm9tKFsgbiBpbiBHIGlmIG4gbm90IGluIHNldChuYnVuY2gpXSlcbiAgKlxuICAqIEBwYXJhbSB7Tm9kZUNvbnRhaW5lcn0gbmJ1bmNoXG4gICogICAgICBBIGNvbnRhaW5lciBvZiBub2RlcyB3aGljaCB3aWxsIGJlIGl0ZXJhdGVkIHRocm91Z2ggb25jZS5cbiAgKlxuICAqIEByZXR1cm4ge0RpR3JhcGh9IEEgc3ViZ3JhcGggb2YgdGhlIGdyYXBoIHdpdGggdGhlIHNhbWUgZWRnZVxuICAqICAgYXR0cmlidXRlcy5cbiAgKlxuICAqXG4gICogQG92ZXJyaWRlXG4gICogQGV4cG9ydFxuICAqL1xuICBzdWJncmFwaChuYnVuY2gpIHtcbiAgICB2YXIgYnVuY2ggPSB0aGlzLm5idW5jaEl0ZXIobmJ1bmNoKTtcbiAgICB2YXIgbjtcbiAgICAvLyBjcmVhdGUgbmV3IGdyYXBoIGFuZCBjb3B5IHN1YmdyYXBoIGludG8gaXRcbiAgICB2YXIgSCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgLy8gY29weSBub2RlIGFuZCBhdHRyaWJ1dGUgZGljdGlvbmFyaWVzXG4gICAgZm9yIChuIG9mIGJ1bmNoKSB7XG4gICAgICBILm5vZGUuc2V0KG4sIHRoaXMubm9kZS5nZXQobikpO1xuICAgIH1cbiAgICAvLyBuYW1lc3BhY2Ugc2hvcnRjdXRzIGZvciBzcGVlZFxuICAgIHZhciBIU3VjYyA9IEguc3VjYztcbiAgICB2YXIgSFByZWQgPSBILnByZWQ7XG5cbiAgICAvLyBhZGQgbm9kZXNcbiAgICBmb3IgKG4gb2YgSCkge1xuICAgICAgSFN1Y2Muc2V0KG4sIG5ldyBNYXAoKSk7XG4gICAgICBIUHJlZC5zZXQobiwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgLy8gYWRkIGVkZ2VzXG4gICAgZm9yICh2YXIgdW5icnMgb2YgSFN1Y2MpIHtcbiAgICAgIHZhciBbdSwgSG5icnNdID0gdW5icnM7XG4gICAgICBmb3IgKHZhciB2ZGF0YWRkaWN0IG9mIHRoaXMuc3VjYy5nZXQodSkpIHtcbiAgICAgICAgdmFyIFt2LCBkYXRhZGljdF0gPSB2ZGF0YWRkaWN0O1xuICAgICAgICBpZiAoSFN1Y2MuaGFzKHYpKSB7XG4gICAgICAgICAgLy8gYWRkIGJvdGggcmVwcmVzZW50YXRpb25zIG9mIGVkZ2U6IHUtdiBhbmQgdi11XG4gICAgICAgICAgSG5icnMuc2V0KHYsIGRhdGFkaWN0KTtcbiAgICAgICAgICBIUHJlZC5nZXQodikuc2V0KHUsIGRhdGFkaWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBILmdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICByZXR1cm4gSDtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBLZXlFcnJvciBmcm9tICcuLi9leGNlcHRpb25zL0tleUVycm9yJztcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbmltcG9ydCBNYXAgZnJvbSAnLi4vX2ludGVybmFscy9NYXAnO1xuaW1wb3J0IFNldCBmcm9tICcuLi9faW50ZXJuYWxzL1NldCc7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuaW1wb3J0IEpTTmV0d29ya1hFcnJvciBmcm9tICcuLi9leGNlcHRpb25zL0pTTmV0d29ya1hFcnJvcic7XG5cbmltcG9ydCBpc0Jvb2xlYW4gZnJvbSAnbG9kYXNoL2xhbmcvaXNCb29sZWFuJztcbmltcG9ydCBpc1N0cmluZyBmcm9tICdsb2Rhc2gvbGFuZy9pc1N0cmluZyc7XG5cbmltcG9ydCBjb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuaW1wb3J0IHtcbiAgY2xlYXIsXG4gIGNsb25lLFxuICBkZWVwY29weSxcbiAgZm9yRWFjaCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgbWFwSXRlcmF0b3IsXG4gIG1hcFNlcXVlbmNlLFxuICB0b0l0ZXJhdG9yLFxuICBzcHJpbnRmLFxuICB0dXBsZTIsXG4gIHR1cGxlMmMsXG4gIHR1cGxlMyxcbiAgdHVwbGUzYyxcbiAgemlwU2VxdWVuY2Vcbn0gZnJvbSAnLi4vX2ludGVybmFscyc7XG5cblxuXG4vKmpzaGludCBleHByOmZhbHNlKi9cblxuLypcbiAqIEJhc2UgY2xhc3MgZm9yIHVuZGlyZWN0ZWQgZ3JhcGhzLlxuICpcbiAqIEEgR3JhcGggc3RvcmVzIG5vZGVzIGFuZCBlZGdlcyB3aXRoIG9wdGlvbmFsIGRhdGEsIG9yIGF0dHJpYnV0ZXMuXG4gKlxuICogR3JhcGhzIGhvbGQgdW5kaXJlY3RlZCBlZGdlcy4gIFNlbGYgbG9vcHMgYXJlIGFsbG93ZWQgYnV0IG11bHRpcGxlXG4gKiAocGFyYWxsZWwpIGVkZ2VzIGFyZSBub3QuXG4gKlxuICogTm9kZXMgY2FuIGJlIGFyYml0cmFyeSAoaGFzaGFibGUpIFB5dGhvbiBvYmplY3RzIHdpdGggb3B0aW9uYWxcbiAqIGtleS92YWx1ZSBhdHRyaWJ1dGVzLlxuICpcbiAqIEVkZ2VzIGFyZSByZXByZXNlbnRlZCBhcyBsaW5rcyBiZXR3ZWVuIG5vZGVzIHdpdGggb3B0aW9uYWxcbiAqIGtleS92YWx1ZSBhdHRyaWJ1dGVzLlxuICpcbiAqIFNlZSBBbHNvXG4gKiAtLS0tLS0tLVxuICogRGlHcmFwaFxuICogTXVsdGlHcmFwaFxuICogTXVsdGlEaUdyYXBoXG4gKlxuICogQHBhcmFtIHsqPX0gb3B0X2RhdGEgRGF0YSB0byBpbml0aWFsaXplIGdyYXBoLiAgSWYgZGF0YT1Ob25lIChkZWZhdWx0KSBhblxuICogICAgICAgZW1wdHkgZ3JhcGggaXMgY3JlYXRlZC4gVGhlIGRhdGEgY2FuIGJlIGFuIGVkZ2UgbGlzdCwgb3IgYW55XG4gKiAgICAgICBOZXR3b3JrWCBncmFwaCBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9hdHRyIChkZWZhdWx0PSBubyBhdHRyaWJ1dGVzKVxuICogICAgICAgQXR0cmlidXRlcyB0byBhZGQgdG8gZ3JhcGggYXMga2V5PXZhbHVlIHBhaXJzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaCB7XG5cbiAgY29uc3RydWN0b3Iob3B0RGF0YSwgb3B0QXR0cikge1xuICAgIC8vIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNhbGwgR3JhcGggd2l0aG91dCBuZXdcbiAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBHcmFwaCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHcmFwaChvcHREYXRhLCBvcHRBdHRyKTtcbiAgICB9XG5cbiAgICB0aGlzLmdyYXBoID0ge307IC8vIGRpY3Rpb25hcnkgZm9yIGdyYXBoIGF0dHJpYnV0ZXNcbiAgICB0aGlzLm5vZGUgPSBuZXcgTWFwKCk7IC8vIGVtcHR5IG5vZGUgZGljdCAoY3JlYXRlZCBiZWZvcmUgY29udmVydClcbiAgICB0aGlzLmFkaiA9IG5ldyBNYXAoKTsgLy8gZW1wdHkgYWRqYWNlbmN5IGRpY3RcblxuICAgIC8vIGF0dGVtcHQgdG8gbG9hZCBncmFwaCB3aXRoIGRhdGFcbiAgICBpZiAob3B0RGF0YSAhPSBudWxsKSB7XG4gICAgICBjb252ZXJ0LnRvTmV0d29ya3hHcmFwaChvcHREYXRhLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBsb2FkIGdyYXBoIGF0dHJpYnV0ZXMgKG11c3QgYmUgYWZ0ZXIgY29udmVydClcbiAgICBpZiAob3B0QXR0cikge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmdyYXBoLCBvcHRBdHRyKTtcbiAgICB9XG4gICAgdGhpcy5lZGdlID0gdGhpcy5hZGo7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBIb2xkcyB0aGUgZ3JhcGggdHlwZSAoY2xhc3MpIG5hbWUgZm9yIGluZm9ybWF0aW9uLlxuICAgKiBUaGlzIGlzIGNvbXBhdGlibGUgdG8gUHl0aG9ucyBfX25hbWVfXyBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgX19uYW1lX18oKSB7XG4gICAgcmV0dXJuICdHcmFwaCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBuYW1lIG9mIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbmFtZSBHcmFwaCBuYW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoc3RyaW5nfHVuZGVmaW5lZCl9IEdyYXBoIG5hbWUgaWYgbm8gcGFyYW1ldGVyIHdhcyBwYXNzZWQuXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdyYXBoLm5hbWUgfHwgJyc7XG4gIH1cblxuICBzZXQgbmFtZShuYW1lKSB7XG4gICAgdGhpcy5ncmFwaC5uYW1lID0gbmFtZTtcbiAgfVxuXG4gIC8vIEltcGxlbWVudHMgX19zdHJfX1xuICAvKipcbiAgICogUmV0dXJuIHRoZSBncmFwaCBuYW1lXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gR3JhcGggbmFtZS5cbiAgICogQGV4cG9ydFxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG5cblxuICAvKiBmb3IgY29udmVuaWVuY2UgKi9cbiAgZm9yRWFjaChjYWxsYmFjaywgb3B0VGhpc1ZhbHVlKSB7XG4gICAgZm9yICh2YXIgbiBvZiB0aGlzLmFkai5rZXlzKCkpIHtcbiAgICAgIGlmIChvcHRUaGlzVmFsdWUpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChvcHRUaGlzVmFsdWUsIG4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIF9fY29udGFpbnNfXyBpcyBub3Qgc3VwcG9ydGVkLCBoYXNfbm9kZSBoYXMgdG8gYmUgdXNlZFxuXG5cbiAgLy8gX19sZW5fXyBpcyBub3Qgc3VwcG9ydGVkLCBudW1iZXJfb2Zfbm9kZXMgb3Igb3JkZXIgaGFzIHRvIGJlIHVzZWRcblxuXG4gIC8vIEltcGxlbWVudHMgX19nZXRpdGVtX19cbiAgLyoqXG4gICAqIFJldHVybiBhIGRpY3Qgb2YgbmVpZ2hib3JzIG9mIG5vZGUgbi5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBuICBBIG5vZGUgaW4gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcmV0dXJuIHshTWFwfSBUaGUgYWRqYWNlbmN5IGRpY3Rpb25hcnkgZm9yIG5vZGVzXG4gICAqICAgY29ubmVjdGVkIHRvIG4uXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGdldChuKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5hZGouZ2V0KG4pO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgS2V5RXJyb3IoJ0dyYXBoIGRvZXMgbm90IGNvbnRhaW4gbm9kZSAnICsgbiArICcuJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBub2RlIG4gYW5kIHVwZGF0ZSBub2RlIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIFNpbmNlIEphdmFTY3JpcHQgZG9lcyBub3QgcHJvdmlkZSBrZXl3b3JkIGFyZ3VtZW50cyxcbiAgICogYWxsIGF0dHJpYnV0ZXMgbXVzdCBiZSBwYXNzZWQgaW4gYW4gb2JqZWN0IGFzIHNlY29uZFxuICAgKiBhcmd1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHshTm9kZX0gbiBBIG5vZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2F0dHJfZGljdCBEaWN0aW9uYXJ5IG9mIG5vZGUgYXR0cmlidXRlcy5cbiAgICogICAgICBLZXkvdmFsdWUgcGFpcnMgd2lsbCB1cGRhdGUgZXhpc3RpbmcgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGUuXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGFkZE5vZGUobiwgb3B0QXR0ckRpY3Q9e30pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qob3B0QXR0ckRpY3QpKSB7XG4gICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKCdUaGUgYXR0cl9kaWN0IGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5ub2RlLmhhcyhuKSkge1xuICAgICAgdGhpcy5hZGouc2V0KG4sIG5ldyBNYXAoKSk7XG4gICAgICB0aGlzLm5vZGUuc2V0KG4sIG9wdEF0dHJEaWN0KTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIHVwZGF0ZSBhdHRyIGV2ZW4gaWYgbm9kZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm5vZGUuZ2V0KG4pLCBvcHRBdHRyRGljdCk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQWRkIG11bHRpcGxlIG5vZGVzLlxuICAgKlxuICAgKiBTaW5jZSBKYXZhU2NyaXB0IGRvZXMgbm90IHByb3ZpZGUga2V5d29yZCBhcmd1bWVudHMsXG4gICAqIGFsbCBhdHRyaWJ1dGVzIG11c3QgYmUgcGFzc2VkIGluIGFuIG9iamVjdCBhcyBzZWNvbmRcbiAgICogYXJndW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7IU5vZGVDb250YWluZXJ9IG5vZGVzXG4gICAqICAgICAgIEEgY29udGFpbmVyIG9mIG5vZGVzIChBcnJheSwgT2JqZWN0LCBBcnJheS1saWtlKS5cbiAgICogICAgICAgT1JcbiAgICogICAgICAgQSBjb250YWluZXIgb2YgKG5vZGUsIGF0dHJpYnV0ZSBkaWN0KSB0dXBsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2F0dHIgIFVwZGF0ZSBhdHRyaWJ1dGVzIGZvciBhbGwgbm9kZXMgaW4gbm9kZXMuXG4gICAqICAgICAgIE5vZGUgYXR0cmlidXRlcyBzcGVjaWZpZWQgaW4gbm9kZXMgYXMgYSB0dXBsZVxuICAgKiAgICAgICB0YWtlIHByZWNlZGVuY2Ugb3ZlciBhdHRyaWJ1dGVzIHNwZWNpZmllZCBnZW5lcmFsbHkuXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGFkZE5vZGVzRnJvbShub2Rlcywgb3B0QXR0cj17fSkge1xuICAgIGZvckVhY2gobm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpICYmIG5vZGUubGVuZ3RoID09PSAyICYmIGlzUGxhaW5PYmplY3Qobm9kZVsxXSkpIHtcbiAgICAgICAgdmFyIFtubiwgbmRpY3RdID0gbm9kZTtcblxuICAgICAgICBpZiAoIXRoaXMuYWRqLmhhcyhubikpIHtcbiAgICAgICAgICB0aGlzLmFkai5zZXQobm4sIG5ldyBNYXAoKSk7XG4gICAgICAgICAgdmFyIG5ld2RpY3QgPSBjbG9uZShvcHRBdHRyKTtcbiAgICAgICAgICB0aGlzLm5vZGUuc2V0KG5uLCBPYmplY3QuYXNzaWduKG5ld2RpY3QsIG5kaWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG9sZGRpY3QgPSB0aGlzLm5vZGUuZ2V0KG5uKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG9sZGRpY3QsIG9wdEF0dHIsIG5kaWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47IC8vIGNvbnRpbnVlIG5leHQgaXRlcmF0aW9uXG4gICAgICB9XG4gICAgICB2YXIgbmV3bm9kZSA9ICF0aGlzLm5vZGUuaGFzKG5vZGUpO1xuICAgICAgaWYgKG5ld25vZGUpIHtcbiAgICAgICAgdGhpcy5hZGouc2V0KG5vZGUsIG5ldyBNYXAoKSk7XG4gICAgICAgIHRoaXMubm9kZS5zZXQobm9kZSwgY2xvbmUob3B0QXR0cikpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5ub2RlLmdldChub2RlKSwgb3B0QXR0cik7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZW1vdmUgbm9kZSBuLlxuICAgKlxuICAgKiBSZW1vdmVzIHRoZSBub2RlIG4gYW5kIGFsbCBhZGphY2VudCBlZGdlcy5cbiAgICogQXR0ZW1wdGluZyB0byByZW1vdmUgYSBub24tZXhpc3RlbnQgbm9kZSB3aWxsIHJhaXNlIGFuIGV4Y2VwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBuIEEgbm9kZSBpbiB0aGUgZ3JhcGguXG4gICAqIEBleHBvcnRcbiAgICovXG4gIHJlbW92ZU5vZGUobikge1xuICAgIHZhciBhZGogPSB0aGlzLmFkajtcblxuICAgIGlmICh0aGlzLm5vZGUuZGVsZXRlKG4pKSB7XG4gICAgICBhZGouZ2V0KG4pLmZvckVhY2goXG4gICAgICAgIChfLCB1KSA9PiBhZGouZ2V0KHUpLmRlbGV0ZShuKSAvLyByZW1vdmUgYWxsIGVkZ2VzIG4tdSBpbiBncmFwaFxuICAgICAgKTtcbiAgICAgIGFkai5kZWxldGUobik7IC8vIG5vdyByZW1vdmUgbm9kZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBKU05ldHdvcmtYRXJyb3IoJ1RoZSBub2RlICVzIGlzIG5vdCBpbiB0aGUgZ3JhcGgnLCBuKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZW1vdmUgbXVsdGlwbGUgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZUNvbnRhaW5lcn0gbm9kZXMgQSBjb250YWluZXIgb2Ygbm9kZXNcbiAgICogICAgICBJZiBhIG5vZGUgaW4gdGhlIGNvbnRhaW5lciBpcyBub3QgaW4gdGhlIGdyYXBoIGl0IGlzIHNpbGVudGx5IGlnbm9yZWQuXG4gICAqXG4gICAqIEBleHBvcnRcbiAgICovXG4gIHJlbW92ZU5vZGVzRnJvbShub2Rlcykge1xuICAgIHZhciBhZGogPSB0aGlzLmFkajtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcblxuICAgIGZvckVhY2gobm9kZXMsIGZ1bmN0aW9uKG4pIHtcbiAgICAgIGlmIChub2RlLmRlbGV0ZShuKSkge1xuICAgICAgICBhZGouZ2V0KG4pLmZvckVhY2goKF8sIHUpID0+IGFkai5nZXQodSkuZGVsZXRlKG4pKTtcbiAgICAgICAgYWRqLmRlbGV0ZShuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpdGVyYXRvciBvdmVyIHRoZSBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2RhdGEgKGRlZmF1bHQgZmFsc2UpIElmIGZhbHNlIHRoZSBpdGVyYXRvciByZXR1cm5zXG4gICAqICAgbm9kZXMuIElmIHRydWUgcmV0dXJuIGEgdHdvLXR1cGxlIG9mIG5vZGUgYW5kIG5vZGUgZGF0YSBkaWN0aW9uYXJ5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYXRvcn0gb2Ygbm9kZXMgSWYgZGF0YT10cnVlIHRoZSBpdGVyYXRvciBnaXZlc1xuICAgKiAgICAgICAgICAgdHdvLXR1cGxlcyBjb250YWluaW5nIChub2RlLCBub2RlIGRhdGEsIGRpY3Rpb25hcnkpLlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBub2Rlc0l0ZXIob3B0RGF0YSkge1xuICAgIGlmIChvcHREYXRhKSB7XG4gICAgICByZXR1cm4gdG9JdGVyYXRvcih0aGlzLm5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ub2RlLmtleXMoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGxpc3Qgb2YgdGhlIG5vZGVzIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2RhdGEgKGRlZmF1bHQgZmFsc2UpIElmIGZhbHNlIHRoZSBpdGVyYXRvciByZXR1cm5zXG4gICAqICAgbm9kZXMuIElmIHRydWUgcmV0dXJuIGEgdHdvLXR1cGxlIG9mIG5vZGUgYW5kIG5vZGUgZGF0YSBkaWN0aW9uYXJ5LlxuICAgKlxuICAgKiBAcmV0dXJuIHshQXJyYXl9IG9mIG5vZGVzIElmIGRhdGE9dHJ1ZSBhIGxpc3Qgb2YgdHdvLXR1cGxlcyBjb250YWluaW5nXG4gICAqICAgICAgICAgICAobm9kZSwgbm9kZSBkYXRhIGRpY3Rpb25hcnkpLlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBub2RlcyhvcHREYXRhKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ob3B0RGF0YSA/IHRoaXMubm9kZS5lbnRyaWVzKCkgOiB0aGlzLm5vZGUua2V5cygpKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBncmFwaC5cbiAgICogQGV4cG9ydFxuICAgKi9cbiAgbnVtYmVyT2ZOb2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLnNpemU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBub2RlcyBpbiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBub2RlcyBpbiB0aGUgZ3JhcGguXG4gICAqIEBleHBvcnRcbiAgICovXG4gIG9yZGVyKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuc2l6ZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSBncmFwaCBjb250YWlucyB0aGUgbm9kZSBuLlxuICAgKlxuICAgKiBAcGFyYW0geyEoTm9kZXxOb2RlQ29udGFpbmVyKX0gbiBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBoYXNOb2RlKG4pIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLmhhcyhuKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFkZCBhbiBlZGdlIGJldHdlZW4gdSBhbmQgdi5cbiAgICpcbiAgICogVGhlIG5vZGVzIHUgYW5kIHYgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGlmIHRoZXkgYXJlXG4gICAqIG5vdCBhbHJlYWR5IGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogRWRnZSBhdHRyaWJ1dGVzIGNhbiBiZSBzcGVjaWZpZWQgYnkgcHJvdmlkaW5nXG4gICAqIGEgZGljdGlvbmFyeSB3aXRoIGtleS92YWx1ZSBwYWlycy5cbiAgICpcbiAgICogVW5saWtlIGluIFB5dGhvbiwgYXR0cmlidXRlcyBjYW4gb25seSBiZSBkZWZpbmVkXG4gICAqIHZpYSB0aGUgZGljdGlvbmFyeS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB1IE5vZGUuXG4gICAqIEBwYXJhbSB7Tm9kZX0gdiBOb2RlLlxuICAgKiBAcGFyYW0gez9PYmplY3Q9fSBvcHRfYXR0cl9kaWN0IERpY3Rpb25hcnkgb2YgZWRnZSBhdHRyaWJ1dGVzLlxuICAgKiAgICAgIEtleS92YWx1ZSBwYWlycyB3aWxsIHVwZGF0ZSBleGlzdGluZyBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWRnZS5cbiAgICpcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgYWRkRWRnZSh1LCB2LCBvcHRBdHRyRGljdCkge1xuICAgIGlmIChvcHRBdHRyRGljdCAmJiAhaXNQbGFpbk9iamVjdChvcHRBdHRyRGljdCkpIHtcbiAgICAgIHRocm93IG5ldyBKU05ldHdvcmtYRXJyb3IoJ1RoZSBhdHRyX2RpY3QgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgLy8gYWRkIG5vZGVzXG4gICAgaWYgKCF0aGlzLm5vZGUuaGFzKHUpKSB7XG4gICAgICB0aGlzLmFkai5zZXQodSwgbmV3IE1hcCgpKTtcbiAgICAgIHRoaXMubm9kZS5zZXQodSwge30pO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubm9kZS5oYXModikpIHtcbiAgICAgIHRoaXMuYWRqLnNldCh2LCBuZXcgTWFwKCkpO1xuICAgICAgdGhpcy5ub2RlLnNldCh2LCB7fSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHRoZSBlZGdlXG4gICAgdmFyIGRhdGFkaWN0ID0gdGhpcy5hZGouZ2V0KHUpLmdldCh2KSB8fCB7fTtcbiAgICBPYmplY3QuYXNzaWduKGRhdGFkaWN0LCBvcHRBdHRyRGljdCk7XG4gICAgdGhpcy5hZGouZ2V0KHUpLnNldCh2LCBkYXRhZGljdCk7XG4gICAgdGhpcy5hZGouZ2V0KHYpLnNldCh1LCBkYXRhZGljdCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBZGQgYWxsIHRoZSBlZGdlcyBpbiBlYnVuY2guXG4gICAqXG4gICAqIEFkZGluZyB0aGUgc2FtZSBlZGdlIHR3aWNlIGhhcyBubyBlZmZlY3QgYnV0IGFueSBlZGdlIGRhdGFcbiAgICogd2lsbCBiZSB1cGRhdGVkIHdoZW4gZWFjaCBkdXBsaWNhdGUgZWRnZSBpcyBhZGRlZC5cbiAgICpcbiAgICogRWRnZSBhdHRyaWJ1dGVzIHNwZWNpZmllZCBpbiBlZGdlcyBhcyBhIHR1cGxlIHRha2UgcHJlY2VkZW5jZVxuICAgKiBvdmVyIGF0dHJpYnV0ZXMgc3BlY2lmaWVkIGdlbmVyYWxseS5cbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZX0gZWJ1bmNoIGNvbnRhaW5lciBvZiBlZGdlc1xuICAgKiAgICAgIEVhY2ggZWRnZSBnaXZlbiBpbiB0aGUgY29udGFpbmVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4gICAqICAgICAgZ3JhcGguIFRoZSBlZGdlcyBtdXN0IGJlIGdpdmVuIGFzIGFzIDItdHVwbGVzICh1LHYpIG9yXG4gICAqICAgICAgMy10dXBsZXMgKHUsdixkKSB3aGVyZSBkIGlzIGEgZGljdGlvbmFyeSBjb250YWluaW5nIGVkZ2VcbiAgICogICAgICBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdF9hdHRyX2RpY3RcbiAgICogICAgIERpY3Rpb25hcnkgb2YgZWRnZSBhdHRyaWJ1dGVzLiAgS2V5L3ZhbHVlIHBhaXJzIHdpbGxcbiAgICogICAgIHVwZGF0ZSBleGlzdGluZyBkYXRhIGFzc29jaWF0ZWQgd2l0aCBlYWNoIGVkZ2UuXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGFkZEVkZ2VzRnJvbShlYnVuY2gsIG9wdEF0dHJEaWN0KSB7XG4gICAgaWYgKG9wdEF0dHJEaWN0ICYmICFpc1BsYWluT2JqZWN0KG9wdEF0dHJEaWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcignVGhlIGF0dHJfZGljdCBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICAvLyBwcm9jZXNzIGVidW5jaFxuICAgIGZvciAodmFyIHR1cGxlIG9mIGVidW5jaCkge1xuICAgICAgaWYgKHR1cGxlLmxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBKU05ldHdvcmtYRXJyb3IoXG4gICAgICAgICAgc3ByaW50ZignRWRnZSB0dXBsZSAlaiBtdXN0IGJlIGEgMi10dXBsZSBvciAzLXR1cGxlLicsIHR1cGxlKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgW3UsIHYsIGRhdGFdID0gdHVwbGU7XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKHUgPT0gbnVsbCB8fCB2ID09IG51bGwgfHwgdHVwbGVbM10gIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKHNwcmludGYoXG4gICAgICAgICAgJ0VkZ2UgdHVwbGUgJWogbXVzdCBiZSBhIDItdHVwbGUgb3IgMy10dXBsZS4nLFxuICAgICAgICAgIHR1cGxlXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMubm9kZS5oYXModSkpIHtcbiAgICAgICAgdGhpcy5hZGouc2V0KHUsIG5ldyBNYXAoKSk7XG4gICAgICAgIHRoaXMubm9kZS5zZXQodSwge30pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm5vZGUuaGFzKHYpKSB7XG4gICAgICAgIHRoaXMuYWRqLnNldCh2LCBuZXcgTWFwKCkpO1xuICAgICAgICB0aGlzLm5vZGUuc2V0KHYsIHt9KTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRoZSBlZGdlXG4gICAgICB2YXIgZGF0YWRpY3QgPSB0aGlzLmFkai5nZXQodSkuZ2V0KHYpIHx8IHt9O1xuICAgICAgT2JqZWN0LmFzc2lnbihkYXRhZGljdCwgb3B0QXR0ckRpY3QsIGRhdGEpO1xuICAgICAgdGhpcy5hZGouZ2V0KHUpLnNldCh2LCBkYXRhZGljdCk7XG4gICAgICB0aGlzLmFkai5nZXQodikuc2V0KHUsIGRhdGFkaWN0KTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBZGQgYWxsIHRoZSBlZGdlcyBpbiBlYnVuY2ggYXMgd2VpZ2h0ZWQgZWRnZXMgd2l0aCBzcGVjaWZpZWQgd2VpZ2h0cy5cbiAgICpcbiAgICpcbiAgICogQWRkaW5nIHRoZSBzYW1lIGVkZ2UgdHdpY2UgZm9yIEdyYXBoL0RpR3JhcGggc2ltcGx5IHVwZGF0ZXNcbiAgICogdGhlIGVkZ2UgZGF0YS4gIEZvciBNdWx0aUdyYXBoL011bHRpRGlHcmFwaCwgZHVwbGljYXRlIGVkZ2VzXG4gICAqIGFyZSBzdG9yZWQuXG4gICAqXG4gICAqIFNpbmNlIEphdmFTY3JpcHQgZG9lcyBub3Qgc3VwcG9ydCBrZXl3b3JkIGFyZ3VtZW50cywgYWxsIGF0dHJpYnV0ZXNcbiAgICogbXVzdCBiZSBwYXNzZWQgaW4gdGhlIGF0dHIgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gez99IGVidW5jaCAgY29udGFpbmVyIG9mIGVkZ2VzXG4gICAqICAgICAgRWFjaCBlZGdlIGdpdmVuIGluIHRoZSBsaXN0IG9yIGNvbnRhaW5lciB3aWxsIGJlIGFkZGVkXG4gICAqICAgICAgdG8gdGhlIGdyYXBoLiBUaGUgZWRnZXMgbXVzdCBiZSBnaXZlbiBhcyAzLXR1cGxlcyAodSx2LHcpXG4gICAqICAgICAgd2hlcmUgdyBpcyBhIG51bWJlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfd2VpZ2h0IChkZWZhdWx0ICd3ZWlnaHQnKVxuICAgKiAgICAgIFRoZSBhdHRyaWJ1dGUgbmFtZSBmb3IgdGhlIGVkZ2Ugd2VpZ2h0cyB0byBiZSBhZGRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfYXR0ciBFZGdlIGF0dHJpYnV0ZXMgdG8gYWRkL3VwZGF0ZSBmb3IgYWxsIGVkZ2VzLlxuICAgKlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBhZGRXZWlnaHRlZEVkZ2VzRnJvbShlYnVuY2gsIG9wdFdlaWdodCwgb3B0QXR0cikge1xuICAgIG9wdEF0dHIgPSBvcHRBdHRyIHx8IHt9O1xuICAgIGlmICghaXNTdHJpbmcob3B0V2VpZ2h0KSkge1xuICAgICAgb3B0QXR0ciA9IG9wdFdlaWdodDtcbiAgICAgIG9wdFdlaWdodCA9ICd3ZWlnaHQnO1xuICAgIH1cblxuICAgIHRoaXMuYWRkRWRnZXNGcm9tKG1hcFNlcXVlbmNlKGVidW5jaCwgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgIGF0dHJbb3B0V2VpZ2h0XSA9IGVbMl07XG4gICAgICBpZiAoYXR0cltvcHRXZWlnaHRdID09IG51bGwpIHsgLy8gc2ltdWxhdGUgdG9vIGZldyB2YWx1ZSB0byB1bnBhY2sgZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWVzIG11c3QgY29uc2lzdCBvZiB0aHJlZSBlbGVtZW50czogJXMuJywgZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2VbMF0sIGVbMV0sIGF0dHJdO1xuICAgIH0pLCBvcHRBdHRyKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZWRnZSBiZXR3ZWVuIHUgYW5kIHYuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdSBOb2RlLlxuICAgKiBAcGFyYW0ge05vZGV9IHYgTm9kZS5cbiAgICpcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgcmVtb3ZlRWRnZSh1LCB2KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLmFkai5nZXQodSk7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWxldGUodik7XG4gICAgICAvLyBzZWxmLWxvb3AgbmVlZHMgb25seSBvbmUgZW50cnkgcmVtb3ZlZFxuICAgICAgdmFyIHZub2RlID0gdGhpcy5hZGouZ2V0KHYpO1xuICAgICAgaWYgKHZub2RlICE9PSBub2RlKSB7XG4gICAgICAgIHZub2RlLmRlbGV0ZSh1KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKCdUaGUgZWRnZSAlcy0lcyBpcyBub3QgaW4gdGhlIGdyYXBoJywgdSwgdik7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBlZGdlcyBzcGVjaWZpZWQgaW4gZWJ1bmNoLlxuICAgKlxuICAgKiBOb3RlczogV2lsbCBmYWlsIHNpbGVudGx5IGlmIGFuIGVkZ2UgaW4gZWJ1bmNoIGlzIG5vdCBpbiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSB7P30gZWJ1bmNoIDFsaXN0IG9yIGNvbnRhaW5lciBvZiBlZGdlIHR1cGxlc1xuICAgKiAgICAgIEVhY2ggZWRnZSBnaXZlbiBpbiB0aGUgbGlzdCBvciBjb250YWluZXIgd2lsbCBiZSByZW1vdmVkXG4gICAqICAgICAgZnJvbSB0aGUgZ3JhcGguIFRoZSBlZGdlcyBjYW4gYmU6XG4gICAqICAgICAgICAgIC0gMi10dXBsZXMgKHUsdikgZWRnZSBiZXR3ZWVuIHUgYW5kIHYuXG4gICAqICAgICAgICAgIC0gMy10dXBsZXMgKHUsdixrKSB3aGVyZSBrIGlzIGlnbm9yZWQuXG4gICAqIEBleHBvcnRcbiAgICovXG4gIHJlbW92ZUVkZ2VzRnJvbShlYnVuY2gpIHtcbiAgICB2YXIgYWRqID0gdGhpcy5hZGo7XG4gICAgZm9yRWFjaChlYnVuY2gsIGZ1bmN0aW9uKFt1LCB2XSkge1xuICAgICAgdmFyIHVub2RlID0gYWRqLmdldCh1KTtcbiAgICAgIGlmICh1bm9kZSAhPSBudWxsICYmIHVub2RlLmhhcyh2KSkge1xuICAgICAgICB1bm9kZS5kZWxldGUodik7XG4gICAgICAgIHZhciB2bm9kZSA9IGFkai5nZXQodik7XG4gICAgICAgIGlmICh2bm9kZSAhPT0gdW5vZGUpIHtcbiAgICAgICAgICB2bm9kZS5kZWxldGUodSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybiBUcnVlIGlmIHRoZSBlZGdlICh1LHYpIGlzIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB1IE5vZGUuXG4gICAqIEBwYXJhbSB7Tm9kZX0gdiBOb2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGVkZ2UgaXMgaW4gdGhlIGdyYXBoLCBGYWxzZSBvdGhlcndpc2UuXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGhhc0VkZ2UodSwgdikge1xuICAgIHZhciB1bm9kZSA9IHRoaXMuYWRqLmdldCh1KTtcbiAgICByZXR1cm4gdW5vZGUgJiYgdW5vZGUuaGFzKHYpO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIGEgbGlzdCBvZiB0aGUgbm9kZXMgY29ubmVjdGVkIHRvIHRoZSBub2RlIG4uXG4gICAqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG4gQSBub2RlIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHJldHVybiB7IUFycmF5fSBBIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgYWRqYWNlbnQgdG8gbi5cbiAgICogQGV4cG9ydFxuICAgKi9cbiAgbmVpZ2hib3JzKG4pIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm5laWdoYm9yc0l0ZXIobikpO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGl0ZXJhdG9yIG92ZXIgYWxsIG5laWdoYm9ycyBvZiBub2RlIG4uXG4gICAqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG4gQSBub2RlIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHJldHVybiB7IUl0ZXJhdG9yfSBBIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgYWRqYWNlbnQgdG8gbi5cbiAgICogQGV4cG9ydFxuICAgKi9cbiAgbmVpZ2hib3JzSXRlcihuKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLmFkai5nZXQobik7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vZGUua2V5cygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBKU05ldHdvcmtYRXJyb3IoJ1RoZSBub2RlICVzIGlzIG5vdCBpbiB0aGUgZ3JhcGguJywgbik7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIGEgbGlzdCBvZiBlZGdlcy5cbiAgICpcbiAgICogRWRnZXMgYXJlIHJldHVybmVkIGFzIHR1cGxlcyB3aXRoIG9wdGlvbmFsIGRhdGFcbiAgICogaW4gdGhlIG9yZGVyIChub2RlLCBuZWlnaGJvciwgZGF0YSkuXG4gICAqXG4gICAqIE5vdGU6IE5vZGVzIGluIG5idW5jaCB0aGF0IGFyZSBub3QgaW4gdGhlIGdyYXBoIHdpbGwgYmUgKHF1aWV0bHkpIGlnbm9yZWQuXG4gICAqIEZvciBkaXJlY3RlZCBncmFwaHMgdGhpcyByZXR1cm5zIHRoZSBvdXQtZWRnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7P05vZGVDb250YWluZXI9fSBvcHRfbmJ1bmNoIEEgY29udGFpbmVyIG9mIG5vZGVzLlxuICAgKiAgICAgIFRoZSBjb250YWluZXIgd2lsbCBiZSBpdGVyYXRlZCB0aHJvdWdoIG9uY2UuXG4gICAqIEBwYXJhbSB7P2Jvb2xlYW49fSBvcHRfZGF0YSBSZXR1cm4gdHdvIHR1cGxlcyAodSx2KSAoRmFsc2UpXG4gICAqICAgICAgb3IgdGhyZWUtdHVwbGVzICh1LHYsZGF0YSkgKFRydWUpLlxuICAgKlxuICAgKiBAcmV0dXJuIHshQXJyYXl9IGxpc3Qgb2YgZWRnZSB0dXBsZXNcbiAgICogICAgICBFZGdlcyB0aGF0IGFyZSBhZGphY2VudCB0byBhbnkgbm9kZSBpbiBuYnVuY2gsIG9yIGEgbGlzdFxuICAgKiAgICAgIG9mIGFsbCBlZGdlcyBpZiBuYnVuY2ggaXMgbm90IHNwZWNpZmllZC5cbiAgICogQGV4cG9ydFxuICAgKi9cbiAgZWRnZXMob3B0TmJ1bmNoLCBvcHREYXRhKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lZGdlc0l0ZXIob3B0TmJ1bmNoLCBvcHREYXRhKSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaXRlcmF0b3Igb3ZlciB0aGUgZWRnZXMuXG4gICAqXG4gICAqIEVkZ2VzIGFyZSByZXR1cm5lZCBhcyB0dXBsZXMgd2l0aCBvcHRpb25hbCBkYXRhXG4gICAqIGluIHRoZSBvcmRlciAobm9kZSwgbmVpZ2hib3IsIGRhdGEpLlxuICAgKlxuICAgKiBOb3RlOiBOb2RlcyBpbiBuYnVuY2ggdGhhdCBhcmUgbm90IGluIHRoZSBncmFwaCB3aWxsIGJlIChxdWlldGx5KSBpZ25vcmVkLlxuICAgKiBGb3IgZGlyZWN0ZWQgZ3JhcGhzIHRoaXMgcmV0dXJucyB0aGUgb3V0LWVkZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0gez8oTm9kZUNvbnRhaW5lcnxib29sZWFuKT19IG9wdF9uYnVuY2ggQSBjb250YWluZXIgb2Ygbm9kZXMuXG4gICAqICAgICAgVGhlIGNvbnRhaW5lciB3aWxsIGJlIGl0ZXJhdGVkIHRocm91Z2ggb25jZS5cbiAgICogQHBhcmFtIHs/Ym9vbGVhbj19IG9wdF9kYXRhIFJldHVybiB0d28gdHVwbGVzICh1LHYpIChGYWxzZSlcbiAgICogICAgICBvciB0aHJlZS10dXBsZXMgKHUsdixkYXRhKSAoVHJ1ZSkuXG4gICAqXG4gICAqIEByZXR1cm4geyFJdGVyYXRvcn0gbGlzdCBvZiBlZGdlIHR1cGxlc1xuICAgKiAgICAgIEVkZ2VzIHRoYXQgYXJlIGFkamFjZW50IHRvIGFueSBub2RlIGluIG5idW5jaCwgb3IgYSBsaXN0XG4gICAqICAgICAgb2YgYWxsIGVkZ2VzIGlmIG5idW5jaCBpcyBub3Qgc3BlY2lmaWVkLlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICAqZWRnZXNJdGVyKG9wdE5idW5jaCwgb3B0RGF0YSkge1xuXG4gICAgLy8gaGFuZGxlIGNhbGxzIHdpdGggZGF0YSBiZWluZyB0aGUgb25seSBhcmd1bWVudFxuICAgIGlmIChpc0Jvb2xlYW4ob3B0TmJ1bmNoKSkge1xuICAgICAgb3B0RGF0YSA9IG9wdE5idW5jaDtcbiAgICAgIG9wdE5idW5jaCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gaGVscGVyIGRpY3QgdG8ga2VlcCB0cmFjayBvZiBtdWx0aXBseSBzdG9yZWQgZWRnZXNcbiAgICB2YXIgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICB2YXIgbm9kZXNOYnJzO1xuXG4gICAgaWYgKG9wdE5idW5jaCA9PSBudWxsKSB7XG4gICAgICBub2Rlc05icnMgPSB0aGlzLmFkai5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGFkaiA9IHRoaXMuYWRqO1xuICAgICAgbm9kZXNOYnJzID0gbWFwSXRlcmF0b3IoXG4gICAgICAgIHRoaXMubmJ1bmNoSXRlcihvcHROYnVuY2gpLFxuICAgICAgICBuID0+IHR1cGxlMihuLCBhZGouZ2V0KG4pKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBub2RlRGF0YSBvZiBub2Rlc05icnMpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZURhdGFbMF07XG5cbiAgICAgIGZvciAodmFyIG5laWdoYm9yc0RhdGEgb2Ygbm9kZURhdGFbMV0uZW50cmllcygpKSB7XG4gICAgICAgIGlmICghc2Vlbi5oYXMobmVpZ2hib3JzRGF0YVswXSkpIHtcbiAgICAgICAgICBpZiAob3B0RGF0YSkge1xuICAgICAgICAgICAgbmVpZ2hib3JzRGF0YS51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgeWllbGQgbmVpZ2hib3JzRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBbbm9kZSwgbmVpZ2hib3JzRGF0YVswXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWVuLmFkZChub2RlKTtcbiAgICAgIG5vZGVEYXRhLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhdHRyaWJ1dGUgZGljdGlvbmFyeSBhc3NvY2lhdGVkIHdpdGggZWRnZSAodSx2KS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB1IE5vZGUuXG4gICAqIEBwYXJhbSB7Tm9kZX0gdiBOb2RlLlxuICAgKiBAcGFyYW0ge1Q9fSBvcHRfZGVmYXVsdCAoZGVmYXVsdD1udWxsKVxuICAgKiAgICAgIFZhbHVlIHRvIHJldHVybiBpZiB0aGUgZWRnZSAodSx2KSBpcyBub3QgZm91bmQuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8VCl9IFRoZSBlZGdlIGF0dHJpYnV0ZSBkaWN0aW9uYXJ5LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBnZXRFZGdlRGF0YSh1LCB2LCBvcHREZWZhdWx0KSB7XG4gICAgdmFyIG5icnMgPSB0aGlzLmFkai5nZXQodSk7XG4gICAgaWYgKG5icnMgIT0gbnVsbCkge1xuICAgICAgdmFyIGRhdGEgPSBuYnJzLmdldCh2KTtcbiAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHREZWZhdWx0O1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFkamFjZW5jeSBsaXN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncmFwaC5cbiAgICpcbiAgICogVGhlIG91dHB1dCBhZGphY2VuY3kgbGlzdCBpcyBpbiB0aGUgb3JkZXIgb2YgRy5ub2RlcygpLlxuICAgKiBGb3IgZGlyZWN0ZWQgZ3JhcGhzLCBvbmx5IG91dGdvaW5nIGFkamFjZW5jaWVzIGFyZSBpbmNsdWRlZC5cbiAgICpcbiAgICogQHJldHVybiB7IUFycmF5LjxBcnJheT59IFRoZSBhZGphY2VuY3kgc3RydWN0dXJlIG9mIHRoZSBncmFwaCBhcyBhXG4gICAqICAgICAgbGlzdCBvZiBsaXN0cy5cbiAgICogQGV4cG9ydFxuICAgKi9cbiAgYWRqYWNlbmN5TGlzdCgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShtYXBJdGVyYXRvcihcbiAgICAgIHRoaXMuYWRqYWNlbmN5SXRlcigpLFxuICAgICAgKFtfLCBhZGpdKSA9PiBBcnJheS5mcm9tKGFkai5rZXlzKCkpXG4gICAgKSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaXRlcmF0b3Igb2YgKG5vZGUsIGFkamFjZW5jeSBkaWN0KSB0dXBsZXMgZm9yIGFsbCBub2Rlcy5cbiAgICpcbiAgICpcbiAgICogQHJldHVybiB7IUl0ZXJhdG9yfSBBbiBhcnJheSBvZiAobm9kZSwgYWRqYWNlbmN5IGRpY3Rpb25hcnkpXG4gICAqICAgICAgZm9yIGFsbCBub2RlcyBpbiB0aGUgZ3JhcGguXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGFkamFjZW5jeUl0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRqLmVudHJpZXMoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGVncmVlIG9mIGEgbm9kZSBvciBub2Rlcy5cbiAgICpcbiAgICogVGhlIG5vZGUgZGVncmVlIGlzIHRoZSBudW1iZXIgb2YgZWRnZXMgYWRqYWNlbnQgdG8gdGhhdCBub2RlLlxuICAgKlxuICAgKiBXQVJOSU5HOiBTaW5jZSBib3RoIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLCBhbmQgdGhlIHdlaWdodCBhdHRyaWJ1dGVcbiAgICogbmFtZSBjb3VsZCBiZSBlcXVhbCB0byBhIG5vZGUgbmFtZSwgbmJ1bmNoIGFzIHRvIGJlIHNldCB0byBudWxsIGV4cGxpY2l0bHlcbiAgICogdG8gdXNlIHRoZSBzZWNvbmQgYXJndW1lbnQgYXMgd2VpZ2h0IGF0dHJpYnV0ZSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0geyhOb2RlfE5vZGVDb250YWluZXIpPX0gb3B0X25idW5jaCAoZGVmYXVsdD1hbGwgbm9kZXMpXG4gICAqICAgICAgQSBjb250YWluZXIgb2Ygbm9kZXMuICBUaGUgY29udGFpbmVyIHdpbGwgYmUgaXRlcmF0ZWRcbiAgICogICAgICB0aHJvdWdoIG9uY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3dlaWdodCAoZGVmYXVsdD1Ob25lKVxuICAgKiAgICAgIFRoZSBlZGdlIGF0dHJpYnV0ZSB0aGF0IGhvbGRzIHRoZSBudW1lcmljYWwgdmFsdWUgdXNlZFxuICAgKiAgICAgIGFzIGEgd2VpZ2h0LiAgSWYgbnVsbCBvciBub3QgZGVmaW5lZCwgdGhlbiBlYWNoIGVkZ2UgaGFzIHdlaWdodCAxLlxuICAgKiAgICAgIFRoZSBkZWdyZWUgaXMgdGhlIHN1bSBvZiB0aGUgZWRnZSB3ZWlnaHRzIGFkamFjZW50IHRvIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHshKG51bWJlcnxNYXApfSBBIGRpY3Rpb25hcnkgd2l0aCBub2RlcyBhcyBrZXlzIGFuZFxuICAgKiBkZWdyZWUgYXMgdmFsdWVzIG9yIGEgbnVtYmVyIGlmIGEgc2luZ2xlIG5vZGUgaXMgc3BlY2lmaWVkLlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBkZWdyZWUob3B0TmJ1bmNoLCBvcHRXZWlnaHQpIHtcbiAgICBpZiAob3B0TmJ1bmNoICE9IG51bGwgJiYgdGhpcy5oYXNOb2RlKG9wdE5idW5jaCkpIHtcbiAgICAgIC8vIHJldHVybiBhIHNpbmdsZSBub2RlXG4gICAgICByZXR1cm4gdGhpcy5kZWdyZWVJdGVyKG9wdE5idW5jaCxvcHRXZWlnaHQpLm5leHQoKS52YWx1ZVsxXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IE1hcCh0aGlzLmRlZ3JlZUl0ZXIob3B0TmJ1bmNoLCBvcHRXZWlnaHQpKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgZm9yIChub2RlLCBkZWdyZWUpLlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0geyhOb2RlfE5vZGVDb250YWluZXIpPX0gb3B0X25idW5jaCAoZGVmYXVsdD1hbGwgbm9kZXMpXG4gICAqICAgICAgIEEgY29udGFpbmVyIG9mIG5vZGVzLiAgVGhlIGNvbnRhaW5lciB3aWxsIGJlIGl0ZXJhdGVkXG4gICAqICAgICAgIHRocm91Z2ggb25jZS5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfd2VpZ2h0IChkZWZhdWx0PU5vbmUpXG4gICAqICAgICAgVGhlIGVkZ2UgYXR0cmlidXRlIHRoYXQgaG9sZHMgdGhlIG51bWVyaWNhbCB2YWx1ZSB1c2VkXG4gICAqICAgICAgYXMgYSB3ZWlnaHQuICBJZiBudWxsIG9yIG5vdCBkZWZpbmVkLCB0aGVuIGVhY2ggZWRnZSBoYXMgd2VpZ2h0IDEuXG4gICAqICAgICAgVGhlIGRlZ3JlZSBpcyB0aGUgc3VtIG9mIHRoZSBlZGdlIHdlaWdodHMgYWRqYWNlbnQgdG8gdGhlIG5vZGUuXG4gICAqXG4gICAqIFdBUk5JTkc6IFNpbmNlIGJvdGggcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwsIGFuZCB0aGUgd2VpZ2h0IGF0dHJpYnV0ZVxuICAgKiBuYW1lIGNvdWxkIGJlIGVxdWFsIHRvIGEgbm9kZSBuYW1lLCBuYnVuY2ggYXMgdG8gYmUgc2V0IHRvIG51bGwgZXhwbGljaXRseVxuICAgKiB0byB1c2UgdGhlIHNlY29uZCBhcmd1bWVudCBhcyB3ZWlnaHQgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4geyFJdGVyYXRvcn0gb2YgdHdvLXR1cGxlcyBvZiAobm9kZSwgZGVncmVlKS5cbiAgICpcbiAgICogQGV4cG9ydFxuICAgKi9cbiAgZGVncmVlSXRlcihvcHROYnVuY2gsIG9wdFdlaWdodCkge1xuICAgIHZhciBub2Rlc05icnM7XG4gICAgdmFyIGl0ZXJhdG9yO1xuXG4gICAgaWYgKG9wdE5idW5jaCA9PSBudWxsKSB7XG4gICAgICBub2Rlc05icnMgPSB0aGlzLmFkai5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGFkaiA9IHRoaXMuYWRqO1xuICAgICAgbm9kZXNOYnJzID0gbWFwSXRlcmF0b3IoXG4gICAgICAgIHRoaXMubmJ1bmNoSXRlcihvcHROYnVuY2gpLFxuICAgICAgICBuID0+IHR1cGxlMihuLCBhZGouZ2V0KG4pKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdFdlaWdodCkge1xuICAgICAgaXRlcmF0b3IgPSBtYXBJdGVyYXRvcihub2Rlc05icnMsIGZ1bmN0aW9uKFtub2RlLCBuYnJzXSkge1xuICAgICAgICByZXR1cm4gW25vZGUsIG5icnMuc2l6ZSArICgrbmJycy5oYXMobm9kZSkpXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGl0ZXJhdG9yID0gbWFwSXRlcmF0b3IoXG4gICAgICAgIG5vZGVzTmJycyxcbiAgICAgICAgZnVuY3Rpb24oW24sIG5icnNdKSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG5cbiAgICAgICAgICBuYnJzLmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIHdlaWdodCA9IGRhdGFbb3B0V2VpZ2h0XTtcbiAgICAgICAgICAgIHN1bSArPSArKHdlaWdodCAhPSBudWxsID8gd2VpZ2h0IDogMSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAobmJycy5oYXMobikpIHtcbiAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBuYnJzLmdldChuKVtvcHRXZWlnaHRdO1xuICAgICAgICAgICAgc3VtICs9ICsod2VpZ2h0ICE9IG51bGwgPyB3ZWlnaHQgOiAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW24sIHN1bV07XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xuICB9XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBub2RlcyBhbmQgZWRnZXMgZnJvbSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIFRoaXMgYWxzbyByZW1vdmVzIHRoZSBuYW1lLCBhbmQgYWxsIGdyYXBoLCBub2RlLCBhbmQgZWRnZSBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLm5hbWUgPSAnJztcbiAgICB0aGlzLmFkai5jbGVhcigpO1xuICAgIHRoaXMubm9kZS5jbGVhcigpO1xuICAgIGNsZWFyKHRoaXMuZ3JhcGgpO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIGEgY29weSBvZiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIFRoaXMgbWFrZXMgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBncmFwaCBpbmNsdWRpbmcgYWxsIG9mIHRoZVxuICAgKiBub2RlIG9yIGVkZ2UgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHJldHVybiB7IUdyYXBofVxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBjb3B5KCkge1xuICAgIHJldHVybiBkZWVwY29weSh0aGlzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybiBUcnVlIGlmIGdyYXBoIGlzIGEgbXVsdGlncmFwaCwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGdyYXBoIGlzIGEgbXVsdGlncmFwaCwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBpc011bHRpZ3JhcGgoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIFRydWUgaWYgZ3JhcGggaXMgZGlyZWN0ZWQsIEZhbHNlIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgZ3JhcGggaXMgZGlyZWN0ZWQsIEZhbHNlIG90aGVyd2lzZS5cbiAgICogQGV4cG9ydFxuICAgKi9cbiAgaXNEaXJlY3RlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBkaXJlY3RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIFRoaXMgcmV0dXJucyBhIFwiZGVlcGNvcHlcIiBvZiB0aGUgZWRnZSwgbm9kZSwgYW5kXG4gICAqIGdyYXBoIGF0dHJpYnV0ZXMgd2hpY2ggYXR0ZW1wdHMgdG8gY29tcGxldGVseSBjb3B5XG4gICAqIGFsbCBvZiB0aGUgZGF0YSBhbmQgcmVmZXJlbmNlcy5cbiAgICpcbiAgICogVGhpcyBpcyBpbiBjb250cmFzdCB0byB0aGUgc2ltaWxhciBEPURpR3JhcGgoRykgd2hpY2ggcmV0dXJucyBhXG4gICAqIHNoYWxsb3cgY29weSBvZiB0aGUgZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7IURpR3JhcGh9XG4gICAqIEBleHBvcnRcbiAgICovXG4gIHRvRGlyZWN0ZWQoKSB7XG4gICAgdmFyIEcgPSBuZXcgKHJlcXVpcmUoJy4vRGlHcmFwaCcpKSgpO1xuICAgIEcubmFtZSA9IHRoaXMubmFtZTtcbiAgICBHLmFkZE5vZGVzRnJvbSh0aGlzKTtcbiAgICBHLmFkZEVkZ2VzRnJvbSgoZnVuY3Rpb24qKCkge1xuICAgICAgZm9yICh2YXIgbmQgb2YgdGhpcy5hZGphY2VuY3lJdGVyKCkpIHtcbiAgICAgICAgdmFyIHUgPSBuZFswXTtcbiAgICAgICAgZm9yICh2YXIgbmJyIG9mIG5kWzFdKSB7XG4gICAgICAgICAgeWllbGQgdHVwbGUzKHUsIG5iclswXSwgZGVlcGNvcHkobmJyWzFdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LmNhbGwodGhpcykpKTtcbiAgICBHLmdyYXBoID0gZGVlcGNvcHkodGhpcy5ncmFwaCk7XG4gICAgRy5ub2RlID0gZGVlcGNvcHkodGhpcy5ub2RlKTtcblxuICAgIHJldHVybiBHO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIGFuIHVuZGlyZWN0ZWQgY29weSBvZiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIFRoaXMgcmV0dXJucyBhIFwiZGVlcGNvcHlcIiBvZiB0aGUgZWRnZSwgbm9kZSwgYW5kXG4gICAqIGdyYXBoIGF0dHJpYnV0ZXMgd2hpY2ggYXR0ZW1wdHMgdG8gY29tcGxldGVseSBjb3B5XG4gICAqIGFsbCBvZiB0aGUgZGF0YSBhbmQgcmVmZXJlbmNlcy5cbiAgICpcbiAgICogVGhpcyBpcyBpbiBjb250cmFzdCB0byB0aGUgc2ltaWxhciBHPURpR3JhcGgoRCkgd2hpY2ggcmV0dXJucyBhXG4gICAqIHNoYWxsb3cgY29weSBvZiB0aGUgZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7IUdyYXBofVxuICAgKiBAZXhwb3J0XG4gICAqL1xuICB0b1VuZGlyZWN0ZWQoKSB7XG4gICAgcmV0dXJuIGRlZXBjb3B5KHRoaXMpO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdWJncmFwaCBpbmR1Y2VkIG9uIG5vZGVzIGluIG5idW5jaC5cbiAgICpcbiAgICogVGhlIGluZHVjZWQgc3ViZ3JhcGggb2YgdGhlIGdyYXBoIGNvbnRhaW5zIHRoZSBub2RlcyBpbiBuYnVuY2hcbiAgICogYW5kIHRoZSBlZGdlcyBiZXR3ZWVuIHRob3NlIG5vZGVzLlxuICAgKlxuICAgKiBUaGUgZ3JhcGgsIGVkZ2Ugb3Igbm9kZSBhdHRyaWJ1dGVzIGp1c3QgcG9pbnQgdG8gdGhlIG9yaWdpbmFsIGdyYXBoLlxuICAgKiBTbyBjaGFuZ2VzIHRvIHRoZSBub2RlIG9yIGVkZ2Ugc3RydWN0dXJlIHdpbGwgbm90IGJlIHJlZmxlY3RlZCBpblxuICAgKiB0aGUgb3JpZ2luYWwgZ3JhcGggd2hpbGUgY2hhbmdlcyB0byB0aGUgYXR0cmlidXRlcyB3aWxsLlxuICAgKlxuICAgKiBUbyBjcmVhdGUgYSBzdWJncmFwaCB3aXRoIGl0cyBvd24gY29weSBvZiB0aGUgZWRnZS9ub2RlIGF0dHJpYnV0ZXMgdXNlOlxuICAgKiBganNueC5HcmFwaChHLnN1YmdyYXBoKG5idW5jaCkpYC5cbiAgICpcbiAgICogSWYgZWRnZSBhdHRyaWJ1dGVzIGFyZSBjb250YWluZXJzLCBhIGRlZXAgY29weSBjYW4gYmUgb2J0YWluZWQgdXNpbmc6XG4gICAqIGBHLnN1YmdyYXBoKG5idW5jaCkuY29weSgpYFxuICAgKlxuICAgKiBGb3IgYW4gaW5wbGFjZSByZWR1Y3Rpb24gb2YgYSBncmFwaCB0byBhIHN1YmdyYXBoIHlvdSBjYW4gcmVtb3ZlIG5vZGVzOlxuICAgKlxuICAgKiBgYGBcbiAgICogRy5yZW1vdmVOb2Rlc0Zyb20oRy5ub2RlcygpLmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAqICAgICAgcmV0dXJuIG5idW5jaC5pbmRleE9mKG4pID4gLTE7XG4gICAqIH0pKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlQ29udGFpbmVyfSBuYnVuY2hcbiAgICogICAgICBBIGNvbnRhaW5lciBvZiBub2RlcyB3aGljaCB3aWxsIGJlIGl0ZXJhdGVkIHRocm91Z2ggb25jZS5cbiAgICpcbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqIEBleHBvcnRcbiAgICovXG4gIHN1YmdyYXBoKG5idW5jaCkge1xuICAgIHZhciBidW5jaCA9IHRoaXMubmJ1bmNoSXRlcihuYnVuY2gpO1xuICAgIHZhciBuO1xuXG4gICAgLy8gY3JlYXRlIG5ldyBncmFwaCBhbmQgY29weSBzdWJncmFwaCBpbnRvIGl0XG4gICAgdmFyIEggPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgIC8vIGNvcHkgbm9kZSBhbmQgYXR0cmlidXRlIGRpY3Rpb25hcmllc1xuICAgIGZvciAobiBvZiBidW5jaCkge1xuICAgICAgSC5ub2RlLnNldChuLCB0aGlzLm5vZGUuZ2V0KG4pKTtcbiAgICB9XG4gICAgLy8gbmFtZXNwYWNlIHNob3J0Y3V0cyBmb3Igc3BlZWRcbiAgICB2YXIgSEFkaiA9IEguYWRqO1xuICAgIHZhciB0aGlzQWRqID0gdGhpcy5hZGo7XG5cbiAgICAvLyBhZGQgbm9kZXMgYW5kIGVkZ2VzICh1bmRpcmVjdGVkIG1ldGhvZClcbiAgICBmb3IgKG4gb2YgSCkge1xuICAgICAgdmFyIEhuYnJzID0gbmV3IE1hcCgpO1xuICAgICAgSEFkai5zZXQobiwgSG5icnMpO1xuXG4gICAgICBmb3IgKHZhciBuYnJkYXRhIG9mIHRoaXNBZGouZ2V0KG4pKSB7XG4gICAgICAgIHZhciBuYnIgPSBuYnJkYXRhWzBdO1xuICAgICAgICB2YXIgZGF0YSA9IG5icmRhdGFbMV07XG4gICAgICAgIGlmIChIQWRqLmhhcyhuYnIpKSB7XG4gICAgICAgICAgLy8gYWRkIGJvdGggcmVwcmVzZW50YXRpb25zIG9mIGVkZ2U6IG4tbmJyIGFuZCBuYnItblxuICAgICAgICAgIEhuYnJzLnNldChuYnIsIGRhdGEpO1xuICAgICAgICAgIEhBZGouZ2V0KG5icikuc2V0KG4sIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIEguZ3JhcGggPSB0aGlzLmdyYXBoO1xuXG4gICAgcmV0dXJuIEg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgbGlzdCBvZiBub2RlcyB3aXRoIHNlbGYgbG9vcHMuXG4gICAqXG4gICAqIEEgbm9kZSB3aXRoIGEgc2VsZiBsb29wIGhhcyBhbiBlZGdlIHdpdGggYm90aCBlbmRzIGFkamFjZW50XG4gICAqIHRvIHRoYXQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEEgbGlzdCBvZiBub2RlcyB3aXRoIHNlbGYgbG9vcHMuXG4gICAqIEBleHBvcnRcbiAgICovXG4gIG5vZGVzV2l0aFNlbGZsb29wcygpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICBmb3IgKHZhciBuZCBvZiB0aGlzLmFkai5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChuZFsxXS5oYXMobmRbMF0pKSB7XG4gICAgICAgIG5vZGVzLnB1c2gobmRbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBsaXN0IG9mIHNlbGZsb29wIGVkZ2VzLlxuICAgKlxuICAgKiBBIHNlbGZsb29wIGVkZ2UgaGFzIHRoZSBzYW1lIG5vZGUgYXQgYm90aCBlbmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfZGF0YSAoZGVmYXVsdD1GYWxzZSlcbiAgICogICAgICBSZXR1cm4gc2VsZmxvb3AgZWRnZXMgYXMgdHdvIHR1cGxlcyAodSx2KSAoZGF0YT1GYWxzZSlcbiAgICogICAgICBvciB0aHJlZS10dXBsZXMgKHUsdixkYXRhKSAoZGF0YT1UcnVlKS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9ICBBIGxpc3Qgb2YgYWxsIHNlbGZsb29wIGVkZ2VzLlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBzZWxmbG9vcEVkZ2VzKG9wdERhdGEpIHtcbiAgICB2YXIgZWRnZXMgPSBbXTtcblxuICAgIGZvciAodmFyIG5kIG9mIHRoaXMuYWRqLmVudHJpZXMoKSkge1xuICAgICAgdmFyIFtub2RlLCBuYnJzXSA9IG5kO1xuICAgICAgaWYgKG5icnMuaGFzKG5vZGUpKSB7XG4gICAgICAgIGlmIChvcHREYXRhKSB7XG4gICAgICAgICAgZWRnZXMucHVzaCh0dXBsZTNjKG5vZGUsIG5vZGUsIG5icnMuZ2V0KG5vZGUpLCBuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVkZ2VzLnB1c2godHVwbGUyYyhub2RlLCBub2RlLCBuZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVkZ2VzO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBudW1iZXIgb2Ygc2VsZmxvb3AgZWRnZXMuXG4gICAqXG4gICAqIEEgc2VsZmxvb3AgZWRnZSBoYXMgdGhlIHNhbWUgbm9kZSBhdCBib3RoIGVuZHMuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBzZWxmbG9vcHMuXG4gICAqIEBleHBvcnRcbiAgICovXG4gIG51bWJlck9mU2VsZmxvb3BzKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGZsb29wRWRnZXMoKS5sZW5ndGg7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBlZGdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfd2VpZ2h0IFRoZSBlZGdlIGF0dHJpYnV0ZSB0aGF0IGhvbGRzIHRoZSBudW1lcmljYWxcbiAgICogICAgICB2YWx1ZSB1c2VkIGFzIGEgd2VpZ2h0LiAgSWYgbm90IGRlZmluZWQsIHRoZW4gZWFjaCBlZGdlIGhhcyB3ZWlnaHQgMS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGVkZ2VzIG9yIHN1bSBvZiBlZGdlIHdlaWdodHMgaW4gdGhlIGdyYXBoLlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBzaXplKG9wdFdlaWdodCkge1xuICAgIHZhciBzID0gMDtcbiAgICBmb3IgKHZhciB2IG9mIHRoaXMuZGVncmVlKG51bGwsIG9wdFdlaWdodCkudmFsdWVzKCkpIHtcbiAgICAgIHMgKz0gdjtcbiAgICB9XG4gICAgcyA9IHMgLyAyO1xuXG4gICAgaWYgKG9wdFdlaWdodCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihzKTsgLy8gaW50KHMpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHM7IC8vIG5vIG5lZWQgdG8gY2FzdCB0byBmbG9hdFxuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGVkZ2VzIGJldHdlZW4gdHdvIG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0geyFOb2RlPX0gdSBub2RlLlxuICAgKiBAcGFyYW0geyFOb2RlPX0gdiBub2RlXG4gICAqICAgICAgIElmIHUgYW5kIHYgYXJlIHNwZWNpZmllZCwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZWRnZXMgYmV0d2VlblxuICAgKiAgICAgICB1IGFuZCB2LiBPdGhlcndpc2UgcmV0dXJuIHRoZSB0b3RhbCBudW1iZXIgb2YgYWxsIGVkZ2VzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZWRnZXMgaW4gdGhlIGdyYXBoLlxuICAgKiAgICAgIElmIG5vZGVzIHUgYW5kIHYgYXJlIHNwZWNpZmllZCByZXR1cm4gdGhlIG51bWJlciBvZiBlZGdlcyBiZXR3ZWVuXG4gICAqICAgICAgdGhvc2Ugbm9kZXMuXG4gICAqIEBleHBvcnRcbiAgICovXG4gIG51bWJlck9mRWRnZXModSwgdikge1xuICAgIGlmICh1ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuc2l6ZSgpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYWRqLmdldCh1KS5oYXModikpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFkZCBhIHN0YXIuXG4gICAqXG4gICAqIFRoZSBmaXJzdCBub2RlIGluIG5vZGVzIGlzIHRoZSBtaWRkbGUgb2YgdGhlIHN0YXIuICBJdCBpcyBjb25uZWN0ZWRcbiAgICogdG8gYWxsIG90aGVyIG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGVDb250YWluZXJ9IG5vZGVzIEEgY29udGFpbmVyIG9mIG5vZGVzLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdF9hdHRyICBBdHRyaWJ1dGVzIHRvIGFkZCB0byBldmVyeSBlZGdlIGluIHN0YXIuXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGFkZFN0YXIobm9kZXMsIG9wdEF0dHIpIHtcbiAgICB2YXIgbml0ZXIgPSB0b0l0ZXJhdG9yKG5vZGVzKTtcbiAgICB2YXIgdiA9IG5pdGVyLm5leHQoKS52YWx1ZTtcbiAgICB2YXIgZWRnZXMgPSBtYXBJdGVyYXRvcihuaXRlciwgbiA9PiB0dXBsZTIodiwgbikpO1xuICAgIHRoaXMuYWRkRWRnZXNGcm9tKGVkZ2VzLCBvcHRBdHRyKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFkZCBhIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZUNvbnRhaW5lcn0gbm9kZXMgQSBjb250YWluZXIgb2Ygbm9kZXMuXG4gICAqICAgICAgQSBwYXRoIHdpbGwgYmUgY29uc3RydWN0ZWQgZnJvbSB0aGUgbm9kZXMgKGluIG9yZGVyKVxuICAgKiAgICAgIGFuZCBhZGRlZCB0byB0aGUgZ3JhcGguXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2F0dHIgQXR0cmlidXRlcyB0byBhZGQgdG8gZXZlcnkgZWRnZSBpbiBwYXRoLlxuICAgKiBAZXhwb3J0XG4gICAqL1xuICBhZGRQYXRoKG5vZGVzLCBvcHRBdHRyKSB7XG4gICAgdmFyIG5saXN0ID0gQXJyYXkuZnJvbShub2Rlcyk7XG4gICAgdmFyIGVkZ2VzID0gemlwU2VxdWVuY2UoXG4gICAgICBubGlzdC5zbGljZSgwLCBubGlzdC5sZW5ndGggLSAxKSxcbiAgICAgIG5saXN0LnNsaWNlKDEpXG4gICAgKTtcbiAgICB0aGlzLmFkZEVkZ2VzRnJvbShlZGdlcywgb3B0QXR0cik7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBZGQgYSBjeWNsZS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlQ29udGFpbmVyfSBub2RlcyBBIGNvbnRhaW5lciBvZiBub2Rlcy5cbiAgICogICAgICBBIGN5Y2xlIHdpbGwgYmUgY29uc3RydWN0ZWQgZnJvbSB0aGUgbm9kZXMgKGluIG9yZGVyKVxuICAgKiAgICAgIGFuZCBhZGRlZCB0byB0aGUgZ3JhcGguXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2F0dHIgIEF0dHJpYnV0ZXMgdG8gYWRkIHRvIGV2ZXJ5IGVkZ2UgaW4gY3ljbGUuXG4gICAqIEBleHBvcnRcbiAgICovXG4gIGFkZEN5Y2xlKG5vZGVzLCBvcHRBdHRyKSB7XG4gICAgdmFyIG5saXN0ID0gQXJyYXkuZnJvbShub2Rlcyk7XG4gICAgdmFyIGVkZ2VzID0gemlwU2VxdWVuY2UoXG4gICAgICBubGlzdCxcbiAgICAgIG5saXN0LnNsaWNlKDEpLmNvbmNhdChbbmxpc3RbMF1dKVxuICAgICk7XG4gICAgdGhpcy5hZGRFZGdlc0Zyb20oZWRnZXMsIG9wdEF0dHIpO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGl0ZXJhdG9yIG9mIG5vZGVzIGNvbnRhaW5lZCBpbiBuYnVuY2ggdGhhdCBhcmVcbiAgICogYWxzbyBpbiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIFRoZSBub2RlcyBpbiBuYnVuY2ggYXJlIGNoZWNrZWQgZm9yIG1lbWJlcnNoaXAgaW4gdGhlIGdyYXBoXG4gICAqIGFuZCBpZiBub3QgYXJlIHNpbGVudGx5IGlnbm9yZWQuXG4gICAqXG4gICAqIE5vdGVzXG4gICAqIC0tLS0tXG4gICAqIFdoZW4gbmJ1bmNoIGlzIGFuIGl0ZXJhdG9yLCB0aGUgcmV0dXJuZWQgaXRlcmF0b3IgeWllbGRzIHZhbHVlc1xuICAgKiBkaXJlY3RseSBmcm9tIG5idW5jaCwgYmVjb21pbmcgZXhoYXVzdGVkIHdoZW4gbmJ1bmNoIGlzIGV4aGF1c3RlZC5cbiAgICpcbiAgICogVG8gdGVzdCB3aGV0aGVyIG5idW5jaCBpcyBhIHNpbmdsZSBub2RlLCBvbmUgY2FuIHVzZVxuICAgKiBcImlmKHRoaXMuaGFzX25vZGUobmJ1bmNoKVwiLCBldmVuIGFmdGVyIHByb2Nlc3Npbmcgd2l0aCB0aGlzIHJvdXRpbmUuXG4gICAqXG4gICAqIElmIG5idW5jaCBpcyBub3QgYSBub2RlIG9yIGEgKHBvc3NpYmx5IGVtcHR5KSBzZXF1ZW5jZS9pdGVyYXRvclxuICAgKiBvciBub3QgZGVmaW5lZCwgYW4gRXJyb3IgaXMgcmFpc2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyhOb2RlfE5vZGVDb250YWluZXIpPX0gb3B0X25idW5jaCAoZGVmYXVsdD1hbGwgbm9kZXMpXG4gICAqICAgICAgQSBjb250YWluZXIgb2Ygbm9kZXMuICBUaGUgY29udGFpbmVyIHdpbGwgYmUgaXRlcmF0ZWRcbiAgICogICAgICB0aHJvdWdoIG9uY2UuXG4gICAqXG4gICAqIEByZXR1cm4geyFJdGVyYXRvcn0gQW4gaXRlcmF0b3Igb3ZlciBub2RlcyBpbiBuYnVuY2hcbiAgICogICAgICB0aGF0IGFyZSBhbHNvIGluIHRoZSBncmFwaC5cbiAgICogICAgICBJZiBuYnVuY2ggaXMgbnVsbCBvciBub3QgZGVmaW5lZCwgaXRlcmF0ZSBvdmVyIGFsbCBub2RlcyBpbiB0aGUgZ3JhcGguXG4gICAqIEBleHBvcnRcbiAgICovXG4gICpuYnVuY2hJdGVyKG9wdE5idW5jaCkge1xuICAgIGlmIChvcHROYnVuY2ggPT0gbnVsbCkgeyAvLyBpbmNsdWRlIGFsbCBub2Rlc1xuICAgICAgLypqc2hpbnQgZXhwcjp0cnVlKi9cbiAgICAgIHlpZWxkKiB0aGlzLmFkai5rZXlzKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaGFzTm9kZShvcHROYnVuY2gpKSB7IC8vIGlmIG5idW5jaCBpcyBhIHNpbmdsZSBub2RlXG4gICAgICB5aWVsZCBvcHROYnVuY2g7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBpZiBuYnVuY2ggaXMgYSBzZXF1ZW5jZSBvZiBub2Rlc1xuICAgICAgdmFyIGFkaiA9IHRoaXMuYWRqO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBuIG9mIHRvSXRlcmF0b3Iob3B0TmJ1bmNoKSkge1xuICAgICAgICAgIGlmIChhZGouaGFzKG4pKSB7XG4gICAgICAgICAgICB5aWVsZCBuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2goZXgpIHtcbiAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcihcbiAgICAgICAgICAgICduYnVuY2ggaXMgbm90IGEgbm9kZSBvciBhIHNlcXVlbmNlIG9mIG5vZGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLmtleXMoKTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEaUdyYXBoIGZyb20gJy4vRGlHcmFwaCc7XG5pbXBvcnQgTXVsdGlHcmFwaCBmcm9tICcuL011bHRpR3JhcGgnO1xuaW1wb3J0IEpTTmV0d29ya1hFcnJvciBmcm9tICcuLi9leGNlcHRpb25zL0pTTmV0d29ya1hFcnJvcic7XG5cblxuaW1wb3J0IHtcbiAgTWFwLFxuICBjbG9uZSxcbiAgZGVlcGNvcHksXG4gIGdldERlZmF1bHQsXG4gIGlzUGxhaW5PYmplY3QsXG4gIG1hcEl0ZXJhdG9yLFxuICBzcHJpbnRmLFxuICB0dXBsZTIsXG4gIHR1cGxlNCxcbiAgY3JlYXRlVHVwbGVGYWN0b3J5LFxuICB6aXBJdGVyYXRvclxufSBmcm9tICcuLi9faW50ZXJuYWxzJztcblxuLyoqXG4gKiBBIGRpcmVjdGVkIGdyYXBoIGNsYXNzIHRoYXQgY2FuIHN0b3JlIG11bHRpZWRnZXMuXG4gKlxuICogTXVsdGllZGdlcyBhcmUgbXVsdGlwbGUgZWRnZXMgYmV0d2VlbiB0d28gbm9kZXMuIEVhY2ggZWRnZSBjYW4gaG9sZCBvcHRpb25hbFxuICogZGF0YSBvciBhdHRyaWJ1dGVzLlxuICpcbiAqIEEgTXVsdGlEaUdyYXBoIGhvbGRzIGRpcmVjdGVkIGVkZ2VzLiBTZWxmIGxvb3BzIGFyZSBhbGxvd2VkLiBFZGdlcyBhcmVcbiAqIHJlc3ByZXNlbnRlZCBhcyBsaW5rcyBiZXR3ZWVuIG5vZGVzIHdpdGggb3B0aW9uYWwga2V5L3ZhbHVlIGF0dHJpYnV0ZXMuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBDcmVhdGUgYW4gZW1wdHkgZ3JhcGggc3RydWN0dXJlIChhIFwibnVsbCBncmFwaFwiKSB3aXRoIG5vIG5vZGVzIGFuZCBubyBlZGdlczpcbiAqXG4gKiBgYGBcbiAqIHZhciBHID0gbmV3IGpzbnguTXVsdGlEaUdyYXBoKCk7XG4gKiBgYGBcbiAqXG4gKiBHIGNhbiBiZSBncm93biBpbiBzZXZlcmFsIHdheXMuXG4gKlxuICogIyMjIyBOb2Rlc1xuICpcbiAqIEFkZCBvbmUgbm9kZSBhdCBhIHRpbWU6XG4gKlxuICogYGBgXG4gKiBHLmFkZE5vZGUoMSk7XG4gKiBgYGBcbiAqXG4gKiBBZGQgdGhlIG5vZGVzIGZyb20gYW55IGl0ZXJhYmxlOlxuICpcbiAqIGBgYFxuICogRy5hZGROb2Rlc0Zyb20oWzIsM10pO1xuICogdmFyIEggPSBuZXcganNueC5HcmFwaCgpO1xuICogSC5hZGRQYXRoKFswLDEsMiwzLDQsNV0pO1xuICogRy5hZGROb2Rlc0Zyb20oSCk7XG4gKiBgYGBcbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBzdHJpbmdzIGFuZCBpbnRlZ2VycywgYW55IG9iamVjdCB0aGF0IGltcGxlbWVudHMgYSBjdXN0b21cbiAqIGB0b1N0cmluZ2AgbWV0aG9kIGNhbiByZXByZXNlbnQgYSBub2RlLlxuICpcbiAqICMjIyMgRWRnZXNcbiAqXG4gKiBgR2AgY2FuIGFsc28gYmUgZ3Jvd24gYnkgYWRkaW5nIGVkZ2VzLiBBZGQgb25lIGVkZ2UsXG4gKlxuICogYGBgXG4gKiBHLmFkZEVkZ2UoMSwgMik7XG4gKiBgYGBcbiAqXG4gKiBhIGxpc3Qgb2YgZWRnZXMsXG4gKlxuICogYGBgXG4gKiBHLmFkZEVkZ2VzRnJvbShbWzEsMl0sIFsxLDNdXSk7XG4gKiBgYGBcbiAqXG4gKiBvciBhIGNvbGxlY3Rpb24gb2YgZWRnZXNcbiAqXG4gKiBgYGBcbiAqIEcuYWRkRWRnZXNGcm9tKEguZWRnZXMoKSk7XG4gKiBgYGBcbiAqXG4gKiBJZiBzb21lIGVkZ2VzIGNvbm5lY3Qgbm9kZXMgbm90IHlldCBpbiB0aGUgZ3JhcGgsIHRoZSBub2RlcyBhcmUgYWRkZWRcbiAqIGF1dG9tYXRpY2FsbHkuIElmIGFuIGVkZ2UgYWxyZWFkeSBleGlzdHMsIGFuIGFkZGl0aW9uYWwgZWRnZSBpcyBjcmVhdGVkIGFuZFxuICogc3RvcmVkIHVzaW5nIGEga2V5IHRvIGlkZW50aWZ5IHRoZSBlZGdlLiBCeSBkZWZhdWx0IHRoZSBrZXkgaXMgdGhlIGxvd2VzdFxuICogdW51c2VkIGludGVnZXIuXG4gKlxuICogYGBgXG4gKiBHLmFkZEVkZ2VzRnJvbShbWzQsNSx7cm91dGU6MjgyfV0sIFs0LDUse3JvdXRlOjM3fV1dKTtcbiAqIEcuZ2V0KDQpO1xuICogLy8gTWFwIHs1OiB7MDoge30sIDE6IHtyb3V0ZTogMjgyfSwgMjoge3JvdXRlOiAzN319fVxuICpcbiAqICMjIyMgQXR0cmlidXRlc1xuICpcbiAqIEVhY2ggZ3JhcGgsIG5vZGUgYW5kIGVkZ2UgY2FuIGhvbGQga2V5L3ZhbHVlIGF0dHJpYnV0ZSBwYWlycyBpbiBhbiBhc3NvY2lhdGVkXG4gKiBhdHRyaWJ1dGUgb2JqZWN0LiBCeSBkZWZhdWx0IHRoZXNlIGFyZSBlbXB0eSwgYnV0IGNhbiBiZSBhZGRlZCBvciBjaGFuZ2VkXG4gKiB1c2luZyBgYWRkRWRnZWAgb3IgYGFkZE5vZGVgLlxuICpcbiAqIGBgYFxuICogRy5hZGROb2RlKDEsIHt0aW1lOiAnNXBtJ30pO1xuICogRy5hZGROb2Rlc0Zyb20oWzNdLCB7dGltZTogJzJwbSd9KTtcbiAqIEcubm9kZXModHJ1ZSk7XG4gKiAvLyBbWzEsIHt0aW1lOiAnNXBtJ31dLCBbMywge3RpbWU6ICcycG0nfV1dXG4gKiBgYGBcbiAqXG4gKiBBZGQgZWRnZSBhdHRyaWJ1dGVzIHVzaW5nIGBhZGRFZGdlYCBhbmQgYGFkZEVkZ2VzRnJvbWA6XG4gKlxuICogYGBgXG4gKiBHLmFkZEVkZ2UoMSwgMiwge3dlaWdodDogNC43fSk7XG4gKiBHLmFkZEVkZ2VzRnJvbShbWzMsNF0sIFs0LDVdXSwge2NvbG9yOiAncmVkJ30pO1xuICogRy5hZGRFZGdlc0Zyb20oW1sxLDIse2NvbG9yOiAnYmx1ZSd9XSwgWzIsMyx7d2VpZ2h0OiA4fV1dKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNdWx0aURpR3JhcGggZXh0ZW5kcyBEaUdyYXBoIHtcblxuICAvKipcbiAgICogQHBhcmFtIHsoT2JqZWN0fEFycmF5fEdyYXBoKX0gb3B0RGF0YSBEYXRhIHRvIGluaXRpYWxpemUgZ3JhcGguXG4gICAqICAgSWYgbm8gZGF0YSBpcyBwYXNzZWQsIGFuIGVtcHR5IGdyYXBoIGlzIGNyZWF0ZWQuIFRoZSBkYXRhIGNhbiBiZSBhbiBlZGdlXG4gICAqICAgbGlzdCwgb3IgYW55IEpTTmV0d29ya1ggZ3JhcGggb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdF9hdHRyIChkZWZhdWx0PSBubyBhdHRyaWJ1dGVzKVxuICAgKiAgICAgICBBdHRyaWJ1dGVzIHRvIGFkZCB0byBncmFwaCBhcyBrZXk9dmFsdWUgcGFpcnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHREYXRhLCBvcHRBdHRyKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE11bHRpRGlHcmFwaCkpIHtcbiAgICAgIHJldHVybiBuZXcgTXVsdGlEaUdyYXBoKG9wdERhdGEsIG9wdEF0dHIpO1xuICAgIH1cbiAgICBzdXBlcihvcHREYXRhLCBvcHRBdHRyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIb2xkcyB0aGUgZ3JhcGggdHlwZSAoY2xhc3MpIG5hbWUgZm9yIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBfX25hbWVfXygpIHtcbiAgICByZXR1cm4gJ011bHRpRGlHcmFwaCc7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGVkZ2UgYmV0d2VlbiB1IGFuZCB2LlxuICAgKlxuICAgKiBUaGUgbm9kZXMgdSBhbmQgdiB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgaWYgdGhleSBhcmUgbm90IGFscmVhZHkgaW5cbiAgICogdGhlIGdyYXBoLlxuICAgKlxuICAgKiBFZGdlIGF0dHJpYnV0ZXMgY2FuIGJlIHNwZWNpZmllZCBieSBwcm92aWRpbmcgYW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlXG4gICAqIHBhaXJzLlxuICAgKlxuICAgKiAjIyMgTm90ZVxuICAgKlxuICAgKiBUbyByZXBsYWNlL3VwZGF0ZSBlZGdlIGRhdGEsIHVzZSB0aGUgb3B0aW9uYWwga2V5IGFyZ3VtZW50IHRvIGlkZW50aWZ5IGFcbiAgICogdW5pcXVlIGVkZ2UuIE90aGVyd2lzZSBhIG5ldyBlZGdlIHdpbGwgYmUgY3JlYXRlZC5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBhZGQgdGhlIGVkZ2UgZT0oMSwyKSB0byBncmFwaCBHOlxuICAgKlxuICAgKiBgYGBcbiAgICogdmFyIEcgPSBuZXcganNueC5NdWx0aURpR3JhcGgoKTtcbiAgICogRy5hZGRFZGdlKDEsIDIpO1xuICAgKiBHLmFkZEVkZ2VzRnJvbShbWzEsMl1dKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEFzc29jaWF0ZSBkYXRhIHRvIGVkZ2VzIHVzaW5nIGtleXdvcmRzOlxuICAgKlxuICAgKiBgYGBcbiAgICogRy5hZGRFZGdlKDEsIDIsIHt3ZWlnaHQ6IDN9KTtcbiAgICogRy5hZGRFZGdlKDEsIDIsIDAsIHt3ZWlnaHQ6IDR9KTsgLy8gdXBkYXRlIGRhdGEgZm9yIGtleT0wXG4gICAqIEcuYWRkRWRnZSgxLCAzLCB7d2VpZ2h0OiA3LCBjYXBhY2l0eTogMTUsIGxlbmd0aDogMzQyLjd9KTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSB7Tm9kZX0gdVxuICAgKiBAcGFyYW0ge05vZGV9IHZcbiAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IG9wdEtleSAoZGVmYXVsdD1sb3dlc3QgdW51c2VkIGludGVnZXIpIFVzZWQgdG9cbiAgICogICBkaXN0aW5ndWlzaCBtdWx0aWVkZ2VzIGJldHdlZW4gYSBwYWlyIG9mIG5vZGVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3BBdHRyRGljdCBPYmplY3Qgb2YgZWRnZSBhdHRyaWJ1dGVzLiBLZXkvdmFsdWUgcGFpcnMgd2lsbFxuICAgKiAgIHVwZGF0ZSBleGlzdGluZyBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWRnZS5cbiAgICovXG4gIGFkZEVkZ2UodSwgdiwgb3B0S2V5LCBvcHRBdHRyRGljdCkge1xuICAgIGlmIChvcHRLZXkgJiYgdHlwZW9mIG9wdEtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdEF0dHJEaWN0ID0gb3B0S2V5O1xuICAgICAgb3B0S2V5ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAob3B0QXR0ckRpY3QgJiYgIWlzUGxhaW5PYmplY3Qob3B0QXR0ckRpY3QpKSB7XG4gICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKFxuICAgICAgICAnVGhlIG9wdEF0dHJEaWN0IGFyZ3VtZW50IG11c3QgYmUgYSBwbGFpbiBvYmplY3QuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgbm9kZXNcbiAgICB2YXIga2V5ZGljdDtcbiAgICBpZiAoIXRoaXMuc3VjYy5oYXModSkpIHtcbiAgICAgIHRoaXMuc3VjYy5zZXQodSwgbmV3IE1hcCgpKTtcbiAgICAgIHRoaXMucHJlZC5zZXQodSwgbmV3IE1hcCgpKTtcbiAgICAgIHRoaXMubm9kZS5zZXQodSwge30pO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3VjYy5oYXModikpIHtcbiAgICAgIHRoaXMuc3VjYy5zZXQodiwgbmV3IE1hcCgpKTtcbiAgICAgIHRoaXMucHJlZC5zZXQodiwgbmV3IE1hcCgpKTtcbiAgICAgIHRoaXMubm9kZS5zZXQodiwge30pO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdWNjLmdldCh1KS5oYXModikpIHtcbiAgICAgIGtleWRpY3QgPSB0aGlzLmdldCh1KS5nZXQodik7XG4gICAgICBpZiAob3B0S2V5ID09IG51bGwpIHtcbiAgICAgICAgLy8gZmluZCB1bmlxdWUgaW50ZWdlciBrZXlcbiAgICAgICAgb3B0S2V5ID0gT2JqZWN0LmtleXMoa2V5ZGljdCkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoa2V5ZGljdFtvcHRLZXldKSB7XG4gICAgICAgICAgb3B0S2V5ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtleWRpY3Rbb3B0S2V5XSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIGdldERlZmF1bHQoa2V5ZGljdFtvcHRLZXldLCB7fSksXG4gICAgICAgIG9wdEF0dHJEaWN0XG4gICAgICApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHNlbGZsb29wcyB3b3JrIHRoaXMgd2F5IHdpdGhvdXQgc3BlY2lhbCB0cmVhdG1lbnRcbiAgICAgIGlmIChvcHRLZXkgPT0gbnVsbCkge1xuICAgICAgICBvcHRLZXkgPSAwO1xuICAgICAgfVxuICAgICAga2V5ZGljdCA9IHtbb3B0S2V5XTogT2JqZWN0LmFzc2lnbih7fSwgb3B0QXR0ckRpY3QpfTtcbiAgICAgIHRoaXMuc3VjYy5nZXQodSkuc2V0KHYsIGtleWRpY3QpO1xuICAgICAgdGhpcy5wcmVkLmdldCh2KS5zZXQodSwga2V5ZGljdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBlZGdlIGJldHdlZW4gdSBhbmQgdi5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBHID0gbmV3IGpzbnguTXVsdGlEaUdyYXBoKCk7XG4gICAqIEcuYWRkUGF0aChbMCwxLDIsM10pO1xuICAgKiBHLnJlbW92ZUVkZ2UoMCwgMSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBGb3IgbXVsdGlwbGUgZWRnZXM6XG4gICAqXG4gICAqIGBgYFxuICAgKiB2YXIgRyA9IG5ldyBqc254Lk11bHRpRGlHcmFwaCgpO1xuICAgKiBHLmFkZEVkZ2VzRnJvbShbWzEsMl0sIFsxLDJdLCBbMSwyXV0pO1xuICAgKiBHLnJlbW92ZUVkZ2UoMSwgMik7IC8vIHJlbW92ZSBhIHNpbmdsZSAoYXJiaXRyYXJ5KSBlZGdlXG4gICAqIGBgYFxuICAgKlxuICAgKiBGb3IgZWRnZXMgd2l0aCBrZXlzOlxuICAgKlxuICAgKiBgYGBcbiAgICogdmFyIEcgPSBuZXcganNueC5NdWx0aURpR3JhcGgoKTtcbiAgICogRy5hZGRFZGdlKDEsIDIsICdmaXJzdCcpO1xuICAgKiBHLmFkZEVkZ2UoMSwgMiwgJ3NlY29uZCcpO1xuICAgKiBHLnJlbW92ZUVkZ2UoMSwgMiwgJ3NlY29uZCcpO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIHtOb2RlfSB1XG4gICAqIEBwYXJhbSB7Tm9kZX0gdlxuICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKX0gb3B0S2V5IFVzZWQgdG8gZGlzdGluZ3Vpc2ggbXVsdGlwbGUgZWRnZXMgYmV0d2VlblxuICAgKiAgIGEgcGFpciBvZiBub2Rlcy4gSWYgdW5kZWZpbmVkLCByZW1vdmUgYSBzaW5nbGUgKGFyYml0cmFyeSkgZWRnZSBiZXR3ZWVuXG4gICAqICAgdSBhbmQgdi5cbiAgICovXG4gIHJlbW92ZUVkZ2UodSwgdiwgb3B0S2V5KSB7XG4gICAgdmFyIGtleWRpY3Q7XG4gICAgdmFyIG5laWdodGJvcnNPZlUgPSB0aGlzLmFkai5nZXQodSk7XG4gICAgaWYgKG5laWdodGJvcnNPZlUpIHtcbiAgICAgIGtleWRpY3QgPSBuZWlnaHRib3JzT2ZVLmdldCh2KTtcbiAgICB9XG4gICAgaWYgKGtleWRpY3QgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcihcbiAgICAgICAgc3ByaW50ZignVGhlIGVkZ2UgJWotJWogaXMgbm90IGluIHRoZSBncmFwaCcsIHUsIHYpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB0aGUgZWRnZSB3aXRoIHNwZWNpZmllZCBkYXRhXG4gICAgaWYgKG9wdEtleSA9PSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4ga2V5ZGljdCkge1xuICAgICAgICBkZWxldGUga2V5ZGljdFtrZXldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoIWtleWRpY3Rbb3B0S2V5XSkge1xuICAgICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKHNwcmludGYoXG4gICAgICAgICAgJ1RoZSBlZGdlICVqLSVqIHdpdGgga2V5ICVqIGlzIG5vdCBpbiB0aGUgZ3JhcGgnLFxuICAgICAgICAgIHUsXG4gICAgICAgICAgdixcbiAgICAgICAgICBvcHRLZXlcbiAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICBkZWxldGUga2V5ZGljdFtvcHRLZXldO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMoa2V5ZGljdCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyByZW1vdmUgdGhlIGtleSBlbnRyaWVzIGlmIGxhc3QgZWRnZVxuICAgICAgdGhpcy5zdWNjLmdldCh1KS5kZWxldGUodik7XG4gICAgICB0aGlzLnByZWQuZ2V0KHYpLmRlbGV0ZSh1KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGVkZ2VzLlxuICAgKlxuICAgKiBFZGdlcyBhcmUgcmV0dXJuZWQgYXMgdHVwbGVzIHdpdGggb3B0aW9uYWwgZGF0YSBhbmQga2V5cyBpbiB0aGUgb3JkZXJcbiAgICogYChub2RlLCBuZWlnaGJvciwga2V5LCBkYXRhKWAuXG4gICAqXG4gICAqICMjIyBOb3RlXG4gICAqXG4gICAqIE5vZGVzIGluIGBvcHROYnVuY2hgIHRoYXQgYXJlIG5vdCBpbiB0aGUgZ3JhcGggd2lsbCBiZSAocXVpZXRseSkgaWdub3JlZC5cbiAgICogRm9yIGRpcmVjdGVkIGdyYXBocyB0aGlzIHJldHVybnMgdGhlIG91dC1lZGdlcy5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBHID0gbmV3IGpzbnguTXVsdGlEaUdyYXBoKCk7XG4gICAqIEcuYWRkUGF0aChbMCwxLDIsM10pO1xuICAgKiBBcnJheS5mcm9tKEcuZWRnZXNJdGVyKCkpO1xuICAgKiAvLyBbWzAsMV0sIFsxLDJdLCBbMiwzXV1cbiAgICogQXJyYXkuZnJvbShHLmVkZ2VzSXRlcih0cnVlKSk7XG4gICAqIC8vIFtbMCwxLHt9XSwgWzEsMix7fV0sIFsyLDMse31dXVxuICAgKiBBcnJheS5mcm9tKEcuZWRnZXNJdGVyKFswLDJdKSk7XG4gICAqIC8vIFtbMCwxXSwgWzIsM11dXG4gICAqIGBgYFxuICAgKlxuICAgKiBAYWxpYXMgb3V0RWRnZXNJdGVyXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGV9IG9wdE5idW5jaCAoZGVmYXVsdD1hbGwgbm9kZXMpIEEgY29udGFpbmVyIG9mIG5vZGVzLlxuICAgKiAgIFRoZSBjb250YWluZXIgd2lsbCBiZSBpdGVyYXRlZCBvdmVyIG9ubHkgb25jZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHREYXRhIChkZWZhdWx0PWZhbHNlKSBJZiB0cnVlLCByZXR1cm4gZWRnZSBhdHRyaWJ1dGVcbiAgICogICBkaWN0aW9uYXJpZXMgd2l0aCBlYWNoIGVkZ2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0S2V5cyAoZGVmYXVsdD1mbGFzZSkgSWYgdHJ1ZSwgcmV0dXJuIGVkZ2Uga2V5cyB3aXRoXG4gICAqICAgZWFjaCBlZGdlLlxuICAgKiBAcmV0dXJuIHtJdGVyYXRvcn0gQW4gaXRlcmF0b3Igb2YgYCh1LHYpYCwgYCh1LHYsZClgIG9yIGAodSx2LGtleSxkKWAgZWRnZXNcbiAgICovXG4gICplZGdlc0l0ZXIob3B0TmJ1bmNoLCBvcHREYXRhPWZhbHNlLCBvcHRLZXlzPWZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHROYnVuY2ggPT09ICdib29sZWFuJykge1xuICAgICAgb3B0S2V5cyA9IG9wdERhdGE7XG4gICAgICBvcHREYXRhID0gb3B0TmJ1bmNoO1xuICAgICAgb3B0TmJ1bmNoID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXNOYnJzID0gb3B0TmJ1bmNoID09IG51bGwgP1xuICAgICAgdGhpcy5hZGogOlxuICAgICAgbWFwSXRlcmF0b3IodGhpcy5uYnVuY2hJdGVyKG9wdE5idW5jaCksIG4gPT4gdHVwbGUyKG4sIHRoaXMuYWRqLmdldChuKSkpO1xuXG4gICAgeWllbGQqIHlpZWxkRWRnZXMobm9kZXNOYnJzLCBvcHREYXRhLCBvcHRLZXlzLCAnb3V0Jyk7XG4gIH1cblxuICAvKipcbiAgICogQGFsaWFzIGVkZ2VzSXRlclxuICAgKi9cbiAgb3V0RWRnZXNJdGVyKG9wdE5idW5jaCwgb3B0RGF0YSwgb3B0S2V5cykge1xuICAgIHJldHVybiB0aGlzLmVkZ2VzSXRlcihvcHROYnVuY2gsIG9wdERhdGEsIG9wdEtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGxpc3Qgb2YgdGhlIG91dGdvaW5nIGVkZ2VzLlxuICAgKlxuICAgKiBFZGdlcyBhcmUgcmV0dXJuZWQgYXMgdHVwbGVzIHdpdGggb3B0aW9uYWwgZGF0YSBhbmQga2V5cyBpbiB0aGUgb3JkZXJcbiAgICogYChub2RlLCBuZWlnaGJvciwga2V5LCBkYXRhKWAuXG4gICAqXG4gICAqICMjIyBOb3RlXG4gICAqXG4gICAqIE5vZGVzIGluIGBvcHROYnVuY2hgIHRoYXQgYXJlIG5vdCBpbiB0aGUgZ3JhcGggd2lsbCBiZSAocXVpZXRseSkgaWdub3JlZC5cbiAgICogRm9yIGRpcmVjdGVkIGdyYXBocyBgZWRnZXMoKWAgaXMgdGhlIHNhbWUgYXMgYG91dEVkZ2VzKClgLlxuICAgKlxuICAgKiBAc2VlIGluRWRnZXNcbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZX0gb3B0TmJ1bmNoIChkZWZhdWx0PWFsbCBub2RlcykgQSBjb250YWluZXIgb2Ygbm9kZXMuXG4gICAqICAgVGhlIGNvbnRhaW5lciB3aWxsIGJlIGl0ZXJhdGVkIG92ZXIgb25seSBvbmNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdERhdGEgKGRlZmF1bHQ9ZmFsc2UpIElmIHRydWUsIHJldHVybiBlZGdlIGF0dHJpYnV0ZVxuICAgKiAgIGRpY3Rpb25hcmllcyB3aXRoIGVhY2ggZWRnZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRLZXlzIChkZWZhdWx0PWZsYXNlKSBJZiB0cnVlLCByZXR1cm4gZWRnZSBrZXlzIHdpdGhcbiAgICogICBlYWNoIGVkZ2UuXG4gICAqIEByZXR1cm4ge0FycmF5fSBBIGxpc3Qgb2YgYCh1LHYpYCwgYCh1LHYsZClgIG9yIGAodSx2LGtleSxkKWAgdHVwbGVzIG9mXG4gICAqICAgZWRnZXNcbiAgICovXG4gIG91dEVkZ2VzKG9wdE5idW5jaCwgb3B0RGF0YSwgb3B0S2V5cykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMub3V0RWRnZXNJdGVyKG9wdE5idW5jaCwgb3B0RGF0YSwgb3B0S2V5cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpdGVyYXRvciBvdmVyIHRoZSBpbmNvbWluZyBlZGdlcy5cbiAgICpcbiAgICogRWRnZXMgYXJlIHJldHVybmVkIGFzIHR1cGxlcyB3aXRoIG9wdGlvbmFsIGRhdGEgYW5kIGtleXMgaW4gdGhlIG9yZGVyXG4gICAqIGAobm9kZSwgbmVpZ2hib3IsIGtleSwgZGF0YSlgLlxuICAgKlxuICAgKiBAc2VlIGVkZ2VzSXRlclxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZXJhYmxlPX0gb3B0TmJ1bmNoIChkZWZhdWx0PWFsbCBub2RlcykgQSBjb250YWluZXIgb2Ygbm9kZXMuXG4gICAqICAgVGhlIGNvbnRhaW5lciB3aWxsIGJlIGl0ZXJhdGVkIG92ZXIgb25seSBvbmNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHREYXRhIChkZWZhdWx0PWZhbHNlKSBJZiB0cnVlLCByZXR1cm4gZWRnZSBhdHRyaWJ1dGVcbiAgICogICBkaWN0aW9uYXJpZXMgd2l0aCBlYWNoIGVkZ2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdEtleXMgKGRlZmF1bHQ9Zmxhc2UpIElmIHRydWUsIHJldHVybiBlZGdlIGtleXMgd2l0aFxuICAgKiAgIGVhY2ggZWRnZS5cbiAgICogQHJldHVybiB7SXRlcmF0b3J9IEFuIGl0ZXJhdG9yIG9mIGAodSx2KWAsIGAodSx2LGQpYCBvciBgKHUsdixrZXksZClgIGVkZ2VzXG4gICAqL1xuICAqaW5FZGdlc0l0ZXIob3B0TmJ1bmNoLCBvcHREYXRhPWZhbHNlLCBvcHRLZXlzPWZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHROYnVuY2ggPT09ICdib29sZWFuJykge1xuICAgICAgb3B0S2V5cyA9IG9wdERhdGE7XG4gICAgICBvcHREYXRhID0gb3B0TmJ1bmNoO1xuICAgICAgb3B0TmJ1bmNoID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXNOYnJzID0gb3B0TmJ1bmNoID09IG51bGwgP1xuICAgICAgdGhpcy5wcmVkIDpcbiAgICAgIG1hcEl0ZXJhdG9yKHRoaXMubmJ1bmNoSXRlcihvcHROYnVuY2gpLCBuID0+IHR1cGxlMihuLCB0aGlzLnByZWQuZ2V0KG4pKSk7XG5cbiAgICB5aWVsZCogeWllbGRFZGdlcyhub2Rlc05icnMsIG9wdERhdGEsIG9wdEtleXMsICdpbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGxpc3Qgb2YgdGhlIGluY29taW5nIGVkZ2VzLlxuICAgKlxuICAgKiBAc2VlIG91dEVkZ2VzXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGU9fSBvcHROYnVuY2ggKGRlZmF1bHQ9YWxsIG5vZGVzKSBBIGNvbnRhaW5lciBvZiBub2Rlcy5cbiAgICogICBUaGUgY29udGFpbmVyIHdpbGwgYmUgaXRlcmF0ZWQgb3ZlciBvbmx5IG9uY2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdERhdGEgKGRlZmF1bHQ9ZmFsc2UpIElmIHRydWUsIHJldHVybiBlZGdlIGF0dHJpYnV0ZVxuICAgKiAgIGRpY3Rpb25hcmllcyB3aXRoIGVhY2ggZWRnZS5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0S2V5cyAoZGVmYXVsdD1mbGFzZSkgSWYgdHJ1ZSwgcmV0dXJuIGVkZ2Uga2V5cyB3aXRoXG4gICAqICAgZWFjaCBlZGdlLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQSBsaXN0IG9mIGAodSx2KWAsIGAodSx2LGQpYCBvciBgKHUsdixrZXksZClgIHR1cGxlcyBvZlxuICAgKiAgIGVkZ2VzXG4gICAqL1xuICBpbkVkZ2VzKG9wdE5idW5jaCwgb3B0RGF0YSwgb3B0S2V5cykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuaW5FZGdlc0l0ZXIob3B0TmJ1bmNoLCBvcHREYXRhLCBvcHRLZXlzKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGl0ZXJhdG9yIGZvciBgKG5vZGUsIGRlZ3JlZSlgLlxuICAgKlxuICAgKiBUaGUgbm9kZSBkZWdyZWUgaXMgdGhlIG51bWJlciBvZiBlZGdlcyBhZGphY2VudCB0byB0aGUgbm9kZS5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBHID0gbmV3IGpzbnguTXVsdGlEaUdyYXBoKCk7XG4gICAqIEcuYWRkUGF0aChbMCwxLDIsM10pO1xuICAgKiBBcnJheS5mcm9tKEcuZGVncmVlSXRlcihbMCwxXSkpO1xuICAgKiAvLyBbWzAsMV0sIFsxLDJdXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZT19IG9wdE5idW5jaCAoZGVmYXVsdD1hbGwgbm9kZXMpIEEgY29udGFpbmVyIG9mIG5vZGVzLlxuICAgKiAgIFRoZSBjb250YWluZXIgd2lsbCBiZSBpdGVyYXRlZCB0aHJvdWdoIG9uY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0U3RyaW5nIChkZWZhdWx0PW51bGwpXG4gICAqICAgVGhlIGVkZ2UgYXR0cmlidXRlIHRoYXQgaG9sZHMgdGhlIG51bWVyaWNhbCB2YWx1ZSB1c2VkIGFzIGEgd2VpZ2h0LiBJZlxuICAgKiAgIE5vbmUsIHRoZW4gZWFjaCBlZGdlIGhhcyB3ZWlnaHQgMS5cbiAgICogICBUaGUgZGVncmVlIGlzIHRoZSBzdW0gb2YgdGhlIGVkZ2Ugd2VpZ2h0cy5cbiAgICogQHJldHVybiB7SXRlcmF0b3J9IFRoZSBpdGVyYXRvciByZXR1cm5zIHR3by10dXBsZXMgb2YgYChub2RlLCBkZWdyZWUpYC5cbiAgICovXG4gICpkZWdyZWVJdGVyKG9wdE5idW5jaCwgb3B0V2VpZ2h0KSB7XG4gICAgdmFyIHR1cGxlMlN1Y2MgPSBjcmVhdGVUdXBsZUZhY3RvcnkoMik7XG4gICAgdmFyIHR1cGxlMlByZWQgPSBjcmVhdGVUdXBsZUZhY3RvcnkoMik7XG5cbiAgICB2YXIgbm9kZXNOYnJzID0gb3B0TmJ1bmNoID09IG51bGwgP1xuICAgICAgemlwSXRlcmF0b3IodGhpcy5zdWNjLmVudHJpZXMoKSwgdGhpcy5wcmVkLmVudHJpZXMoKSkgOlxuICAgICAgemlwSXRlcmF0b3IoXG4gICAgICAgIG1hcEl0ZXJhdG9yKFxuICAgICAgICAgIHRoaXMubmJ1bmNoSXRlcihvcHROYnVuY2gpLFxuICAgICAgICAgIG4gPT4gdHVwbGUyU3VjYyhuLCB0aGlzLnN1Y2MuZ2V0KG4pKVxuICAgICAgICApLFxuICAgICAgICBtYXBJdGVyYXRvcihcbiAgICAgICAgICB0aGlzLm5idW5jaEl0ZXIob3B0TmJ1bmNoKSxcbiAgICAgICAgICBuID0+IHR1cGxlMlByZWQobiwgdGhpcy5wcmVkLmdldChuKSlcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgIGlmIChvcHRXZWlnaHQgPT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgW1tuLCBzdWNjXSwgW18sIHByZWRdXSBvZiBub2Rlc05icnMpIHtcbiAgICAgICAgdmFyIGtleWRpY3Q7XG4gICAgICAgIHZhciBpbkRlZ3JlZSA9IDA7XG4gICAgICAgIGZvciAoa2V5ZGljdCBvZiBwcmVkLnZhbHVlcygpKSB7XG4gICAgICAgICAgaW5EZWdyZWUgKz0gT2JqZWN0LmtleXMoa2V5ZGljdCkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXREZWdyZWUgPSAwO1xuICAgICAgICBmb3IgKGtleWRpY3Qgb2Ygc3VjYy52YWx1ZXMoKSkge1xuICAgICAgICAgIGluRGVncmVlICs9IE9iamVjdC5rZXlzKGtleWRpY3QpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBbbiwgaW5EZWdyZWUgKyBvdXREZWdyZWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvciAodmFyIFtbbiwgc3VjY10sIFtfLCBwcmVkXV0gb2Ygbm9kZXNOYnJzKSB7XG4gICAgICAgIHlpZWxkIFtcbiAgICAgICAgICBuLFxuICAgICAgICAgIHN1bUVkZ2VBdHRyaWJ1dGUocHJlZCwgb3B0V2VpZ2h0LCAxKSArXG4gICAgICAgICAgICBzdW1FZGdlQXR0cmlidXRlKHN1Y2MsIG9wdFdlaWdodCwgMSlcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGl0ZXJhdG9yIGZvciBgKG5vZGUsIGluLWRlZ3JlZSlgLlxuICAgKlxuICAgKiBUaGUgbm9kZSBpbi1kZWdyZWUgaXMgdGhlIG51bWJlciBvZiBlZGdlcyBwb2ludGluZyB0byB0aGUgbm9kZS5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBHID0gbmV3IGpzbnguTXVsdGlEaUdyYXBoKCk7XG4gICAqIEcuYWRkUGF0aChbMCwxLDIsM10pO1xuICAgKiBBcnJheS5mcm9tKEcuZGVncmVlSXRlcihbMCwxXSkpO1xuICAgKiAvLyBbWzAsMF0sIFsxLDFdXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZT19IG9wdE5idW5jaCAoZGVmYXVsdD1hbGwgbm9kZXMpIEEgY29udGFpbmVyIG9mIG5vZGVzLlxuICAgKiAgIFRoZSBjb250YWluZXIgd2lsbCBiZSBpdGVyYXRlZCB0aHJvdWdoIG9uY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0U3RyaW5nIChkZWZhdWx0PW51bGwpXG4gICAqICAgVGhlIGVkZ2UgYXR0cmlidXRlIHRoYXQgaG9sZHMgdGhlIG51bWVyaWNhbCB2YWx1ZSB1c2VkIGFzIGEgd2VpZ2h0LiBJZlxuICAgKiAgIE5vbmUsIHRoZW4gZWFjaCBlZGdlIGhhcyB3ZWlnaHQgMS5cbiAgICogICBUaGUgZGVncmVlIGlzIHRoZSBzdW0gb2YgdGhlIGVkZ2Ugd2VpZ2h0cy5cbiAgICogQHJldHVybiB7SXRlcmF0b3J9IFRoZSBpdGVyYXRvciByZXR1cm5zIHR3by10dXBsZXMgb2YgYChub2RlLCBkZWdyZWUpYC5cbiAgICovXG4gICppbkRlZ3JlZUl0ZXIob3B0TmJ1bmNoLCBvcHRXZWlnaHQpIHtcbiAgICB5aWVsZCogeWllbGREZWdyZWUodGhpcywgdGhpcy5wcmVkLCBvcHROYnVuY2gsIG9wdFdlaWdodCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGl0ZXJhdG9yIGZvciBgKG5vZGUsIG91dC1kZWdyZWUpYC5cbiAgICpcbiAgICogVGhlIG5vZGUgb3V0LWRlZ3JlZSBpcyB0aGUgbnVtYmVyIG9mIGVkZ2VzIHBvaW50aW5nIG91dCBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBHID0gbmV3IGpzbnguTXVsdGlEaUdyYXBoKCk7XG4gICAqIEcuYWRkUGF0aChbMCwxLDIsM10pO1xuICAgKiBBcnJheS5mcm9tKEcuZGVncmVlSXRlcihbMCwxXSkpO1xuICAgKiAvLyBbWzAsMV0sIFsxLDFdXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZT19IG9wdE5idW5jaCAoZGVmYXVsdD1hbGwgbm9kZXMpIEEgY29udGFpbmVyIG9mIG5vZGVzLlxuICAgKiAgIFRoZSBjb250YWluZXIgd2lsbCBiZSBpdGVyYXRlZCB0aHJvdWdoIG9uY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0U3RyaW5nIChkZWZhdWx0PW51bGwpXG4gICAqICAgVGhlIGVkZ2UgYXR0cmlidXRlIHRoYXQgaG9sZHMgdGhlIG51bWVyaWNhbCB2YWx1ZSB1c2VkIGFzIGEgd2VpZ2h0LiBJZlxuICAgKiAgIE5vbmUsIHRoZW4gZWFjaCBlZGdlIGhhcyB3ZWlnaHQgMS5cbiAgICogICBUaGUgZGVncmVlIGlzIHRoZSBzdW0gb2YgdGhlIGVkZ2Ugd2VpZ2h0cy5cbiAgICogQHJldHVybiB7SXRlcmF0b3J9IFRoZSBpdGVyYXRvciByZXR1cm5zIHR3by10dXBsZXMgb2YgYChub2RlLCBkZWdyZWUpYC5cbiAgICovXG4gICpvdXREZWdyZWVJdGVyKG9wdE5idW5jaCwgb3B0V2VpZ2h0KSB7XG4gICAgeWllbGQqIHlpZWxkRGVncmVlKHRoaXMsIHRoaXMuc3VjYywgb3B0TmJ1bmNoLCBvcHRXZWlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBUcnVlIGlmIGdyYXBoIGlzIGEgbXVsdGlncmFwaCwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGdyYXBoIGlzIGEgbXVsdGlncmFwaCwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNNdWx0aWdyYXBoKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBUcnVlIGlmIGdyYXBoIGlzIGRpcmVjdGVkLCBGYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIGdyYXBoIGlzIGRpcmVjdGVkLCBGYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0RpcmVjdGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGRpcmVjdGVkIGNvcHkgb2YgdGhlIGdyYXBoLlxuICAgKlxuICAgKiAjIyMgTm90ZXNcbiAgICpcbiAgICogVGhpcyByZXR1cm5zIGEgZGVlcCBjb3B5IG9mIHRoZSBlZGdlLCBub2RlLCBhbmRcbiAgICogZ3JhcGggYXR0cmlidXRlcyB3aGljaCBhdHRlbXB0cyB0byBjb21wbGV0ZWx5IGNvcHlcbiAgICogYWxsIG9mIHRoZSBkYXRhIGFuZCByZWZlcmVuY2VzLlxuICAgKlxuICAgKiBUaGlzIGlzIGluIGNvbnRyYXN0IHRvIHRoZSBzaW1pbGFyIGB2YXIgRyA9IG5ldyBNdWx0aURpR3JhcGgoRCk7YCwgd2hpY2hcbiAgICogcmV0dXJucyBhIHNoYWxsb3cgY29weSBvZiB0aGUgZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7TXVsdGlEaUdyYXBofSBBIGRlZXAgY29weSBvZiB0aGUgZ3JhcGguXG4gICAqL1xuICB0b0RpcmVjdGVkKCkge1xuICAgIHJldHVybiBkZWVwY29weSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gdW5kaXJlY3RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGlncmFwaC5cbiAgICpcbiAgICogIyMjIE5vdGVzXG4gICAqXG4gICAqIFRoZSByZXN1bHQgaXMgYW4gdW5kaXJlY3RlZCBncmFwaCB3aXRoIHRoZSBzYW1lIG5hbWUsIG5vZGVzIGFuZFxuICAgKiB3aXRoIGVkZ2UgYCh1LHYsZGF0YSlgIGlmIGVpdGhlciBgKHUsdixkYXRhKWAgb3IgYCh2LHUsZGF0YSlgXG4gICAqIGlzIGluIHRoZSBkaWdyYXBoLiAgSWYgYm90aCBlZGdlcyBleGlzdCBpbiBkaWdyYXBoIGFuZFxuICAgKiB0aGVpciBlZGdlIGRhdGEgaXMgZGlmZmVyZW50LCBvbmx5IG9uZSBlZGdlIGlzIGNyZWF0ZWRcbiAgICogd2l0aCBhbiBhcmJpdHJhcnkgY2hvaWNlIG9mIHdoaWNoIGVkZ2UgZGF0YSB0byB1c2UuXG4gICAqIFlvdSBtdXN0IGNoZWNrIGFuZCBjb3JyZWN0IGZvciB0aGlzIG1hbnVhbGx5IGlmIGRlc2lyZWQuXG4gICAqXG4gICAqIFRoaXMgcmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGUgZWRnZSwgbm9kZSwgYW5kXG4gICAqIGdyYXBoIGF0dHJpYnV0ZXMgd2hpY2ggYXR0ZW1wdHMgdG8gY29tcGxldGVseSBjb3B5XG4gICAqIGFsbCBvZiB0aGUgZGF0YSBhbmQgcmVmZXJlbmNlcy5cbiAgICpcbiAgICogVGhpcyBpcyBpbiBjb250cmFzdCB0byB0aGUgc2ltaWxhciBgdmFyIEcgPSBuZXcgTXVsdGlHcmFwaChEKTtgLCB3aGljaFxuICAgKiByZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRSZWNpcHJvY2FsIElmIHRydWUsIG9ubHkga2VlcCBlZGdlcyB0aGF0IGFwcGVhciBpblxuICAgKiAgIGJvdGggZGlyZWN0aW9ucyBpbiB0aGUgb3JpZ2luYWwgZGlncmFwaC5cbiAgICogQHJldHVybiB7TXVsdGlHcmFwaH1cbiAgICovXG4gIHRvVW5kaXJlY3RlZChvcHRSZWNpcHJvY2FsKSB7XG4gICAgdmFyIEggPSBuZXcgTXVsdGlHcmFwaCgpO1xuICAgIEgubmFtZSA9IHRoaXMubmFtZTtcbiAgICBILmFkZE5vZGVzRnJvbSh0aGlzKTtcbiAgICBmb3IgKHZhciBbdSwgbmJyc10gb2YgdGhpcy5hZGphY2VuY3lJdGVyKCkpIHtcbiAgICAgIGZvciAodmFyIFt2LCBrZXlkaWN0XSBvZiBuYnJzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlkaWN0KSB7XG4gICAgICAgICAgaWYgKCFvcHRSZWNpcHJvY2FsIHx8IHRoaXMuaGFzRWRnZSh2LCB1LCBrZXkpKSB7XG4gICAgICAgICAgICBILmFkZEVkZ2UodSwgdiwga2V5LCBkZWVwY29weShrZXlkaWN0W2tleV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBILmdyYXBoID0gZGVlcGNvcHkodGhpcy5ncmFwaCk7XG4gICAgSC5ub2RlID0gZGVlcGNvcHkodGhpcy5ub2RlKTtcbiAgICByZXR1cm4gSDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN1YmdyYXBoIGluZHVjZWQgb24gbm9kZXMgaW4gYG5idW5jaGAuXG4gICAqXG4gICAqIFRoZSBpbmR1Y2VkIHN1YmdyYXBoIG9mIHRoZSBncmFwaCBjb250YWlucyB0aGUgbm9kZXMgaW4gYG9wdE5idW5jaGAgYW5kIHRoZVxuICAgKiBlZGdlcyBiZXR3ZWVuIHRob3NlIG5vZGVzLlxuICAgKlxuICAgKiAjIyMgTm90ZXNcbiAgICpcbiAgICogVGhlIGdyYXBoLCBlZGdlIG9yIG5vZGUgYXR0cmlidXRlcyBqdXN0IHBvaW50IHRvIHRoZSBvcmlnaW5hbCBncmFwaC5cbiAgICogU28gY2hhbmdlcyB0byB0aGUgbm9kZSBvciBlZGdlIHN0cnVjdHVyZSB3aWxsIG5vdCBiZSByZWZsZWN0ZWQgaW5cbiAgICogdGhlIG9yaWdpbmFsIGdyYXBoIHdoaWxlIGNoYW5nZXMgdG8gdGhlIGF0dHJpYnV0ZXMgd2lsbC5cbiAgICpcbiAgICogVG8gY3JlYXRlIGEgc3ViZ3JhcGggd2l0aCBpdHMgb3duIGNvcHkgb2YgdGhlIGVkZ2Uvbm9kZSBhdHRyaWJ1dGVzIHVzZTpcbiAgICogYGpzbnguTXVsdGlEaUdyYXBoKEcuc3ViZ3JhcGgobmJ1bmNoKSlgLlxuICAgKlxuICAgKiAjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBcbiAgICogdmFyIEcgPSBuZXcganNueC5NdWx0aURpR3JhcGgoKTtcbiAgICogRy5hZGRQYXRoKFswLDEsMiwzXSk7XG4gICAqIHZhciBIID0gRy5zdWJncmFwaChbMCwxLDJdKTtcbiAgICogSC5lZGdlcygpO1xuICAgKiAvLyBbWzAsMV0sIFsxLDJdXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZX0gbkJ1bmNoIEEgY29udGFpbmVyIG9mIG5vZGVzIHdoaWNoIHdpbGwgYmUgaXRlcmF0ZWRcbiAgICogICB0aHJvdWdoIG9uY2UuXG4gICAqIEByZXR1cm4ge011bHRpRGlHcmFwaH1cbiAgICovXG4gIHN1YmdyYXBoKG5CdW5jaCkge1xuICAgIHZhciBidW5jaCA9IHRoaXMubmJ1bmNoSXRlcihuQnVuY2gpO1xuICAgIC8vIGNyZWF0ZSBuZXcgZ3JhcGggYW5kIGNvcHkgc3ViZ3JhcGggaW50byBpdFxuICAgIHZhciBIID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICAvLyBjb3B5IG5vZGUgYW5kIGF0dHJpYnV0ZSBkaWN0aW9uYXJpZXNcbiAgICBmb3IgKHZhciBuIG9mIGJ1bmNoKSB7XG4gICAgICBILm5vZGUuc2V0KG4sIHRoaXMubm9kZS5nZXQobikpO1xuICAgIH1cbiAgICB2YXIgSFN1Y2MgPSBILnN1Y2M7XG4gICAgdmFyIEhQcmVkID0gSC5wcmVkO1xuICAgIHZhciB0aGlzU3VjYyA9IHRoaXMuc3VjYztcblxuICAgIC8vIGFkZCBub2Rlc1xuICAgIGZvciAodmFyIG4gb2YgSCkge1xuICAgICAgSFN1Y2Muc2V0KG4sIG5ldyBNYXAoKSk7XG4gICAgICBIUHJlZC5zZXQobiwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgLy8gYWRkIGVkZ2VzXG4gICAgZm9yICh2YXIgW3UsIEhOYnJzXSBvZiBIU3VjYykge1xuICAgICAgZm9yICh2YXIgW3YsIGtleWRpY3RdIG9mIHRoaXNTdWNjLmdldCh1KSkge1xuICAgICAgICBpZiAoSFN1Y2MuaGFzKHYpKSB7XG4gICAgICAgICAgLy8gYWRkIGJvdGggcmVwcmVzZW50YXRpb25zIG9mIGVkZ2U6IHUtdiBhbmQgdi11XG4gICAgICAgICAgLy8gdGhleSBzaGFyZSB0aGUgc2FtZSBrZXlkaWN0XG4gICAgICAgICAgdmFyIGtleWRpY3RDb3B5ID0gY2xvbmUoa2V5ZGljdCk7XG4gICAgICAgICAgSE5icnMuc2V0KHYsIGtleWRpY3RDb3B5KTtcbiAgICAgICAgICBIUHJlZC5nZXQodikuc2V0KHUsIGtleWRpY3RDb3B5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBILmdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICByZXR1cm4gSDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHJldmVyc2Ugb2YgdGhlIGdyYXBoLlxuICAgKlxuICAgKiBUaGUgcmV2ZXJzZSBpcyBhIGdyYXBoIHdpdGggdGhlIHNhbWUgbm9kZXMgYW5kIGVkZ2VzIGJ1dCB3aXRoIHRoZVxuICAgKiBkaXJlY3Rpb25zIG9mIHRoZSBlZGdlcyByZXZlcnNlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0Q29weSBJZiB0cnVlLCByZXR1cm4gYSBuZXcgTXVsdGlEaUdyYXBoIGhvbGRpbmcgdGhlXG4gICAqICAgcmV2ZXJzZWQgZWRnZXMuIElmIGZhbHNlLCB0aGUgcmV2ZXJzZSBncmFwaCBpcyBjcmVhdGVkIHVzaW5nIHRoZSBvcmlnaW5hbFxuICAgKiAgIGdyYXBoICh0aGlzIGNoYW5nZXMgdGhlIG9yaWdpbmFsIGdyYXBoKS5cbiAgICogQHJldHVybiB7P011bHRpRGlHcmFwaH1cbiAgICovXG4gIHJldmVyc2Uob3B0Q29weT10cnVlKSB7XG4gICAgdmFyIEg7XG4gICAgaWYgKG9wdENvcHkpIHtcbiAgICAgIEggPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihcbiAgICAgICAgbnVsbCxcbiAgICAgICAge25hbWU6IHNwcmludGYoJ1JldmVyc2Ugb2YgKCVzKScsIHRoaXMubmFtZSl9XG4gICAgICApO1xuXG4gICAgICBILmFkZE5vZGVzRnJvbSh0aGlzKTtcbiAgICAgIEguYWRkRWRnZXNGcm9tKG1hcEl0ZXJhdG9yKFxuICAgICAgICB0aGlzLmVkZ2VzKHRydWUsIHRydWUpLFxuICAgICAgICAoW3UsdixrZXksZGF0YV0pID0+IHR1cGxlNCh2LCB1LCBrZXksIGRlZXBjb3B5KGRhdGEpKVxuICAgICAgKSk7XG4gICAgICBILmdyYXBoID0gZGVlcGNvcHkodGhpcy5ncmFwaCk7XG4gICAgICBILm5vZGUgPSBkZWVwY29weSh0aGlzLm5vZGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIFt0aGlzLnByZWQsIHRoaXMuc3VjY10gPSBbdGhpcy5zdWNjLCB0aGlzLnByZWRdO1xuICAgICAgdGhpcy5hZGogPSB0aGlzLnN1Y2M7XG4gICAgICBIID0gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEg7XG4gIH1cbn1cblxuLy8gU2ltdWxhdGUgbXVsdGlwbGUgaW5oZXJpdGFuY2UgYnkgbWVyZ2luZyBwcm90b3R5cGVzXG5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNdWx0aUdyYXBoLnByb3RvdHlwZSkuZm9yRWFjaChwcm9wID0+IHtcbiAgaWYgKCFNdWx0aURpR3JhcGgucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgTXVsdGlEaUdyYXBoLnByb3RvdHlwZVtwcm9wXSA9IE11bHRpR3JhcGgucHJvdG90eXBlW3Byb3BdO1xuICB9XG59KTtcblxuZnVuY3Rpb24qIHlpZWxkRWRnZXMobm9kZXNOYnJzLCBkYXRhLCBrZXlzLCB0eXBlKSB7XG4gIGZvciAodmFyIFtuLCBuYnJzXSBvZiBub2Rlc05icnMpIHtcbiAgICBmb3IgKHZhciBbbmJyLCBrZXlkaWN0XSBvZiBuYnJzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4ga2V5ZGljdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHlwZSA9PT0gJ291dCcgPyBbbiwgbmJyXSA6IFtuYnIsIG5dO1xuICAgICAgICBpZiAoa2V5cykge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IGlzTmFOKGtleSkgPyBrZXkgOiAra2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5ZGljdFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN1bUVkZ2VBdHRyaWJ1dGUobmJycywgYXR0cmlidXRlLCBkZWYpIHtcbiAgdmFyIHN1bSA9IDA7XG4gIGZvciAodmFyIGtleWRpY3Qgb2YgbmJycy52YWx1ZXMoKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBrZXlkaWN0KSB7XG4gICAgICBzdW0gKz0gZ2V0RGVmYXVsdChrZXlkaWN0W2tleV1bYXR0cmlidXRlXSwgZGVmKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gKnlpZWxkRGVncmVlKGdyYXBoLCBlZGdlcywgbkJ1bmNoLCB3ZWlnaHQpIHtcbiAgdmFyIG5vZGVzTmJycyA9IG5CdW5jaCA9PSBudWxsID9cbiAgICBlZGdlcyA6XG4gICAgbWFwSXRlcmF0b3IoZ3JhcGgubmJ1bmNoSXRlcihuQnVuY2gpLCBuID0+IHR1cGxlMihuLCBlZGdlcy5nZXQobikpKTtcblxuICBpZiAod2VpZ2h0ID09IG51bGwpIHtcbiAgICBmb3IgKHZhciBbbiwgbmJyc10gb2Ygbm9kZXNOYnJzKSB7XG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIGZvciAodmFyIGtleWRpY3Qgb2YgbmJycy52YWx1ZXMoKSkge1xuICAgICAgICBzdW0gKz0gT2JqZWN0LmtleXMoa2V5ZGljdCkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgeWllbGQgW24sIHN1bV07XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGZvciAodmFyIFtuLCBuYnJzXSBvZiBub2Rlc05icnMpIHtcbiAgICAgIHlpZWxkIFtuLCBzdW1FZGdlQXR0cmlidXRlKG5icnMsIHdlaWdodCwgMSldO1xuICAgIH1cbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBHcmFwaCBmcm9tICcuL0dyYXBoJztcbmltcG9ydCBKU05ldHdvcmtYRXJyb3IgZnJvbSAnLi4vZXhjZXB0aW9ucy9KU05ldHdvcmtYRXJyb3InO1xuXG5pbXBvcnQge1xuICBNYXAsXG4gIFNldCxcbiAgY2xvbmUsXG4gIGRlZXBjb3B5LFxuICBmb3JFYWNoLFxuICBnZXREZWZhdWx0LFxuICBpc0FycmF5TGlrZSxcbiAgaXNQbGFpbk9iamVjdCxcbiAgbWFwSXRlcmF0b3IsXG4gIG5vZGVzQXJlRXF1YWwsXG4gIHNwcmludGYsXG4gIHR1cGxlMlxufSBmcm9tICcuLi9faW50ZXJuYWxzJztcblxuLyoqXG4gKiBBbiB1bmRpcmVjdGVkIGdyYXBoIGNsYXNzIHRoYXQgY2FuIHN0b3JlIG11bHRpZWRnZXMuXG4gKlxuICogTXVsdGllZGdlcyBhcmUgbXVsdGlwbGUgZWRnZXMgYmV0d2VlbiB0d28gbm9kZXMuICBFYWNoIGVkZ2VcbiAqIGNhbiBob2xkIG9wdGlvbmFsIGRhdGEgb3IgYXR0cmlidXRlcy4gQSBNdWx0aUdyYXBoIGhvbGRzIHVuZGlyZWN0ZWQgZWRnZXMuXG4gKiBTZWxmIGxvb3BzIGFyZSBhbGxvd2VkLlxuICpcbiAqIEVkZ2VzIGFyZSByZXByZXNlbnRlZCBhcyBsaW5rcyBiZXR3ZWVuIG5vZGVzIHdpdGggb3B0aW9uYWxcbiAqIGtleS92YWx1ZSBhdHRyaWJ1dGVzLlxuICpcbiAqICMjIyBFeGFtcGxlc1xuICpcbiAqIENyZWF0ZSBhbiBlbXB0eSBncmFwaCBzdHJ1Y3R1cmUgKGEgXCJudWxsIGdyYXBoXCIpIHdpdGggbm8gbm9kZXMgYW5kIG5vIGVkZ2VzLlxuICpcbiAqIGBgYFxuICogdmFyIEcgPSBqc254Lk11bHRpR3JhcGgoKTtcbiAqIGBgYFxuICpcbiAqIEcgY2FuIGJlIGdyb3duIGluIHNldmVyYWwgd2F5cy5cbiAqXG4gKiAjIyMjIE5vZGVzXG4gKlxuICogQWRkIG9uZSBub2RlIGF0IGEgdGltZTpcbiAqXG4gKiBgYGBcbiAqIEcuYWRkTm9kZSgxKTtcbiAqIGBgYFxuICpcbiAqIEFkZCB0aGUgbm9kZXMgZnJvbSBhbnkgaXRlcmFibGU6XG4gKlxuICogYGBgXG4gKiBHLmFkZE5vZGVzRnJvbShbMiwgM10pO1xuICogdmFyIEggPSBqc254LkdyYXBoKCk7XG4gKiBILmFkZFBhdGgoWzAsMSwyLDMsNCw1LDYsNyw4LDldKTtcbiAqIEcuYWRkTm9kZXNGcm9tKGgpO1xuICogYGBgXG4gKlxuICogSW4gYWRkaXRpb24gdG8gc3RyaW5ncyBhbmQgaW50ZWdlcnMsIGFueSBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIGEgY3VzdG9tXG4gKiBgdG9TdHJpbmdgIG1ldGhvZCBjYW4gYmUgdXNlZCBhcyBub2RlLiBGb3IgZXhhbXBsZSwgYXJyYXlzOlxuICpcbiAqIGBgYFxuICogRy5hZGROb2RlKFsxLDJdKTtcbiAqIGBgYFxuICpcbiAqICMjIyMgRWRnZXNcbiAqXG4gKiBBIGdyYXBoIGNhbiBhbHNvIGJlIGdyb3duIGJ5IGFkZGluZyBlZGdlcy5cbiAqXG4gKiBBZGQgb25lIGVkZ2UsXG4gKlxuICogYGBgXG4gKiBHLmFkZEVkZ2UoMSwgMik7XG4gKiBgYGBcbiAqXG4gKiBhIGxpc3Qgb3IgY29sbGVjdGlvbiBvZiBlZGdlcyxcbiAqXG4gKiBgYGBcbiAqIEcuYWRkRWRnZXNGcm9tKFtbMSwyXSwgWzEsM11dKTtcbiAqIEcuYWRkRWRnZXNGcm9tKEguZWRnZXMoKSk7XG4gKiBgYGBcbiAqXG4gKiBJZiBzb21lIGVkZ2VzIGNvbm5lY3Qgbm9kZXMgbm90IHlldCBpbiB0aGUgZ3JhcGgsIHRoZSBub2RlcyBhcmUgYWRkZWRcbiAqIGF1dG9tYXRpY2FsbHkuIElmIGFuIGVkZ2UgYWxyZWFkeSBleGlzdHMsIGFuIGFkZGl0aW9uIGVkZ2UgaXMgY3JlYXRlZCBhbmRcbiAqIHN0b3JlZCB1c2luZyBhIGtleSB0byBpZGVudGlmeSB0aGUgZWRnZS4gQnkgZGVmYXVsdCwgdGhlIGtleSBpcyB0aGUgbG93ZXN0XG4gKiB1bnVzZWQgaW50ZWdlci5cbiAqXG4gKiBgYGBcbiAqIEcuYWRkRWRnZXNGcm9tKFtbNCw1LHtyb3V0ZTogMjgyfV0sIFs0LDUse3JvdXRlOiAzN31dXSk7XG4gKiBHLmdldCg0KTtcbiAqIC8vIE1hcCB7IDM6IHswOiB7fX0sIDU6IHswOiB7fSwgMToge3JvdXRlOiAyODJ9LCAyOiB7cm91dGU6IDM3fX19XG4gKiBgYGBcbiAqXG4gKiAjIyMjIEF0dHJpYnV0ZXNcbiAqXG4gKiBFYWNoIGdyYXBoLCBub2RlIGFuZCBlZGdlIGNhbiBob2xkIGtleS92YWx1ZSBhdHRyaWJ1dGUgcGFpcnMgaW4gYW4gYXNzb2NpYXRlZFxuICogYXR0cmlidXRlIFwiZGljdGlvbmFyeVwiIChvYmplY3QpLiBCeSBkZWZhdWx5IHRoZXNlIGFyZSBlbXB0eSwgYnV0IGNhbiBiZSBhZGRlZFxuICogb3IgY2hhbmdlZCB1c2luZyBgYWRkRWRnZWAgb3IgYGFkZE5vZGVgLlxuICpcbiAqIGBgYFxuICogdmFyIEcgPSBqc254Lk11bHRpR3JhcGgobnVsbCwge2RheTogRnJpZGF5fSk6XG4gKiBHLmdyYXBoXG4gKiAvLyB7ZGF5OiAnRnJpZGF5J31cbiAqXG4gKiBHLmFkZE5vZGUoMSwge3RpbWU6ICc1cG0nfSk7XG4gKiBHLmFkZE5vZGVzRnJvbShbM10sIHt0aW1lOiAnMnBtJ30pO1xuICogRy5ub2Rlcyh0cnVlKTtcbiAqIC8vIFtbMSwge3RpbWU6ICc1cG0nfV0sIFszLCB7dGltZTogJzJwbSd9XV1cbiAqIGBgYFxuICpcbiAqIEBzZWUgR3JhcGhcbiAqIEBzZWUgRGlHcmFwaFxuICogQHNlZSBNdWx0aURpR3JhcGhcbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE11bHRpR3JhcGggZXh0ZW5kcyBHcmFwaCB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Pz19IG9wdERhdGEgRGF0YSB0byBpbml0aWFsemUgZ3JhcGguXG4gICAqICAgICAgSWYgbm8gZGF0YSBpcyBwcm92aWRlZCwgYW4gZW1wdHkgZ3JhcGggaXMgY3JlYXRlZC4gVGhlIGRhdGEgY2FuIGJlXG4gICAqICAgICAgYW4gZWRnZSBsaXN0IG9yIGFueSBncmFwaCBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0QXR0ciBBdHRyaWJ1dGVzIHRvIGFkZCB0byBncmFwaCBhcyBrZXk9dmFsdWUgcGFpcnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHREYXRhLCBvcHRBdHRyKSB7XG4gICAgLy8gbWFrZXMgaXQgcG9zc2libGUgdG8gY2FsbCBqc254LkdyYXBoIHdpdGhvdXQgbmV3XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE11bHRpR3JhcGgpKSB7XG4gICAgICByZXR1cm4gbmV3IE11bHRpR3JhcGgob3B0RGF0YSwgb3B0QXR0cik7XG4gICAgfVxuICAgIHN1cGVyKG9wdERhdGEsIG9wdEF0dHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhvbGRzIHRoZSBncmFwaCB0eXBlIChjbGFzcykgbmFtZSBmb3IgaW5mb3JtYXRpb24uXG4gICAqIFRoaXMgaXMgY29tcGF0aWJsZSB0byBQeXRob25zIF9fbmFtZV9fIHByb3BlcnR5LlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBfX25hbWVfXygpIHtcbiAgICByZXR1cm4gJ011bHRpR3JhcGgnO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBlZGdlIGJldHdlZW4gdSBhbmQgdi5cbiAgICpcbiAgICogVGhlIG5vZGVzIHUgYW5kIHYgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGlmIHRoZXkgYXJlXG4gICAqIG5vdCBhbHJlYWR5IGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogRWRnZSBhdHRyaWJ1dGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aCBrZXl3b3JkcyBvciBieSBwcm92aWRpbmdcbiAgICogYSBkaWN0aW9uYXJ5IHdpdGgga2V5L3ZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiAjIyMgTm90ZXM6XG4gICAqXG4gICAqIFRvIHJlcGxhY2UvdXBkYXRlIGVkZ2UgZGF0YSwgdXNlIHRoZSBvcHRpb25hbCBrZXkgYXJndW1lbnRcbiAgICogdG8gaWRlbnRpZnkgYSB1bmlxdWUgZWRnZS4gIE90aGVyd2lzZSBhIG5ldyBlZGdlIHdpbGwgYmUgY3JlYXRlZC5cbiAgICpcbiAgICogTmV0d29ya1ggYWxnb3JpdGhtcyBkZXNpZ25lZCBmb3Igd2VpZ2h0ZWQgZ3JhcGhzIGNhbm5vdCB1c2VcbiAgICogbXVsdGlncmFwaHMgZGlyZWN0bHkgYmVjYXVzZSBpdCBpcyBub3QgY2xlYXIgaG93IHRvIGhhbmRsZVxuICAgKiBtdWx0aWVkZ2Ugd2VpZ2h0cy4gIENvbnZlcnQgdG8gR3JhcGggdXNpbmcgZWRnZSBhdHRyaWJ1dGVcbiAgICogJ3dlaWdodCcgdG8gZW5hYmxlIHdlaWdodGVkIGdyYXBoIGFsZ29yaXRobXMuXG4gICAqXG4gICAqICMjIyBFeGFtcGxlXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgYWxsIGFkZCB0aGUgZWRnZSBbMSwyXSB0byB0aGUgZ3JhcGggRzpcbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBHID0ganNueC5NdWx0aUdyYXBoKCk7XG4gICAqIHZhciBlID0gWzEsMl07XG4gICAqIEcuYWRkRWRnZSgxLCAyKTtcbiAgICogRy5hZGRFZGdlLmFwcGx5KEcsIGUpO1xuICAgKiBHLmFkZEVkZ2VzRnJvbShbZV0pO1xuICAgKiBgYGBcbiAgICogQXNzb2NpYXRlIGRhdGEgdG8gZWRnZXMgYnkgcGFzc2luZyBhIGRhdGEgb2JqZWN0OlxuICAgKlxuICAgKiBgYGBcbiAgICogRy5hZGRFZGdlKDEsIDIsIHt3ZWlnaHQ6IDN9KTtcbiAgICogRy5hZGRFZGdlKDEsIDIsIDAsIHt3ZWlnaHQ6IDR9KTsgLy8gdXBkYXRlIGRhdGEgZm9yIGtleT0wXG4gICAqIEcuYWRkRWRnZSgxLCAzLCB7d2VpZ2h0OiA3LCBjYXBhY2l0eTogMTUsIGxlbmd0aDogMzQyLjd9KTtcbiAgICogYGBgXG4gICAqIEBzZWUgI2FkZEVkZ2VzRnJvbVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHUgbm9kZVxuICAgKiBAcGFyYW0ge05vZGV9IHYgbm9kZVxuICAgKiBAcGFyYW0gez8obnVtYmVyfHN0cmluZyk9fSBvcHRLZXkgaWRlbnRpZmllclxuICAgKiAgICAgIFVzZWQgdG8gZGlzdGluZ3Vpc2ggbXVsdGllZGdlcyBiZXR3ZWVuIGEgcGFpciBvZiBub2Rlcy4gRGVmYXVsdCBpc1xuICAgKiAgICAgIHRoZSBsb3dlc3QgdW51c2VkIGludGVnZXIuXG4gICAqIEBwYXJhbSB7P09iamVjdD19IG9wdEF0dHJEaWN0ICBEaWN0aW9uYXJ5IG9mIGVkZ2UgYXR0cmlidXRlcy5cbiAgICogICAgICBLZXkvdmFsdWUgcGFpcnMgd2lsbCB1cGRhdGUgZXhpc3RpbmcgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGVkZ2UuXG4gICAqL1xuICBhZGRFZGdlKHUsIHYsIG9wdEtleSwgb3B0QXR0ckRpY3QpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvcHRLZXk7XG4gICAgaWYgKG9wdEtleSAhPSBudWxsICYmIHR5cGUgIT09ICdudW1iZXInICYmIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRBdHRyRGljdCA9IG9wdEtleTtcbiAgICAgIG9wdEtleSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2V0IHVwIGF0dHJpYnV0ZSBkaWN0XG4gICAgaWYgKG9wdEF0dHJEaWN0ICYmICFpc1BsYWluT2JqZWN0KG9wdEF0dHJEaWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcignVGhlIG9wdEF0dHJEaWN0IGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cblxuICAgIC8vIGFkZCBub2Rlc1xuICAgIGlmICghdGhpcy5hZGouaGFzKHUpKSB7XG4gICAgICB0aGlzLmFkai5zZXQodSwgbmV3IE1hcCgpKTtcbiAgICAgIHRoaXMubm9kZS5zZXQodSwge30pO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYWRqLmhhcyh2KSkge1xuICAgICAgdGhpcy5hZGouc2V0KHYsIG5ldyBNYXAoKSk7XG4gICAgICB0aGlzLm5vZGUuc2V0KHYsIHt9KTtcbiAgICB9XG5cbiAgICB2YXIga2V5ZGljdDtcbiAgICBpZiAodGhpcy5hZGouZ2V0KHUpLmhhcyh2KSkge1xuICAgICAga2V5ZGljdCA9IHRoaXMuYWRqLmdldCh1KS5nZXQodik7XG4gICAgICBpZiAob3B0S2V5ID09IG51bGwpIHtcbiAgICAgICAgLy8gZmluZCBhIHVuaXF1ZSBpbnRlZ2VyIGtleVxuICAgICAgICAvLyBvdGhlciBtZXRob2RzIG1pZ2h0IGJlIGJldHRlciBoZXJlP1xuICAgICAgICBvcHRLZXkgPSBPYmplY3Qua2V5cyhrZXlkaWN0KS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChrZXlkaWN0W29wdEtleV0pIHsgLy8gb2ssIGJlY2F1c2UgdmFsdWVzIGFyZSBvYmplY3RzIG9ubHlcbiAgICAgICAgICBvcHRLZXkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGRhdGFkaWN0ID0ga2V5ZGljdFtvcHRLZXldIHx8IHt9O1xuICAgICAga2V5ZGljdFtvcHRLZXldID0gT2JqZWN0LmFzc2lnbihkYXRhZGljdCwgb3B0QXR0ckRpY3QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHNlbGZsb29wcyB3b3JrIHRoaXMgd2F5IHdpdGhvdXQgc3BlY2lhbCB0cmVhdG1lbnRcbiAgICAgIGlmIChvcHRLZXkgPT0gbnVsbCkge1xuICAgICAgICBvcHRLZXkgPSAwO1xuICAgICAgfVxuICAgICAga2V5ZGljdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBrZXlkaWN0W29wdEtleV0gPSBPYmplY3QuYXNzaWduKHt9LCBvcHRBdHRyRGljdCk7XG4gICAgICB0aGlzLmFkai5nZXQodSkuc2V0KHYsIGtleWRpY3QpO1xuICAgICAgdGhpcy5hZGouZ2V0KHYpLnNldCh1LCBrZXlkaWN0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFsbCB0aGUgZWRnZXMgaW4gYGVidW5jaGAuXG4gICAqXG4gICAqIEFkZGluZyB0aGUgc2FtZSBlZGdlIHR3aWNlIGhhcyBubyBlZmZlY3QgYnV0IGFueSBlZGdlIGRhdGEgd2lsbCBiZSB1cGRhdGVkXG4gICAqIHdoZW4gZWFjaCBkdXBsaWNhdGUgZWRnZSBpcyBhZGRlZC5cbiAgICpcbiAgICogRWRnZSBhdHRyaWJ1dGVzIHNwZWNpZmllZCBpbiBlZGdlcyBhcyBhIHR1cGxlIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoZVxuICAgKiBhdHRyaWJ1dGVzIHNwZWNpZmllZCBnZW5lcmFsbHkuXG4gICAqXG4gICAqICMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYFxuICAgKiB2YXIgRyA9IG5ldyBqc254Lk11bHRpR3JhcGgoKTtcbiAgICogRy5hZGRFZGdlc0Zyb20oW1swLDFdLCBbMSwyXV0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQXNzb2NpYXRlIGRhdGEgdG8gZWRnZXNcbiAgICpcbiAgICogYGBgXG4gICAqIEcuYWRkRWRnZXNGcm9tKFtbMSwyXSwgWzIsM11dLCB7d2VpZ2h0OiAzfSk7XG4gICAqIEcuYWRkRWRnZXNGcm9tKFtbMSwyXSwgWzIsM11dLCB7bGFiZWw6ICdXTjI4OTgnfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VlICNhZGRFZGdlXG4gICAqIEBzZWUgI2FkZFdlaWdodGVkRWRnZXNGcm9tXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGV9IGVidW5jaCBjb250YWluZXIgb2YgZWRnZXNcbiAgICogICAgICBFYWNoIGVkZ2UgZ2l2ZW4gaW4gdGhlIGNvbnRhaW5lciB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAgKiAgICAgIGdyYXBoLiBUaGUgZWRnZXMgY2FuIGJlOlxuICAgKlxuICAgKiAgICAgICAgICAtIDItdHVwbGVzICh1LHYpIG9yXG4gICAqICAgICAgICAgIC0gMy10dXBsZXMgKHUsdixkKSBmb3IgYW4gZWRnZSBhdHRyaWJ1dGUgZGljdCBkIG9yXG4gICAqICAgICAgICAgIC0gNC10dXBsZXMgKHUsdixrLGQpIGZvciBhbiBlZGdlIGlkZW50aWZpZWQgYnkga2V5IGtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRBdHRyRGljdCBEaWN0aW9uYXJ5IG9mIGVkZ2UgYXR0cmlidXRlcy5cbiAgICogICAgICAgS2V5L3ZhbHVlIHBhaXJzIHdpbGwgdXBkYXRlIGV4aXN0aW5nIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGVhY2ggZWRnZS5cbiAgICovXG4gIGFkZEVkZ2VzRnJvbShlYnVuY2gsIG9wdEF0dHJEaWN0KSB7XG4gICAgaWYgKG9wdEF0dHJEaWN0ICYmICFpc1BsYWluT2JqZWN0KG9wdEF0dHJEaWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcignVGhlIG9wdEF0dHJEaWN0IGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cblxuICAgIC8vIHByb2Nlc3MgZWJ1bmNoXG4gICAgZm9yRWFjaChlYnVuY2gsIGVkZ2UgPT4ge1xuICAgICAgdmFyIHU7XG4gICAgICB2YXIgdjtcbiAgICAgIHZhciBrZXk7XG4gICAgICB2YXIgZGF0YTtcblxuICAgICAgc3dpdGNoIChlZGdlLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdSA9IGVkZ2VbMF07XG4gICAgICAgICAgdiA9IGVkZ2VbMV07XG4gICAgICAgICAga2V5ID0gZWRnZVsyXTtcbiAgICAgICAgICBkYXRhID0gZWRnZVszXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHUgPSBlZGdlWzBdO1xuICAgICAgICAgIHYgPSBlZGdlWzFdO1xuICAgICAgICAgIGRhdGEgPSBlZGdlWzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdSA9IGVkZ2VbMF07XG4gICAgICAgICAgdiA9IGVkZ2VbMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFpc0FycmF5TGlrZShlZGdlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRWxlbWVudHMgaW4gZWRnZWxpc3RzIG11c3QgYmUgdHVwbGVzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKHNwcmludGYoXG4gICAgICAgICAgICAnRWRnZSB0dXBsZSAlaiBtdXN0IGJlIGEgMi10dXBsZSwgMy10dXBsZSBvciA0LXR1cGxlLicsXG4gICAgICAgICAgICBlZGdlXG4gICAgICAgICAgKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlkaWN0ID0gdGhpcy5hZGouaGFzKHUpID9cbiAgICAgICAgdGhpcy5hZGouZ2V0KHUpLmdldCh2KSB8fCBPYmplY3QuY3JlYXRlKG51bGwpIDpcbiAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgIC8vIGZpbmQgYSB1bmlxdWUgaW50ZWdlciBrZXlcbiAgICAgICAgLy8gb3RoZXIgbWV0aG9kcyBtaWdodCBiZSBiZXR0ZXIgaGVyZT9cbiAgICAgICAga2V5ID0gT2JqZWN0LmtleXMoa2V5ZGljdCkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoa2V5ZGljdFtrZXldKSB7XG4gICAgICAgICAga2V5ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBkYXRhZGljdCA9IGtleWRpY3Rba2V5XSB8fCB7fTtcbiAgICAgIE9iamVjdC5hc3NpZ24oZGF0YWRpY3QsIG9wdEF0dHJEaWN0LCBkYXRhKTtcbiAgICAgIHRoaXMuYWRkRWRnZSh1LCB2LCBrZXksIGRhdGFkaWN0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZWRnZSBiZXR3ZWVuIHUgYW5kIHYuXG4gICAqXG4gICAqICMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYFxuICAgKiB2YXIgRyA9IG5ldyBqc254Lk11bHRpR3JhcGgoKTtcbiAgICogRy5hZGRQYXRoKFswLDEsMiwzXSk7XG4gICAqIEcucmVtb3ZlRWRnZSgwLCAxKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEZvciBtdWx0aXBsZSBlZGdlc1xuICAgKlxuICAgKiBgYGBcbiAgICogdmFyIEcgPSBuZXcganNueC5NdWx0aUdyYXBoKCk7XG4gICAqIEcuYWRkRWRnZXNGcm9tKFtbMSwyXSwgWzEsMl0sIFsxLDJdXSk7XG4gICAqIEcucmVtb3ZlRWRnZSgxLCAyKTsgLy8gcmVtb3ZlIGEgc2luZ2xlIGVkZ2VcbiAgICogYGBgXG4gICAqXG4gICAqIEZvciBlZGdlcyB3aXRoIGtleXNcbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBHID0gbmV3IGpzbnguTXVsdGlHcmFwaCgpO1xuICAgKiBHLmFkZEVkZ2UoMSwgMiwgJ2ZpcnN0Jyk7XG4gICAqIEcuYWRkRWRnZSgxLCAyLCAnc2Vjb25kJyk7XG4gICAqIEcucmVtb3ZlRWRnZSgxLCAyLCAnc2Vjb25kJyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VlICNyZW1vdmVFZGdlc0Zyb21cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB1XG4gICAqIEBwYXJhbSB7Tm9kZX0gdlxuICAgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKT19IG9wdEtleVxuICAgKiAgICAgIFVzZWQgdG8gZGlzdGluZ3Vpc2ggbXVsdGlwbGUgZWRnZXMgYmV0d2VlbiBhIHBhaXIgb2Ygbm9kZXMuXG4gICAqICAgICAgSWYgbnVsbCBvciB1bmRlZmluZWQgcmVtb3ZlIGEgc2luZ2xlIChhcmJpdHJhcnkpIGVkZ2UgYmV0d2VlbiB1IGFuZCB2LlxuICAgKi9cbiAgcmVtb3ZlRWRnZSh1LCB2LCBvcHRLZXkpIHtcbiAgICB2YXIga2V5ZGljdDtcbiAgICB2YXIgbmVpZ2h0Ym9yc09mVSA9IHRoaXMuYWRqLmdldCh1KTtcbiAgICBpZiAobmVpZ2h0Ym9yc09mVSkge1xuICAgICAga2V5ZGljdCA9IG5laWdodGJvcnNPZlUuZ2V0KHYpO1xuICAgIH1cbiAgICBpZiAoa2V5ZGljdCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKFxuICAgICAgICBzcHJpbnRmKCdUaGUgZWRnZSAlai0laiBpcyBub3QgaW4gdGhlIGdyYXBoJywgdSwgdilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHRoZSBlZGdlIHdpdGggc3BlY2lmaWVkIGRhdGFcbiAgICBpZiAob3B0S2V5ID09IG51bGwpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBrZXlkaWN0KSB7XG4gICAgICAgIGRlbGV0ZSBrZXlkaWN0W2tleV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICgha2V5ZGljdFtvcHRLZXldKSB7XG4gICAgICAgIHRocm93IG5ldyBKU05ldHdvcmtYRXJyb3Ioc3ByaW50ZihcbiAgICAgICAgICAnVGhlIGVkZ2UgJWotJWogd2l0aCBrZXkgJWogaXMgbm90IGluIHRoZSBncmFwaCcsXG4gICAgICAgICAgdSxcbiAgICAgICAgICB2LFxuICAgICAgICAgIG9wdEtleVxuICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBrZXlkaWN0W29wdEtleV07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhrZXlkaWN0KS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIHJlbW92ZSB0aGUga2V5IGVudHJpZXMgaWYgbGFzdCBlZGdlXG4gICAgICBuZWlnaHRib3JzT2ZVLmRlbGV0ZSh2KTtcbiAgICAgIGlmICghbm9kZXNBcmVFcXVhbCh1LCB2KSkge1xuICAgICAgICB0aGlzLmFkai5nZXQodikuZGVsZXRlKHUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGVkZ2VzIHNwZWNpZmllZCBpbiBgZWJ1bmNoYC5cbiAgICpcbiAgICogV2lsbCBmYWlsIHNpbGVudGx5IGlmIGFuIGVkZ2UgaW4gYGVidW5jaGAgaXMgbm90IGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBHID0gbmV3IGpzbnguTXVsdGlHcmFwaCgpO1xuICAgKiBHLmFkZFBhdGgoWzAsMSwyLDNdKTtcbiAgICogdmFyIGVidW5jaCA9IFtbMSwyXSwgWzIsM11dO1xuICAgKiBHLnJlbW92ZUVkZ2VzRnJvbShlYnVuY2gpO1xuICAgKiBgYGBcbiAgICpcbiAgICogUmVtb3ZpbmcgbXVsdGlwbGUgY29waWVzIG9mIGVkZ2VzLlxuICAgKlxuICAgKiBgYGBcbiAgICogdmFyIEcgPSBuZXcganNueC5NdWx0aUdyYXBoKCk7XG4gICAqIEcuYWRkRWRnZXNGcm9tKFtbMSwyXSwgWzEsMl0sIFsxLDJdXSk7XG4gICAqIEcucmVtb3ZlRWRnZXNGcm9tKFtbMSwyXSwgWzEsMl1dKTtcbiAgICogRy5lZGdlcygpO1xuICAgKiAvLyBbWzEsMl1dXG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VlICNyZW1vdmVFZGdlXG4gICAqXG4gICAqIEBwYXJhbSB7P30gZWJ1bmNoIGxpc3Qgb3IgY29udGFpbmVyIG9mIGVkZ2UgdHVwbGVzXG4gICAqICAgICAgRWFjaCBlZGdlIGdpdmVuIGluIHRoZSBsaXN0IG9yIGNvbnRhaW5lciB3aWxsIGJlIHJlbW92ZWRcbiAgICogICAgICBmcm9tIHRoZSBncmFwaC4gVGhlIGVkZ2VzIGNhbiBiZTpcbiAgICpcbiAgICogICAgICAgIC0gMi10dXBsZXMgKHUsdikgQWxsIGVkZ2VzIGJldHdlZW4gdSBhbmQgdiBhcmUgcmVtb3ZlZC5cbiAgICogICAgICAgIC0gMy10dXBsZXMgKHUsdixrZXkpIFRoZSBlZGdlIGlkZW50aWZpZWQgYnkga2V5IGlzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmVFZGdlc0Zyb20oZWJ1bmNoKSB7XG4gICBmb3JFYWNoKGVidW5jaCwgZWRnZSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnJlbW92ZUVkZ2UoZWRnZVswXSwgZWRnZVsxXSwgZWRnZVsyXSk7XG4gICAgICB9XG4gICAgICBjYXRjaChleCkge1xuICAgICAgICBpZiAoIShleCBpbnN0YW5jZW9mIEpTTmV0d29ya1hFcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBUcnVlIGlmIHRoZSBncmFwaCBoYXMgYW4gZWRnZSBiZXR3ZWVuIG5vZGVzIHUgYW5kIHYuXG4gICAqXG4gICAqICMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYFxuICAgKiB2YXIgRyA9IG5ldyBqc254Lk11bHRpR3JhcGgoKTtcbiAgICogRy5hZGRQYXRoKFswLDEsMiwzXSk7XG4gICAqIEcuaGFzRWRnZSgwLDEpO1xuICAgKiAvLyB0cnVlXG4gICAqIEcuYWRkRWRnZSgwLCAxLCAnYScpO1xuICAgKiBHLmhhc0VkZ2UoMCwgMSwgJ2EnKTtcbiAgICogLy8gdHJ1ZVxuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBzeW50YXggYXJlIGVxdWl2YWxlbnQ6XG4gICAqXG4gICAqIGBgYFxuICAgKiBHLmhhc0VkZ2UoMCwgMSk7XG4gICAqIC8vIHRydWVcbiAgICogRy5nZXQoMCkuaGFzKDEpO1xuICAgKiAvLyB0cnVlXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHUgbm9kZVxuICAgKiBAcGFyYW0ge05vZGV9IHYgbm9kZVxuICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKT19IG9wdEtleSBJZiBzcGVjaWZpZWQgcmV0dXJuIHRydWUgb25seVxuICAgKiAgICAgIGlmIHRoZSBlZGdlIHdpdGgga2V5IGlzIGZvdW5kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGVkZ2UgaXMgaW4gdGhlIGdyYXBoLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBoYXNFZGdlKHUsIHYsIG9wdEtleSkge1xuICAgIHZhciBuZWlnaGJvcnNPZlUgPSB0aGlzLmFkai5nZXQodSk7XG4gICAgaWYgKG5laWdoYm9yc09mVSkge1xuICAgICAgcmV0dXJuIG5laWdoYm9yc09mVS5oYXModikgJiZcbiAgICAgICAgKG9wdEtleSA9PSBudWxsIHx8ICEhbmVpZ2hib3JzT2ZVLmdldCh2KVtvcHRLZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGxpc3Qgb2YgZWRnZXMuXG4gICAqXG4gICAqIEVkZ2VzIGFyZSByZXR1cm5lZCBhcyB0dXBsZXMgd2l0aCBvcHRpb25hbCBkYXRhIGFuZCBrZXlzIGluIHRoZSBvcmRlclxuICAgKiAobm9kZSwgbmVpZ2hib3IsIGtleSwgZGF0YSkuXG4gICAqXG4gICAqIE5vZGVzIGluIGBuYnVuY2hgIHRoYXQgYXJlIG5vdCBpbiB0aGUgZ3JhcGggd2lsbCBiZSAocXVpZXRseSkgaWdub3JlZC5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBHID0gbmV3IGpzbnguTXVsdGlHcmFwaCgpO1xuICAgKiBHLmFkZFBhdGgoWzAsMSwyLDNdKTtcbiAgICogRy5lZGdlcygpO1xuICAgKiAvLyBbWzAsMV0sIFsxLDJdLCBbMiwzXV1cbiAgICogRy5lZGdlcyh0cnVlKTtcbiAgICogLy8gW1swLDEse31dLCBbMSwyLHt9XSwgWzIsMyx7fV1dXG4gICAqIEcuZWRnZXMoZmFsc2UsIHRydWUpO1xuICAgKiAvLyBbWzAsMSwwXSwgWzEsMiwwXSwgWzIsMywwXV1cbiAgICogRy5lZGdlcyh0cnVlLCB0cnVlKTtcbiAgICogLy8gW1swLDEsMCx7fV0sIFsxLDIsMCx7fV0sIFsyLDMsMCx7fV1dXG4gICAqIEcuZWRnZXMoWzAsM10pO1xuICAgKiAvLyBbWzAsMV0sIFszLCAyXV1cbiAgICogRy5lZGdlcygwKTtcbiAgICogLy8gW1swLDFdXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHNlZSAjZWRnZXNJdGVyXG4gICAqXG4gICAqIEBwYXJhbSB7P05vZGVDb250YWluZXI9fSBvcHROYnVuY2ggQSBjb250YWluZXIgb2Ygbm9kZXMuXG4gICAqICAgICAgVGhlIGNvbnRhaW5lciB3aWxsIGJlIGl0ZXJhdGVkIHRocm91Z2ggb25jZS5cbiAgICogQHBhcmFtIHs/Ym9vbGVhbj19IG9wdERhdGEgKGRlZmF1bHQ9RmFsc2UpXG4gICAqICAgICAgUmV0dXJuIHR3byB0dXBsZXMgKHUsdikgKEZhbHNlKSBvciB0aHJlZS10dXBsZXMgKHUsdixkYXRhKSAoVHJ1ZSkuXG4gICAqIEBwYXJhbSB7P2Jvb2xlYW49fSBvcHRLZXlzIChkZWZhdWx0PUZhbHNlKVxuICAgKiAgICAgIFJldHVybiB0d28gdHVwbGVzICh1LHYpIChGYWxzZSkgb3IgdGhyZWUtdHVwbGVzICh1LHYsa2V5KSAoVHJ1ZSkuXG4gICAqXG4gICAqIEByZXR1cm4geyFBcnJheX0gbGlzdCBvZiBlZGdlIHR1cGxlc1xuICAgKiAgICAgIEVkZ2VzIHRoYXQgYXJlIGFkamFjZW50IHRvIGFueSBub2RlIGluIG5idW5jaCwgb3IgYSBsaXN0XG4gICAqICAgICAgb2YgYWxsIGVkZ2VzIGlmIG5idW5jaCBpcyBub3Qgc3BlY2lmaWVkLlxuICAgKi9cbiAgZWRnZXMob3B0TmJ1bmNoLCBvcHREYXRhLCBvcHRLZXlzKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lZGdlc0l0ZXIob3B0TmJ1bmNoLCBvcHREYXRhLCBvcHRLZXlzKSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaXRlcmF0b3Igb3ZlciBlZGdlcy5cbiAgICpcbiAgICogRWRnZXMgYXJlIHJldHVybmVkIGFzIHR1cGxlcyB3aXRoIG9wdGlvbmFsIGRhdGEgYW5kIGtleXNcbiAgICogaW4gdGhlIG9yZGVyIChub2RlLCBuZWlnaGJvciwga2V5LCBkYXRhKS5cbiAgICpcbiAgICogTm9kZXMgaW4gbmJ1bmNoIHRoYXQgYXJlIG5vdCBpbiB0aGUgZ3JhcGggd2lsbCBiZSAocXVpZXRseSkgaWdub3JlZC5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBHID0gbmV3IGpzbnguTXVsdGlHcmFwaCgpO1xuICAgKiBHLmFkZFBhdGgoWzAsMSwyLDNdKTtcbiAgICogQXJyYXkuZnJvbShHLmVkZ2VzSXRlcik7XG4gICAqIC8vIFtbMCwxXSwgWzEsMl0sIFsyLDNdXVxuICAgKiBBcnJheS5mcm9tKEcuZWRnZXModHJ1ZSkpO1xuICAgKiAvLyBbWzAsMSx7fV0sIFsxLDIse31dLCBbMiwzLHt9XV1cbiAgICogQXJyYXkuZnJvbShHLmVkZ2VzKGZhbHNlLCB0cnVlKSk7XG4gICAqIC8vIFtbMCwxLDBdLCBbMSwyLDBdLCBbMiwzLDBdXVxuICAgKiBBcnJheS5mcm9tKEcuZWRnZXModHJ1ZSwgdHJ1ZSkpO1xuICAgKiAvLyBbWzAsMSwwLHt9XSwgWzEsMiwwLHt9XSwgWzIsMywwLHt9XV1cbiAgICogQXJyYXkuZnJvbShHLmVkZ2VzKFswLDNdKSk7XG4gICAqIC8vIFtbMCwxXSwgWzMsIDJdXVxuICAgKiBBcnJheS5mcm9tKEcuZWRnZXMoMCkpO1xuICAgKiAvLyBbWzAsMV1dXG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VlICNlZGdlc1xuICAgKlxuICAgKiBAcGFyYW0gez8oTm9kZUNvbnRhaW5lcnxib29sZWFuKT19IG9wdE5idW5jaCBBIGNvbnRhaW5lciBvZiBub2Rlcy5cbiAgICogICAgICBUaGUgY29udGFpbmVyIHdpbGwgYmUgaXRlcmF0ZWQgdGhyb3VnaCBvbmNlLlxuICAgKiBAcGFyYW0gez9ib29sZWFuPX0gb3B0RGF0YSAoZGVmYXVsdD1GYWxzZSlcbiAgICogICAgICBJZiBUcnVlLCByZXR1cm4gZWRnZSBhdHRyaWJ1dGUgZGljdCB3aXRoIGVhY2ggZWRnZS5cbiAgICogQHBhcmFtIHs/Ym9vbGVhbj19IG9wdEtleXMgKGRlZmF1bHQ9RmFsc2UpXG4gICAqICAgICAgSWYgVHJ1ZSwgcmV0dXJuIGVkZ2Uga2V5cyB3aXRoIGVhY2ggZWRnZS5cbiAgICpcbiAgICogQHJldHVybiB7IUl0ZXJhdG9yfVxuICAgKiAgICAgIEFuIGl0ZXJhdG9yIG9mICh1LHYpLCAodSx2LGQpIG9yICh1LHYsa2V5LGQpIHR1cGxlcyBvZiBlZGdlcy5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqIEBleHBvcnRcbiAgICovXG4gICplZGdlc0l0ZXIob3B0TmJ1bmNoLCBvcHREYXRhPWZhbHNlLCBvcHRLZXlzPWZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHROYnVuY2ggPT09ICdib29sZWFuJykge1xuICAgICAgb3B0S2V5cyA9IG9wdERhdGE7XG4gICAgICBvcHREYXRhID0gb3B0TmJ1bmNoO1xuICAgICAgb3B0TmJ1bmNoID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgc2VlbiA9IG5ldyBTZXQoKTtcblxuICAgIHZhciBub2Rlc05icnMgPSBvcHROYnVuY2ggPT0gbnVsbCA/XG4gICAgICB0aGlzLmFkaiA6XG4gICAgICBtYXBJdGVyYXRvcih0aGlzLm5idW5jaEl0ZXIob3B0TmJ1bmNoKSwgbiA9PiB0dXBsZTIobiwgdGhpcy5hZGouZ2V0KG4pKSk7XG5cbiAgICBmb3IgKHZhciBbbiwgbmJyc10gb2Ygbm9kZXNOYnJzKSB7XG4gICAgICBmb3IgKHZhciBbbmJyLCBrZXlkaWN0XSBvZiBuYnJzKSB7XG4gICAgICAgIGlmICghc2Vlbi5oYXMobmJyKSkge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlkaWN0KSB7XG4gICAgICAgICAgICB2YXIgdHVwbGUgPSBbbiwgbmJyXTtcbiAgICAgICAgICAgIGlmIChvcHRLZXlzKSB7XG4gICAgICAgICAgICAgIHR1cGxlWzJdID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdERhdGEpIHtcbiAgICAgICAgICAgICAgdHVwbGUucHVzaChrZXlkaWN0W2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdHVwbGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlZW4uYWRkKG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYXR0cmlidXRlIGRpY3Rpb25hcnkgYXNzb2NpYXRlZCB3aXRoIGVkZ2UgKHUsdikuXG4gICAqXG4gICAqICMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYFxuICAgKiB2YXIgRyA9IGpzbnguTXVsdGlHcmFwaCgpO1xuICAgKiBHLmFkZFBhdGgoWzAsMSwyLDNdKTtcbiAgICogRy5nZXRFZGdlRGF0YSgwLCAxKTtcbiAgICogLy8gezA6IHt9fVxuICAgKiBHLmdldEVkZ2VEYXRhKCdhJywgJ2InLCBudWxsLCAwKTsgLy8gZWRnZSBub3QgaW4gZ3JhcGgsIHJldHVybiAwXG4gICAqIC8vIDBcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdSBub2RlXG4gICAqIEBwYXJhbSB7Tm9kZX0gdiBub2RlXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpPX0gb3B0S2V5IFJldHVybiBkYXRhIG9ubHkgZm9yIHRoZSBlZGdlIHdpdGhcbiAgICogICAgICBzcGVjaWZpZWQga2V5LlxuICAgKiBAcGFyYW0ge1Q9fSBvcHREZWZhdWx0IFZhbHVlIHRvIHJldHVybiBpZiB0aGUgZWRnZSAodSx2KSBpcyBub3QgZm91bmQuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8VCl9IFRoZSBlZGdlIGF0dHJpYnV0ZSBkaWN0aW9uYXJ5LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgZ2V0RWRnZURhdGEodSwgdiwgb3B0S2V5LCBvcHREZWZhdWx0KSB7XG4gICAgdmFyIG5laWdodGJvcnNPZlUgPSB0aGlzLmFkai5nZXQodSk7XG4gICAgaWYgKG5laWdodGJvcnNPZlUpIHtcbiAgICAgIGlmIChvcHRLZXkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmVpZ2h0Ym9yc09mVS5nZXQodikgfHwgb3B0RGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZWlnaHRib3JzT2ZVLmhhcyh2KSAmJiBuZWlnaHRib3JzT2ZVLmdldCh2KVtvcHRLZXldIHx8IG9wdERlZmF1bHQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpdGVyYXRvciBmb3IgKG5vZGUsIGRlZ3JlZSkuXG4gICAqXG4gICAqIFRoZSBub2RlIGRlZ3JlZSBpcyB0aGUgbnVtYmVyIG9mIGVkZ2VzIGFkamFjZW50IHRvIHRoZSBub2RlLlxuICAgKlxuICAgKiAjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBcbiAgICogdmFyIEcgPSBuZXcganNueC5HcmFwaCgpO1xuICAgKiBHLmFkZFBhdGgoWzAsMSwyLDNdKTtcbiAgICogQXJyYXkuZnJvbShHLmRlZ3JlZUl0ZXIoMCkpO1xuICAgKiAvLyBbWzAsMV1dICAvLyBub2RlIDAgd2l0aCBkZWdyZWUgMVxuICAgKiBBcnJheS5mcm9tKEcuZGVncmVlSXRlcihbMCwxXSkpO1xuICAgKiAvLyBbWzAsMV0sIFsxLDJdXVxuICAgKlxuICAgKiBAc2VlICNkZWdyZWVcbiAgICpcbiAgICogQHBhcmFtIHs/KE5vZGV8Tm9kZUNvbnRhaW5lcik9fSBvcHROYnVuY2ggIEEgY29udGFpbmVyIG9mIG5vZGVzXG4gICAqICAgICAgVGhlIGNvbnRhaW5lciB3aWxsIGJlIGl0ZXJhdGVkIHRocm91Z2ggb25jZS5cbiAgICogQHBhcmFtIHs/c3RyaW5nPX0gb3B0V2VpZ2h0ICBUaGUgZWRnZSBhdHRyaWJ1dGUgdGhhdCBob2xkcyB0aGUgbnVtZXJpY2FsXG4gICAqICAgICAgdmFsdWUgdXNlZCBhcyBhIHdlaWdodC4gIElmIHVuZGVmaW5lZCwgdGhlbiBlYWNoIGVkZ2UgaGFzIHdlaWdodCAxLlxuICAgKiAgICAgIFRoZSBkZWdyZWUgaXMgdGhlIHN1bSBvZiB0aGUgZWRnZSB3ZWlnaHRzIGFkamFjZW50IHRvIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHshSXRlcmF0b3J9IFRoZSBpdGVyYXRvciByZXR1cm5zIHR3by10dXBsZXMgb2YgKG5vZGUsIGRlZ3JlZSkuXG4gICAqL1xuICAqZGVncmVlSXRlcihvcHROYnVuY2gsIG9wdFdlaWdodCkge1xuICAgIGlmICh0eXBlb2Ygb3B0TmJ1bmNoID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0V2VpZ2h0ID0gb3B0TmJ1bmNoO1xuICAgICAgb3B0TmJ1bmNoID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIG5vZGVzTmJycyA9IG9wdE5idW5jaCA9PSBudWxsID9cbiAgICAgIHRoaXMuYWRqIDpcbiAgICAgIG1hcEl0ZXJhdG9yKHRoaXMubmJ1bmNoSXRlcihvcHROYnVuY2gpLCBuID0+IHR1cGxlMihuLCB0aGlzLmFkai5nZXQobikpKTtcblxuICAgIGZvciAodmFyIFtuLCBuYnJzXSBvZiBub2Rlc05icnMpIHtcbiAgICAgIHZhciBkZWcgPSAwO1xuICAgICAgaWYgKG9wdFdlaWdodCA9PSBudWxsKSB7XG4gICAgICAgIG5icnMuZm9yRWFjaChrZXlkaWN0ID0+IGRlZyArPSBPYmplY3Qua2V5cyhrZXlkaWN0KS5sZW5ndGgpO1xuICAgICAgICB5aWVsZCBbbiwgZGVnICsgKCsobmJycy5oYXMobikgJiYgT2JqZWN0LmtleXMobmJycy5nZXQobikpLmxlbmd0aCkpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVkZ2Ugd2VpZ2h0ZWQgZ3JhcGggLSBkZWdyZWUgaXMgc3VtIG9mIG5iciBlZGdlIHdlaWdodHNcbiAgICAgICAgbmJycy5mb3JFYWNoKGtleWRpY3QgPT4ge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlkaWN0KSB7XG4gICAgICAgICAgICBkZWcgKz0gZ2V0RGVmYXVsdChrZXlkaWN0W2tleV1bb3B0V2VpZ2h0XSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobmJycy5oYXMobikpIHtcbiAgICAgICAgICB2YXIga2V5ZGljdCA9IG5icnMuZ2V0KG4pO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlkaWN0KSB7XG4gICAgICAgICAgICBkZWcgKz0gZ2V0RGVmYXVsdChrZXlkaWN0W2tleV1bb3B0V2VpZ2h0XSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgeWllbGQgW24sIGRlZ107XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGdyYXBoIGlzIGEgbXVsdGlncmFwaCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGdyYXBoIGlzIGEgbXVsdGlncmFwaCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNNdWx0aWdyYXBoKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGdyYXBoIGlzIGRpcmVjdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIGdyYXBoIGlzIGRpcmVjdGVkLCBGYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0RpcmVjdGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBkaXJlY3RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ3JhcGguXG4gICAqXG4gICAqICMjIyBOb3Rlc1xuICAgKlxuICAgKiBUaGlzIHJldHVybnMgYSBcImRlZXBjb3B5XCIgb2YgdGhlIGVkZ2UsIG5vZGUsIGFuZCBncmFwaCBhdHRyaWJ1dGVzIHdoaWNoXG4gICAqIGF0dGVtcHRzIHRvIGNvbXBsZXRlbHkgY29weSBhbGwgb2YgdGhlIGRhdGEgYW5kIHJlZmVyZW5jZXMuXG4gICAqXG4gICAqIFRoaXMgaXMgaW4gY29udHJhc3QgdG8gdGhlIHNpbWlsYXIgRCA9IERpR3JhcGgoRykgd2hpY2ggcmV0dXJucyBhIHNoYWxsb3dcbiAgICogY29weSBvZiB0aGUgZGF0YS5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBHID0gbmV3IGpzbnguTXVsdGlHcmFwaCgpO1xuICAgKiBHLmFkZFBhdGgoWzAsMV0pO1xuICAgKiB2YXIgSCA9IEcudG9EaXJlY3RlZCgpO1xuICAgKiBHLmVkZ2VzKCk7XG4gICAqIC8vIFtbMCwxXSwgWzEsMF1dXG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiBhbHJlYWR5IGRpcmVjdGVkLCByZXR1cm4gYSAoZGVlcCkgY29weVxuICAgKlxuICAgKiBgYGBcbiAgICogdmFyIEcgPSBuZXcganNueC5NdWx0aURpR3JhcGgoKTtcbiAgICogRy5hZGRQYXRoKFswLDFdKTtcbiAgICogdmFyIEggPSBHLnRvRGlyZWN0ZWQoKTtcbiAgICogRy5lZGdlcygpO1xuICAgKiAvLyBbWzAsMV1dXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJuIHshTXVsdGlEaUdyYXBofVxuICAgKiAgICAgIEEgZGlyZWN0ZWQgZ3JhcGggd2l0aCB0aGUgc2FtZSBuYW1lLCBzYW1lIG5vZGVzLCBhbmQgd2l0aFxuICAgKiAgICAgIGVhY2ggZWRnZSAodSx2LGRhdGEpIHJlcGxhY2VkIGJ5IHR3byBkaXJlY3RlZCBlZGdlc1xuICAgKiAgICAgICh1LHYsZGF0YSkgYW5kICh2LHUsZGF0YSkuXG4gICAqL1xuICB0b0RpcmVjdGVkKCkge1xuICAgIHZhciBHID0gbmV3IChyZXF1aXJlKCcuL011bHRpRGlHcmFwaCcpKSgpO1xuICAgIEcuYWRkTm9kZXNGcm9tKHRoaXMpO1xuICAgIGZvciAodmFyIFt1LCBuYnJzXSBvZiB0aGlzLmFkamFjZW5jeUl0ZXIoKSkge1xuICAgICAgZm9yICh2YXIgW3YsIGtleWRpY3RdIG9mIG5icnMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGtleWRpY3QpIHtcbiAgICAgICAgICAgIEcuYWRkRWRnZSh1LCB2LCBrZXksIGRlZXBjb3B5KGtleWRpY3Rba2V5XSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIEcuZ3JhcGggPSBkZWVwY29weSh0aGlzLmdyYXBoKTtcbiAgICBHLm5vZGUgPSBkZWVwY29weSh0aGlzLm5vZGUpO1xuICAgIHJldHVybiBHO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGxpc3Qgb2Ygc2VsZmxvb3AgZWRnZXMuXG4gICAqXG4gICAqICMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYFxuICAgKiB2YXIgRyA9IG5ldyBqc254Lk11bHRpR3JhcGgoKTtcbiAgICogRy5hZGRFZGdlKDEsIDEpO1xuICAgKiBHLmFkZEVkZ2UoMSwgMik7XG4gICAqIEcuc2VsZmxvb3BFZGdlcygpO1xuICAgKiAvLyBbWzEsMV1dXG4gICAqIEcuc2VsZmxvb3BFZGdlcyh0cnVlKTtcbiAgICogLy8gW1sxLDEse31dXVxuICAgKiBHLnNlbGZsb29wRWRnZXMoZmFsc2UsIHRydWUpO1xuICAgKiAvLyBbWzEsMSwwXV1cbiAgICogRy5zZWxmbG9vcEVkZ2VzKHRydWUsIHRydWUpO1xuICAgKiAvLyBbWzEsMSwwLHt9XV1cbiAgICpcbiAgICogQHNlZSAjbm9kZXNXaXRoU2VsZmxvb3BzXG4gICAqIEBzZWUgI251bWJlck9mU2VsZmxvb3BzXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdERhdGEgIChkZWZhdWx0PUZhbHNlKVxuICAgKiAgICAgIFJldHVybiBzZWxmbG9vcCBlZGdlcyBhcyB0d28gdHVwbGVzICh1LHYpIChkYXRhPUZhbHNlKVxuICAgKiAgICAgIG9yIHRocmVlLXR1cGxlcyAodSx2LGRhdGEpIChkYXRhPVRydWUpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdEtleXMgIChkZWZhdWx0PUZhbHNlKVxuICAgKiAgICAgICBJZiBUcnVlLCByZXR1cm4gZWRnZSBrZXlzIHdpdGggZWFjaCBlZGdlXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBIGxpc3Qgb2YgYWxsIHNlbGZsb29wIGVkZ2VzXG4gICAqL1xuICBzZWxmbG9vcEVkZ2VzKG9wdERhdGE9ZmFsc2UsIG9wdEtleXM9ZmFsc2UpIHtcbiAgICB2YXIgZWRnZXMgPSBbXTtcbiAgICBmb3IgKHZhciBbbiwgbmJyc10gb2YgdGhpcy5hZGopXG4gICAgICBpZiAobmJycy5oYXMobikpIHtcbiAgICAgICAgdmFyIGtleWRpY3QgPSBuYnJzLmdldChuKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGtleWRpY3QpIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IFtuLCBuXTtcbiAgICAgICAgICBpZiAob3B0S2V5cykge1xuICAgICAgICAgICAgZWRnZVsyXSA9IGtleTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdERhdGEpIHtcbiAgICAgICAgICAgIGVkZ2UucHVzaChrZXlkaWN0W2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgcmV0dXJuIGVkZ2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGVkZ2VzIGJldHdlZW4gdHdvIG5vZGVzLlxuICAgKlxuICAgKiAjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBcbiAgICogdmFyIEcgPSBuZXcganNueC5NdWx0aUdyYXBoKCk7XG4gICAqIEcuYWRkUGF0aChbMCwxLDIsM10pO1xuICAgKiBHLm51bWJlck9mRWRnZXMoKTtcbiAgICogLy8gM1xuICAgKiBHLm51bWJlck9mRWRnZXMoMCwxKTtcbiAgICogLy8gMVxuICAgKiBgYGBcbiAgICpcbiAgICogQHNlZSAjc2l6ZVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGU9fSBvcHRVIG5vZGVcbiAgICogQHBhcmFtIHtOb2RlPX0gb3B0ViBub2RlXG4gICAqICAgICAgSWYgdSBhbmQgdiBhcmUgc3BlY2lmaWVkLCByZXR1cm4gdGhlIG51bWJlciBvZiBlZGdlcyBiZXR3ZWVuXG4gICAqICAgICAgdSBhbmQgdi4gT3RoZXJ3aXNlIHJldHVybiB0aGUgdG90YWwgbnVtYmVyIG9mIGFsbCBlZGdlcy5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGVkZ2VzIGluIHRoZSBncmFwaC5cbiAgICogICAgICBJZiBub2RlcyB1IGFuZCB2IGFyZSBzcGVjaWZpZWQgcmV0dXJuIHRoZSBudW1iZXIgb2YgZWRnZXMgYmV0d2VlblxuICAgKiAgICAgIHRob3NlIG5vZGVzLlxuICAgKi9cbiAgbnVtYmVyT2ZFZGdlcyhvcHRVLCBvcHRWKSB7XG4gICAgaWYgKG9wdFUgPT0gbnVsbCB8fCBvcHRWID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemUoKTtcbiAgICB9XG5cbiAgICB2YXIgbmVpZ2h0Ym9yc09mVSA9IHRoaXMuZ2V0KG9wdFUpO1xuICAgIGlmIChuZWlnaHRib3JzT2ZVKSB7XG4gICAgICByZXR1cm4gbmVpZ2h0Ym9yc09mVS5oYXMob3B0VikgP1xuICAgICAgICBPYmplY3Qua2V5cyhuZWlnaHRib3JzT2ZVLmdldChvcHRWKSkubGVuZ3RoIDpcbiAgICAgICAgMDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdWJncmFwaCBpbmR1Y2VkIG9uIG5vZGVzIGluIG5idW5jaC5cbiAgICpcbiAgICogVGhlIGluZHVjZWQgc3ViZ3JhcGggb2YgdGhlIGdyYXBoIGNvbnRhaW5zIHRoZSBub2RlcyBpbiBuYnVuY2ggYW5kIHRoZVxuICAgKiBlZGdlcyBiZXR3ZWVuIHRob3NlIG5vZGVzLlxuICAgKlxuICAgKiAjIyMgTm90ZXNcbiAgICpcbiAgICogVGhlIGdyYXBoLCBlZGdlIG9yIG5vZGUgYXR0cmlidXRlcyBqdXN0IHBvaW50IHRvIHRoZSBvcmlnaW5hbCBncmFwaC5cbiAgICogU28gY2hhbmdlcyB0byB0aGUgbm9kZSBvciBlZGdlIHN0cnVjdHVyZSB3aWxsIG5vdCBiZSByZWZsZWN0ZWQgaW5cbiAgICogdGhlIG9yaWdpbmFsIGdyYXBoIHdoaWxlIGNoYW5nZXMgdG8gdGhlIGF0dHJpYnV0ZXMgd2lsbC5cbiAgICpcbiAgICogVG8gY3JlYXRlIGEgc3ViZ3JhcGggd2l0aCBpdHMgb3duIGNvcHkgb2YgdGhlIGVkZ2Uvbm9kZSBhdHRyaWJ1dGVzIHVzZTpcbiAgICogYGpzbnguR3JhcGgoRy5zdWJncmFwaChuYnVuY2gpKWBcbiAgICpcbiAgICogSWYgZWRnZSBhdHRyaWJ1dGVzIGFyZSBjb250YWluZXJzLCBhIGRlZXAgY29weSBjYW4gYmUgb2J0YWluZWQgdXNpbmc6XG4gICAqIGBHLnN1YmdyYXBoKG5idW5jaCkuY29weSgpYC5cbiAgICpcbiAgICogIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBHID0gbmV3IGpzbnguR3JhcGgoKTtcbiAgICogRy5hZGRQYXRoKFswLDEsMiwzXSk7XG4gICAqIHZhciBIID0gRy5zdWJncmFwaChbMCwxLDJdKTtcbiAgICogSC5lZGdlcygpO1xuICAgKiAvLyBbWzAsMV0sIFsxLDJdXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlQ29udGFpbmVyPX0gbmJ1bmNoIEEgY29udGFpbmVyIG9mIG5vZGVzIHdoaWNoIHdpbGwgYmVcbiAgICogICAgICBpdGVyYXRlZCB0aHJvdWdoIG9uY2UuXG4gICAqIEByZXR1cm4ge011bHRpR3JhcGh9IEEgc3ViZ3JhcGggb2YgdGhlIGdyYXBoIHdpdGggdGhlIHNhbWUgZWRnZSBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgc3ViZ3JhcGgobmJ1bmNoKSB7XG4gICAgdmFyIGJ1bmNoID0gdGhpcy5uYnVuY2hJdGVyKG5idW5jaCk7XG4gICAgLy8gY3JlYXRlIG5ldyBncmFwaCBhbmQgY29weSBzdWJncmFwaCBpbnRvIGl0XG4gICAgdmFyIEggPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgIC8vIGNvcHkgbm9kZSBhbmQgYXR0cmlidXRlIGRpY3Rpb25hcmllc1xuICAgIHRoaXMubm9kZS5mb3JFYWNoKChkLCBuKSA9PiBILm5vZGUuc2V0KG4sIGQpKTtcbiAgICAvLyBuYW1lc3BhY2Ugc2hvcnRjdXRzIGZvciBzcGVlZFxuICAgIHZhciBIQWRqID0gSC5hZGosXG4gICAgdGhpc0FkaiA9IHRoaXMuYWRqO1xuXG4gICAgLy8gYWRkIG5vZGVzIGFuZCBlZGdlcyAodW5kaXJlY3RlZCBtZXRob2QpXG4gICAgZm9yICh2YXIgbiBvZiBidW5jaCkge1xuICAgICAgdmFyIEhuYnJzID0gbmV3IE1hcCgpO1xuICAgICAgSEFkai5zZXQobiwgSG5icnMpO1xuXG4gICAgICBmb3IgKHZhciBbbmJyLCBlZGdlZGljdF0gb2YgdGhpc0Fkai5nZXQobikpIHtcbiAgICAgICAgaWYgKEhBZGouaGFzKG5icikpIHtcbiAgICAgICAgICAvLyBhZGQgYm90aCByZXByZXNlbnRhdGlvbnMgb2YgZWRnZTogbi1uYnIgYW5kIG5ici1uXG4gICAgICAgICAgLy8gdGhleSBzaGFyZSB0aGUgc2FtZSBlZGdlZGljdFxuICAgICAgICAgIHZhciBlZCA9IGNsb25lKGVkZ2VkaWN0KTtcbiAgICAgICAgICBIbmJycy5zZXQobmJyLCBlZCk7XG4gICAgICAgICAgSEFkai5nZXQobmJyKS5zZXQobiwgZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIEguZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgIHJldHVybiBIO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEpTTmV0d29ya1hFcnJvciBmcm9tICcuLi9leGNlcHRpb25zL0pTTmV0d29ya1hFcnJvcic7XG5cbmltcG9ydCB7XG4gIGZpbGxBcnJheSxcbiAgaXNNYXAsXG4gIGlzUGxhaW5PYmplY3QsXG4gIHNwcmludGZcbn0gZnJvbSAnLi4vX2ludGVybmFscyc7XG5cbi8qKlxuICogUmV0dXJuIGEgY29weSBvZiB0aGUgZ3JhcGggbm9kZXMgaW4gYSBsaXN0LlxuICpcbiAqIEBwYXJhbSB7R3JhcGh9IEcgR3JhcGhcbiAqIEByZXR1cm4ge0FycmF5fSBMaXN0IG9mIG5vZGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub2RlcyhHKSB7XG4gIHJldHVybiBHLm5vZGVzKCk7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGdyYXBoIG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7R3JhcGh9IEcgR3JhcGhcbiAqIEByZXR1cm4ge0l0ZXJhdG9yfSBJdGVyYXRvciBvdmVyIGdyYXBoIG5vZGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub2Rlc0l0ZXIoRykge1xuICByZXR1cm4gRy5ub2Rlc0l0ZXIoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGVkZ2VzIGFkamFjZW50IHRvIG5vZGVzIGluIG5idW5jaC5cbiAqXG4gKiBSZXR1cm4gYWxsIGVkZ2VzIGlmIG5idW5jaCBpcyB1bnNwZWNpZmllZCBvciBuYnVuY2g9Tm9uZS5cbiAqIEZvciBkaWdyYXBocywgZWRnZXM9b3V0X2VkZ2VzXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gRyBHcmFwaFxuICogQHBhcmFtIHtOb2RlQ29udGFpbmVyPX0gb3B0X25idW5jaCBOb2Rlc1xuICogQHJldHVybiB7QXJyYXl9IExpc3Qgb2YgZWRnZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkZ2VzKEcsIG9wdE5idW5jaCkge1xuICByZXR1cm4gRy5lZGdlcyhvcHROYnVuY2gpO1xufVxuXG4vKipcbiAqIFJldHVybiBpdGVyYXRvciBvdmVyICBlZGdlcyBhZGphY2VudCB0byBub2RlcyBpbiBuYnVuY2guXG4gKlxuICogUmV0dXJuIGFsbCBlZGdlcyBpZiBuYnVuY2ggaXMgdW5zcGVjaWZpZWQgb3IgbmJ1bmNoPU5vbmUuXG4gKiBGb3IgZGlncmFwaHMsIGVkZ2VzPW91dF9lZGdlc1xuICpcbiAqIEBwYXJhbSB7R3JhcGh9IEcgR3JhcGhcbiAqIEBwYXJhbSB7Tm9kZUNvbnRhaW5lcj19IG9wdF9uYnVuY2ggTm9kZXNcbiAqIEByZXR1cm4ge0l0ZXJhdG9yfSBJdGVyYXRvciBvdmVyIGVkZ2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZGdlc0l0ZXIoRywgb3B0TmJ1bmNoKSB7XG4gIHJldHVybiBHLmVkZ2VzSXRlcihvcHROYnVuY2gpO1xufVxuXG4vKipcbiAqIFJldHVybiBkZWdyZWUgb2Ygc2luZ2xlIG5vZGUgb3Igb2YgbmJ1bmNoIG9mIG5vZGVzLlxuICogSWYgbmJ1bmNoIGlzIG9taXR0ZWQsIHRoZW4gcmV0dXJuIGRlZ3JlZXMgb2YgKmFsbCogbm9kZXMuXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gRyBHcmFwaFxuICogQHBhcmFtIHtOb2RlQ29udGFpbmVyPX0gb3B0X25idW5jaCBOb2Rlc1xuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfd2VpZ2h0IFdlaWdodCBhdHRyaWJ1dGUgbmFtZVxuICogQHJldHVybiB7KG51bWJlcnxNYXApfSBEZWdyZWUgb2Ygbm9kZShzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVncmVlKEcsIG9wdE5idW5jaCwgb3B0V2VpZ2h0KSB7XG4gIHJldHVybiBHLmRlZ3JlZShvcHROYnVuY2gsIG9wdFdlaWdodCk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbGlzdCBvZiBub2RlcyBjb25uZWN0ZWQgdG8gbm9kZSBuLlxuICpcbiAqIEBwYXJhbSB7R3JhcGh9IEcgR3JhcGhcbiAqIEBwYXJhbSB7Tm9kZX0gbiBOb2RlXG4gKiBAcmV0dXJuIHtBcnJheX0gTGlzdCBvZiBub2Rlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbmVpZ2hib3JzKEcsIG4pIHtcbiAgcmV0dXJuIEcubmVpZ2hib3JzKG4pO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBncmFwaC5cbiAqXG4gKiBAcGFyYW0ge0dyYXBofSBHIEdyYXBoXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBub2Rlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyT2ZOb2RlcyhHKSB7XG4gIHJldHVybiBHLm51bWJlck9mTm9kZXMoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBlZGdlcyBpbiB0aGUgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gRyBHcmFwaFxuICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgZWRnZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlck9mRWRnZXMoRykge1xuICByZXR1cm4gRy5udW1iZXJPZkVkZ2VzKCk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBkZW5zaXR5IG9mIGEgZ3JhcGguXG4gKiBUaGUgZGVuc2l0eSBmb3IgdW5kaXJlY3RlZCBncmFwaHMgaXNcbiAqXG4gKiBgYGBtYXRoXG4gKiBkID0gXFxmcmFjezJtfXtuKG4tMSl9XG4gKiBgYGBcbiAqXG4gKiBhbmQgZm9yIGRpcmVjdGVkIGdyYXBocyBpc1xuICpcbiAqIGBgYG1hdGhcbiAqIFxcZnJhY3ttfXtuKG4tMSl9XG4gKiBgYGBcbiAqXG4gKiB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2Ygbm9kZXMgYW5kIG0gaXMgdGhlIG51bWJlciBvZiBlZGdlcyBpbiBHXG4gKlxuICogVGhlIGRlbnNpdHkgaXMgMCBmb3IgYW4gZ3JhcGggd2l0aG91dCBlZGdlcyBhbmQgMS4wIGZvciBhIGNvbXBsZXRlIGdyYXBoLlxuICogVGhlIGRlbnNpdHkgb2YgbXVsdGlncmFwaHMgY2FuIGJlIGhpZ2hlciB0aGFuIDEuXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gRyBHcmFwaFxuICogQHJldHVybiB7bnVtYmVyfSBEZW5zaXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZW5zaXR5KEcpIHtcbiAgdmFyIG4gPSBHLm51bWJlck9mTm9kZXMoKTtcbiAgdmFyIG0gPSBHLm51bWJlck9mRWRnZXMoKTtcbiAgdmFyIGQ7XG5cbiAgaWYobSA9PT0gMCkgeyAvLyBpbmNsdWRlcyBjYXNlcyBuID09PSAwIGFuZCBuID09PSAxXG4gICAgZCA9IDAuMDtcbiAgfVxuICBlbHNlIHtcbiAgICBpZihHLmlzRGlyZWN0ZWQoKSkge1xuICAgICAgZCA9IG0gLyAobiAqIChuLTEpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkID0gKG0gKiAyKSAvIChuICogKG4tMSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGxpc3Qgb2YgdGhlIGZyZXF1ZW5jeSBvZiBlYWNoIGRlZ3JlZSB2YWx1ZS5cbiAqXG4gKiBOb3RlOiB0aGUgYmlucyBhcmUgd2lkdGggb25lLCBoZW5jZSBsaXN0Lmxlbmd0aCBjYW4gYmUgbGFyZ2VcbiAqIChPcmRlcihudW1iZXJfb2ZfZWRnZXMpKVxuICpcbiAqXG4gKiBAcGFyYW0ge0dyYXBofSBHIEdyYXBoXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBsaXN0IG9mIGZyZXF1ZW5jaWVzIG9mIGRlZ3JlZXMuXG4gKiAgICAgIFRoZSBkZWdyZWUgdmFsdWVzIGFyZSB0aGUgaW5kZXggaW4gdGhlIGxpc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWdyZWVIaXN0b2dyYW0oRykge1xuICB2YXIgZGVnc2VxID0gQXJyYXkuZnJvbShHLmRlZ3JlZSgpLnZhbHVlcygpKTtcbiAgdmFyIGRtYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBkZWdzZXEpICsgMTtcbiAgdmFyIGZyZXEgPSBmaWxsQXJyYXkoZG1heCwgMCk7XG5cbiAgZGVnc2VxLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgIGZyZXFbZF0gKz0gMTtcbiAgfSk7XG5cbiAgcmV0dXJuIGZyZXE7XG59XG5cbi8qKlxuICogUmV0dXJuIFRydWUgaWYgZ3JhcGggaXMgZGlyZWN0ZWQuXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gRyBHcmFwaFxuICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgZ3JhcGggaXMgZGlyZWN0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGlyZWN0ZWQoRykge1xuICByZXR1cm4gRy5pc0RpcmVjdGVkKCk7XG59XG5cbi8qKlxuICogTW9kaWZ5IGdyYXBoIHRvIHByZXZlbnQgYWRkaXRpb24gb2Ygbm9kZXMgb3IgZWRnZXMuXG4gKlxuICogVGhpcyBkb2VzIG5vdCBwcmV2ZW50IG1vZGlmaWNhdGlvbiBvZiBlZGdlIGRhdGEuXG4gKiBUbyBcInVuZnJlZXplXCIgYSBncmFwaCB5b3UgbXVzdCBtYWtlIGEgY29weS5cbiAqXG4gKiBAc2VlICNpc19mcm96ZW5cbiAqXG4gKiBAcGFyYW0ge0dyYXBofSBHIEdyYXBoXG4gKiBAcmV0dXJuIHtHcmFwaH0gQSByZWZlcmVuY2UgdG8gdGhlIGlucHV0IGdyYXBoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmVlemUoRykge1xuICBmdW5jdGlvbiBmcm96ZW4oKSB7XG4gICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcihcbiAgICAgIFwiRnJvemVuIGdyYXBoIGNhbid0IGJlIG1vZGlmaWVkXCJcbiAgICApO1xuICB9XG5cbiAgLy8gVGhpcyBkb3VibGUgYXNzaWdubWVudCBpcyBuZWNlc3NhcnkgZm9yIHRoZSBjbG9zdXJlIGNvbXBpbGVyXG4gIEcuYWRkTm9kZSA9IGZyb3plbjtcbiAgRy5hZGROb2Rlc0Zyb20gPSBmcm96ZW47XG4gIEcucmVtb3ZlTm9kZSA9IGZyb3plbjtcbiAgRy5yZW1vdmVOb2Rlc0Zyb20gPSBmcm96ZW47XG4gIEcuYWRkRWRnZSA9IGZyb3plbjtcbiAgRy5hZGRFZGdlc0Zyb20gPSBmcm96ZW47XG4gIEcucmVtb3ZlRWRnZSA9IGZyb3plbjtcbiAgRy5yZW1vdmVFZGdlc0Zyb20gPSBmcm96ZW47XG4gIEcuY2xlYXIgPSBmcm96ZW47XG4gIEcuZnJvemVuID0gdHJ1ZTtcbiAgcmV0dXJuIEc7XG59XG5cbi8qKlxuICogUmV0dXJuIFRydWUgaWYgZ3JhcGggaXMgZnJvemVuLlxuICpcbiAqIEBzZWUgI2ZyZWV6ZVxuICpcbiAqIEBwYXJhbSB7R3JhcGh9IEcgR3JhcGhcbiAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIGdyYXBoIGlzIGZyb3plbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRnJvemVuKEcpIHtcbiAgcmV0dXJuICEhRy5mcm96ZW47XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdWJncmFwaCBpbmR1Y2VkIG9uIG5vZGVzIGluIG5idW5jaC5cbiAqXG4gKiBOb3RlOiAgc3ViZ3JhcGgoRykgY2FsbHMgRy5zdWJncmFwaCgpXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gRyBHcmFwaFxuICogQHBhcmFtIHtOb2RlQ29udGFpbmVyfSBuYnVuY2hcbiAqICAgICAgQSBjb250YWluZXIgb2Ygbm9kZXMgdGhhdCB3aWxsIGJlIGl0ZXJhdGVkIHRocm91Z2ggb25jZSAodGh1c1xuICogICAgICBpdCBzaG91bGQgYmUgYW4gaXRlcmF0b3Igb3IgYmUgaXRlcmFibGUpLiAgRWFjaCBlbGVtZW50IG9mIHRoZVxuICogICAgICBjb250YWluZXIgc2hvdWxkIGJlIGEgdmFsaWQgbm9kZSB0eXBlOiBhbnkgaGFzaGFibGUgdHlwZSBleGNlcHRcbiAqICAgICAgTm9uZS4gIElmIG5idW5jaCBpcyBOb25lLCByZXR1cm4gYWxsIGVkZ2VzIGRhdGEgaW4gdGhlIGdyYXBoLlxuICogICAgICBOb2RlcyBpbiBuYnVuY2ggdGhhdCBhcmUgbm90IGluIHRoZSBncmFwaCB3aWxsIGJlIChxdWlldGx5KVxuICogICAgICBpZ25vcmVkLlxuICogQHJldHVybiB7R3JhcGh9IFN1YmdyYXBoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJncmFwaChHLCBuYnVuY2gpIHtcbiAgcmV0dXJuIEcuc3ViZ3JhcGgobmJ1bmNoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBncmFwaCBHIHdpdGggYWxsIG9mIHRoZSBlZGdlcyByZW1vdmVkLlxuICpcbiAqIE5vdGVzOiBHcmFwaCwgbm9kZSwgYW5kIGVkZ2UgZGF0YSBpcyBub3QgcHJvcGFnYXRlZCB0byB0aGUgbmV3IGdyYXBoLlxuICpcbiAqIEBwYXJhbSB7R3JhcGh9IEcgR3JhcGhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X3dpdGhfbm9kZXMgKGRlZmF1bHQ9VHJ1ZSlcbiAqICAgICAgSW5jbHVkZSBub2Rlcy5cbiAqXG4gKiBAcmV0dXJuIHtHcmFwaH0gQSBjb3B5IG9mIHRoZSBncmFwaFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1wdHlDb3B5KEcsIG9wdFdpdGhOb2Rlcz10cnVlKSB7XG4gIHZhciBIID0gbmV3IEcuY29uc3RydWN0b3IoKTtcbiAgaWYob3B0V2l0aE5vZGVzKSB7XG4gICAgSC5hZGROb2Rlc0Zyb20oRyk7XG4gIH1cbiAgcmV0dXJuIEg7XG59XG5cbi8qKlxuICogUHJpbnQgc2hvcnQgc3VtbWFyeSBvZiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdyYXBoIEcgb3IgdGhlIG5vZGUgbi5cbiAqXG4gKiBAcGFyYW0ge0dyYXBofSBHIEdyYXBoXG4gKiBAcGFyYW0ge05vZGU9fSBvcHRfbiBBIG5vZGUgaW4gdGhlIGdyYXBoIEdcbiAqIEByZXR1cm4ge3N0cmluZ30gSW5mb1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbyhHLCBvcHROKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKG9wdE4gPT0gbnVsbCkge1xuICAgIHZhciB0ZW1wbGF0ZSA9XG4gICAgICAnTmFtZTogJXNcXG4nICtcbiAgICAgICdUeXBlOiAlc1xcbicgK1xuICAgICAgJ051bWJlciBvZiBub2RlczogJXNcXG4nICtcbiAgICAgICdOdW1iZXIgb2YgZWRnZXM6ICVzXFxuJztcbiAgICB2YXIgbm5vZGVzID0gRy5udW1iZXJPZk5vZGVzKCk7XG4gICAgcmVzdWx0ID0gc3ByaW50ZihcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgRy5uYW1lLFxuICAgICAgRy5jb25zdHJ1Y3Rvci5fX25hbWVfXyxcbiAgICAgIG5ub2RlcyxcbiAgICAgIEcubnVtYmVyT2ZFZGdlcygpXG4gICAgKTtcbiAgICBpZihubm9kZXMgPiAwKSB7XG4gICAgICBpZihHLmlzRGlyZWN0ZWQoKSkge1xuICAgICAgICB2YXIgaW5EZWdyZWUgPSAwO1xuICAgICAgICB2YXIgb3V0RGVncmVlID0gMDtcbiAgICAgICAgZm9yICh2YXIgZGVncmVlIG9mIEcuaW5EZWdyZWUoKS52YWx1ZXMoKSkge1xuICAgICAgICAgIGluRGVncmVlICs9IGRlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGRlZ3JlZSBvZiBHLm91dERlZ3JlZSgpLnZhbHVlcygpKSB7XG4gICAgICAgICAgb3V0RGVncmVlICs9IGRlZ3JlZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBzcHJpbnRmKFxuICAgICAgICAgICdBdmVyYWdlIGluIGRlZ3JlZTogJXNcXG5BdmVyYWdlIG91dCBkZWdyZWU6ICVzJyxcbiAgICAgICAgICAoaW5EZWdyZWUgLyBubm9kZXMpLnRvRml4ZWQoNCksXG4gICAgICAgICAgKG91dERlZ3JlZSAvIG5ub2RlcykudG9GaXhlZCg0KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciB2IG9mIEcuZGVncmVlKCkudmFsdWVzKCkpIHtcbiAgICAgICAgICBzdW0gKz0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gc3ByaW50ZignQXZlcmFnZSBkZWdyZWU6ICVzJywgKHN1bSAvIG5ub2RlcykudG9GaXhlZCg0KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmKCFHLmhhc05vZGUob3B0TikpIHtcbiAgICAgIHRocm93IG5ldyBKU05ldHdvcmtYRXJyb3IoXG4gICAgICAgIHNwcmludGYoJ05vZGUgJWogbm90IGluIGdyYXBoLicsIG9wdE4pXG4gICAgICApO1xuICAgIH1cbiAgICByZXN1bHQgPSBzcHJpbnRmKFxuICAgICAgJ05vZGUgJWogaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcXG5EZWdyZWU6ICVzXFxuTmVpZ2hib3JzOiAlcycsXG4gICAgICBvcHROLFxuICAgICAgRy5kZWdyZWUob3B0TiksXG4gICAgICBHLm5laWdoYm9ycyhvcHROKS5tYXAobiA9PiBKU09OLnN0cmluZ2lmeShuKSkuam9pbignICcpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFNldCBub2RlIGF0dHJpYnV0ZXMgZnJvbSBkaWN0aW9uYXJ5IG9mIG5vZGVzIGFuZCB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge0dyYXBofSBHIEdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBdHRyaWJ1dGUgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fE1hcCl9IGF0dHJpYnV0ZXMgRGljdGlvbmFyeSBvZiBhdHRyaWJ1dGVzIGtleWVkIGJ5IG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE5vZGVBdHRyaWJ1dGVzKEcsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgaWYgKGlzTWFwKGF0dHJpYnV0ZXMpKSB7XG4gICAgYXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwgbm9kZSkgPT4gRy5ub2RlLmdldChub2RlKVtuYW1lXSA9IHZhbHVlKTtcbiAgfVxuICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKSB7XG4gICAgZm9yICh2YXIgbm9kZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBub2RlID0gaXNOYU4obm9kZSkgPyBub2RlIDogK25vZGU7XG4gICAgICBHLm5vZGUuZ2V0KG5vZGUpW25hbWVdID0gYXR0cmlidXRlc1tub2RlXTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXR0cmlidXRlcyBtdXN0IGJlIGEgTWFwIG9yIGEgcGxhaW4gb2JqZWN0Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgbm9kZSBhdHRyaWJ1dGVzIGZyb20gZ3JhcGhcbiAqXG4gKiBAcGFyYW0ge0dyYXBofSBHIEdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBdHRyaWJ1dGUgbmFtZVxuICogQHJldHVybiB7IU1hcH0gRGljdGlvbmFyeSBvZiBhdHRyaWJ1dGVzIGtleWVkIGJ5IG5vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlQXR0cmlidXRlcyhHLCBuYW1lKSB7XG4gIHZhciBkaWN0ID0gbmV3IE1hcCgpO1xuICBHLm5vZGUuZm9yRWFjaChmdW5jdGlvbihub2RlLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGRpY3Quc2V0KG5vZGUsIGRhdGFbbmFtZV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkaWN0O1xufVxuXG4vKipcbiAqIFNldCBlZGdlIGF0dHJpYnV0ZXMgZnJvbSBkaWN0aW9uYXJ5IG9mIGVkZ2UgdHVwbGVzIGFuZCB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge0dyYXBofSBHIEdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBdHRyaWJ1dGUgbmFtZVxuICogQHBhcmFtIHtNYXB9IGF0dHJpYnV0ZXNcbiAqICAgIERpY3Rpb25hcnkgb2YgYXR0cmlidXRlcyBrZXllZCBieSBlZGdlICh0dXBsZSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFZGdlQXR0cmlidXRlcyhHLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbihlZGdlLCB2YWx1ZSkge1xuICAgIEcuZ2V0KGVkZ2VbMF0pLmdldChlZGdlWzFdKVtuYW1lXSA9IHZhbHVlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgZWRnZSBhdHRyaWJ1dGVzIGZyb20gZ3JhcGhcbiAqXG4gKiBTaW5jZSBrZXlzIGNhbiBvbmx5IGJlIHN0cmluZ3MgaW4gSmF2YVNjcmlwdCwgdGhlIGVkZ2UgaXMgcmV0dXJuZWQgYXNcbiAqIHtAY29kZSBcIm5vZGUxLG5vZGUyXCJ9IHN0cmluZy4gWW91J2QgaGF2ZSB0byBjYWxsIHtAY29kZSAuc3BsaXQoJywnKX0gb25cbiAqIHRoZSBrZXlzIHRvIGV4dHJhY3QgdGhlIGFjdHVhbCBub2RlIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7R3JhcGh9IEcgR3JhcGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEF0dHJpYnV0ZSBuYW1lXG4gKiBAcmV0dXJuIHshTWFwfSBEaWN0aW9uYXJ5IG9mIGF0dHJpYnV0ZXMga2V5ZWQgYnkgZWRnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVkZ2VBdHRyaWJ1dGVzKEcsIG5hbWUpIHtcbiAgdmFyIGRpY3QgPSBuZXcgTWFwKCk7XG4gIEcuZWRnZXMobnVsbCwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbihlZGdlZCkge1xuICAgIGlmIChlZGdlZFsyXS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgdmFyIHZhbHVlID0gZWRnZWRbMl1bbmFtZV07XG4gICAgICBlZGdlZC5sZW5ndGggPSAyOyAvLyBjdXQgb2YgZGF0YVxuICAgICAgZGljdC5zZXQoZWRnZWQsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGljdDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEdyYXBoIGZyb20gJy4vR3JhcGgnO1xuaW1wb3J0IERpR3JhcGggZnJvbSAnLi9EaUdyYXBoJztcbmltcG9ydCBNdWx0aUdyYXBoIGZyb20gJy4vTXVsdGlHcmFwaCc7XG5pbXBvcnQgTXVsdGlEaUdyYXBoIGZyb20gJy4vTXVsdGlEaUdyYXBoJztcblxuaW1wb3J0IGZ1bmN0aW9ucyBmcm9tICcuL2Z1bmN0aW9ucyc7XG5cbmV4cG9ydCB7XG4gIEdyYXBoLFxuICBEaUdyYXBoLFxuICBNdWx0aUdyYXBoLFxuICBNdWx0aURpR3JhcGgsXG4gIGZ1bmN0aW9uc1xufTtcbmV4cG9ydCAqIGZyb20gJy4vZnVuY3Rpb25zJztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgcHJlcENyZWF0ZVVzaW5nIGZyb20gJy4vcHJlcENyZWF0ZVVzaW5nJztcblxuaW1wb3J0IHtcbiAgLypqc2hpbnQgaWdub3JlOnN0YXJ0Ki9cbiAgTWFwLFxuICBTZXQsXG4gIC8qanNoaW50IGlnbm9yZTplbmQqL1xuXG4gIGlzQXJyYXlMaWtlLFxuICB0dXBsZTJcbn0gZnJvbSAnLi4vX2ludGVybmFscyc7XG5cbi8qKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGNvbnZlcnQgSlNOZXR3b3JrWCBncmFwaHMgdG8gYW5kIGZyb21cbiAqIG5vbi1OZXR3b3JrWCBmb3JtYXRzLlxuICovXG5cbiAvKipcbiAgKiBSZXR1cm4gYWRqYWNlbmN5IHJlcHJlc2VudGF0aW9uIG9mIGdyYXBoIGFzIGEgbWFwIG9mIGxpc3RzLlxuICAqXG4gICogQ29tcGxldGVseSBpZ25vcmVzIGVkZ2UgZGF0YSBmb3IgTXVsdGlHcmFwaCBhbmQgTXVsdGlEaUdyYXBoLlxuICAqXG4gICogQHBhcmFtIHtHcmFwaH0gRyBBIGdyYXBoXG4gICogQHBhcmFtIHtOb2RlQ29udGFpbmVyPX0gb3B0X25vZGVsaXN0IFVzZSBvbmx5IG5vZHMgc3BlY2lmaWVkIGluIG5vZGVsaXN0LlxuICAqXG4gICogQHJldHVybiB7IU1hcH1cbiAgKi9cbmV4cG9ydCBmdW5jdGlvbiB0b01hcE9mTGlzdHMoRywgb3B0Tm9kZWxpc3QpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcblxuICBpZiAob3B0Tm9kZWxpc3QgIT0gbnVsbCkge1xuICAgIEFycmF5LmZyb20ob3B0Tm9kZWxpc3QpLmZvckVhY2goXG4gICAgICBuID0+IG1hcC5zZXQobiwgRy5uZWlnaGJvcnMobikuZmlsdGVyKHYgPT4gb3B0Tm9kZWxpc3QuaW5kZXhPZih2KSA+IC0xKSlcbiAgICApO1xuICB9XG4gIGVsc2Uge1xuICAgIGZvciAodmFyIG4gb2YgRykge1xuICAgICAgbWFwLnNldChuLCBHLm5laWdoYm9ycyhuKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hcDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBncmFwaCBmcm9tIGEgbWFwIG9mIGxpc3RzLlxuICogKlxuICogQHBhcmFtIHshTWFwfSBtYXAgQSBtYXAgb2YgbGlzdHMgYWRqYWNlbmN5IHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHtHcmFwaD19IG9wdF9jcmVhdGVfdXNpbmcgVXNlIHNwZWNpZmllZCBncmFwaCBmb3IgcmVzdWx0LlxuICogICAgT3RoZXJ3aXNlIGEgbmV3IGdyYXBoIGlzIGNyZWF0ZWQuXG4gKlxuICogQHJldHVybiB7IUdyYXBofVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hcE9mTGlzdHMobWFwLCBvcHRDcmVhdGVVc2luZykge1xuICB2YXIgRyA9IHByZXBDcmVhdGVVc2luZyhvcHRDcmVhdGVVc2luZyk7XG4gIEcuYWRkTm9kZXNGcm9tKG1hcC5rZXlzKCkpO1xuXG4gIGlmKEcuaXNNdWx0aWdyYXBoKCkgJiYgIUcuaXNEaXJlY3RlZCgpKSB7XG4gICAgLy8gYSBtYXBfb2ZfbGlzdHMgY2FuJ3Qgc2hvdyBtdWx0aWVkZ2VzLiAgQlVUIGZvciB1bmRpcmVjdGVkIGdyYXBocyxcbiAgICAvLyBlYWNoIGVkZ2Ugc2hvd3MgdXAgdHdpY2UgaW4gdGhlIG1hcF9vZl9saXN0cy5cbiAgICAvLyBTbyB3ZSBuZWVkIHRvIHRyZWF0IHRoaXMgY2FzZSBzZXBhcmF0ZWx5LlxuICAgIHZhciBzZWVuID0gbmV3IFNldCgpO1xuXG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24obmJybGlzdCwgbm9kZSkge1xuICAgICAgbmJybGlzdC5mb3JFYWNoKGZ1bmN0aW9uKG5icikge1xuICAgICAgICBpZiAoIXNlZW4uaGFzKG5icikpIHtcbiAgICAgICAgICBHLmFkZEVkZ2Uobm9kZSwgbmJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWVuLmFkZChub2RlKTsgLy8gZG9uJ3QgYWxsb3cgcmV2ZXJzZSBlZGdlIHRvIHNob3cgdXBcbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbihuYnJsaXN0LCBub2RlKSB7XG4gICAgICBuYnJsaXN0LmZvckVhY2gobmJyID0+IEcuYWRkRWRnZShub2RlLCBuYnIpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBHO1xufVxuXG4vKipcbiAqIFJldHVybiBhZGphY2VuY3kgcmVwcmVzZW50YXRpb24gb2YgZ3JhcGggYXMgYSBtYXAgb2YgbWFwcy5cbiAqXG4gKiBAcGFyYW0ge0dyYXBofSBHIEEganNueCBHcmFwaFxuICogQHBhcmFtIHtOb2RlQ29udGFpbmVyPX0gb3B0X25vZGVsaXN0IFVzZSBvbmx5IG5vZGVzIHNwZWNpZmllZCBpbiBub2RlbGlzdFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfZWRnZV9kYXRhIElmIHByb3ZpZGVkLCAgdGhlIHZhbHVlIG9mIHRoZSBtYXAgd2lsbCBiZVxuICogICAgICBzZXQgdG8gZWRnZV9kYXRhIGZvciBhbGwgZWRnZXMuICBUaGlzIGlzIHVzZWZ1bCB0byBtYWtlXG4gKiAgICAgIGFuIGFkamFjZW5jeSBtYXRyaXggdHlwZSByZXByZXNlbnRhdGlvbiB3aXRoIDEgYXMgdGhlIGVkZ2UgZGF0YS5cbiAqICAgICAgSWYgb3B0X2VkZ2VfZGF0YSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgdGhlIGVkZ2UgZGF0YSBpbiBHIGlzIHVzZWQgdG9cbiAqICAgICAgZmlsbCB0aGUgdmFsdWVzLlxuICogICAgICBJZiBHIGlzIGEgbXVsdGlncmFwaCwgdGhlIGVkZ2UgZGF0YSBpcyBhIGRpY3QgZm9yIGVhY2ggcGFpciAodSx2KS5cbiAqXG4gKiBAcmV0dXJuIHshTWFwfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9NYXBPZk1hcHMoRywgb3B0Tm9kZWxpc3QsIG9wdEVkZ2VEYXRhKSB7XG4gICB2YXIgbWFwT2ZNYXBzID0gbmV3IE1hcCgpO1xuXG4gICBpZiAob3B0Tm9kZWxpc3QgIT0gbnVsbCkge1xuICAgICBvcHROb2RlbGlzdCA9IEFycmF5LmZyb20ob3B0Tm9kZWxpc3QpO1xuICAgICBvcHROb2RlbGlzdC5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICAgICB2YXIgbWFwT2ZVID0gbWFwT2ZNYXBzLnNldCh1LCBuZXcgTWFwKCkpO1xuICAgICAgIEcuZ2V0KHUpLmZvckVhY2goZnVuY3Rpb24odiwgZGF0YSkge1xuICAgICAgICAgaWYgKG9wdE5vZGVsaXN0LmluZGV4T2YodikgPiAtMSkge1xuICAgICAgICAgICBtYXBPZlUuc2V0KHYsIG9wdEVkZ2VEYXRhID09IG51bGwgPyBkYXRhIDogb3B0RWRnZURhdGEpO1xuICAgICAgICAgfVxuICAgICAgIH0pO1xuICAgICB9KTtcbiAgIH1cbiAgIGVsc2UgeyAvLyBub2RlbGlzdCBpcyB1bmRlZmluZWRcbiAgICAgZm9yICh2YXIgW25icm1hcCwgdV0gb2YgRy5hZGphY2VuY3lJdGVyKCkpIHtcbiAgICAgICAvKmpzaGludCBsb29wZnVuYzp0cnVlKi9cbiAgICAgICB2YXIgbWFwT2ZVID0gbWFwT2ZNYXBzLnNldCh1LCBuZXcgTWFwKCkpO1xuICAgICAgIG5icm1hcC5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEsIHYpIHtcbiAgICAgICAgIG1hcE9mVS5zZXQodiwgb3B0RWRnZURhdGEgPT0gbnVsbCA/IGRhdGEgOiBvcHRFZGdlRGF0YSk7XG4gICAgICAgfSk7XG4gICAgIH1cbiAgIH1cblxuICAgcmV0dXJuIG1hcE9mTWFwcztcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBncmFwaCBmcm9tIGEgbWFwIG9mIG1hcHMuXG4gKlxuICogQHBhcmFtIHshTWFwfSBtYXAgQSBtYXAgb2YgbWFwcyBhZGphY2VuY3kgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0ge0dyYXBoPX0gb3B0X2NyZWF0ZV91c2luZyBVc2Ugc3BlY2lmaWVkIGdyYXBoIGZvciByZXN1bHQuXG4gKiAgICAgIE90aGVyd2lzZSBhIG5ldyBncmFwaCBpcyBjcmVhdGVkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X211bHRpZ3JhcGhfaW5wdXQgKGRlZmF1bHQ9RmFsc2UpXG4gKiAgICAgIFdoZW4gVHJ1ZSwgdGhlIHZhbHVlcyBvZiB0aGUgaW5uZXIgZGljdCBhcmUgYXNzdW1lZFxuICogICAgICB0byBiZSBjb250YWluZXJzIG9mIGVkZ2UgZGF0YSBmb3IgbXVsdGlwbGUgZWRnZXMuXG4gKiAgICAgIE90aGVyd2lzZSB0aGlzIHJvdXRpbmUgYXNzdW1lcyB0aGUgZWRnZSBkYXRhIGFyZSBzaW5nbGV0b25zLlxuICpcbiAqIEByZXR1cm4ge0dyYXBofVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hcE9mTWFwcyhtYXAsIG9wdENyZWF0ZVVzaW5nLCBvcHRNdWx0aWdyYXBoSW5wdXQpIHtcbiAgdmFyIEcgPSBwcmVwQ3JlYXRlVXNpbmcob3B0Q3JlYXRlVXNpbmcpO1xuICB2YXIgc2VlbiA9IG5ldyBTZXQoKTsgLy8gZG9uJ3QgYWRkIGJvdGggZGlyZWN0aW9ucyBvZiB1bmRpcmVjdGVkIGdyYXBoXG4gIEcuYWRkTm9kZXNGcm9tKG1hcC5rZXlzKCkpO1xuXG4gIC8vIGlzIG1hcCBhIE11bHRpR3JhcGggb3IgTXVsdGlEaUdyYXBoP1xuICBpZiAob3B0TXVsdGlncmFwaElucHV0KSB7XG4gICAgLy8gbWFrZSBhIGNvcHkgIG9mIHRoZSBsaXN0IG9mIGVkZ2UgZGF0YSAoYnV0IG5vdCB0aGUgZWRnZSBkYXRhKVxuICAgIGlmIChHLmlzRGlyZWN0ZWQoKSkge1xuICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24obmJycywgdSkge1xuICAgICAgICBpZihpc0FycmF5TGlrZShuYnJzKSkgeyAvLyB0aHJvdyBleHBlY3Rpb24gb2Ygbm90IG1hcCAob2JqZWN0KVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGlzIG5vdCBhIG1hcC4nKTtcbiAgICAgICAgfVxuICAgICAgICBuYnJzLmZvckVhY2goZnVuY3Rpb24oZGF0YWRpY3QsIHYpIHtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YWRpY3QpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YWRpY3Rba2V5XTtcbiAgICAgICAgICAgIGlmIChHLmlzTXVsdGlncmFwaCgpKSB7XG4gICAgICAgICAgICAgIEcuYWRkRWRnZSh1LCB2LCBrZXksIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIEcuYWRkRWRnZSh1LCB2LCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyB1bmRpcmVjdGVkXG4gICAgICB2YXIgaXNNdWx0aWdyYXBoID0gRy5pc011bHRpZ3JhcGgoKTtcbiAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKG5icnMsIHUpIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKG5icnMpKSB7IC8vIHRocm93IGV4Y2VwdGlvbiBvZiBub3QgbWFwXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgbWFwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbmJycy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFkaWN0LCB2KSB7XG4gICAgICAgICAgLy8gdGhpcyB3b3JrcyBiZWNhdXNlIHNldHMgY29udmVydCB0aGUgdmFsdWUgdG8gdGhlaXIgc3RyaW5nXG4gICAgICAgICAgLy8gcmVwcmVzZW50YXRpb25cbiAgICAgICAgICBpZiAoIXNlZW4uaGFzKHR1cGxlMih1LCB2KSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhZGljdCkge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGFkaWN0W2tleV07XG4gICAgICAgICAgICAgIGlmIChpc011bHRpZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICBHLmFkZEVkZ2UodSwgdiwga2V5LCBkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBHLmFkZEVkZ2UodSwgdiwgZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uYWRkKHR1cGxlMih2LCB1KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBlbHNlIHsgLy8gbm90IGEgbXVsdGlncmFwaCB0byBtdWx0aWdyYXBoIHRyYW5zZmVyXG4gICAgaWYoRy5pc011bHRpZ3JhcGgoKSAmJiAhRy5pc0RpcmVjdGVkKCkpIHtcbiAgICAgIC8vIG1hcCBjYW4gaGF2ZSBib3RoIHJlcHJlc2VudGF0aW9ucyB1LXYsIHYtdSBpbiBkaWN0LiAgT25seSBhZGQgb25lLlxuICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0aGlzIGNoZWNrIGZvciBkaWdyYXBocyBzaW5jZSB3ZSBhZGQgYm90aCBkaXJlY3Rpb25zLFxuICAgICAgLy8gb3IgZm9yIEdyYXBoKCkgc2luY2UgaXQgaXMgZG9uZSBpbXBsaWNpdGx5IChwYXJhbGxlbCBlZGdlcyBub3QgYWxsb3dlZClcbiAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKG5icnMsIHUpIHtcbiAgICAgICAgaWYoaXNBcnJheUxpa2UobmJycykpIHsgLy8gdGhyb3cgZXhjZXB0aW9uIG9mIG5vdCBkaWN0IChvYmplY3QpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgaXMgbm90IGEgbWFwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbmJycy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEsIHYpIHtcbiAgICAgICAgICBpZighc2Vlbi5oYXModHVwbGUyKHUsIHYpKSkge1xuICAgICAgICAgICAgRy5hZGRFZGdlKHUsIHYsIGRhdGEpO1xuICAgICAgICAgICAgc2Vlbi5hZGQodHVwbGUyKHYsIHUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24obmJycywgdSkge1xuICAgICAgICBpZihpc0FycmF5TGlrZShuYnJzKSkgeyAvLyB0aHJvdyBleGNlcHRpb24gb2Ygbm90IGRpY3QgKG9iamVjdClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBpcyBub3QgYSBtYXAnKTtcbiAgICAgICAgfVxuICAgICAgICBuYnJzLmZvckVhY2goZnVuY3Rpb24oZGF0YSwgdikge1xuICAgICAgICAgIEcuYWRkRWRnZSh1LCB2LCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gRztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEEgc2ltcGxlIGV2ZW50IG9iamVjdCB0byBhbnkgZGF0YSBjYW4gYmUgYWRkZWQuIEl0IHByb3ZpZGVzIGZvdXIgbWV0aG9kczpcbiAqXG4gKiAtIHN0b3BQcm9wYWdhdGlvbiB0byBpbmRpY2F0ZWQgdGhhdCBzdWJzZXF1ZW50IGV2ZW50IGhhbmRsZXJzIHNob3VsZCBub3QgYmVcbiAqICAgZXhlY3V0ZWQuXG4gKiAtIGlzUHJvcGdhdGlvblN0b3BwZWQgdG8gdGVzdCB0aGUgc3RhdHVzIChpbnRlcm5hbCBvbmx5KVxuICogLSBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvblxuICogLSBpc0RlZmF1bHRQcmV2ZW50ZWQgdG8gdGVzdCB0aGUgc3RhdHVzXG4gKi9cbmNsYXNzIEV2ZW50IHtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIHRhcmdldCkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fZGVmYXVsdEFjdGlvbiA9IHRydWU7XG4gICAgdGhpcy5fcHJvcGFnYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGNhbGxlZCwgc2hvdWxkIHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiBzdWJzZXF1ZW50IGhhbmRsZXJzLlxuICAgKi9cbiAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuX3Byb3BhZ2F0ZSA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgdGhlIHByb3BhZ2F0aW9uIHNob3VsZCBiZSBzdG9wcGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNQcm9wZ2F0aW9uU3RvcHBlZCgpIHtcbiAgICByZXR1cm4gIXRoaXMuX3Byb3BhZ2F0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGNhbGxlZCwgc2hvdWxkIHByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uLlxuICAgKi9cbiAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgdGhpcy5fZGVmYXVsdEFjdGlvbiA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYWN0aW9uIHNob3VsZCBiZSBzdG9wcGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNEZWZhdWx0UHJldmVudGVkKCkge1xuICAgIHJldHVybiAhdGhpcy5fZGVmYXVsdEFjdGlvbjtcbiAgfVxufVxuXG4gLyoqXG4gICogTWFrZXMgYSBncmFwaCBvYnNlcnZhYmxlLCBpLmUuIGV4dGVybmFsIGNvZGUgY2FuIGJpbmQgZXZlbnQgaGFuZGxlcnMgdG9cbiAgKiBiZSBub3RpZmllZCBhYm91dCBjaGFuZ2VzIGluIHRoZSBncmFwaCAoYWRkaW5nIG9yIHJlbW92aW5nIG5vZGVzIG9yIGVkZ2VzKS5cbiAgKlxuICAqIEBwYXJhbSB7R3JhcGh9IEcgVGhlIGdyYXBoIHRvIG1ha2Ugb2JzZXJ2YWJsZVxuICAqIEByZXR1cm4ge0dyYXBofSBUaGUgc2FtZSBncmFwaCBwYXNzZWQgYXMgYXJndW1lbnQgKG5vdCBhIG5ldyBncmFwaClcbiAgKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlKEcpIHtcbiAgaWYgKHR5cGVvZiBHLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZ3JhcGggaXMgYWxyZWFkeSBvYnNlcnZhYmxlLCBkbyBub3RoaW5nXG4gICAgcmV0dXJuIEc7XG4gIH1cblxuICB2YXIgZXZlbnRIYW5kbGVycyA9IHtcbiAgICAnYWRkTm9kZXMnOiBbXSxcbiAgICAncmVtb3ZlTm9kZXMnOiBbXSxcbiAgICAnYWRkRWRnZXMnOiBbXSxcbiAgICAncmVtb3ZlRWRnZXMnOiBbXSxcbiAgICAnY2xlYXInOiBbXVxuICB9O1xuICB2YXIgcHJvdG8gPSBHLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiB0cmlnZ2VySGFuZGxlcnMoZXZlbnQsIEcsIGZ1bmNOYW1lLCBhcmdzKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gZXZlbnRIYW5kbGVyc1tldmVudC50eXBlXTtcbiAgICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJ1biBiZWZvcmUgaGFuZGxlcnNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDtcbiAgICAgICAgIGkgPCBsICYmICFldmVudC5pc1Byb3BnYXRpb25TdG9wcGVkKCk7XG4gICAgICAgICBpICs9IDNcbiAgICApIHtcbiAgICAgIGlmIChoYW5kbGVyc1tpKzJdKSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwoaGFuZGxlcnNbaSsxXSB8fCBHLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgcHJvdG9bZnVuY05hbWVdLmFwcGx5KEcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHByb3RvW2Z1bmNOYW1lXS5jYWxsKEcpO1xuICAgICAgfVxuICAgICAgaWYgKCFldmVudC5pc1Byb3BnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgLy8gcnVuIGFmdGVyIGhhbmRsZXJzXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7XG4gICAgICAgICAgIGkgPCBsICYmICFldmVudC5pc1Byb3BnYXRpb25TdG9wcGVkKCk7XG4gICAgICAgICAgIGkgKz0gM1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoIWhhbmRsZXJzW2krMl0pIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2ldLmNhbGwoaGFuZGxlcnNbaSsxXSB8fCBHLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgRy5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBoYW5kbGVyLCB0aGlzT2JqLCBiZWZvcmUpIHtcbiAgICBpZiAoIWV2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IFwiJyArIGV2ZW50ICsgJ1wiIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIGV2ZW50SGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlciwgdGhpc09iaiwgISFiZWZvcmUpO1xuICB9O1xuXG4gIEcub2ZmID0gZnVuY3Rpb24oZXZlbnQsIGhhbmRsZXIsIHRoaXNPYmopIHtcbiAgICB2YXIgaGFuZGxlcnM7XG4gICAgdmFyIHN0YXJ0SW5kZXg7XG4gICAgdmFyIGk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIFJlbW92ZSBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICAgIGV2ZW50SGFuZGxlcnNbZXZlbnRdLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIC8vIFJlbW92ZSBwYXJ0aWN1bGFyIGhhbmRsZXIgb3Igb2JqZWN0IG9ubHlcbiAgICAgIGhhbmRsZXJzID0gZXZlbnRIYW5kbGVyc1tldmVudF07XG4gICAgICBzdGFydEluZGV4ID0gaGFuZGxlcnMubGVuZ3RoIC0gMjtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdGFydEluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSBzdGFydEluZGV4OyBpID4gMDsgaSAtPSAyKSB7XG4gICAgICAgIGlmIChoYW5kbGVyc1tpXSA9PT0gaGFuZGxlcikge1xuICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShpLCAzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBwYXJ0aWN1bGFyIGhhbmRsZXItb2JqZWN0IGNvbWJpbmF0aW9uXG4gICAgICBoYW5kbGVycyA9IGV2ZW50SGFuZGxlcnNbZXZlbnRdO1xuICAgICAgc3RhcnRJbmRleCA9IGhhbmRsZXJzLmxlbmd0aCAtIDI7XG4gICAgICBmb3IgKGkgPSBzdGFydEluZGV4OyBpID4gMDsgaSAtPSAyKSB7XG4gICAgICAgIGlmIChoYW5kbGVyc1tpXSA9PT0gaGFuZGxlciAmJiBoYW5kbGVyc1tpKzFdID09PSB0aGlzT2JqKSB7XG4gICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGksIDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEcuYWRkTm9kZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgbmV3Tm9kZXMgPSBHLmhhc05vZGUobikgPyBbXSA6IFtuXTtcbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZE5vZGVzJywgdGhpcyk7XG4gICAgZXZlbnQubm9kZXMgPSBbbl07XG4gICAgZXZlbnQubmV3Tm9kZXMgPSBuZXdOb2RlcztcblxuICAgIHRyaWdnZXJIYW5kbGVycyhldmVudCwgdGhpcywgJ2FkZE5vZGUnLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIEcuYWRkTm9kZXNGcm9tID0gZnVuY3Rpb24obmJ1bmNoKSB7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIG5ld05vZGVzID0gW107XG5cbiAgICBmb3IgKHZhciBidW5jaCBvZiBuYnVuY2gpIHtcbiAgICAgIHZhciB2ID0gQXJyYXkuaXNBcnJheShidW5jaCkgPyBidW5jaFswXSA6IGJ1bmNoO1xuICAgICAgbm9kZXMucHVzaChBcnJheS5pc0FycmF5KGJ1bmNoKSA/IGJ1bmNoLnNsaWNlKCkgOiBidW5jaCk7XG4gICAgICBpZiAoIUcuaGFzTm9kZSh2KSkge1xuICAgICAgICBuZXdOb2Rlcy5wdXNoKHYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnYWRkTm9kZXMnLCB0aGlzKTtcbiAgICBldmVudC5ub2RlcyA9IG5vZGVzLmZpbHRlcih2ID0+IEFycmF5LmlzQXJyYXkodikgPyB2WzBdIDogdik7XG4gICAgZXZlbnQubmV3Tm9kZXMgPSBuZXdOb2RlcztcblxuICAgIHZhciBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgIGFyZ3NbMF0gPSBub2RlcztcblxuICAgIHRyaWdnZXJIYW5kbGVycyhldmVudCwgdGhpcywgJ2FkZE5vZGVzRnJvbScsIGFyZ3MpO1xuICB9O1xuXG4gIEcuYWRkRWRnZSA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICB2YXIgZWRnZXMgPSBbW3Usdl1dO1xuICAgIHZhciBuZXdFZGdlcyA9IHRoaXMuaGFzRWRnZSh1LCB2KSA/IFtdIDogZWRnZXM7XG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZEVkZ2VzJywgdGhpcyk7XG4gICAgZXZlbnQuZWRnZXMgPSBlZGdlcztcbiAgICBldmVudC5uZXdFZGdlcyA9IG5ld0VkZ2VzO1xuXG4gICAgdHJpZ2dlckhhbmRsZXJzKGV2ZW50LCB0aGlzLCAnYWRkRWRnZScsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgIEcuYWRkRWRnZXNGcm9tID0gZnVuY3Rpb24oZWJ1bmNoKSB7XG4gICAgdmFyIGVkZ2VzID0gW107XG4gICAgdmFyIG5ld0VkZ2VzID0gW107XG4gICAgZm9yICh2YXIgYnVuY2ggb2YgZWJ1bmNoKSB7XG4gICAgICBlZGdlcy5wdXNoKGJ1bmNoLnNsaWNlKCkpO1xuICAgICAgaWYgKCF0aGlzLmhhc0VkZ2UoYnVuY2hbMF0sIGJ1bmNoWzFdKSkge1xuICAgICAgICBuZXdFZGdlcy5wdXNoKGJ1bmNoLnNsaWNlKDAsMikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnYWRkRWRnZXMnLCB0aGlzKTtcbiAgICBldmVudC5lZGdlcyA9IGVkZ2VzO1xuICAgIGV2ZW50Lm5ld0VkZ2VzID0gbmV3RWRnZXM7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgICBhcmdzWzBdID0gZWRnZXM7XG5cbiAgICB0cmlnZ2VySGFuZGxlcnMoZXZlbnQsIHRoaXMsICdhZGRFZGdlc0Zyb20nLCBhcmdzKTtcbiAgfTtcblxuICBHLnJlbW92ZU5vZGUgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdyZW1vdmVOb2RlcycsIHRoaXMpO1xuICAgIGV2ZW50Lm5vZGVzID0gW25dO1xuXG4gICAgdHJpZ2dlckhhbmRsZXJzKGV2ZW50LCB0aGlzLCAncmVtb3ZlTm9kZScsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgRy5yZW1vdmVOb2Rlc0Zyb20gPSBmdW5jdGlvbihuYnVuY2gpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICBmb3IgKHZhciBidW5jaCBvZiBuYnVuY2gpIHtcbiAgICAgIG5vZGVzLnB1c2goQXJyYXkuaXNBcnJheShidW5jaCkgPyBidW5jaC5zbGljZSgpIDogYnVuY2gpO1xuICAgIH1cbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ3JlbW92ZU5vZGVzJywgdGhpcyk7XG4gICAgZXZlbnQubm9kZXMgPSBub2RlcztcblxuICAgIHZhciBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgIGFyZ3NbMF0gPSBub2RlcztcblxuICAgIHRyaWdnZXJIYW5kbGVycyhldmVudCwgdGhpcywgJ3JlbW92ZU5vZGVzRnJvbScsIGFyZ3MpO1xuICB9O1xuXG4gIEcucmVtb3ZlRWRnZSA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ3JlbW92ZUVkZ2VzJywgdGhpcyk7XG4gICAgZXZlbnQuZWRnZXMgPSBbW3Usdl1dO1xuXG4gICAgdHJpZ2dlckhhbmRsZXJzKGV2ZW50LCB0aGlzLCAncmVtb3ZlRWRnZScsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgRy5yZW1vdmVFZGdlc0Zyb20gPSBmdW5jdGlvbihlYnVuY2gpIHtcbiAgICB2YXIgZWRnZXMgPSBbXTtcbiAgICBmb3IgKHZhciBidW5jaCBvZiBlYnVuY2gpIHtcbiAgICAgIGVkZ2VzLnB1c2goYnVuY2guc2xpY2UoKSk7XG4gICAgfVxuICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgncmVtb3ZlRWRnZXMnKTtcbiAgICBldmVudC5lZGdlcyA9IGVkZ2VzO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gICAgYXJnc1swXSA9IGVkZ2VzO1xuXG4gICAgdHJpZ2dlckhhbmRsZXJzKGV2ZW50LCB0aGlzLCAncmVtb3ZlRWRnZXNGcm9tJywgYXJncyk7XG4gIH07XG5cbiAgRy5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRyaWdnZXJIYW5kbGVycyhuZXcgRXZlbnQoJ2NsZWFyJywgdGhpcyksIHRoaXMsICdjbGVhcicpO1xuICB9O1xuXG4gIHJldHVybiBHO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHByb3BlcnRpZXMgYWRkZWQgdG8gYSBncmFwaCBmb3IgZXZlbnQgaGFuZGxpbmcuXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gR1xuICogQHJldHVybiB7R3JhcGh9IFRoZSBncmFwaCBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bm9ic2VydmUoRykge1xuICB2YXIgcHJvdG8gPSBHLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICBpZiAodHlwZW9mIEcub24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgcmV0dXJuIEc7XG4gIH1cblxuICBHLmFkZE5vZGUgPSBwcm90by5hZGROb2RlO1xuICBHLmFkZE5vZGVzRnJvbWUgPSBwcm90by5hZGROb2Rlc0Zyb207XG4gIEcuYWRkRWRnZSA9IHByb3RvLmFkZEVkZ2U7XG4gIEcuYWRkRWRnZXNGcm9tZSA9IHByb3RvLmFkZEVkZ2VzRnJvbTtcbiAgRy5yZW1vdmVOb2RlID0gcHJvdG8ucmVtb3ZlTm9kZTtcbiAgRy5yZW1vdmVFZGdlID0gcHJvdG8ucmVtb3ZlRWRnZTtcbiAgRy5yZW1vdmVOb2Rlc0Zyb20gPSBwcm90by5yZW1vdmVOb2Rlc0Zyb207XG4gIEcucmVtb3ZlRWRnZXNGcm9tID0gcHJvdG8ucmVtb3ZlRWRnZXNGcm9tO1xuICBHLmNsZWFyID0gcHJvdG8uY2xlYXI7XG5cbiAgZGVsZXRlIEcub247XG4gIGRlbGV0ZSBHLm9mZjtcblxuICByZXR1cm4gRztcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIHRoZSBncmFwaCBpcyBvYnNlcnZhYmxlLlxuICpcbiAqIEBwYXJhbSB7R3JhcGh9IEdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09ic2VydmFibGUoRykge1xuICByZXR1cm4gdHlwZW9mIEcub24gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIEcub2ZmID09PSAnZnVuY3Rpb24nO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmV0dXJuIGEgZ3JhcGggb2JqZWN0IHJlYWR5IHRvIGJlIHBvcHVsYXRlZC5cbiAqXG4gKiBJZiBjcmVhdGVfdXNpbmcgaXMgbnVsbCBvciB1bmRlZmluZWQgcmV0dXJuIHRoZSBkZWZhdWx0IChqdXN0IGpzbnguR3JhcGgoKSlcbiAqIElmIGNyZWF0ZV91c2luZy5jbGVhcigpIHdvcmtzLCBhc3N1bWUgaXQgcmV0dXJucyBhIGdyYXBoIG9iamVjdC5cbiAqIE90aGVyd2lzZSByYWlzZSBhbiBleGNlcHRpb24gYmVjYXVzZSBjcmVhdGVfdXNpbmcgaXMgbm90IGEganNueCBncmFwaC5cbiAqXG4gKiBAcGFyYW0ge0dyYXBoPX0gb3B0X2NyZWF0ZV91c2luZ1xuICogQHJldHVybiB7R3JhcGh9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwQ3JlYXRlVXNpbmcob3B0Q3JlYXRlVXNpbmcpIHtcbiAgdmFyIEc7XG4gIC8vIGNhbid0IHVzZSBpbXBvcnQgc3RhdGVtZW50IGJlY2F1c2Ugb2YgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICB2YXIgR3JhcGggPSByZXF1aXJlKCcuLi9jbGFzc2VzL0dyYXBoJyk7XG5cbiAgaWYgKG9wdENyZWF0ZVVzaW5nID09IG51bGwpIHtcbiAgICBHID0gbmV3IEdyYXBoKCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgRyA9IG9wdENyZWF0ZVVzaW5nO1xuXG4gICAgdHJ5IHtcbiAgICAgIEcuY2xlYXIoKTtcbiAgICB9XG4gICAgY2F0Y2goZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklucHV0IGdyYXBoIGlzIG5vdCBhIGpzbnggZ3JhcGggdHlwZVwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJlcENyZWF0ZVVzaW5nO1xuIiwiLypqc2hpbnQgbGF0ZWRlZjpmYWxzZSovXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGNvbnZlcnRcbiAqIE5ldHdvcmtYIGdyYXBocyB0byBhbmQgZnJvbSBvdGhlciBmb3JtYXRzLlxuICpcbiAqIFRoZSBwcmVmZXJyZWQgd2F5IG9mIGNvbnZlcnRpbmcgZGF0YSB0byBhIE5ldHdvcmtYIGdyYXBoXG4gKiBpcyB0aHJvdWdoIHRoZSBncmFwaCBjb25zdHVjdG9yLiAgVGhlIGNvbnN0cnVjdG9yIGNhbGxzXG4gKiB0aGUgdG9fbmV0d29ya3hfZ3JhcGgoKSBmdW5jdGlvbiB3aGljaCBhdHRlbXB0cyB0byBndWVzcyB0aGVcbiAqIGlucHV0IHR5cGUgYW5kIGNvbnZlcnQgaXQgYXV0b21hdGljYWxseS5cbiAqL1xuXG4vKmpzaGludCBpZ25vcmU6c3RhcnQqL1xudmFyIE1hcCA9IHJlcXVpcmUoJy4vX2ludGVybmFscy9NYXAnKTtcbnZhciBTZXQgPSByZXF1aXJlKCcuL19pbnRlcm5hbHMvU2V0Jyk7XG4vKmpzaGludCBpZ25vcmU6ZW5kKi9cblxudmFyIGNvbnZlcnRNYXAgPSByZXF1aXJlKCcuL2NvbnRyaWIvY29udmVydCcpO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJlcENyZWF0ZVVzaW5nID0gcmVxdWlyZSgnLi9jb250cmliL3ByZXBDcmVhdGVVc2luZycpO1xudmFyIF9tYXBWYWx1ZXMgPSByZXF1aXJlKCdsb2Rhc2gvb2JqZWN0L21hcFZhbHVlcycpO1xuXG52YXIge1xuICBjbG9uZSxcbiAgZm9yRWFjaCxcbiAgaXNNYXAsXG4gIGlzQXJyYXlMaWtlLFxuICBpc1BsYWluT2JqZWN0XG59ID0gcmVxdWlyZSgnLi9faW50ZXJuYWxzJyk7XG5cbi8qKlxuICogTWFrZSBhIGpzbnggZ3JhcGggZnJvbSBhIGtub3duIGRhdGEgc3RydWN0dXJlLlxuICpcbiAqIEBwYXJhbSB7P30gZGF0YSBBbiBvYmplY3QgdG8gYmUgY29udmVydGVkXG4gKiAgICAgQ3VycmVudCBrbm93biB0eXBlcyBhcmU6XG4gKiAgICAgICAgYW55IGpzbnggZ3JhcGhcbiAqICAgICAgICBkaWN0LW9mLWRpY3RzXG4gKiAgICAgICAgZGljdC1vZi1saXN0c1xuICogICAgICAgIGxpc3Qgb2YgZWRnZXNcbiAqXG4gKiBAcGFyYW0ge0dyYXBoPX0gb3B0X2NyZWF0ZV91c2luZyBOZXR3b3JrWCBncmFwaFxuICogICAgIFVzZSBzcGVjaWZpZWQgZ3JhcGggZm9yIHJlc3VsdC4gIE90aGVyd2lzZSBhIG5ldyBncmFwaCBpcyBjcmVhdGVkLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9tdWx0aWdyYXBoX2lucHV0IChkZWZhdWx0IGZhbHNlKVxuICogICAgIElmIHRydWUgYW5kICBkYXRhIGlzIGEgZGljdF9vZl9kaWN0cyxcbiAqICAgICB0cnkgdG8gY3JlYXRlIGEgbXVsdGlncmFwaCBhc3N1bWluZyBkaWN0X29mX2RpY3Rfb2ZfbGlzdHMuXG4gKiAgICAgSWYgZGF0YSBhbmQgY3JlYXRlX3VzaW5nIGFyZSBib3RoIG11bHRpZ3JhcGhzIHRoZW4gY3JlYXRlXG4gKiAgICAgYSBtdWx0aWdyYXBoIGZyb20gYSBtdWx0aWdyYXBoLlxuICpcbiAqIEByZXR1cm4ge0dyYXBofVxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiB0b05ldHdvcmt4R3JhcGgoZGF0YSwgb3B0Q3JlYXRlVXNpbmcsIG9wdE11bHRpZ3JhcGhJbnB1dCkge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAvLyBqc254IGdyYXBoXG4gIGlmIChoYXNPd24uY2FsbChkYXRhLCAnYWRqJykpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY29udmVydE1hcC5mcm9tTWFwT2ZNYXBzKFxuICAgICAgICBkYXRhLmFkaixcbiAgICAgICAgb3B0Q3JlYXRlVXNpbmcsXG4gICAgICAgIGRhdGEuaXNNdWx0aWdyYXBoKClcbiAgICAgICk7XG4gICAgICBpZiAoaGFzT3duLmNhbGwoZGF0YSwgJ2dyYXBoJykgJiYgdHlwZW9mIGRhdGEuZ3JhcGggPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJlc3VsdC5ncmFwaCA9IGNsb25lKGRhdGEuZ3JhcGgpO1xuICAgICAgfVxuICAgICAgaWYgKGhhc093bi5jYWxsKGRhdGEsICdub2RlJykgJiYgaXNNYXAoZGF0YS5ub2RlKSkge1xuICAgICAgICByZXN1bHQubm9kZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgZGF0YS5ub2RlLmZvckVhY2goXG4gICAgICAgICAgKGVsZW1lbnQsIGspID0+IHJlc3VsdC5ub2RlLnNldChrLCBjbG9uZShlbGVtZW50KSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoKGV4KSB7XG4gICAgICB0aHJvdyBleDtcbiAgICB9XG4gIH1cblxuICAvLyBtYXAgb2YgbWFwcyAvIGxpc3RzXG4gIGlmIChpc01hcChkYXRhKSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29udmVydE1hcC5mcm9tTWFwT2ZNYXBzKFxuICAgICAgICBkYXRhLFxuICAgICAgICBvcHRDcmVhdGVVc2luZyxcbiAgICAgICAgb3B0TXVsdGlncmFwaElucHV0XG4gICAgICApO1xuICAgIH1cbiAgICBjYXRjaChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29udmVydE1hcC5mcm9tTWFwT2ZMaXN0cyhkYXRhLCBvcHRDcmVhdGVVc2luZyk7XG4gICAgICB9XG4gICAgICBjYXRjaChleCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcCBkYXRhIHN0cnVjdHVyZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgZ3JhcGguJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZGljdCBvZiBkaWN0cyAvIGxpc3RzXG4gIGlmIChpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmcm9tRGljdE9mRGljdHMoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9wdENyZWF0ZVVzaW5nLFxuICAgICAgICBvcHRNdWx0aWdyYXBoSW5wdXRcbiAgICAgICk7XG4gICAgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmcm9tRGljdE9mTGlzdHMoZGF0YSwgb3B0Q3JlYXRlVXNpbmcpO1xuICAgICAgfVxuICAgICAgY2F0Y2goZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdPYmplY3QgZGF0YSBzdHJ1Y3R1cmUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIGdyYXBoLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBsaXN0IG9mIGVkZ2VzXG4gIGlmIChpc0FycmF5TGlrZShkYXRhKSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnJvbUVkZ2VsaXN0KGRhdGEsIG9wdENyZWF0ZVVzaW5nKTtcbiAgICB9XG4gICAgY2F0Y2goZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpcyBub3QgYSB2YWxpZCBlZGdlIGxpc3QnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybiBhIG5ldyB1bmRpcmVjdGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncmFwaCBHLlxuICpcbiAqIEBwYXJhbSB7R3JhcGh9IEcgR3JhcGggdG8gY29udmVydFxuICpcbiAqIEByZXR1cm4geyFHcmFwaH1cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gY29udmVydFRvVW5kaXJlY3RlZChHKSB7XG4gIHJldHVybiBHLnRvVW5kaXJlY3RlZCgpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIG5ldyBkaXJlY3RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ3JhcGggRy5cbiAqXG4gKiBAcGFyYW0ge0dyYXBofSBHIEdyYXBoIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4geyFHcmFwaH1cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gY29udmVydFRvRGlyZWN0ZWQoRykge1xuICByZXR1cm4gRy50b0RpcmVjdGVkKCk7XG59XG5cbi8qKlxuICogUmV0dXJuIGFkamFjZW5jeSByZXByZXNlbnRhdGlvbiBvZiBncmFwaCBhcyBhIGRpY3Rpb25hcnkgb2YgbGlzdHMuXG4gKlxuICogQ29tcGxldGVseSBpZ25vcmVzIGVkZ2UgZGF0YSBmb3IgTXVsdGlHcmFwaCBhbmQgTXVsdGlEaUdyYXBoLlxuICpcbiAqIEBwYXJhbSB7R3JhcGh9IEcgQSBqc254IGdyYXBoXG4gKiBAcGFyYW0ge05vZGVDb250YWluZXI9fSBvcHRfbm9kZWxpc3QgVXNlIG9ubHkgbm9kZXMgc3BlY2lmaWVkIGluIG5vZGVsaXN0XG4gKlxuICogQHJldHVybiB7IU9iamVjdC48QXJyYXk+fVxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiB0b0RpY3RPZkxpc3RzKEcsIG9wdE5vZGVsaXN0KSB7XG4gIHZhciBjb250YWlucyA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gb3B0Tm9kZWxpc3QuaW5kZXhPZihuKSA+IC0xO1xuICB9O1xuICB2YXIgZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgaWYgKG9wdE5vZGVsaXN0ID09IG51bGwpIHtcbiAgICBvcHROb2RlbGlzdCA9IEc7XG4gICAgY29udGFpbnMgPSBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gb3B0Tm9kZWxpc3QuaGFzTm9kZShuKTtcbiAgICB9O1xuICB9XG4gIGVsc2Uge1xuICAgIG9wdE5vZGVsaXN0ID0gQXJyYXkuZnJvbShvcHROb2RlbGlzdCk7XG4gIH1cblxuICBmb3IgKHZhciBuIG9mIG9wdE5vZGVsaXN0KSB7XG4gICAgZFtuXSA9IEcubmVpZ2hib3JzKG4pLmZpbHRlcihjb250YWlucyk7XG4gIH1cblxuICByZXR1cm4gZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBncmFwaCBmcm9tIGEgZGljdGlvbmFyeSBvZiBsaXN0cy5cbiAqICpcbiAqIEBwYXJhbSB7IU9iamVjdC48QXJyYXk+fSBkIEEgZGljdGlvbmFyeSBvZiBsaXN0cyBhZGphY2VuY3kgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0ge0dyYXBoPX0gb3B0X2NyZWF0ZV91c2luZyBVc2Ugc3BlY2lmaWVkIGdyYXBoIGZvciByZXN1bHQuXG4gKiAgICBPdGhlcndpc2UgYSBuZXcgZ3JhcGggaXMgY3JlYXRlZC5cbiAqXG4gKiBAcmV0dXJuIHshR3JhcGh9XG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGZyb21EaWN0T2ZMaXN0cyhkLCBvcHRDcmVhdGVVc2luZykge1xuICB2YXIgRyA9IHByZXBDcmVhdGVVc2luZyhvcHRDcmVhdGVVc2luZyk7XG5cbiAgLy8gQ29udmVydCBudW1lcmljIHByb3BlcnR5IG5hbWVzIHRvIG51bWJlcnNcbiAgRy5hZGROb2Rlc0Zyb20oKGZ1bmN0aW9uKigpIHtcbiAgICBmb3IgKHZhciBuIGluIGQpIHtcbiAgICAgIHlpZWxkIGlzTmFOKG4pID8gbiA6ICtuO1xuICAgIH1cbiAgfSkoKSk7XG5cbiAgdmFyIG5vZGU7XG4gIHZhciBuYnJsaXN0O1xuICBpZihHLmlzTXVsdGlncmFwaCgpICYmICFHLmlzRGlyZWN0ZWQoKSkge1xuICAgIC8vIGEgZGljdF9vZl9saXN0cyBjYW4ndCBzaG93IG11bHRpZWRnZXMuICBCVVQgZm9yIHVuZGlyZWN0ZWQgZ3JhcGhzLFxuICAgIC8vIGVhY2ggZWRnZSBzaG93cyB1cCB0d2ljZSBpbiB0aGUgZGljdF9vZl9saXN0cy5cbiAgICAvLyBTbyB3ZSBuZWVkIHRvIHRyZWF0IHRoaXMgY2FzZSBzZXBhcmF0ZWx5LlxuICAgIHZhciBzZWVuID0gbmV3IFNldCgpO1xuXG4gICAgZm9yIChub2RlIGluIGQpIHtcbiAgICAgIG5icmxpc3QgPSBkW25vZGVdO1xuICAgICAgLy8gdHJlYXQgbnVtZXJpYyBrZXlzIGxpa2UgbnVtYmVyc1xuICAgICAgbm9kZSA9IGlzTmFOKG5vZGUpID8gbm9kZSA6ICtub2RlO1xuICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSovXG4gICAgICBmb3JFYWNoKG5icmxpc3QsIGZ1bmN0aW9uKG5icikge1xuICAgICAgICBpZiAoIXNlZW4uaGFzKG5icikpIHtcbiAgICAgICAgICBHLmFkZEVkZ2Uobm9kZSwgbmJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWVuLmFkZChub2RlKTsgLy8gZG9uJ3QgYWxsb3cgcmV2ZXJzZSBlZGdlIHRvIHNob3cgdXBcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGVkZ2VMaXN0ID0gW107XG4gICAgZm9yIChub2RlIGluIGQpIHtcbiAgICAgIG5icmxpc3QgPSBkW25vZGVdO1xuICAgICAgLy8gdHJlYXQgbnVtZXJpYyBrZXlzIGxpa2UgbnVtYmVyc1xuICAgICAgbm9kZSA9IGlzTmFOKG5vZGUpID8gbm9kZSA6ICtub2RlO1xuICAgICAgZm9yRWFjaChuYnJsaXN0LCBmdW5jdGlvbihuYnIpIHtcbiAgICAgICAgZWRnZUxpc3QucHVzaChbbm9kZSwgbmJyXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBHLmFkZEVkZ2VzRnJvbShlZGdlTGlzdCk7XG4gIH1cblxuICByZXR1cm4gRztcbn1cblxuLyoqXG4gKiBSZXR1cm4gYWRqYWNlbmN5IHJlcHJlc2VudGF0aW9uIG9mIGdyYXBoIGFzIGEgZGljdGlvbmFyeSBvZiBkaWN0aW9uYXJpZXMuXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gRyBBIGpzbnggR3JhcGhcbiAqIEBwYXJhbSB7Tm9kZUNvbnRhaW5lcj19IG9wdF9ub2RlbGlzdCBVc2Ugb25seSBub2RlcyBzcGVjaWZpZWQgaW4gbm9kZWxpc3RcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2VkZ2VfZGF0YSBJZiBwcm92aWRlZCwgIHRoZSB2YWx1ZSBvZiB0aGUgZGljdGlvbmFyeSB3aWxsXG4gKiAgICAgIGJlIHNldCB0byBlZGdlX2RhdGEgZm9yIGFsbCBlZGdlcy4gIFRoaXMgaXMgdXNlZnVsIHRvIG1ha2VcbiAqICAgICAgYW4gYWRqYWNlbmN5IG1hdHJpeCB0eXBlIHJlcHJlc2VudGF0aW9uIHdpdGggMSBhcyB0aGUgZWRnZSBkYXRhLlxuICogICAgICBJZiBlZGdlZGF0YSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgdGhlIGVkZ2VkYXRhIGluIEcgaXMgdXNlZCB0byBmaWxsXG4gKiAgICAgIHRoZSB2YWx1ZXMuXG4gKiAgICAgIElmIEcgaXMgYSBtdWx0aWdyYXBoLCB0aGUgZWRnZWRhdGEgaXMgYSBkaWN0IGZvciBlYWNoIHBhaXIgKHUsdikuXG4gKlxuICogQHJldHVybiB7IU9iamVjdC48T2JqZWN0Pn1cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gdG9EaWN0T2ZEaWN0cyhHLCBvcHROb2RlbGlzdCwgb3B0RWRnZURhdGEpIHtcbiAgdmFyIGRvZCA9IHt9O1xuXG4gIGlmIChvcHROb2RlbGlzdCAhPSBudWxsKSB7XG4gICAgb3B0Tm9kZWxpc3QgPSBBcnJheS5mcm9tKG9wdE5vZGVsaXN0KTtcbiAgICBpZihvcHRFZGdlRGF0YSAhPSBudWxsKSB7XG4gICAgICBvcHROb2RlbGlzdC5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgZG9kW3VdID0ge307XG4gICAgICAgIEcuZ2V0KHUpLmZvckVhY2goZnVuY3Rpb24oZGF0YSwgdikge1xuICAgICAgICAgIGlmIChvcHROb2RlbGlzdC5pbmRleE9mKHYpID4gLTEpIHtcbiAgICAgICAgICAgIGRvZFt1XVt2XSA9IG9wdEVkZ2VEYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIG5vZGVsaXN0IGFuZCBlZGdlX2RhdGEgYXJlIGRlZmluZWRcbiAgICAgIG9wdE5vZGVsaXN0LmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgICAgICBkb2RbdV0gPSB7fTtcbiAgICAgICAgRy5nZXQodSkuZm9yRWFjaChmdW5jdGlvbihkYXRhLCB2KSB7XG4gICAgICAgICAgaWYgKG9wdE5vZGVsaXN0LmluZGV4T2YodikgPiAtMSkge1xuICAgICAgICAgICAgZG9kW3VdW3ZdID0gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVsc2UgeyAvLyBub2RlbGlzdCBpcyB1bmRlZmluZWRcbiAgICBpZihvcHRFZGdlRGF0YSAhPSBudWxsKSB7XG4gICAgICAvLyBkbiA9IFtuYnJkaWN0LCB1XVxuICAgICAgZm9yICh2YXIgZG4gb2YgRy5hZGphY2VuY3lJdGVyKCkpIHtcbiAgICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSovXG4gICAgICAgIGRvZFtkblsxXV0gPSBfbWFwVmFsdWVzKGRuWzBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gb3B0RWRnZURhdGE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHsgLy8gZWRnZV9kYXRhIGlzIGRlZmluZWRcbiAgICAgIC8vIGRuID0gW25icmRpY3QsIHVdXG4gICAgICBmb3IgKHZhciBkbiBvZiBHLmFkamFjZW5jeUl0ZXIoKSkge1xuICAgICAgICBkb2RbZG5bMV1dID0gY2xvbmUoZG5bMF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb2Q7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZ3JhcGggZnJvbSBhIGRpY3Rpb25hcnkgb2YgZGljdGlvbmFyaWVzLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdC48IU9iamVjdD59IGQgQSBkaWN0aW9uYXJ5IG9mIGRpY3Rpb25hcmllcyBhZGphY2VuY3lcbiAqICAgICAgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0ge0dyYXBoPX0gb3B0X2NyZWF0ZV91c2luZyBVc2Ugc3BlY2lmaWVkIGdyYXBoIGZvciByZXN1bHQuXG4gKiAgICAgIE90aGVyd2lzZSBhIG5ldyBncmFwaCBpcyBjcmVhdGVkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X211bHRpZ3JhcGhfaW5wdXQgKGRlZmF1bHQ9RmFsc2UpXG4gKiAgICAgIFdoZW4gVHJ1ZSwgdGhlIHZhbHVlcyBvZiB0aGUgaW5uZXIgZGljdCBhcmUgYXNzdW1lZFxuICogICAgICB0byBiZSBjb250YWluZXJzIG9mIGVkZ2UgZGF0YSBmb3IgbXVsdGlwbGUgZWRnZXMuXG4gKiAgICAgIE90aGVyd2lzZSB0aGlzIHJvdXRpbmUgYXNzdW1lcyB0aGUgZWRnZSBkYXRhIGFyZSBzaW5nbGV0b25zLlxuICpcbiAqIEByZXR1cm4ge0dyYXBofVxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiBmcm9tRGljdE9mRGljdHMoZCwgb3B0Q3JlYXRlVXNpbmcsIG9wdE11bHRpZ3JhcGhJbnB1dCkge1xuICB2YXIgRyA9IHByZXBDcmVhdGVVc2luZyhvcHRDcmVhdGVVc2luZyk7XG4gIHZhciBzZWVuID0gbmV3IFNldCgpO1xuXG4gIC8vIENvbnZlcnQgbnVtZXJpYyBwcm9wZXJ0eSBuYW1lcyB0byBudW1iZXJzXG4gIEcuYWRkTm9kZXNGcm9tKChmdW5jdGlvbiooKSB7XG4gICAgZm9yICh2YXIgbiBpbiBkKSB7XG4gICAgICB5aWVsZCBpc05hTihuKSA/IG4gOiArbjtcbiAgICB9XG4gIH0pKCkpO1xuXG4gIC8vIGlzIGRpY3QgYSBNdWx0aUdyYXBoIG9yIE11bHRpRGlHcmFwaD9cbiAgaWYgKG9wdE11bHRpZ3JhcGhJbnB1dCkge1xuICAgIC8vIG1ha2UgYSBjb3B5ICBvZiB0aGUgbGlzdCBvZiBlZGdlIGRhdGEgKGJ1dCBub3QgdGhlIGVkZ2UgZGF0YSlcbiAgICBpZiAoRy5pc0RpcmVjdGVkKCkpIHtcbiAgICAgIGZvciAodmFyIHUgaW4gZCkge1xuICAgICAgICB2YXIgbmJycyA9IGRbdV07XG4gICAgICAgIGlmKGlzQXJyYXlMaWtlKG5icnMpKSB7IC8vIHRocm93IGV4Y2VwdGlvbiBvZiBub3QgZGljdCAob2JqZWN0KVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lubmVyIG9iamVjdCBzZWVtcyB0byBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyZWF0IG51bWVyaWMga2V5cyBsaWtlIG51bWJlcnNcbiAgICAgICAgdSA9IGlzTmFOKHUpID8gdSA6ICt1O1xuICAgICAgICBmb3IgKHZhciB2IGluIG5icnMpIHtcbiAgICAgICAgICB2YXIgZGF0YWRpY3QgPSBuYnJzW3ZdO1xuICAgICAgICAgIC8vIHRyZWF0IG51bWVyaWMga2V5cyBsaWtlIG51bWJlcnNcbiAgICAgICAgICB2ID0gaXNOYU4odikgPyB2IDogK3Y7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGFkaWN0KSB7XG4gICAgICAgICAgICBpZiAoRy5pc011bHRpZ3JhcGgoKSkge1xuICAgICAgICAgICAgICBHLmFkZEVkZ2UodSwgdiwga2V5LCBkYXRhZGljdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBHLmFkZEVkZ2UodSwgdiwgZGF0YWRpY3Rba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgeyAvLyB1bmRpcmVjdGVkXG4gICAgICAvLyBkb24ndCBhZGQgYm90aCBkaXJlY3Rpb25zIG9mIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgICAgIGZvciAodmFyIHUgaW4gZCkge1xuICAgICAgICB2YXIgbmJycyA9IGRbdV07XG4gICAgICAgIGlmKGlzQXJyYXlMaWtlKG5icnMpKSB7IC8vIHRocm93IGV4Y2VwdGlvbiBvZiBub3QgZGljdCAob2JqZWN0KVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lubmVyIG9iamVjdCBzZWVtcyB0byBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyZWF0IG51bWVyaWMga2V5cyBsaWtlIG51bWJlcnNcbiAgICAgICAgdSA9IGlzTmFOKHUpID8gdSA6ICt1O1xuICAgICAgICBmb3IgKHZhciB2IGluIG5icnMpIHtcbiAgICAgICAgICB2YXIgZGF0YWRpY3QgPSBuYnJzW3ZdO1xuICAgICAgICAgIC8vIHRyZWF0IG51bWVyaWMga2V5cyBsaWtlIG51bWJlcnNcbiAgICAgICAgICB2ID0gaXNOYU4odikgPyB2IDogK3Y7XG4gICAgICAgICAgaWYoIXNlZW4uaGFzKFt1LCB2XSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhZGljdCkge1xuICAgICAgICAgICAgICBpZiAoRy5pc011bHRpZ3JhcGgoKSkge1xuICAgICAgICAgICAgICAgIEcuYWRkRWRnZSh1LCB2LCBrZXksIGRhdGFkaWN0W2tleV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEcuYWRkRWRnZSh1LCB2LCBkYXRhZGljdFtrZXldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Vlbi5hZGQoW3YsIHVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7IC8vIG5vdCBhIG11bHRpZ3JhcGggdG8gbXVsdGlncmFwaCB0cmFuc2ZlclxuICAgIGlmKEcuaXNNdWx0aWdyYXBoKCkgJiYgIUcuaXNEaXJlY3RlZCgpKSB7XG4gICAgICAvLyBkIGNhbiBoYXZlIGJvdGggcmVwcmVzZW50YXRpb25zIHUtdiwgdi11IGluIGRpY3QuICBPbmx5IGFkZCBvbmUuXG4gICAgICAvLyBXZSBkb24ndCBuZWVkIHRoaXMgY2hlY2sgZm9yIGRpZ3JhcGhzIHNpbmNlIHdlIGFkZCBib3RoIGRpcmVjdGlvbnMsXG4gICAgICAvLyBvciBmb3IgR3JhcGgoKSBzaW5jZSBpdCBpcyBkb25lIGltcGxpY2l0bHkgKHBhcmFsbGVsIGVkZ2VzIG5vdCBhbGxvd2VkKVxuICAgICAgZm9yICh2YXIgdSBpbiBkKSB7XG4gICAgICAgIHZhciBuYnJzID0gZFt1XTtcbiAgICAgICAgaWYoaXNBcnJheUxpa2UobmJycykpIHsgLy8gdGhyb3cgZXhjZXB0aW9uIG9mIG5vdCBkaWN0IChvYmplY3QpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5uZXIgb2JqZWN0IHNlZW1zIHRvIGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJlYXQgbnVtZXJpYyBrZXlzIGxpa2UgbnVtYmVyc1xuICAgICAgICB1ID0gaXNOYU4odSkgPyB1IDogK3U7XG4gICAgICAgIGZvciAodmFyIHYgaW4gbmJycykge1xuICAgICAgICAgIHZhciBkYXRhID0gbmJyc1t2XTtcbiAgICAgICAgICB2ID0gaXNOYU4odikgPyB2IDogK3Y7XG4gICAgICAgICAgaWYgKCFzZWVuLmhhcyhbdSwgdl0pKSB7XG4gICAgICAgICAgICBHLmFkZEVkZ2UodSwgdiwgZGF0YSk7XG4gICAgICAgICAgICBzZWVuLmFkZChbdiwgdV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvciAodmFyIHUgaW4gZCkge1xuICAgICAgICB2YXIgbmJycyA9IGRbdV07XG4gICAgICAgIGlmKGlzQXJyYXlMaWtlKG5icnMpKSB7IC8vIHRocm93IGV4Y2VwdGlvbiBvZiBub3QgZGljdCAob2JqZWN0KVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lubmVyIG9iamVjdCBzZWVtcyB0byBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyZWF0IG51bWVyaWMga2V5cyBsaWtlIG51bWJlcnNcbiAgICAgICAgdSA9IGlzTmFOKHUpID8gdSA6ICt1O1xuICAgICAgICBmb3IgKHZhciB2IGluIG5icnMpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IG5icnNbdl07XG4gICAgICAgICAgLy8gdHJlYXQgbnVtZXJpYyBrZXlzIGxpa2UgbnVtYmVyc1xuICAgICAgICAgIHYgPSBpc05hTih2KSA/IHYgOiArdjtcbiAgICAgICAgICBHLmFkZEVkZ2UodSwgdiwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gRztcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGVkZ2VzIGluIHRoZSBncmFwaC5cbiAqXG4gKiBAcGFyYW0ge0dyYXBofSBHIEEganNueCBncmFwaFxuICogQHBhcmFtIHtOb2RlQ29udGFpbmVyPX0gb3B0X25vZGVsaXN0IFVzZSBvbmx5IG5vZGVzIHNwZWNpZmllZCBpbiBub2RlbGlzdFxuICpcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gdG9FZGdlbGlzdChHLCBvcHROb2RlbGlzdCkge1xuICBpZiAob3B0Tm9kZWxpc3QgIT0gbnVsbCkge1xuICAgIHJldHVybiBHLmVkZ2VzKG9wdE5vZGVsaXN0LCB0cnVlKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gRy5lZGdlcyhudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogUmV0dXJuIGEgZ3JhcGggZnJvbSBhIGxpc3Qgb2YgZWRnZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSBlZGdlbGlzdCBFZGdlIHR1cGxlc1xuICogQHBhcmFtIHtHcmFwaD19IG9wdF9jcmVhdGVfdXNpbmcgVXNlIHNwZWNpZmllZCBncmFwaCBmb3IgcmVzdWx0LlxuICogICAgICBPdGhlcndpc2UgYSBuZXcgZ3JhcGggaXMgY3JlYXRlZC5cbiAqXG4gKiBAcmV0dXJuIHshR3JhcGh9XG4gKiBAZXhwb3J0XG4gKi9cbmZ1bmN0aW9uIGZyb21FZGdlbGlzdChlZGdlbGlzdCwgb3B0Q3JlYXRlVXNpbmcpIHtcbiAgdmFyIEcgPSBwcmVwQ3JlYXRlVXNpbmcob3B0Q3JlYXRlVXNpbmcpO1xuICBHLmFkZEVkZ2VzRnJvbShlZGdlbGlzdCk7XG4gIHJldHVybiBHO1xufVxuXG5cbi8vIE5PVCBJTVBMRU1FTlRFRFxuXG4vLyB0b19udW1weV9tYXRyaXhcbi8vIGZyb21fbnVtcHlfbWF0cml4XG4vLyB0b19udW1weV9yZWNhcnJheVxuLy8gdG9fc2NpcHlfc3BhcnNlX21hdHJpeFxuLy8gZnJvbV9zY2lweV9zcGFyc2VfbWF0cml4XG4vLyBzZXR1cF9tb2R1bGVcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRvTmV0d29ya3hHcmFwaCxcbiAgY29udmVydFRvVW5kaXJlY3RlZCxcbiAgY29udmVydFRvRGlyZWN0ZWQsXG4gIHRvRGljdE9mTGlzdHMsXG4gIGZyb21EaWN0T2ZMaXN0cyxcbiAgdG9EaWN0T2ZEaWN0cyxcbiAgZnJvbURpY3RPZkRpY3RzLFxuICB0b0VkZ2VsaXN0LFxuICBmcm9tRWRnZWxpc3Rcbn07XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgc3ZnIGZyb20gJy4vc3ZnJztcblxuZXhwb3J0IHtzdmd9O1xuZXhwb3J0ICogZnJvbSAnLi9zdmcnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqXG4gKiBEMyhodHRwOi8vbWJvc3RvY2suZ2l0aHViLmNvbS9kMy8pIGlzIGEgcG93ZXJmdWwgbGlicmFyeSB0byBhc3NvY2lhdGUgZGF0YVxuICogd2l0aCBlbGVtZW50cyBhbmQgcHJvdmlkZXMgdmFyaW91cyBoZWxwZnVsIG1ldGhvZHMgdG8gdmlzdWFsaXplIHRoZSBkYXRhLFxuICogc3VjaCBhcyBjb2xvciBnZW5lcmF0b3JzLCBsYXlvdXRzIGFuZCBET00gbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gKlxuICogTm90ZTogRDMgbXVzdCBiZSBpbmNsdWRlZCBiZWZvcmUgcnVubmluZyB0aGVzZSBmdW5jdGlvbnNcbiAqL1xuXG5pbXBvcnQge1xuICBNYXAsXG4gIFNldCxcbiAgZGVlcG1lcmdlLFxuICBnZXREZWZhdWx0LFxuICBpc0FycmF5TGlrZVxufSBmcm9tICcuLi9faW50ZXJuYWxzJztcblxudmFyIG51bGxGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge307XG5cbmZ1bmN0aW9uIGFuZ2xlRm9yKHgxLCB5MSwgeDIsIHkyKSB7XG4gIHJldHVybiBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogMTgwIC8gTWF0aC5QSTtcbn1cblxuLyoqXG4gKiBTYWZlbHkgY29udmVydHMgYW4gaXRlcmF0b3IgdG8gYW4gYXJyYXkuIEJlY2F1c2Ugd2Ugb2Z0ZW4gdXNlIHR1cGxlcyB3aGVuXG4gKiB1c2luZyBnZW5lcmF0b3JzIGludGVybmFsbHksIHdlIGhhdmUgdG8gYmUgY2FyZWZ1bCB3aGVuIGNvbnZlcnRpbmcgdGhlXG4gKiBnZW5lcmF0b3IgdG8gYW4gYXJyYXkuIEV2ZXJ5IGVsZW1lbnQgaGFzIHRvIGJlIGNvbnZlcnRlZCBleHBsaWNpdGx5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5KGl0ZXJhdG9yKSB7XG4gIC8vIHNob3J0Y3V0LiBJZiB0aGUgdmFsdWUgaXMgYWN0dWFsbHkgYW4gYXJyYXksIHdlIGNhbiBqdXN0IHJldHVybiBpdFxuICBpZiAoQXJyYXkuaXNBcnJheShpdGVyYXRvcikpIHtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIHZhbHVlIG9mIGl0ZXJhdG9yKSB7XG4gICAgcmVzdWx0W2krK10gPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IEFycmF5LmZyb20odmFsdWUpIDogdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBIb2xkcyBhIHJlZmVyZW5jZSB0byB0aGUgbGFzdCBjb250YWluZXIgZWxlbWVudCBmb3IgY29udmVuaWVuY2UuXG4gKlxuICogQHR5cGUgez8oc3RyaW5nfEVsZW1lbnQpfVxuICogQHByaXZhdGVcbiAqL1xudmFyIExBU1RfRUxFTUVOVCA9IG51bGw7XG5cbi8qKlxuICogSG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIGxhc3QgY29uZmlndXJhdGlvbiBmb3IgY29udmVuaWVuY2UuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBMQVNUX0NPTkZJR1VSQVRJT04gPSBudWxsO1xuXG4vKipcbiAqIEEgbGlzdCBvZiBncmFwaCBtdXRhdG9yIG1ldGhvZHMuXG4gKlxuICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICogQGNvbnN0XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTVVUQVRPUl9NRVRIT0RTID0gW1xuICAnYWRkTm9kZScsXG4gICdhZGROb2Rlc0Zyb20nLFxuICAnYWRkRWRnZScsXG4gICdhZGRFZGdlc0Zyb20nLFxuICAncmVtb3ZlTm9kZScsXG4gICdyZW1vdmVOb2Rlc0Zyb20nLFxuICAncmVtb3ZlRWRnZScsXG4gICdyZW1vdmVFZGdlc0Zyb20nLFxuICAnY2xlYXInXG5dO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdGhlIEQzIGRhdGEgaXMgYXNzaWduZWQgdG8gaW4gdGhlIG5vZGUgYW5kXG4gKiBlZGdlIGRhdGEuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgRDNfREFUQV9OQU1FID0gJ19fZDNkYXR1bV9fJztcblxuLyoqXG4gKiBLZWVwIGEgcmVmZXJlbmNlIHRvIGQzLlxuICovXG52YXIgZDMgPSBnbG9iYWwuZDM7XG5cbi8qKlxuICogRHJhdyBncmFwaCBHIHdpdGggRDMuXG4gKlxuICpcbiAqIEBwYXJhbSB7anNueC5jbGFzc2VzLkdyYXBofSBHIFRoZSBncmFwaCB0byBkcmF3XG4gKiBAcGFyYW0gez9PYmplY3Q9fSBjb25maWcgQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICogICAgICBmb3IgRDMuIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICpcbiAqICAgICAgLSBlbGVtZW50OiBET01FbGVtZW50IG9yIHNlbGVjdG9yIHN0cmluZy4gUkVRVUlSRURcbiAqICAgICAgICAgICAgICAgICBUaGUgZWxlbWVudCB0byBkcmF3IHRoZSBncmFwaCBpbnRvLlxuICogICAgICAtIGQzOiBBIHJlZmVyZW5jZSB0byBEMy4gQ2FuIGJlIHVzZWQgaWYgZDMgaXMgbm90IGdsb2JhbC5cbiAqICAgICAgLSB3aWR0aDogbnVtYmVyIFRoZSB3aWR0aCBvZiB0aGUgZHJhd2luZyBhcmVhIGluIHBpeGVsLlxuICogICAgICAgICAgICAgICBEZWZhdWx0IGlzIHRoZSB3aWR0aCBvZiBlbGVtZW50LlxuICogICAgICAtIGhlaWdodDogbnVtYmVyIFRoZSBoZWlnaHQgb2YgdGhlIGRyYXdpbmcgYXJlIGluIHBpeGVsLlxuICogICAgICAgICAgICAgICAgRGVmYXVsdCBpcyB0aGUgaGVpZ2h0IG9mIGVsZW1lbnQuXG4gKiAgICAgIC0gbGF5b3V0X2F0dHI6IE9iamVjdCBBIGRpY3Rpb25hcnkgb2YgbGF5b3V0IGF0dHJpYnV0ZXMuXG4gKiAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgbGF5b3V0IGlzIGZvcmNlLCBzbyB0aGUgdGhlIGF0dHJpYnV0ZXNcbiAqICAgICAgICAgICAgICBjYW4gYmUgc2l6ZSwgbGlua0Rpc3RhbmNlLCBsaW5rU3RyZW5ndGgsIGZyaWN0aW9uLFxuICogICAgICAgICAgICAgIGNoYXJnZSwgdGhldGEgYW5kIGdyYXZpdHkuIG5vZGVzIGFuZCBsaW5rcyBhcmUgc2V0XG4gKiAgICAgICAgICAgICAgdGhyb3VnaCB0aGUgZ3JhcGhcbiAqICAgICAgLSBub2RlbGlzdDogQXJyYXkgQW4gYXJyYXkgb2Ygbm9kZXMgdG8gYmUgZHJhd24uIE5vZGVzIG5vdCBpbiB0aGVcbiAqICAgICAgICAgIEdyYXBoIGFyZSBpZ25vcmVkXG4gKiAgICAgIC0gbm9kZV9zaGFwZTogc3RyaW5nIE5hbWUgb2YgYSBTVkcgZWxlbWVudC4gRGVmYXVsdCBpcyBjaXJjbGVcbiAqICAgICAgLSBub2RlX2F0dHI6IE9iamVjdCBBIGRpY3Rpb25hcnkgb2YgYXR0cmlidXRlcyB0byBzZXQgb24gZWFjaFxuICogICAgICAgICAgbm9kZSBTVkcgZWxlbWVudC4gU2VlIEQzIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiAgICAgIC0gbm9kZV9zdHlsZTogT2JqZWN0IEEgZGljdGlvbmFyeSBvZiBDU1Mgc3R5bGVzIHRvIHNldCBvbiBlYWNoXG4gKiAgICAgICAgICBub2RlIFNWRyBlbGVtZW50LiBTZWUgRDMgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqICAgICAgLSBlZGdlX2F0dHI6IE9iamVjdFxuICogICAgICAtIGVkZ2Vfc3R5bGU6IE9iamVjdFxuICogICAgICAtIHdpdGhfbGFiZWxzOiBib29sZWFuIChkZWZhdWx0PWZhbHNlKSBTZXQgdG8gdHJ1ZSB0byBkcmF3IGxhYmVsc1xuICogICAgICAgICAgb24gdGhlIG5vZGVzLiBFYWNoIGxhYmVsIGlzIGEgU1ZHIHRleHQgbm9kZS5cbiAqICAgICAgLSBsYWJlbHM6IGZ1bmN0aW9uIG9yIERpY3Rpb25hcnkgb3JlIHN0cmluZyB0byByZXR1cm4gb3IgcmV0cmlldmUgdGhlXG4gKiAgICAgICAgICBsYWJlbCBmb3IgZWFjaCBub2RlLlxuICogICAgICAtIGxhYmVsX2F0dHI6IE9iamVjdFxuICogICAgICAtIGxhYmVsX3N0eWxlOiBPYmplY3RcbiAqICAgICAgLSB3aXRoX2VkZ2VfbGFiZWxzOiBib29sZWFuXG4gKiAgICAgIC0gZWRnZV9sYWJlbHM6IGZ1bmN0aW9uIG9yIERpY3Rpb25hcnkgb3Igc3RyaW5nXG4gKiAgICAgIC0gZWRnZV9sYWJlbF9hdHRyOiBPYmplY3RcbiAqICAgICAgLSBlZGdlX2xhYmVsX3N0eWxlOiBPYmplY3RcbiAqICAgICAgLSB3ZWlnaHRlZDogYm9vbGVhblxuICogICAgICAtIHdlaWdodHM6IHN0cmluZyBvciBmdW5jdGlvblxuICogICAgICAtIGVkZ2Vfb2Zmc2V0OiBudW1iZXIgb3IgZnVuY3Rpb25cbiAqICAgICAgLSBwYW5fem9vbTogb2JqZWN0IHdpdGggcHJvcGVydGllcyBgZW5hYmxlZGAgKGJvb2wpIGFuZCBgc2NhbGVgIChib29sKVxuICpcbiAqICBAcGFyYW0gez9ib29sZWFuPX0gb3B0QmluZCBTZXQgdG8gdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IHVwZGF0ZVxuICogICAgICB0aGUgb3V0cHV0IHVwb24gZ3JhcGggbWFuaXB1bGF0aW9uLiBPbmx5IHdvcmtzIGZvciBhZGRpbmcgbm9kZXMgb3IgZWRnZXNcbiAqICAgICAgZm9yIG5vdy5cbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXcoRywgY29uZmlnLCBvcHRCaW5kKSB7XG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnYm9vbGVhbicpIHtcbiAgICAgIG9wdEJpbmQgPSBjb25maWc7XG4gICAgICBjb25maWcgPSBudWxsO1xuICB9XG5cbiAgY29uZmlnID0gY29uZmlnIHx8IExBU1RfQ09ORklHVVJBVElPTiB8fCB7fTtcbiAgTEFTVF9DT05GSUdVUkFUSU9OID0gY29uZmlnO1xuICBpZiAoY29uZmlnLmQzKSB7XG4gICAgZDMgPSBjb25maWcuZDM7XG4gIH1cbiAgY29uZmlnID0gZGVlcG1lcmdlKHt9LCBERUZBVUxUX0NPTkZJRywgY29uZmlnKTtcblxuICBpZiAoIWQzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEMyByZXF1cmllZCBmb3IgZHJhdygpJyk7XG4gIH1cblxuICBpZiAoY29uZmlnLmVsZW1lbnQgPT0gbnVsbCAmJiBMQVNUX0VMRU1FTlQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT3V0cHV0IGVsZW1lbnQgcmVxdWlyZWQgZm9yIGRyYXcoKScpO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZVxuICBMQVNUX0VMRU1FTlQgPSBjb25maWcuZWxlbWVudCB8fCBMQVNUX0VMRU1FTlQ7XG5cbiAgLy8gcmVtb3ZlIGFueSBwb3NzaWJsZSBwcmV2aW91cyBncmFwaFxuICBkMy5zZWxlY3QoTEFTVF9FTEVNRU5UKS5zZWxlY3QoJ3N2Zy5qc254JykucmVtb3ZlKCk7XG5cbiAgLy8gc2V0IHVwIGJhc2UgZWxlbWVudHNcbiAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdChMQVNUX0VMRU1FTlQpO1xuICB2YXIgZDNub2RlcyA9IFtdO1xuICB2YXIgZDNsaW5rcyA9IFtdO1xuICB2YXIgY2FudmFzID0gY29udGFpbmVyXG4gICAgLmFwcGVuZCgnc3ZnJylcbiAgICAuY2xhc3NlZCgnanNueCcsIHRydWUpXG4gICAgLmF0dHIoJ3BvaW50ZXItZXZlbnRzJywgJ2FsbCcpO1xuICB2YXIgcGFyZW50X2NvbnRhaW5lciA9IGNhbnZhcy5hcHBlbmQoJ2cnKTtcbiAgdmFyIGVkZ2Vfc2VsZWN0aW9uID0gcGFyZW50X2NvbnRhaW5lclxuICAgIC5hcHBlbmQoJ2cnKVxuICAgIC5jbGFzc2VkKCdlZGdlcycsIHRydWUpXG4gICAgLnNlbGVjdEFsbCgnZy5lZGdlJyk7XG4gIHZhciBub2RlX3NlbGVjdGlvbiA9IHBhcmVudF9jb250YWluZXJcbiAgICAuYXBwZW5kKCdnJylcbiAgICAuY2xhc3NlZCgnbm9kZXMnLCB0cnVlKVxuICAgIC5zZWxlY3RBbGwoJ2cubm9kZScpO1xuICB2YXIgZm9yY2UgPSBkMy5sYXlvdXQuZm9yY2UoKTtcbiAgdmFyIHdpZHRoID0gY29uZmlnLndpZHRoIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSwgMTApO1xuICB2YXIgaGVpZ2h0ID0gY29uZmlnLmhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpLCAxMCk7XG4gIHZhciBsYXlvdXRfYXR0ciA9IGNvbmZpZy5sYXlvdXRBdHRyO1xuICB2YXIgbm9kZWxpc3QgPSBjb25maWcubm9kZWxpc3QgfHwgbnVsbDtcbiAgdmFyIGxhYmVsX2Z1bmM7XG4gIHZhciBlZGdlX2xhYmVsX2Z1bmM7XG4gIHZhciB3ZWlnaHRfZnVuYztcbiAgdmFyIGRpcmVjdGVkID0gRy5pc0RpcmVjdGVkKCk7XG4gIHZhciB3ZWlnaHRlZCA9ICBjb25maWcud2VpZ2h0ZWQ7XG4gIHZhciBzZWxlY3Rpb25zID0ge1xuICAgIG5vZGVfc2VsZWN0aW9uOiBub2RlX3NlbGVjdGlvbixcbiAgICBlZGdlX3NlbGVjdGlvbjogZWRnZV9zZWxlY3Rpb25cbiAgfTtcblxuICAvLyBkZXRlcm1pbmUgbm9kZSBsYWJlbCBmdW5jdGlvblxuICBpZiAoY29uZmlnLndpdGhMYWJlbHMpIHtcbiAgICB2YXIgbGFiZWxzID0gIGNvbmZpZy5sYWJlbHM7XG4gICAgc3dpdGNoICh0eXBlb2YgbGFiZWxzKSB7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBsYWJlbF9mdW5jID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBnZXREZWZhdWx0KGxhYmVsc1tkLm5vZGVdLCAnJyk7XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICBsYWJlbF9mdW5jID0gbGFiZWxzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGxhYmVsX2Z1bmMgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuZGF0YVtsYWJlbHNdO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxhYmVsX2Z1bmMgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIGQubm9kZTtcbiAgICAgICAgfTtcbiAgICB9XG4gIH1cbiAgY29uZmlnLmxhYmVscyA9IGxhYmVsX2Z1bmM7XG5cbiAgLy8gaWYgdGhlIGdyYXBoIHNob3VsZCBiZSB3ZWlnaHRlZCwgd2UgbmVlZCBhIHdlaWdodCBmdW5jdGlvblxuICAvLyB0aGVzZSB3aWxsIGJlIHVzZWQgYXMgZWRnZSBsYWJlbHMgaWYgbm8gb3RoZXJzIGFyZSBwcm92aWRlZFxuICBpZiAod2VpZ2h0ZWQpIHtcbiAgICB2YXIgd2VpZ2h0cyA9ICBjb25maWcud2VpZ2h0cztcbiAgICBzd2l0Y2ggKHR5cGVvZiB3ZWlndGhzKSB7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICB3ZWlnaHRfZnVuYyA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdCh3ZWlnaHRzW2Qubm9kZV0sIDEpO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgd2VpZ2h0X2Z1bmMgPSB3ZWlnaHRzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHdlaWdodF9mdW5jID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBnZXREZWZhdWx0KGQuZGF0YVt3ZWlnaHRzXSwgMSk7XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd2VpZ2h0X2Z1bmMgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGVkZ2UgbGFiZWxzXG4gIGlmIChjb25maWcud2l0aEVkZ2VMYWJlbHMpIHtcbiAgICB2YXIgZWxhYmVscyA9IGNvbmZpZy5lZGdlTGFiZWxzO1xuXG4gICAgaWYgKHdlaWdodGVkICYmIGVsYWJlbHMgPT0gbnVsbCkge1xuICAgICAgZWRnZV9sYWJlbF9mdW5jID0gd2VpZ2h0X2Z1bmM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3dpdGNoICh0eXBlb2YgZWxhYmVscykge1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGVkZ2VfbGFiZWxfZnVuYyA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXREZWZhdWx0KGxhYmVsc1tkLm5vZGVdLCAnJyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgIGVkZ2VfbGFiZWxfZnVuYyA9IGVsYWJlbHM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgZWRnZV9sYWJlbF9mdW5jID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuZGF0YVtlbGFiZWxzXTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGVkZ2VfbGFiZWxfZnVuYyA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmVkZ2U7XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uZmlnLmVkZ2VMYWJlbHMgPSBlZGdlX2xhYmVsX2Z1bmM7XG4gIH1cblxuICAvLyBzY2FsZSB0aGUgd2lkdGggb2YgdGhlIGVkZ2UgYWNjb3JkaW5nIHRvIHRoZSB3ZWlnaHRcbiAgaWYgKHdlaWdodGVkICYmIGNvbmZpZy53ZWlnaHRlZFN0cm9rZSkge1xuICAgIHZhciBtYXhfd2VpZ2h0ID0gMTtcbiAgICBmb3IgKGxldCB7dSx2LGRhdGF9IG9mIEcuZWRnZXNJdGVyKG51bGwsIHRydWUpKSB7XG4gICAgICBsZXQgd2VpZ2h0ID0gd2VpZ2h0X2Z1bmMoe2RhdGF9KTtcbiAgICAgIGlmICh3ZWlnaHQgPiBtYXhfd2VpZ2h0KSB7XG4gICAgICAgIG1heF93ZWlnaHQgPSB3ZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAucmFuZ2UoWzIsIGNvbmZpZy5lZGdlU3R5bGVbJ3N0cm9rZS13aWR0aCddXSlcbiAgICAgIC5kb21haW4oWzAsIG1heF93ZWlnaHRdKTtcblxuICAgIGNvbmZpZy5lZGdlU3R5bGVbJ3N0cm9rZS13aWR0aCddID0gZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIHNjYWxlKHdlaWdodF9mdW5jLmNhbGwodGhpcywgZCkpO1xuICAgIH07XG4gIH1cblxuICAvLyByZW1vdmUgYW55IHBvc3NpYmxlIHByZXZpb3VzIGdyYXBoXG4gIGNhbnZhcy5zZWxlY3QoJ3N2Zy5qc254JykucmVtb3ZlKCk7XG5cbiAgLy8gc2V0IHNpemUgYW5kIGhpZGUgdGhlIHdpbGQgbW92ZW1lbnQgb2Ygbm9kZXMgYXQgdGhlIGJlZ2lubmluZ1xuICBjYW52YXNcbiAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoICsgJ3B4JylcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKVxuICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxZS02KVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDEwMDApXG4gICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuXG5cbiAgLy8gaW5pdGlhbGl6ZSBsYXlvdXRcbiAgLy8gZG9uJ3QgbGV0IHRoZSB1c2VyIHNldCB0aGVzZTpcbiAgdmFyIGV4Y2x1ZGUgPSB7XG4gICAgc2l6ZTogdHJ1ZSxcbiAgICBub2RlczogdHJ1ZSxcbiAgICBsaW5rczogdHJ1ZSxcbiAgICBzdGFydDogdHJ1ZVxuICB9O1xuXG4gIGZvciAobGV0IGF0dHIgaW4gbGF5b3V0X2F0dHIpIHtcbiAgICBpZiAoZXhjbHVkZVthdHRyXSAhPT0gdHJ1ZSkge1xuICAgICAgZm9yY2VbYXR0cl0obGF5b3V0X2F0dHJbYXR0cl0pO1xuICAgIH1cbiAgfVxuICBmb3JjZS5ub2RlcyhkM25vZGVzKS5saW5rcyhkM2xpbmtzKS5zaXplKFt3aWR0aCwgaGVpZ2h0XSk7XG5cbiAgLy8gc2V0IHVwIHpvb20gYW5kIHBhbiBiZWhhdmlvdXJcbiAgdmFyIHpvb20gPSAxO1xuICB2YXIgaW52X3NjYWxlID0gMTsgLy8gdXNlZCB0byBzY2FsZSBub2RlcyBhbmQgdGV4dCBhY2NvcmRpbmdseVxuXG4gIGlmIChjb25maWcucGFuWm9vbS5lbmFibGVkKSB7XG4gICAgbGV0IHNjYWxlZCA9IGNvbmZpZy5wYW5ab29tLnNjYWxlO1xuICAgIGxldCB6b29taW5nID0gZmFsc2U7XG4gICAgbGV0IHpvb21fc3RhcnRfc2NhbGUgPSAxO1xuICAgIGxldCB6b29tX3N0YXJ0ID0gem9vbTtcblxuICAgIGNhbnZhcy5jYWxsKGQzLmJlaGF2aW9yLnpvb20oKS5vbignem9vbScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNoaWZ0S2V5ID0gZDMuZXZlbnQuc291cmNlRXZlbnQuc2hpZnRLZXksXG4gICAgICB6b29tZWQgPSAoc2NhbGVkICYmIHNoaWZ0S2V5KSB8fCAhKHNjYWxlZCB8fCBzaGlmdEtleSk7XG5cbiAgICAgIC8vIGlmIHRoZSBncmFwaCBpcyB6b29tZWQsIHdlIGhhdmUgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAgICAgIC8vIHJhdGlvbiBpdCB3YXMgem9vbWVkIGJ5XG4gICAgICBpZih6b29tZWQgJiYgIXpvb21pbmcpIHtcbiAgICAgICAgem9vbV9zdGFydF9zY2FsZSA9IGQzLmV2ZW50LnNjYWxlO1xuICAgICAgICB6b29tX3N0YXJ0ID0gem9vbTtcbiAgICAgICAgem9vbWluZyA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghem9vbWVkICYmIHpvb21pbmcpIHtcbiAgICAgICAgem9vbWluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB6b29tID0gIHpvb21lZCA/IHpvb21fc3RhcnQgKiAoZDMuZXZlbnQuc2NhbGUvem9vbV9zdGFydF9zY2FsZSkgOiB6b29tO1xuICAgICAgaW52X3NjYWxlID0gIXpvb21lZCA/ICB6b29tIC8gZDMuZXZlbnQuc2NhbGUgOiBpbnZfc2NhbGU7XG5cbiAgICAgIHZhciB0ciA9IGQzLmV2ZW50LnRyYW5zbGF0ZTtcbiAgICAgIHBhcmVudF9jb250YWluZXIuYXR0cihcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICd0cmFuc2xhdGUoJyArICB0clswXSArICcsJyArICB0clsxXSArICcpc2NhbGUoJyArIGQzLmV2ZW50LnNjYWxlICsgJyknXG4gICAgICApO1xuICAgICAgcmVkcmF3KCk7XG4gICAgfSkpO1xuICB9XG5cbiAgdmFyIHVwZGF0ZV9lZGdlX3Bvc2l0aW9uID0gbnVsbEZ1bmN0aW9uO1xuICB2YXIgb2Zmc2V0ID0gY29uZmlnLmVkZ2VPZmZzZXQ7XG4gIHZhciBub2RlX3JhZGl1cyA9IGNvbmZpZy5ub2RlQXR0ci5yO1xuICB2YXIgbm9kZV9zdHJ3ID0gY29uZmlnLm5vZGVTdHlsZVsnc3Ryb2tlLXdpZHRoJ107XG5cbiAgaWYgKGNvbmZpZy5ub2RlU2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlX3JhZGl1cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbm9kZV9yYWRpdXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5ub2RlQXR0ci5yO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBub2RlX3N0cncgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5vZGVfc3RydyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLm5vZGVTdHlsZVsnc3Ryb2tlLXdpZHRoJ107XG4gICAgICB9O1xuICAgIH1cbiAgICBvZmZzZXQgPSBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBub2RlX3JhZGl1cyhkLnNvdXJjZSkgKyBub2RlX3N0cncoZC5zb3VyY2UpLFxuICAgICAgICBub2RlX3JhZGl1cyhkLnRhcmdldCkgKyBub2RlX3N0cncoZC50YXJnZXQpXG4gICAgICBdO1xuICAgIH07XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2Zmc2V0KSkge1xuICAgICAgb2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAgY29uZmlnLmVkZ2VPZmZzZXQ7XG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgb2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAgW2NvbmZpZy5lZGdlT2Zmc2V0LCBjb25maWcuZWRnZU9mZnNldF07XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB2YXIgc3RydyA9IGNvbmZpZy5lZGdlU3R5bGVbJ3N0cm9rZS13aWR0aCddO1xuICBpZiAodHlwZW9mIHN0cncgIT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHJ3ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVkZ2VTdHlsZVsnc3Ryb2tlLXdpZHRoJ107XG4gICAgfTtcbiAgfVxuICB2YXIgbGFiZWxfb2Zmc2V0ID0gY29uZmlnLmVkZ2VMYWJlbE9mZnNldDtcblxuICBpZiAoZGlyZWN0ZWQpIHsgLy8gZG9uJ3Qgcm90YXRlIGxhYmVscyBhbmQgZHJhdyBjdXJ2eSBsaW5lc1xuICAgIHVwZGF0ZV9lZGdlX3Bvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxlY3Rpb25zLmVkZ2Vfc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICBpZiAoZC5zb3VyY2UgIT09IGQudGFyZ2V0KSB7XG4gICAgICAgICAgdmFyICR0aGlzID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgIHZhciB4MSA9IGQuc291cmNlLng7XG4gICAgICAgICAgdmFyIHkxID0gZC5zb3VyY2UueTtcbiAgICAgICAgICB2YXIgeDIgPSBkLnRhcmdldC54O1xuICAgICAgICAgIHZhciB5MiA9IGQudGFyZ2V0Lnk7XG4gICAgICAgICAgdmFyIGFuZ2xlID0gYW5nbGVGb3IoeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgIHZhciBkeCA9IE1hdGguc3FydChcbiAgICAgICAgICAgIE1hdGgucG93KHgyIC0geDEsIDIpICsgTWF0aC5wb3coeTIgLSB5MSwgMilcbiAgICAgICAgICApO1xuICAgICAgICAgIHZhciBvZmZzZXRfID0gb2Zmc2V0KGQpO1xuXG4gICAgICAgICAgb2Zmc2V0XyA9IFtvZmZzZXRfWzBdICogaW52X3NjYWxlLCBvZmZzZXRfWzFdICogaW52X3NjYWxlXTtcblxuICAgICAgICAgICR0aGlzLmF0dHIoXG4gICAgICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgICAgIFsndHJhbnNsYXRlKCcseDEsJywnLHkxLCcpJywgJ3JvdGF0ZSgnLCBhbmdsZSwnKSddLmpvaW4oJycpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHZhciBzaGlmdCA9IHN0cncoZCkgKiBpbnZfc2NhbGU7XG4gICAgICAgICAgdmFyIGFycm93X3N0YXJ0X3BvaW50ID0gZHggLSBvZmZzZXRfWzFdIC0gMipzaGlmdDtcbiAgICAgICAgICB2YXIgaGFsZl9zaGlmdCA9IHNoaWZ0LzI7XG4gICAgICAgICAgJHRoaXMuc2VsZWN0KCcubGluZScpLmF0dHIoJ2QnLCBbXG4gICAgICAgICAgICAgICdNJywgb2Zmc2V0X1swXSwgMCxcbiAgICAgICAgICAgICAgJ0wnLCBvZmZzZXRfWzBdLCAtaGFsZl9zaGlmdCxcbiAgICAgICAgICAgICAgJ0wnLCBhcnJvd19zdGFydF9wb2ludCwgLWhhbGZfc2hpZnQsXG4gICAgICAgICAgICAgICdMJywgYXJyb3dfc3RhcnRfcG9pbnQsIC1zaGlmdCxcbiAgICAgICAgICAgICAgJ0wnLCBkeCAtIG9mZnNldF9bMV0sIDAsXG4gICAgICAgICAgICAgICd6J1xuICAgICAgICAgIF0uam9pbignICcpKTtcblxuICAgICAgICAgIHZhciBzY2FsZSA9IDEvaW52X3NjYWxlO1xuICAgICAgICAgICR0aGlzLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAuYXR0cigneCcsIChsYWJlbF9vZmZzZXQueCAqIHNjYWxlKSArIG9mZnNldF9bMF0gKyAoZHgqc2NhbGUgLSBvZmZzZXRfWzBdIC0gb2Zmc2V0X1sxXSkgLyAyKVxuICAgICAgICAgICAgLmF0dHIoJ3knLCAtc3RydyhkKS8yICsgLWxhYmVsX29mZnNldC55ICogc2NhbGUpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3NjYWxlKCcgKyBpbnZfc2NhbGUgKyAnKScpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGVsc2Uge1xuICAgIHVwZGF0ZV9lZGdlX3Bvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxlY3Rpb25zLmVkZ2Vfc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICBpZiAoZC5zb3VyY2UgIT09IGQudGFyZ2V0KSB7XG4gICAgICAgICAgdmFyICR0aGlzID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgIHZhciB4MSA9IGQuc291cmNlLng7XG4gICAgICAgICAgdmFyIHkxID0gZC5zb3VyY2UueTtcbiAgICAgICAgICB2YXIgeDIgPSBkLnRhcmdldC54O1xuICAgICAgICAgIHZhciB5MiA9IGQudGFyZ2V0Lnk7XG4gICAgICAgICAgdmFyIGFuZ2xlID0gYW5nbGVGb3IoeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgIHZhciBkeCA9IE1hdGguc3FydChcbiAgICAgICAgICAgIE1hdGgucG93KHgyIC0geDEsIDIpICsgTWF0aC5wb3coeTIgLSB5MSwgMilcbiAgICAgICAgICApO1xuICAgICAgICAgIHZhciBjZW50ZXIgPSBkeC8yO1xuICAgICAgICAgIHZhciBvZmZzZXRfID0gb2Zmc2V0KGQpO1xuXG4gICAgICAgICAgb2Zmc2V0XyA9IFtvZmZzZXRfWzBdICogaW52X3NjYWxlLCBvZmZzZXRfWzFdICogaW52X3NjYWxlXTtcblxuICAgICAgICAgIHZhciBzY2FsZSA9IDEvaW52X3NjYWxlO1xuICAgICAgICAgIHZhciBzaGlmdCA9IHN0cncoZCkgKiBpbnZfc2NhbGU7XG4gICAgICAgICAgdmFyIGZsaXAgPSBhbmdsZSA+IDkwICYmIGFuZ2xlIDwgMjc5O1xuICAgICAgICAgICR0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIFtcbiAgICAgICAgICAgICd0cmFuc2xhdGUoJyx4MSwnLCcseTEsJyknLFxuICAgICAgICAgICAgJ3JvdGF0ZSgnLCBhbmdsZSwnKSdcbiAgICAgICAgICBdLmpvaW4oJycpKTtcbiAgICAgICAgICAkdGhpcy5zZWxlY3QoJy5saW5lJykuYXR0cignZCcsIFtcbiAgICAgICAgICAgICdNJywgb2Zmc2V0X1swXSwgc2hpZnQvNCxcbiAgICAgICAgICAgICdMJywgb2Zmc2V0X1swXSwgLXNoaWZ0LzQsXG4gICAgICAgICAgICAnTCcsIGR4IC0gb2Zmc2V0X1sxXSwgLXNoaWZ0LzQsXG4gICAgICAgICAgICAnTCcsIGR4IC0gb2Zmc2V0X1sxXSwgc2hpZnQvNCxcbiAgICAgICAgICAgICd6J1xuICAgICAgICAgIF0uam9pbignICcpKTtcbiAgICAgICAgICBpZiAoY29uZmlnLndpdGhFZGdlTGFiZWxzKSB7XG4gICAgICAgICAgICAkdGhpcy5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgICAgICAuYXR0cigneCcsICAoKGZsaXAgPyAxIDogLTEpICogbGFiZWxfb2Zmc2V0LnggKiBzY2FsZSkgKyBvZmZzZXRfWzBdICsgKGR4KnNjYWxlIC0gb2Zmc2V0X1swXSAtIG9mZnNldF9bMV0pIC8gMilcbiAgICAgICAgICAgICAgLmF0dHIoJ3knLCAtc3RydyhkKS80ICsgLWxhYmVsX29mZnNldC55ICogc2NhbGUpXG4gICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAnc2NhbGUoJyArIGludl9zY2FsZSArICcpJyArXG4gICAgICAgICAgICAgICAgKGZsaXAgPyAncm90YXRlKDE4MCwnICsgIGNlbnRlciAqICgxL2ludl9zY2FsZSkgKycsMCknIDogJycpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwZGF0ZSBub2RlIHBvc2l0aW9uXG4gICAgc2VsZWN0aW9ucy5ub2RlX3NlbGVjdGlvblxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAndHJhbnNsYXRlKCcsZC54LCcsJyxkLnksJyknLFxuICAgICAgICAgICdzY2FsZSgnICwgaW52X3NjYWxlICwgJyknXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgfSk7XG5cbiAgICB1cGRhdGVfZWRnZV9wb3NpdGlvbigpO1xuICB9O1xuXG4gIGZvcmNlLm9uKCd0aWNrJywgcmVkcmF3KTtcblxuICB2YXIgbm9kZXMgPSBHLm5vZGVzSXRlcigpO1xuICB2YXIgZWRnZXMgPSBHLmVkZ2VzSXRlcigpO1xuXG4gIGlmIChub2RlbGlzdCkgeyAvLyBsaW1pdCBkcmF3biBub2RlcywgZGlzYWJsZSBiaW5kaW5nXG4gICAgb3B0QmluZCA9IGZhbHNlO1xuICAgIG5vZGVzID0gRy5uYnVuY2hfaXRlcihub2RlbGlzdCk7XG4gICAgZWRnZXMgPSBHLmVkZ2VzX2l0ZXIobm9kZWxpc3QpO1xuICB9XG5cbiAgLy8gdXBkYXRlIGQzIG5vZGUgYW5kIGxpbmsgZGF0YVxuICBzZWxlY3Rpb25zLm5vZGVfc2VsZWN0aW9uID0gYWRkTm9kZXMoXG4gICAgRyxcbiAgICBub2RlcyxcbiAgICBmb3JjZSxcbiAgICBub2RlX3NlbGVjdGlvbixcbiAgICBjb25maWdcbiAgKTtcblxuICBzZWxlY3Rpb25zLmVkZ2Vfc2VsZWN0aW9uID0gYWRkRWRnZXMoXG4gICAgRyxcbiAgICBlZGdlcyxcbiAgICBmb3JjZSxcbiAgICBlZGdlX3NlbGVjdGlvbixcbiAgICBlZGdlX2xhYmVsX2Z1bmNcbiAgKTtcblxuICAvLyBhcHBseSBhdHRyaWJ1dGVzIGFuZCBzdHlsZXNcbiAgdXBkYXRlTm9kZUF0dHIoc2VsZWN0aW9ucy5ub2RlX3NlbGVjdGlvbiwgY29uZmlnKTtcblxuICB1cGRhdGVFZGdlQXR0cihzZWxlY3Rpb25zLmVkZ2Vfc2VsZWN0aW9uLCBjb25maWcsIG51bGwsIGRpcmVjdGVkKTtcblxuICBpZiAob3B0QmluZCkge1xuICAgIGJpbmQoRywgZm9yY2UsIGNvbmZpZywgc2VsZWN0aW9ucyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKGlzQm91bmQoRykpIHtcbiAgICAgIHVuYmluZChHKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjbGVhbihHKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5zdGFydCgpO1xuXG4gIHJldHVybiBmb3JjZTtcbn1cblxuLyoqXG4qIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgbmV3IG5vZGUgb2JqZWN0cyBmb3IgdGhlIGZvcmNlIGxheW91dCBhbmRcbiogY3JlYXRlIHRoZSBuZWNlc3NhcnkgU1ZHIGVsZW1lbnRzLlxuKlxuKiBAcGFyYW0ge0dyYXBofSBHXG4qIEBwYXJhbSB7SXRlcmFibGV9IG5vZGVzIFRoZSBub2RlcyB0byBpbmNsdWRlIGZyb20gdGhlIEdyYXBoXG4qICAgICAgZGVmYXVsdCBhcmUgYWxsIG5vZGVzXG4qIEBwYXJhbSB7ZDMubGF5b3V0LmZvcmNlfSBmb3JjZSBUaGUgbGF5b3V0XG4qIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBzZWxlY3Rpb24gRDMgRE9NIG5vZGUgc2VsZWN0aW9uIG9mIG5vZGVzXG4qIEBwYXJhbSB7T2JqZWN0fSBEcmF3aW5nIGNvbmZpZ3VyYXRpb25cbipcbiogQHJldHVybiB7IWQzLnNlbGVjdGlvbn0gVGhlIG5ldyBzZWxlY3Rpb24gb2YgU1ZHIGVsZW1lbnRzLlxuKi9cbmZ1bmN0aW9uIGFkZE5vZGVzKEcsIG5vZGVzLCBmb3JjZSwgc2VsZWN0aW9uLCBjb25maWcpIHtcbiAgLy8gR2V0IGN1cnJlbnQgZGF0YVxuICB2YXIgbGF5b3V0Tm9kZXMgPSBmb3JjZS5ub2RlcygpO1xuICAvLyBhZGQgbmV3IGRhdGFcbiAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xuICAgIGxldCBkYXRhID0gRy5ub2RlLmdldChub2RlKTtcbiAgICBsZXQgbm9iaiA9IHtub2RlLCBkYXRhLCBHfTtcbiAgICBsYXlvdXROb2Rlcy5wdXNoKG5vYmopO1xuICAgIGRhdGFbRDNfREFUQV9OQU1FXSA9IG5vYmo7XG4gIH1cbiAgLy8gdXBkYXRlIGRhdGEgam9pblxuICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uZGF0YShsYXlvdXROb2Rlcywgbm9kZUtleUZ1bmN0aW9uKTtcbiAgLy8gY3JlYXRlIG5ldyBlbGVtZW50c1xuICB2YXIgZHJhZyA9IGZvcmNlLmRyYWcoKVxuICAgIC5vbihcImRyYWdzdGFydFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAvLyBQcmV2ZW50IHBhbiBpZiBub2RlIGlzIGRyYWdnZWRcbiAgICAgIGQzLmV2ZW50LnNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKGNvbmZpZy5zdGlja3lEcmFnKSB7XG4gICAgICAgIGQuZml4ZWQgPSB0cnVlO1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZChcImZpeGVkXCIsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB2YXIgbnNlbCA9IHNlbGVjdGlvbi5lbnRlcigpXG4gICAgLmFwcGVuZCgnZycpXG4gICAgLmNsYXNzZWQoJ25vZGUnLCB0cnVlKVxuICAgIC5jYWxsKGRyYWcpO1xuXG4gIG5zZWwuYXBwZW5kKGNvbmZpZy5ub2RlU2hhcGUpLmNsYXNzZWQoJ25vZGUtc2hhcGUnLCB0cnVlKTtcblxuICBpZiAoY29uZmlnLmxhYmVscykge1xuICAgIG5zZWwuYXBwZW5kKCd0ZXh0JykudGV4dChjb25maWcubGFiZWxzKTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb247XG59XG5cbi8qKlxuKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIG5ldyBlZGdlIG9iamVjdHMgZm9yIHRoZSBmb3JjZSBsYXlvdXQuXG4qXG4qIEBwYXJhbSB7R3JhcGh9IEdcbiogQHBhcmFtIHtJdGVyYWJsZX0gZWRnZXMgVGhlIG5vZGVzIHRvIGluY2x1ZGUgZnJvbSB0aGUgR3JhcGhcbiogICAgICBkZWZhdWx0IGFyZSBhbGwgbm9kZXNcbiogQHBhcmFtIHtkMy5sYXlvdXQuZm9yY2V9IGZvcmNlXG4qIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBzZWxlY3Rpb24gRDMgRE9NIG5vZGUgc2VsZWN0aW9uIG9mIG5vZGVzXG4qIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRfbGFiZWxfZnVuYyBGdW5jdGlvbiB0byBleHRyYWN0IHRleHQgZm9yIGxhYmVsc1xuKlxuKiBAcmV0dXJuIHshZDMuc2VsZWN0aW9ufVxuKi9cbmZ1bmN0aW9uIGFkZEVkZ2VzKEcsIGVkZ2VzLCBmb3JjZSwgc2VsZWN0aW9uLCBvcHRMYWJlbEZ1bmMpIHtcbiAgLy8gR2V0IGN1cnJlbnQgZGF0YVxuICB2YXIgbGF5b3V0TGlua3MgPSBmb3JjZS5saW5rcygpO1xuICAvLyBhZGQgbmV3IGRhdGFcbiAgZm9yIChsZXQgW3UsIHYsIGRhdGFdIG9mIGVkZ2VzKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwgRy5nZXRFZGdlRGF0YSh1LCB2KTtcbiAgICBsZXQgZW9iaiA9IHtcbiAgICAgIGVkZ2U6IFt1LCB2XSxcbiAgICAgIHNvdXJjZTogRy5ub2RlLmdldCh1KVtEM19EQVRBX05BTUVdLFxuICAgICAgdGFyZ2V0OiBHLm5vZGUuZ2V0KHYpW0QzX0RBVEFfTkFNRV0sXG4gICAgICBkYXRhLFxuICAgICAgR1xuICAgIH07XG4gICAgbGF5b3V0TGlua3MucHVzaChlb2JqKTtcbiAgICBkYXRhW0QzX0RBVEFfTkFNRV0gPSBlb2JqO1xuICB9XG4gIC8vIHVwZGF0ZSBkYXRhIGpvaW5cbiAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLmRhdGEobGF5b3V0TGlua3MsIGVkZ2VLZXlGdW5jdGlvbik7XG4gIC8vIGNyZWF0ZSBuZXcgZWxlbWVudHNcbiAgdmFyIGVzZWwgPSBzZWxlY3Rpb24uZW50ZXIoKVxuICAgIC5hcHBlbmQoJ2cnKVxuICAgIC5jbGFzc2VkKCdlZGdlJywgdHJ1ZSk7XG4gIGVzZWwuYXBwZW5kKCdwYXRoJykuY2xhc3NlZCgnbGluZScsIHRydWUpO1xuXG4gIGlmIChvcHRMYWJlbEZ1bmMpIHtcbiAgICBlc2VsLmFwcGVuZCgndGV4dCcpLnRleHQob3B0TGFiZWxGdW5jKTtcbiAgfVxuICByZXR1cm4gc2VsZWN0aW9uO1xufVxuXG4vKipcbiogVXBkYXRlcyBhdHRyaWJ1dGVzIG9mIG5vZGVzLlxuKlxuKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gc2VsZWN0aW9uXG4qIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiogQHBhcmFtIHtJdGVyYWJsZT19IG9wdF9ub2RlcyBhIGNvbnRhaW5lciBvZiBub2Rlcy4gSWYgc2V0LFxuKiAgICAgIG9ubHkgdXBkYXRlIHRoZXNlIG5vZGVzLlxuKi9cbmZ1bmN0aW9uIHVwZGF0ZU5vZGVBdHRyKHNlbGVjdGlvbiwgY29uZmlnLCBvcHROb2Rlcykge1xuICBpZiAob3B0Tm9kZXMgIT0gbnVsbCkge1xuICAgIHZhciBuZXdOb2RlcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBub2RlIG9mIG9wdE5vZGVzKSB7XG4gICAgICBuZXdOb2Rlcy5hZGQoaXNBcnJheUxpa2Uobm9kZSkgPyBub2RlWzBdIDogbm9kZSk7XG4gICAgfVxuICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5maWx0ZXIoZCA9PiBuZXdOb2Rlcy5oYXMoZC5ub2RlKSk7XG4gIH1cbiAgc2VsZWN0aW9uLnNlbGVjdEFsbCgnLm5vZGUtc2hhcGUnKVxuICAgIC5hdHRyKGNvbmZpZy5ub2RlQXR0cilcbiAgICAuc3R5bGUoY29uZmlnLm5vZGVTdHlsZSk7XG5cbiAgaWYgKGNvbmZpZy53aXRoTGFiZWxzKSB7XG4gICAgc2VsZWN0aW9uLnNlbGVjdEFsbCgndGV4dCcpXG4gICAgICAuYXR0cihjb25maWcubGFiZWxBdHRyKVxuICAgICAgLnN0eWxlKGNvbmZpZy5sYWJlbFN0eWxlKTtcbiAgfVxufVxuXG5cbi8qKlxuKiBVcGRhdGVzIGF0dHJpYnV0ZXMgb2YgZWRnZXMuXG4qXG4qIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBzZWxlY3Rpb25cbiogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuKiBAcGFyYW0gez89fSBvcHRFZGdlcyBJZiBzZXQsIG9ubHkgdXBkYXRlcyB0aGUgc3R5bGVzIG9mIHRoZSBwcm92aWRlZFxuKiAgICAgIGVkZ2VzXG4qIEBwYXJhbSB7Ym9vbGVhbj19IG9wdERpcmVjdGVkXG4qL1xuZnVuY3Rpb24gdXBkYXRlRWRnZUF0dHIoc2VsZWN0aW9uLCBjb25maWcsIG9wdEVkZ2VzLCBvcHREaXJlY3RlZCkge1xuICBpZiAob3B0RWRnZXMgIT0gbnVsbCkge1xuICAgIHZhciBuZXdFZGdlcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBbdSwgdl0gb2Ygb3B0RWRnZXMpIHtcbiAgICAgIG5ld0VkZ2VzLnNldCh1LCB2KTtcbiAgICB9XG4gICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLmZpbHRlcihcbiAgICAgICh7ZWRnZX0pID0+IG5ld0VkZ2VzLmdldChlZGdlWzBdKSA9PT0gZWRnZVsxXSB8fCBvcHREaXJlY3RlZCB8fFxuICAgICAgICBuZXdFZGdlcy5nZXQoZWRnZVsxXSkgPT09IGVkZ2VbMF1cbiAgICApO1xuICB9XG5cbiAgc2VsZWN0aW9uLnNlbGVjdEFsbCgnLmxpbmUnKVxuICAgIC5hdHRyKGNvbmZpZy5lZGdlQXR0cilcbiAgICAuc3R5bGUoY29uZmlnLmVkZ2VTdHlsZSlcbiAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIDApO1xuXG4gIGlmIChjb25maWcud2l0aEVkZ2VMYWJlbHMpIHtcbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCd0ZXh0JylcbiAgICAgIC5hdHRyKGNvbmZpZy5lZGdlTGFiZWxBdHRyKVxuICAgICAgLnN0eWxlKGNvbmZpZy5lZGdlTGFiZWxTdHlsZSk7XG4gIH1cbn1cblxuLyoqXG4qIEtleSBmdW5jdGlvbiB0byBleHRyYWN0IHRoZSBqb2luIHZhbHVlIGZvciB0aGUgU1ZHIG5vZGVzIGFuZCB0aGUgZGF0YS5cbipcbiogQHBhcmFtIHtPYmplY3R9IGQgVGhlIGN1cnJlbnQgZGF0dW1cbiogQHJldHVybiB7Tm9kZX1cbiovXG5mdW5jdGlvbiBub2RlS2V5RnVuY3Rpb24oZCkge1xuICByZXR1cm4gZC5ub2RlO1xufVxuXG4vKipcbiogS2V5IGZ1bmN0aW9uIHRvIGV4dHJhY3QgdGhlIGpvaW4gdmFsdWUgZm9yIHRoZSBTVkcgbm9kZXMgYW5kIHRoZSBkYXRhLlxuKlxuKiBAcGFyYW0ge09iamVjdH0gZCBUaGUgY3VycmVudCBkYXR1bVxuKiBAcmV0dXJuIHtBcnJheX1cbiovXG5mdW5jdGlvbiBlZGdlS2V5RnVuY3Rpb24oZCkge1xuICByZXR1cm4gZC5lZGdlO1xufVxuXG4vKipcbiogSGVscGVyIGZ1bmN0aW9uIHRvIHJlbW92ZSBub2RlIG9iamVjdHMgZm9yIHRoZSBmb3JjZSBsYXlvdXQuXG4qXG4qIEBwYXJhbSB7R3JhcGh9IEdcbiogQHBhcmFtIHtJdGVyYWJsZX0gbm9kZXMgdG8gcmVtb3ZlIGZyb20gdGhlIGdyYXBoXG4qIEBwYXJhbSB7ZDMubGF5b3V0LmZvcmNlfSBmb3JjZSBUaGUgZm9yY2UgdGhlIG5vZGVzIGFyZSBib3VuZCB0b1xuKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gc2VsZWN0aW9uIFNlbGVjdGlvbiBvZiBub2RlIGVsZW1lbnRzXG4qXG4qIEByZXR1cm4ge2QzLnNlbGVjdGlvbn0gVXBkYXRlZCBzZWxlY3Rpb25cbiovXG5mdW5jdGlvbiByZW1vdmVOb2RlcyhHLCBub2RlcywgZm9yY2UsIHNlbGVjdGlvbikge1xuICAvLyBnZXQgY3VycmVudCBkYXRhIHNldFxuICB2YXIgZGF0YSA9IGZvcmNlLm5vZGVzKCk7XG5cbiAgLy8gcmVtb3ZlIGl0ZW1zIGZyb20gZGF0YVxuICBmb3IgKGxldCBub2RlIG9mIEcubmJ1bmNoSXRlcihub2RlcykpIHtcbiAgICBsZXQgaW5kZXggPSBkYXRhLmluZGV4T2YoRy5ub2RlLmdldChub2RlKVtEM19EQVRBX05BTUVdKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlYmluZCBkYXRhXG4gIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5kYXRhKGRhdGEsIG5vZGVLZXlGdW5jdGlvbik7XG4gIC8vIHJlbW92ZSBTVkcgZWxlbWVudHNcbiAgc2VsZWN0aW9uLmV4aXQoKS5yZW1vdmUoKTtcbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cblxuLyoqXG4qIEhlbHBlciBmdW5jdGlvbiB0byByZW1vdmUgZWRnZSBvYmplY3RzIGZvciB0aGUgZm9yY2UgbGF5b3V0LlxuKlxuKiBAcGFyYW0ge2pzbnguY2xhc3Nlcy5HcmFwaH0gR1xuKiBAcGFyYW0gez99IGVkZ2VzIEVkZ2VzIHRvIHJlbW92ZVxuKiBAcGFyYW0ge2QzLmxheW91dC5mb3JjZX0gZm9yY2UgVGhlIGZvcmNlIHRoZSBlZGdlcyBhcmUgYm91bmQgdG9cbiogQHBhcmFtIHtkMy5zZWxlY3Rpb259IHNlbGVjdGlvbiBTZWxlY3Rpb24gb2YgZWRnZSBlbGVtZW50c1xuKlxuKiBAcmV0dXJuIHshZDMuc2VsZWN0aW9ufSBVcGRhdGVkIHNlbGVjdGlvblxuKi9cbmZ1bmN0aW9uIHJlbW92ZUVkZ2VzKEcsIGVkZ2VzLCBmb3JjZSwgc2VsZWN0aW9uKSB7XG4gIC8vIGdldCBjdXJyZW50IGRhdGEgc2V0XG4gIHZhciBkYXRhID0gZm9yY2UubGlua3MoKTtcbiAgLy8gcmVtb3ZlIGl0ZW1zIGZyb20gZGF0YVxuICBmb3IgKGxldCBbdSx2XSBvZiBlZGdlcykge1xuICAgIGxldCBpbmRleCA9IGRhdGEuaW5kZXhPZihHLmdldEVkZ2VEYXRhKHUsIHYsIHt9KVtEM19EQVRBX05BTUVdKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuICAvLyByZWJpbmQgZGF0YVxuICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uZGF0YShkYXRhLCBlZGdlS2V5RnVuY3Rpb24pO1xuICAvLyByZW1vdmUgU1ZHIGVsZW1lbnRzXG4gIHNlbGVjdGlvbi5leGl0KCkucmVtb3ZlKCk7XG4gIHJldHVybiBzZWxlY3Rpb247XG59XG5cbi8qKlxuKiBCaW5kcyB0aGUgb3V0cHV0IHRvIHRoZSBncmFwaC4gVGhpcyBvdmVycmlkZXMgbXV0YXRvciBtZXRob2RzLiBUbyBcImZyZWVcIlxuKiB0aGUgZ3JhcGgsIHlvdSBjYW4gY2FsbCBqc254LnVuYmluZCAod2hpY2ggaXMgcHVibGljKVxuKlxuKiBAcGFyYW0ge0dyYXBofSBHIEEgR3JhcGhcbiogQHBhcmFtIHtkMy5sYXlvdXQuZm9yY2V9IGZvcmNlIEZvcmNlIGxheW91dFxuKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgb3V0cHV0XG4qIEBwYXJhbSB7e25vZGVfc2VsZWN0aW9uOmQzLnNlbGVjdGlvbiwgZWRnZV9zZWxlY3Rpb246ZDMuc2VsZWN0aW9uIH19IHNlbGVjdGlvbnNcbiogICBWYXJpb3VzIEQzIHNlbGVjdGlvbnNcbiovXG5mdW5jdGlvbiBiaW5kKEcsIGZvcmNlLCBjb25maWcsIHNlbGVjdGlvbnMpIHtcbiAgdW5iaW5kKEcsIGZhbHNlKTtcblxuICB2YXIgcHJvdG8gPSBHLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgdmFyIGVkZ2VfbGFiZWxfZnVuYyA9IGNvbmZpZy5lZGdlTGFiZWxzO1xuICB2YXIgZGlyZWN0ZWQgPSBHLmlzRGlyZWN0ZWQoKTtcblxuICBHLmFkZE5vZGUgPSBmdW5jdGlvbihuLCBvcHRBdHRyKSB7XG4gICAgdmFyIG5ld19ub2RlID0gIXRoaXMuaGFzTm9kZShuKTtcbiAgICBwcm90by5hZGROb2RlLmNhbGwodGhpcywgbiwgb3B0QXR0cik7XG5cbiAgICBpZiAobmV3X25vZGUpIHtcbiAgICAgIHNlbGVjdGlvbnMubm9kZV9zZWxlY3Rpb24gPSBhZGROb2RlcyhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgW25dLFxuICAgICAgICBmb3JjZSxcbiAgICAgICAgc2VsZWN0aW9ucy5ub2RlX3NlbGVjdGlvbixcbiAgICAgICAgY29uZmlnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBub2RlIGF0dHJpYnV0ZXNcbiAgICB1cGRhdGVOb2RlQXR0cihzZWxlY3Rpb25zLm5vZGVfc2VsZWN0aW9uLCBjb25maWcsIFtuXSk7XG5cbiAgICBmb3JjZS5zdGFydCgpO1xuICB9O1xuXG4gIEcuYWRkTm9kZXNGcm9tID0gZnVuY3Rpb24obmJ1bmNoLCBvcHRBdHRyKSB7XG4gICAgbmJ1bmNoID0gdG9BcnJheShuYnVuY2gpO1xuICAgIHZhciBuZXdfbm9kZXMgPSBuYnVuY2guZmlsdGVyKFxuICAgICAgbm9kZSA9PiAhdGhpcy5oYXNOb2RlKGlzQXJyYXlMaWtlKG5vZGUpID8gbm9kZVswXSA6IG5vZGUpXG4gICAgKTtcblxuICAgIHByb3RvLmFkZE5vZGVzRnJvbS5jYWxsKHRoaXMsIG5idW5jaCwgb3B0QXR0cik7XG5cbiAgICBpZihuZXdfbm9kZXMubGVuZ3RoID4gMCkgeyAvLyBhZGQgbmV3IG5vZGVzIGFuZCB1cGRhdGVcbiAgICAgIHNlbGVjdGlvbnMubm9kZV9zZWxlY3Rpb24gPSBhZGROb2RlcyhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbmV3X25vZGVzLFxuICAgICAgICBmb3JjZSxcbiAgICAgICAgc2VsZWN0aW9ucy5ub2RlX3NlbGVjdGlvbixcbiAgICAgICAgY29uZmlnXG4gICAgICApO1xuICAgIH1cblxuICAgIHVwZGF0ZU5vZGVBdHRyKHNlbGVjdGlvbnMubm9kZV9zZWxlY3Rpb24sIGNvbmZpZywgbmJ1bmNoKTtcbiAgICBmb3JjZS5zdGFydCgpO1xuICB9O1xuXG4gIEcuYWRkRWRnZSA9IGZ1bmN0aW9uKHUsIHYsIG9wdEF0dHIpIHtcbiAgICB2YXIgbmV3X2VkZ2UgPSAhdGhpcy5oYXNFZGdlKHUsIHYpO1xuICAgIHZhciBlZGdlcyA9IFtbdSx2XV07XG4gICAgdmFyIG5ld19ub2RlcyA9IG5ld19lZGdlID9cbiAgICAgICh1ID09PSB2ID8gW3VdIDogZWRnZXNbMF0pLmZpbHRlcihub2RlID0+ICF0aGlzLmhhc05vZGUobm9kZSkpIDpcbiAgICAgIFtdO1xuICAgIHByb3RvLmFkZEVkZ2UuY2FsbChHLCB1LCB2LCBvcHRBdHRyKTtcblxuICAgIGlmKG5ld19ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICBzZWxlY3Rpb25zLm5vZGVfc2VsZWN0aW9uID0gYWRkTm9kZXMoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG5ld19ub2RlcyxcbiAgICAgICAgZm9yY2UsXG4gICAgICAgIHNlbGVjdGlvbnMubm9kZV9zZWxlY3Rpb24sXG4gICAgICAgIGNvbmZpZ1xuICAgICAgKTtcblxuICAgICAgdXBkYXRlTm9kZUF0dHIoc2VsZWN0aW9ucy5ub2RlX3NlbGVjdGlvbiwgY29uZmlnLCBuZXdfbm9kZXMpO1xuICAgIH1cblxuICAgIGlmIChuZXdfZWRnZSkge1xuICAgICAgc2VsZWN0aW9ucy5lZGdlX3NlbGVjdGlvbiA9IGFkZEVkZ2VzKFxuICAgICAgICB0aGlzLFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgZm9yY2UsXG4gICAgICAgIHNlbGVjdGlvbnMuZWRnZV9zZWxlY3Rpb24sXG4gICAgICAgIGVkZ2VfbGFiZWxfZnVuY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFZGdlQXR0cihzZWxlY3Rpb25zLmVkZ2Vfc2VsZWN0aW9uLCBjb25maWcsIGVkZ2VzLCBkaXJlY3RlZCk7XG4gICAgZm9yY2Uuc3RhcnQoKTtcbiAgfTtcblxuICBHLmFkZEVkZ2VzRnJvbSA9IGZ1bmN0aW9uKGVidW5jaCwgb3B0QXR0cikge1xuICAgICAgdmFyIG5ld19lZGdlcyA9IFtdO1xuICAgICAgdmFyIG5ld19ub2RlcyA9IFtdO1xuICAgICAgdmFyIHNlZW5fZWRnZXMgPSBuZXcgTWFwKCk7XG4gICAgICB2YXIgc2Vlbl9ub2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgIHZhciBkaXJlY3RlZCA9IHRoaXMuaXNEaXJlY3RlZCgpO1xuXG4gICAgICBlYnVuY2ggPSB0b0FycmF5KGVidW5jaCk7XG5cbiAgICAgIGZvciAodmFyIFt1LCB2XSBvZiBlYnVuY2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0VkZ2UodSwgdikgJiZcbiAgICAgICAgICAgIHNlZW5fZWRnZXMuZ2V0KHUpICE9PSB2ICYmXG4gICAgICAgICAgICAoZGlyZWN0ZWQgfHwgc2Vlbl9lZGdlcy5nZXQodikgPT09IHUpXG4gICAgICAgICkge1xuICAgICAgICAgIG5ld19lZGdlcy5wdXNoKFt1LCB2XSk7XG4gICAgICAgICAgc2Vlbl9lZGdlcy5zZXQodSwgdik7XG4gICAgICAgICAgaWYgKCF0aGlzLmhhc05vZGUodSkgJiYgIXNlZW5fbm9kZXMuaGFzKHUpKSB7XG4gICAgICAgICAgICBuZXdfbm9kZXMucHVzaCh1KTtcbiAgICAgICAgICAgIHNlZW5fbm9kZXMuYWRkKHUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuaGFzTm9kZSh2KSAmJiAhc2Vlbl9ub2Rlcy5oYXModikpIHtcbiAgICAgICAgICAgIG5ld19ub2Rlcy5wdXNoKHYpO1xuICAgICAgICAgICAgc2Vlbl9ub2Rlcy5hZGQodik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb3RvLmFkZEVkZ2VzRnJvbS5jYWxsKEcsIGVidW5jaCwgb3B0QXR0cik7XG5cbiAgICAgIGlmKG5ld19ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGVjdGlvbnMubm9kZV9zZWxlY3Rpb24gPSBhZGROb2RlcyhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG5ld19ub2RlcyxcbiAgICAgICAgICBmb3JjZSxcbiAgICAgICAgICBzZWxlY3Rpb25zLm5vZGVfc2VsZWN0aW9uLFxuICAgICAgICAgIGNvbmZpZ1xuICAgICAgICApO1xuXG4gICAgICAgIHVwZGF0ZU5vZGVBdHRyKHNlbGVjdGlvbnMubm9kZV9zZWxlY3Rpb24sIGNvbmZpZywgbmV3X25vZGVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld19lZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGVjdGlvbnMuZWRnZV9zZWxlY3Rpb24gPSBhZGRFZGdlcyhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG5ld19lZGdlcyxcbiAgICAgICAgICBmb3JjZSxcbiAgICAgICAgICBzZWxlY3Rpb25zLmVkZ2Vfc2VsZWN0aW9uLFxuICAgICAgICAgIGVkZ2VfbGFiZWxfZnVuY1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVFZGdlQXR0cihzZWxlY3Rpb25zLmVkZ2Vfc2VsZWN0aW9uLCBjb25maWcsIG5ld19lZGdlcywgZGlyZWN0ZWQpO1xuICAgICAgZm9yY2Uuc3RhcnQoKTtcbiAgfTtcblxuICBHLnJlbW92ZU5vZGUgPSBmdW5jdGlvbihuKSB7XG4gICAgaWYgKHRoaXMuaGFzTm9kZShuKSkge1xuICAgICAgc2VsZWN0aW9ucy5ub2RlX3NlbGVjdGlvbiA9IHJlbW92ZU5vZGVzKFxuICAgICAgICB0aGlzLFxuICAgICAgICBbbl0sXG4gICAgICAgIGZvcmNlLFxuICAgICAgICBzZWxlY3Rpb25zLm5vZGVfc2VsZWN0aW9uXG4gICAgICApO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlc0l0ZXIoW25dKTtcblxuICAgICAgaWYgKHRoaXMuaXNEaXJlY3RlZCgpKSB7XG4gICAgICAgIGVkZ2VzID0gKGZ1bmN0aW9uKihHLCBlZGdlcykge1xuICAgICAgICAgIHlpZWxkKiBlZGdlcztcbiAgICAgICAgICB5aWVsZCogRy5pbkVkZ2VzSXRlcihbbl0pO1xuICAgICAgICB9KHRoaXMsIGVkZ2VzKSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdGlvbnMuZWRnZV9zZWxlY3Rpb24gPSByZW1vdmVFZGdlcyhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZWRnZXMsXG4gICAgICAgIGZvcmNlLFxuICAgICAgICBzZWxlY3Rpb25zLmVkZ2Vfc2VsZWN0aW9uXG4gICAgICApO1xuXG4gICAgICBmb3JjZS5yZXN1bWUoKTtcbiAgICB9XG4gICAgcHJvdG8ucmVtb3ZlTm9kZS5jYWxsKHRoaXMsIG4pO1xuICB9O1xuXG4gIEcucmVtb3ZlTm9kZXNGcm9tID0gZnVuY3Rpb24obmJ1bmNoKSB7XG4gICAgbmJ1bmNoID0gdG9BcnJheShuYnVuY2gpO1xuICAgIHNlbGVjdGlvbnMubm9kZV9zZWxlY3Rpb24gPSByZW1vdmVOb2RlcyhcbiAgICAgIHRoaXMsXG4gICAgICBuYnVuY2gsXG4gICAgICBmb3JjZSxcbiAgICAgIHNlbGVjdGlvbnMubm9kZV9zZWxlY3Rpb25cbiAgICApO1xuXG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlc0l0ZXIobmJ1bmNoKTtcbiAgICBpZiAodGhpcy5pc0RpcmVjdGVkKCkpIHtcbiAgICAgICAgZWRnZXMgPSAoZnVuY3Rpb24qKEcsIGVkZ2VzKSB7XG4gICAgICAgICAgeWllbGQqIGVkZ2VzO1xuICAgICAgICAgIHlpZWxkKiBHLmluRWRnZXNJdGVyKG5idW5jaCk7XG4gICAgICAgIH0odGhpcywgZWRnZXMpKTtcbiAgICB9XG5cbiAgICBzZWxlY3Rpb25zLmVkZ2Vfc2VsZWN0aW9uID0gcmVtb3ZlRWRnZXMoXG4gICAgICB0aGlzLFxuICAgICAgZWRnZXMsXG4gICAgICBmb3JjZSxcbiAgICAgIHNlbGVjdGlvbnMuZWRnZV9zZWxlY3Rpb25cbiAgICApO1xuXG4gICAgZm9yY2UucmVzdW1lKCk7XG4gICAgcHJvdG8ucmVtb3ZlTm9kZXNGcm9tLmNhbGwodGhpcywgbmJ1bmNoKTtcbiAgfTtcblxuICBHLnJlbW92ZUVkZ2UgPSBmdW5jdGlvbih1LCB2KSB7XG4gICAgc2VsZWN0aW9ucy5lZGdlX3NlbGVjdGlvbiA9IHJlbW92ZUVkZ2VzKFxuICAgICAgdGhpcyxcbiAgICAgIFtbdSx2XV0sXG4gICAgICBmb3JjZSxcbiAgICAgIHNlbGVjdGlvbnMuZWRnZV9zZWxlY3Rpb25cbiAgICApO1xuXG4gICAgZm9yY2UucmVzdW1lKCk7XG4gICAgcHJvdG8ucmVtb3ZlRWRnZS5jYWxsKHRoaXMsIHUsIHYpO1xuICB9O1xuXG4gIEcucmVtb3ZlRWRnZXNGcm9tID0gZnVuY3Rpb24oZWJ1bmNoKSB7XG4gICAgZWJ1bmNoID0gdG9BcnJheShlYnVuY2gpO1xuICAgIHNlbGVjdGlvbnMuZWRnZV9zZWxlY3Rpb24gPSByZW1vdmVFZGdlcyhcbiAgICAgIHRoaXMsXG4gICAgICBlYnVuY2gsXG4gICAgICBmb3JjZSxcbiAgICAgIHNlbGVjdGlvbnMuZWRnZV9zZWxlY3Rpb25cbiAgICApO1xuXG4gICAgZm9yY2UucmVzdW1lKCk7XG4gICAgcHJvdG8ucmVtb3ZlRWRnZXNGcm9tLmNhbGwoRywgZWJ1bmNoKTtcbiAgfTtcblxuICBHLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZWN0aW9ucy5ub2RlX3NlbGVjdGlvbiA9IHNlbGVjdGlvbnMubm9kZV9zZWxlY3Rpb24uZGF0YShcbiAgICAgIFtdLFxuICAgICAgbm9kZUtleUZ1bmN0aW9uXG4gICAgKTtcbiAgICBzZWxlY3Rpb25zLm5vZGVfc2VsZWN0aW9uLmV4aXQoKS5yZW1vdmUoKTtcbiAgICBzZWxlY3Rpb25zLmVkZ2Vfc2VsZWN0aW9uID0gc2VsZWN0aW9ucy5lZGdlX3NlbGVjdGlvbi5kYXRhKFxuICAgICAgW10sXG4gICAgICBlZGdlS2V5RnVuY3Rpb25cbiAgICApO1xuICAgIHNlbGVjdGlvbnMuZWRnZV9zZWxlY3Rpb24uZXhpdCgpLnJlbW92ZSgpO1xuICAgIGZvcmNlLm5vZGVzKFtdKS5saW5rcyhbXSkucmVzdW1lKCk7XG4gICAgcHJvdG8uY2xlYXIuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUgYm9vbGVhblxuICAgKi9cbiAgRy5ib3VuZCA9IHRydWU7XG59XG5cblxuLyoqXG4qIFJldHVybnMgVHJ1ZSBpZiB0aGUgZ3JhcGggaXMgYm91bmQgdG8gYW4gb3V0cHV0LlxuKlxuKiBAcGFyYW0ge0dyYXBofSBHIEEgR3JhcGhcbiogQHJldHVybiB7Ym9vbGVhbn1cbiovXG5mdW5jdGlvbiBpc0JvdW5kKEcpIHtcbiAgcmV0dXJuIEcuYm91bmQ7XG59XG5cbi8qKlxuKiBSZXNldHMgbXV0YXRvciBtZXRob2RzIHRvIHRoZSBvcmlnaW5hbHNcbipcbiogQHBhcmFtIHt9IEcgZ3JhcGhcbiogQHBhcmFtIHtib29sZWFuPX0gb3B0X2NsZWFuIChkZWZhdWx0PVRydWUpXG4qICAgIElmIHRydWUsIGFsbCBEMyBkYXRhIGlzIHJlbW92ZWQgZnJvbSB0aGUgZ3JhcGhcbiovXG5mdW5jdGlvbiB1bmJpbmQoRywgb3B0Q2xlYW49dHJ1ZSkge1xuICBpZiAoaXNCb3VuZChHKSkge1xuICAgIHZhciBwcm90byA9IEcuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIE1VVEFUT1JfTUVUSE9EUy5mb3JFYWNoKG0gPT4gR1ttXSA9IHByb3RvW21dKTtcbiAgICBkZWxldGUgRy5ib3VuZDtcbiAgICBpZiAob3B0Q2xlYW4pIHtcbiAgICAgIGNsZWFuKEcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiogUmVtb3ZlcyBhbnkgRDMgZGF0YSBmcm9tIHRoZSBHcmFwaC5cbipcbiogQHBhcmFtIHtHcmFwaH0gRyBBIEdyYXBoXG4qL1xuZnVuY3Rpb24gY2xlYW4oRykge1xuICBmb3IgKGxldCBbXyxkYXRhXSBvZiBHLm5vZGVzSXRlcih0cnVlKSkge1xuICAgIGRlbGV0ZSBkYXRhW0QzX0RBVEFfTkFNRV07XG4gIH1cbiAgZm9yIChsZXQgW3UsdixkYXRhXSBvZiBHLmVkZ2VzSXRlcihudWxsLCB0cnVlKSkge1xuICAgIGRlbGV0ZSBkYXRhW0QzX0RBVEFfTkFNRV07XG4gIH1cbn1cblxuLyoqXG4qIERlZmF1bHQgRDMgY29uZmlndXJhdGlvbi5cbipcbiogQHR5cGUgT2JqZWN0XG4qIEBwcml2YXRlXG4qL1xudmFyIERFRkFVTFRfQ09ORklHID0ge1xuICBsYXlvdXRBdHRyOiB7XG4gICAgY2hhcmdlOiAtMTIwLFxuICAgIGxpbmtEaXN0YW5jZTogNjBcbiAgfSxcbiAgbm9kZVNoYXBlOiAnY2lyY2xlJyxcbiAgbm9kZUF0dHI6IHtcbiAgICByOiAxMCAvLyByYWRpdXMgb2YgMTBcbiAgfSxcbiAgbm9kZVN0eWxlOiB7XG4gICAgJ3N0cm9rZS13aWR0aCc6IDIsXG4gICAgc3Ryb2tlOiAnIzMzMycsXG4gICAgZmlsbDogJyM5OTknLFxuICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gIH0sXG4gIGVkZ2VBdHRyOiB7fSxcbiAgZWRnZVN0eWxlOiB7XG4gICAgZmlsbDogJyMwMDAnLFxuICAgICdzdHJva2Utd2lkdGgnOiAzXG4gIH0sXG4gIGxhYmVsQXR0cjoge30sXG4gIGxhYmVsU3R5bGU6IHtcbiAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcbiAgICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnY2VudHJhbCcsXG4gICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgJy13ZWJraXQtdXNlci1zZWxlY3QnOiAnbm9uZScsXG4gICAgZmlsbDogJyMwMDAnXG4gIH0sXG4gIGVkZ2VMYWJlbEF0dHI6IHt9LFxuICBlZGdlTGFiZWxTdHlsZToge1xuICAgICdmb250LXNpemUnOiAnMC44ZW0nLFxuICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxuICAgICctd2Via2l0LXVzZXItc2VsZWN0JzogJ25vbmUnXG4gIH0sXG4gIGVkZ2VMYWJlbE9mZnNldDoge1xuICAgIHg6IDAsXG4gICAgeTogMC41XG4gIH0sXG4gIHdpdGhMYWJlbHM6IGZhbHNlLFxuICB3aXRoRWRnZUxhYmVsczogZmFsc2UsXG4gIGVkZ2VPZmZzZXQ6IDEwLFxuICB3ZWlnaHRlZDogZmFsc2UsXG4gIHdlaWdodHM6ICd3ZWlnaHQnLFxuICB3ZWlnaHRlZF9zdHJva2U6IHRydWUsXG4gIHBhblpvb206IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHNjYWxlOiB0cnVlXG4gIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEpTTmV0d29ya1hFeGNlcHRpb24gZnJvbSAnLi9KU05ldHdvcmtYRXhjZXB0aW9uJztcblxuLyoqXG4gKiBFeGNlcHRpb24gZm9yIHVuZXhwZWN0ZWQgdGVybWluYXRpb24gb2YgYWxnb3JpdGhtcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0pTTmV0d29ya1hFeGNlcHRpb259XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEpTTmV0d29ya1hBbGdvcml0aG1FcnJvciBleHRlbmRzIEpTTmV0d29ya1hFeGNlcHRpb24ge1xuICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgdGhpcy5uYW1lID0gJ0pTTmV0d29ya1hBbGdvcml0aG1FcnJvcic7XG4gICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEpTTmV0d29ya1hFeGNlcHRpb24gZnJvbSAnLi9KU05ldHdvcmtYRXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSlNOZXR3b3JrWEVycm9yIGV4dGVuZHMgSlNOZXR3b3JrWEV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnSlNOZXR3b3JrWEVycm9yJztcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEpTTmV0d29ya1hFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm5hbWUgPSAnSlNOZXR3b3JrWEV4Y2VwdGlvbic7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBKU05ldHdvcmtYVW5mZWFzaWJsZSBmcm9tICcuL0pTTmV0d29ya1hVbmZlYXNpYmxlJztcblxuLyoqXG4gKiBFeGNlcHRpb24gZm9yIGFsZ29yaXRobXMgdGhhdCBzaG91bGQgcmV0dXJuIGEgcGF0aCB3aGVuIHJ1bm5pbmdcbiAqIG9uIGdyYXBocyB3aGVyZSBzdWNoIGEgcGF0aCBkb2VzIG5vdCBleGlzdC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSlNOZXR3b3JrWE5vUGF0aCBleHRlbmRzIEpTTmV0d29ya1hVbmZlYXNpYmxlIHtcbiAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgIHRoaXMubmFtZSA9ICdKU05ldHdvcmtYTm9QYXRoJztcbiAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgSlNOZXR3b3JrWEFsZ29yaXRobUVycm9yIGZyb20gJy4vSlNOZXR3b3JrWEFsZ29yaXRobUVycm9yJztcblxuLyoqXG4gKiBFeGNlcHRpb24gcmFpc2VkIGJ5IGFsZ29yaXRobXMgdHJ5aW5nIHRvIHNvbHZlIGEgcHJvYmxlbVxuICogaW5zdGFuY2UgdGhhdCBoYXMgbm8gZmVhc2libGUgc29sdXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtKU05ldHdvcmtYQWxnb3JpdGhtRXJyb3J9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEpTTmV0d29ya1hVbmZlYXNpYmxlIGV4dGVuZHMgSlNOZXR3b3JrWEFsZ29yaXRobUVycm9yIHtcbiAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgIHRoaXMubmFtZSA9ICdKU05ldHdvcmtYVW5mZWFzaWJsZSc7XG4gICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2V5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm5hbWUgPSAnS2V5RXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgS2V5RXJyb3IgZnJvbSAnLi9LZXlFcnJvcic7XG5pbXBvcnQgSlNOZXR3b3JrWEFsZ29yaXRobUVycm9yIGZyb20gJy4vSlNOZXR3b3JrWEFsZ29yaXRobUVycm9yJztcbmltcG9ydCBKU05ldHdvcmtYRXJyb3IgZnJvbSAnLi9KU05ldHdvcmtYRXJyb3InO1xuaW1wb3J0IEpTTmV0d29ya1hFeGNlcHRpb24gZnJvbSAnLi9KU05ldHdvcmtYRXhjZXB0aW9uJztcbmltcG9ydCBKU05ldHdvcmtYTm9QYXRoIGZyb20gJy4vSlNOZXR3b3JrWE5vUGF0aCc7XG5pbXBvcnQgSlNOZXR3b3JrWFVuZmVhc2libGUgZnJvbSAnLi9KU05ldHdvcmtYVW5mZWFzaWJsZSc7XG5cbmV4cG9ydCB7XG4gIEtleUVycm9yLFxuICBKU05ldHdvcmtYQWxnb3JpdGhtRXJyb3IsXG4gIEpTTmV0d29ya1hFcnJvcixcbiAgSlNOZXR3b3JrWEV4Y2VwdGlvbixcbiAgSlNOZXR3b3JrWE5vUGF0aCxcbiAgSlNOZXR3b3JrWFVuZmVhc2libGVcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEdyYXBoIGZyb20gJy4uL2NsYXNzZXMvR3JhcGgnO1xuXG5pbXBvcnQge1xuICBnZW5Db21iaW5hdGlvbnMsXG4gIGdlblBlcm11dGF0aW9ucyxcbiAgZ2VuUmFuZ2UsXG4gIGlzR3JhcGgsXG4gIG1hcEl0ZXJhdG9yLFxuICBuZXh0LFxuICByYW5nZSxcbiAgdHVwbGUyXG59IGZyb20gJy4uL19pbnRlcm5hbHMnO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIG5vZGVzXG4gKiBAcGFyYW0ge251bWJlcn0gciBicmVhZHRoXG4gKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAqL1xuZnVuY3Rpb24gKnRyZWVFZGdlcyhuLCByKSB7XG4gIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgdHJlZXNcbiAgLy8geWllbGRzIGVkZ2VzIGluIHJvb3RlZCB0cmVlIGF0IDAgd2l0aCBuIG5vZGVzIGFuZCBicmFuY2hpbmcgcmF0aW8gclxuICB2YXIgbm9kZXMgPSBnZW5SYW5nZShuKTtcbiAgaWYgKG4gPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBhcmVudHMgPSBbbmV4dChub2RlcyldO1xuICB3aGlsZSAocGFyZW50cy5sZW5ndGggPiAwKSB7XG4gICAgLypqc2hpbnQgdW51c2VkOmZhbHNlKi9cbiAgICB2YXIgc291cmNlID0gcGFyZW50cy5zaGlmdCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcjsgaSsrKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbm9kZXMubmV4dCgpO1xuICAgICAgaWYgKHRhcmdldC5kb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRhcmdldCA9IHRhcmdldC52YWx1ZTtcbiAgICAgIHBhcmVudHMucHVzaCh0YXJnZXQpO1xuICAgICAgeWllbGQgdHVwbGUyKHNvdXJjZSwgdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVsbCByLWFyeSB0cmVlIG9mIG4gdmVydGljZXMuXG4gKiBTb21ldGltZXMgY2FsbGVkIGEgay1hcnksIG4tYXJ5LCBvciBtLWFyeSB0cmVlLiAgXCIuLi4gYWxsIG5vbi1sZWFmXG4gKiB2ZXJ0aWNlcyBoYXZlIGV4YWN0bHkgciBjaGlsZHJlbiBhbmQgYWxsIGxldmVscyBhcmUgZnVsbCBleGNlcHRcbiAqIGZvciBzb21lIHJpZ2h0bW9zdCBwb3NpdGlvbiBvZiB0aGUgYm90dG9tIGxldmVsIChpZiBhIGxlYWYgYXQgdGhlXG4gKiBib3R0b20gbGV2ZWwgaXMgbWlzc2luZywgdGhlbiBzbyBhcmUgYWxsIG9mIHRoZSBsZWF2ZXMgdG8gaXRzXG4gKiByaWdodC5cIlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByIGJyYW5jaGluZyBmYWN0b3Igb2YgdGhlIHRyZWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZVxuICogQHBhcmFtIHtHcmFwaD19IG9wdENyZWF0ZVVzaW5nXG4gKiAgIFVzZSBzcGVjaWZpZWQgdHlwZSB0byBjb25zdHJ1Y3QgZ3JhcGhcbiAqIEByZXR1cm4ge0dyYXBofSBBbiByLWFyeSB0cmVlIHdpdGggbiBub2Rlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZ1bGxSYXJ5VHJlZShyLCBuLCBvcHRDcmVhdGVVc2luZykge1xuICB2YXIgRyA9IGVtcHR5R3JhcGgobiwgb3B0Q3JlYXRlVXNpbmcpO1xuICBHLmFkZEVkZ2VzRnJvbSh0cmVlRWRnZXMobixyKSk7XG4gIHJldHVybiBHO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBwZXJmZWN0bHkgYmFsYW5jZWQgci10cmVlIG9mIGhlaWdodCBoLlxuICpcbiAqIFRoaXMgaXMgdGhlIHJvb3RlZCB0cmVlIHdoZXJlIGFsbCBsZWF2ZXMgYXJlIGF0IGRpc3RhbmNlIGggZnJvbVxuICogdGhlIHJvb3QuIFRoZSByb290IGhhcyBkZWdyZWUgciBhbmQgYWxsIG90aGVyIGludGVybmFsIG5vZGVzIGhhdmVcbiAqIGRlZ3JlZSByKzEuXG4gKlxuICogTm9kZSBsYWJlbHMgYXJlIHRoZSBpbnRlZ2VycyAwICh0aGUgcm9vdCkgdXAgdG8gIG51bWJlck9mTm9kZXMgLSAxLlxuICpcbiAqIEFsc28gcmVmZXJlZCB0byBhcyBhIGNvbXBsZXRlIHItYXJ5IHRyZWUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHIgIEJyYW5jaGluZyBmYWN0b3Igb2YgdGhlIHRyZWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgdHJlZVxuICogQHBhcmFtIHtHcmFwaH0gb3B0Q3JlYXRlVXNpbmdcbiAqICAgIFVzZSBzcGVjaWZpZWQgdHlwZSB0byBjb25zdHJ1Y3QgZ3JhcGhcbiAqIEByZXR1cm4ge0dyYXBofVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmFsYW5jZWRUcmVlKHIsIGgsIG9wdENyZWF0ZVVzaW5nKSB7XG4gIHZhciBuID0gciA9PT0gMSA/IDIgOiBNYXRoLmZsb29yKCgxIC0gTWF0aC5wb3cociwgKGgrMSkpKSAvICgxIC0gcikpO1xuICB2YXIgRyA9IGVtcHR5R3JhcGgobiwgb3B0Q3JlYXRlVXNpbmcpO1xuICBHLmFkZEVkZ2VzRnJvbSh0cmVlRWRnZXMobixyKSk7XG4gIHJldHVybiBHO1xufVxuXG4vL1RPRE86IGJhcmJlbGxfZ3JhcGhcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGNvbXBsZXRlIGdyYXBoIGAkS19uJCB3aXRoIG4gbm9kZXMuXG4gKlxuICogTm9kZSBsYWJlbHMgYXJlIHRoZSBpbnRlZ2VycyAwIHRvIG4tMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2Ygbm9kZXMgdG8gYWRkIHRvIHRoZSBncmFwaFxuICogQHBhcmFtIHtHcmFwaD19IG9wdENyZWF0ZVVzaW5nIEdyYXBoIGluc3RhbmNlIHRvIGVtcHR5IGFuZCBhZGQgbm9kZXMgdG8uXG4gKiBAcmV0dXJuIHtHcmFwaH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBsZXRlR3JhcGgobiwgb3B0Q3JlYXRlVXNpbmcpIHtcbiAgdmFyIEcgPSBlbXB0eUdyYXBoKG4sIG9wdENyZWF0ZVVzaW5nKTtcbiAgRy5uYW1lID0gJ2NvbXBsZXRlX2dyYXBoKCcgKyBuICsgJyknO1xuICBpZiAobiA+IDEpIHtcbiAgICBHLmFkZEVkZ2VzRnJvbShHLmlzRGlyZWN0ZWQoKSA/XG4gICAgICBnZW5QZXJtdXRhdGlvbnMocmFuZ2UobiksIDIpIDpcbiAgICAgIGdlbkNvbWJpbmF0aW9ucyhyYW5nZShuKSwgMilcbiAgICApO1xuICB9XG4gIHJldHVybiBHO1xufVxuXG4vL1RPRE86IGNvbXBsZXRlX2JpcGFydGl0ZV9ncmFwaFxuLy9UT0RPOiBjaXJjdWxhcl9sYWRkZXJfZ3JhcGhcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGN5Y2xlIGdyYXBoIENfbiBvdmVyIG4gbm9kZXMuXG4gKlxuICogQ19uIGlzIHRoZSBuLXBhdGggd2l0aCB0d28gZW5kLW5vZGVzIGNvbm5lY3RlZC5cbiAqXG4gKiBOb2RlIGxhYmVscyBhcmUgdGhlIGludGVnZXJzIDAgdG8gbi0xXG4gKiBJZiBjcmVhdGVfdXNpbmcgaXMgYSBEaUdyYXBoLCB0aGUgZGlyZWN0aW9uIGlzIGluIGluY3JlYXNpbmcgb3JkZXIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBub2RlcyB0byBhZGQgdG8gdGhlIGdyYXBoXG4gKiBAcGFyYW0ge0dyYXBoPX0gb3B0Q3JlYXRlVXNpbmcgR3JhcGggaW5zdGFuY2UgdG8gZW1wdHkgYW5kIGFkZCBub2RlcyB0by5cbiAqIEByZXR1cm4ge0dyYXBofVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3ljbGVHcmFwaChuLCBvcHRDcmVhdGVVc2luZykge1xuICB2YXIgRyA9IHBhdGhHcmFwaChuLCBvcHRDcmVhdGVVc2luZyk7XG4gIEcubmFtZSA9ICdjeWNsZV9ncmFwaCgnICsgbiArICcpJztcbiAgaWYgKG4gPiAxKSB7XG4gICAgRy5hZGRFZGdlKG4tMSwwKTtcbiAgfVxuICByZXR1cm4gRztcbn1cblxuLy9UT0RPOiBkb3JvZ292dHNldl9nb2x0c2V2X21lbmRlc19ncmFwaFxuXG4vKipcbiAqIFJldHVybiB0aGUgZW1wdHkgZ3JhcGggd2l0aCBuIG5vZGVzIGFuZCB6ZXJvIGVkZ2VzLlxuICpcbiAqIE5vZGUgbGFiZWxzIGFyZSB0aGUgaW50ZWdlcnMgMCB0byBuLTFcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYFxuICogdmFyIEcgPSBqc254LmVtcHR5R3JhcGgoMTApXG4gKiBHLm51bWJlck9mTm9kZXMoKVxuICogLy8gMTBcbiAqIEcubnVtYmVyT2ZFZGdlcygpXG4gKiAvLyAwXG4gKiBgYGBcbiAqXG4gKiBUaGUgdmFyaWFibGUgY3JlYXRlX3VzaW5nIHNob3VsZCBwb2ludCB0byBhIFwiZ3JhcGhcIi1saWtlIG9iamVjdCB0aGF0XG4gKiB3aWxsIGJlIGNsZWFuZWQgKG5vZGVzIGFuZCBlZGdlcyB3aWxsIGJlIHJlbW92ZWQpIGFuZCByZWZpdHRlZCBhc1xuICogYW4gZW1wdHkgXCJncmFwaFwiIHdpdGggbiBub2RlcyB3aXRoIGludGVnZXIgbGFiZWxzLiBUaGlzIGNhcGFiaWxpdHlcbiAqIGlzIHVzZWZ1bCBmb3Igc3BlY2lmeWluZyB0aGUgY2xhc3MtbmF0dXJlIG9mIHRoZSByZXN1bHRpbmcgZW1wdHlcbiAqIFwiZ3JhcGhcIiAoaS5lLiBHcmFwaCwgRGlHcmFwaCwgTXlXZWlyZEdyYXBoQ2xhc3MsIGV0Yy4pLlxuICpcbiAqIFRoZSB2YXJpYWJsZSBjcmVhdGVfdXNpbmcgaGFzIHR3byBtYWluIHVzZXM6XG4gKiBGaXJzdGx5LCB0aGUgdmFyaWFibGUgY3JlYXRlX3VzaW5nIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhblxuICogZW1wdHkgZGlncmFwaCwgbmV0d29yayxldGMuICBGb3IgZXhhbXBsZSxcbiAqXG4gKiBgYGBcbiAqIHZhciBuID0gMTBcbiAqIHZhciBHID0ganNueC5lbXB0eUdyYXBoKG4sIGpzbnguRGlHcmFwaCgpKVxuICogYGBgXG4gKlxuICogd2lsbCBjcmVhdGUgYW4gZW1wdHkgZGlncmFwaCBvbiBuIG5vZGVzLlxuICpcbiAqIFNlY29uZGx5LCBvbmUgY2FuIHBhc3MgYW4gZXhpc3RpbmcgZ3JhcGggKGRpZ3JhcGgsIHBzZXVkb2dyYXBoLFxuICogZXRjLikgdmlhIGNyZWF0ZV91c2luZy4gRm9yIGV4YW1wbGUsIGlmIEcgaXMgYW4gZXhpc3RpbmcgZ3JhcGhcbiAqIChyZXNwLiBkaWdyYXBoLCBwc2V1ZG9ncmFwaCwgZXRjLiksIHRoZW4gZW1wdHlfZ3JhcGgobixHKVxuICogd2lsbCBlbXB0eSBHIChpLmUuIGRlbGV0ZSBhbGwgbm9kZXMgYW5kIGVkZ2VzIHVzaW5nIEcuY2xlYXIoKSBpblxuICogYmFzZSkgYW5kIHRoZW4gYWRkIG4gbm9kZXMgYW5kIHplcm8gZWRnZXMsIGFuZCByZXR1cm4gdGhlIG1vZGlmaWVkXG4gKiBncmFwaCAocmVzcC4gZGlncmFwaCwgcHNldWRvZ3JhcGgsIGV0Yy4pLlxuICpcbiAqIEBzZWUgY3JlYXRlRW1wdHlDb3B5XG4gKlxuICogQHBhcmFtez9udW1iZXI9fSBvcHROIFRoZSBudW1iZXIgb2Ygbm9kZXMgdG8gYWRkIHRvIHRoZSBncmFwaFxuICogQHBhcmFtez9HcmFwaD19IG9wdENyZWF0ZVVzaW5nIEdyYXBoIGluc3RhbmNlIHRvIGVtcHR5IGFuZFxuICogICAgIGFkZCBub2RlcyB0by5cbiAqIEByZXR1cm4ge0dyYXBofVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW1wdHlHcmFwaChvcHROLCBvcHRDcmVhdGVVc2luZykge1xuICBpZiAoaXNHcmFwaChvcHROKSkge1xuICAgIG9wdENyZWF0ZVVzaW5nID0gb3B0TjtcbiAgICBvcHROID0gbnVsbDtcbiAgfVxuICBpZiAob3B0TiA9PSBudWxsKSB7XG4gICAgb3B0TiA9IDA7XG4gIH1cblxuICB2YXIgRztcblxuICBpZiAob3B0Q3JlYXRlVXNpbmcgPT0gbnVsbCkge1xuICAgIC8vIGRlZmF1bHQgZW1wdHkgZ3JhcGggaXMgYSBzaW1wbGUgZ3JhcGhcbiAgICBHID0gbmV3IEdyYXBoKCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgRyA9IG9wdENyZWF0ZVVzaW5nO1xuICAgIEcuY2xlYXIoKTtcbiAgfVxuXG4gIEcuYWRkTm9kZXNGcm9tKGdlblJhbmdlKG9wdE4pKTtcbiAgRy5uYW1lID0gJ2VtcHR5R3JhcGgoJyArIG9wdE4gKyAnKSc7XG4gIHJldHVybiBHO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgMmQgZ3JpZCBncmFwaCBvZiBteG4gbm9kZXMsXG4gKiBlYWNoIGNvbm5lY3RlZCB0byBpdHMgbmVhcmVzdCBuZWlnaGJvcnMuXG4gKiBPcHRpb25hbCBhcmd1bWVudCBwZXJpb2RpYz1UcnVlIHdpbGwgY29ubmVjdFxuICogYm91bmRhcnkgbm9kZXMgdmlhIHBlcmlvZGljIGJvdW5kYXJ5IGNvbmRpdGlvbnMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgTnVtYmVyIG9mIHJvd3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zIE51bWJlciBvZiBjb2x1bW5zXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRQZXJpb2RpY1xuICogQHBhcmFtIHtHcmFwaD19IG9wdENyZWF0ZVVzaW5nXG4gKiBAcmV0dXJuIHtHcmFwaH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyaWQyZEdyYXBoKHJvd3MsIGNvbHVtbnMsIG9wdFBlcmlvZGljLCBvcHRDcmVhdGVVc2luZykge1xuICB2YXIgRyA9IGVtcHR5R3JhcGgoMCwgb3B0Q3JlYXRlVXNpbmcpO1xuICBHLm5hbWUgPSAnZ3JpZDJkR3JhcGgnO1xuICB2YXIgaTtcbiAgdmFyIGo7XG4gIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICBHLmFkZE5vZGUoW2ksal0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAxOyBpIDwgcm93czsgaSsrKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgRy5hZGRFZGdlKFtpLGpdLCBbaS0xLGpdKTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgIGZvciAoaiA9IDE7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgIEcuYWRkRWRnZShbaSxqXSwgW2ksai0xXSk7XG4gICAgfVxuICB9XG4gIGlmIChHLmlzRGlyZWN0ZWQoKSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCByb3dzLTE7IGkrKykge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgICBHLmFkZEVkZ2UoW2ksal0sIFtpKzEsal0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1ucy0xOyBqKyspIHtcbiAgICAgICAgRy5hZGRFZGdlKFtpLGpdLCBbaSxqKzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAob3B0UGVyaW9kaWMpIHtcbiAgICBpZiAoY29sdW1ucyA+IDIpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgRy5hZGRFZGdlKFtpLDBdLCBbaSxjb2x1bW5zLTFdKTtcbiAgICAgIH1cbiAgICAgIGlmIChHLmlzRGlyZWN0ZWQoKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgRy5hZGRFZGdlKFtpLGNvbHVtbnMtMV0sIFtpLDBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocm93cyA+IDIpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgRy5hZGRFZGdlKFswLGpdLCBbcm93cy0xLGpdKTtcbiAgICAgIH1cbiAgICAgIGlmIChHLmlzRGlyZWN0ZWQoKSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgRy5hZGRFZGdlKFtyb3dzLTEsal0sIFswLGpdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBHLm5hbWUgPSAncGVyaW9kaWNHcmlkMmRHcmFwaCgnICsgcm93cyArICcsJyArIGNvbHVtbnMgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIEc7XG59XG5cbi8vVE9ETzogZ3JpZF9ncmFwaFxuLy9UT0RPOiBoeXBlcmN1YmVfZ3JhcGhcbi8vVE9ETzogbGFkZGVyX2dyYXBoXG4vL1RPRE86IGxvbGxpcG9wX2dyYXBoXG5cbi8qKlxuICogUmV0dXJuIHRoZSBOdWxsIGdyYXBoIHdpdGggbm8gbm9kZXMgb3IgZWRnZXMuXG4gKlxuICogU2VlIGBlbXB0eUdyYXBoYCBmb3IgdGhlIHVzZSBvZiBgb3B0Q3JlYXRlVXNpbmdgLlxuICpcbiAqIEBwYXJhbSB7R3JhcGg9fSBvcHRDcmVhdGVVc2luZyBHcmFwaCBpbnN0YW5jZSB0byBlbXB0eSBhbmQgYWRkIG5vZGVzIHRvLlxuICogQHJldHVybiB7R3JhcGh9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudWxsR3JhcGgob3B0Q3JlYXRlVXNpbmcpIHtcbiAgdmFyIEcgPSBlbXB0eUdyYXBoKDAsIG9wdENyZWF0ZVVzaW5nKTtcbiAgRy5uYW1lID0gJ251bGxHcmFwaCgpJztcbiAgcmV0dXJuIEc7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBOdWxsIGdyYXBoIHdpdGggbm8gbm9kZXMgb3IgZWRnZXMuXG4gKlxuICogU2VlIGBlbXB0eUdyYXBoYCBmb3IgdGhlIHVzZSBvZiBgb3B0Q3JlYXRlVXNpbmdgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2Ygbm9kZXMgdG8gYWRkIHRvIHRoZSBncmFwaFxuICogQHBhcmFtIHtHcmFwaD19IG9wdENyZWF0ZVVzaW5nIEdyYXBoIGluc3RhbmNlIHRvIGVtcHR5IGFuZFxuICogICAgICBhZGQgbm9kZXMgdG8uXG4gKiBAcmV0dXJuIHtHcmFwaH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGhHcmFwaChuLCBvcHRDcmVhdGVVc2luZykge1xuICB2YXIgRyA9IGVtcHR5R3JhcGgobiwgb3B0Q3JlYXRlVXNpbmcpO1xuICBHLm5hbWUgPSAncGF0aEdyYXBoKCcgKyBuICsgJyknO1xuICBHLmFkZEVkZ2VzRnJvbShtYXBJdGVyYXRvcihcbiAgICBnZW5SYW5nZShuLTEpLFxuICAgIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB0dXBsZTIodiwgdisxKTtcbiAgICB9XG4gICkpO1xuICByZXR1cm4gRztcbn1cblxuLy9UT0RPOiBzdGFyX2dyYXBoXG5cbi8qKlxuICogUmV0dXJuIHRoZSBUcml2aWFsIGdyYXBoIHdpdGggb25lIG5vZGUgKHdpdGggaW50ZWdlciBsYWJlbCAwKSBhbmQgbm8gZWRnZXMuXG4gKlxuICogQHBhcmFte0dyYXBoPX0gb3B0Q3JlYXRlVXNpbmcgR3JhcGggaW5zdGFuY2UgdG8gZW1wdHkgYW5kXG4gKiAgICAgIGFkZCBub2RlcyB0by5cbiAqIEByZXR1cm4ge0dyYXBofVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpdmlhbEdyYXBoKG9wdENyZWF0ZVVzaW5nKSB7XG4gIHZhciBHID0gZW1wdHlHcmFwaCgxLCBvcHRDcmVhdGVVc2luZyk7XG4gIEcubmFtZSA9ICdudWxsR3JhcGgoKSc7XG4gIHJldHVybiBHO1xufVxuXG4vL1RPRE86IHdoZWVsX2dyYXBoXG4iLCJpbXBvcnQgZGVsZWdhdGUgZnJvbSBcIi4uL19pbnRlcm5hbHMvZGVsZWdhdGVcIjtcblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgSlNOZXR3b3JrWEVycm9yIGZyb20gJy4uL2V4Y2VwdGlvbnMvSlNOZXR3b3JrWEVycm9yJztcblxuaW1wb3J0IHtpc1ZhbGlkRGVncmVlU2VxdWVuY2V9IGZyb20gJy4uL2FsZ29yaXRobXMvZ3JhcGhpY2FsJztcbmltcG9ydCB7ZW1wdHlHcmFwaH0gZnJvbSAnLi9jbGFzc2ljJztcbmltcG9ydCBzcHJpbnRmIGZyb20gJy4uL19pbnRlcm5hbHMvc3ByaW50Zic7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGhhdmVsSGFraW1pR3JhcGgoZGVncmVlU2VxdWVuY2UsIG9wdENyZWF0ZVVzaW5nKSB7XG4gIGRlZ3JlZVNlcXVlbmNlID0gQXJyYXkuZnJvbShkZWdyZWVTZXF1ZW5jZSk7XG4gIGlmICghKGlzVmFsaWREZWdyZWVTZXF1ZW5jZShkZWdyZWVTZXF1ZW5jZSkpKSB7XG4gICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcignSW52YWxpZCBkZWdyZWUgc2VxdWVuY2UnKTtcbiAgfVxuICBpZiAob3B0Q3JlYXRlVXNpbmcgIT0gbnVsbCkge1xuICAgIGlmIChvcHRDcmVhdGVVc2luZy5pc0RpcmVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBKU05ldHdvcmtYRXJyb3IoJ0RpcmVjdGVkIEdyYXBoIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cbiAgdmFyIG51bWJlck9mTm9kZXMgPSBkZWdyZWVTZXF1ZW5jZS5sZW5ndGg7XG4gIHZhciBHID0gZW1wdHlHcmFwaChudW1iZXJPZk5vZGVzLCBvcHRDcmVhdGVVc2luZyk7XG4gIHZhciBudW1EZWdyZWVzID0gbmV3IEFycmF5KG51bWJlck9mTm9kZXMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mTm9kZXM7IGkrKykge1xuICAgIG51bURlZ3JlZXNbaV0gPSBbXTtcbiAgfVxuXG4gIHZhciBtYXhEZWdyZWUgPSAwO1xuICB2YXIgZGVncmVlU3VtID0gMDtcbiAgdmFyIG4gPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBudW1iZXJPZk5vZGVzOyBpKyspIHtcbiAgICB2YXIgZGVncmVlID0gZGVncmVlU2VxdWVuY2VbaV07XG4gICAgLy8gcHJvY2VzcyBvbmx5IHRoZSBub24temVybyBpbnRlZ2Vyc1xuICAgIGlmIChkZWdyZWUgPiAwKSB7XG4gICAgICBudW1EZWdyZWVzW2RlZ3JlZV0ucHVzaChuKTtcbiAgICAgIG1heERlZ3JlZSA9IE1hdGgubWF4KG1heERlZ3JlZSwgZGVncmVlKTtcbiAgICAgIGRlZ3JlZVN1bSArPSBkZWdyZWU7XG4gICAgICBuICs9IDE7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIGdyYXBoIGlmIG5vIGVkZ2VzXG4gIGlmIChuID09PSAwKSB7XG4gICAgcmV0dXJuIEc7XG4gIH1cblxuICAvLyBmb3JtIGxpc3Qgb2YgW3N0dWJzLG5hbWVdIGZvciBlYWNoIG5vZGUuXG4gIHZhciBtb2RzdHVicyA9IG5ldyBBcnJheShtYXhEZWdyZWUgKyAxKTtcbiAgZm9yIChpID0gMDsgaSA8IG1heERlZ3JlZSArIDE7IGkrKykge1xuICAgIG1vZHN0dWJzW2ldID0gWzAsMF07XG4gIH1cbiAgLy8gU3VjY2Vzc2l2ZWx5IHJlZHVjZSBkZWdyZWUgc2VxdWVuY2UgYnkgcmVtb3ZpbmcgdGhlIG1heGltdW0gZGVncmVlXG4gIHdoaWxlIChuID4gMCkge1xuICAgIC8vIFJldHJpZXZlIHRoZSBtYXhpbXVtIGRlZ3JlZSBpbiB0aGUgc2VxdWVuY2VcbiAgICB3aGlsZSAobnVtRGVncmVlc1ttYXhEZWdyZWVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbWF4RGVncmVlIC09IDE7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGFyZSBub3QgZW5vdWdoIHN0dWJzIHRvIGNvbm5lY3QgdG8sIHRoZW4gdGhlIHNlcXVlbmNlIGlzIG5vdFxuICAgIC8vIGdyYXBoaWNhbFxuICAgIGlmIChtYXhEZWdyZWUgPiBuIC0gMSkge1xuICAgICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcignTm9uLWdyYXBoaWNhbCBpbnRlZ2VyIHNlcXVlbmNlJyk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBsYXJnZXN0IHN0dWIgaW4gbGlzdFxuICAgIHZhciBzb3VyY2UgPSBudW1EZWdyZWVzW21heERlZ3JlZV0ucG9wKCk7XG4gICAgbiAtPSAxO1xuICAgIC8vIFJlZHVjZSB0aGUgbmV4dCBtYXhEZWdyZWUgbGFyZ2VzdCBzdHVic1xuICAgIHZhciBtc2xlbiA9IDA7XG4gICAgdmFyIGsgPSBtYXhEZWdyZWU7XG4gICAgZm9yIChpID0gMDsgaSA8IG1heERlZ3JlZTsgaSsrKSB7XG4gICAgICB3aGlsZSAobnVtRGVncmVlc1trXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgayAtPSAxO1xuICAgICAgfVxuICAgICAgdmFyIHRhcmdldCA9IG51bURlZ3JlZXNba10ucG9wKCk7XG4gICAgICBHLmFkZEVkZ2Uoc291cmNlLCB0YXJnZXQpO1xuICAgICAgbiAtPSAxO1xuICAgICAgaWYgKGsgPiAxKSB7XG4gICAgICAgIG1vZHN0dWJzW21zbGVuXSA9IFtrIC0gMSwgdGFyZ2V0XTtcbiAgICAgICAgbXNsZW4gKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIGJhY2sgdG8gdGhlIGxpc3QgYW55IG5vbnplcm8gc3R1YnMgdGhhdCB3ZXJlIHJlbW92ZWRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbXNsZW47IGkrKykge1xuICAgICAgdmFyIFtzdHVidmFsLCBzdHVidGFyZ2V0XSA9IG1vZHN0dWJzW2ldO1xuICAgICAgbnVtRGVncmVlc1tzdHVidmFsXS5wdXNoKHN0dWJ0YXJnZXQpO1xuICAgICAgbiArPSAxO1xuICAgIH1cbiAgfVxuXG4gIEcubmFtZSA9IHNwcmludGYoJ2hhdmVsSGFraW1pR3JhcGggJXMgbm9kZXMgJWQgZWRnZXMnLCBHLm9yZGVyKCksIEcuc2l6ZSgpKTtcbiAgcmV0dXJuIEc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5IYXZlbEhha2ltaUdyYXBoKGRlZ3JlZVNlcXVlbmNlLCBvcHRDcmVhdGVVc2luZykge1xuICByZXR1cm4gZGVsZWdhdGUoXCJoYXZlbEhha2ltaUdyYXBoXCIsIFtkZWdyZWVTZXF1ZW5jZSwgb3B0Q3JlYXRlVXNpbmddKTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIGNsYXNzaWMgZnJvbSAnLi9jbGFzc2ljJztcbmltcG9ydCAqIGFzIGRlZ3JlZVNlcXVlbmNlIGZyb20gJy4vZGVncmVlU2VxdWVuY2UnO1xuaW1wb3J0ICogYXMgcmFuZG9tR3JhcGhzIGZyb20gJy4vcmFuZG9tR3JhcGhzJztcbmltcG9ydCAqIGFzIHNtYWxsIGZyb20gJy4vc21hbGwnO1xuaW1wb3J0ICogYXMgc29jaWFsIGZyb20gJy4vc29jaWFsJztcblxuZXhwb3J0IHtcbiAgY2xhc3NpYyxcbiAgZGVncmVlU2VxdWVuY2UsXG4gIHJhbmRvbUdyYXBocyxcbiAgc21hbGwsXG4gIHNvY2lhbFxufTtcblxuZXhwb3J0ICogZnJvbSAnLi9jbGFzc2ljJztcbmV4cG9ydCAqIGZyb20gJy4vZGVncmVlU2VxdWVuY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9yYW5kb21HcmFwaHMnO1xuZXhwb3J0ICogZnJvbSAnLi9zbWFsbCc7XG5leHBvcnQgKiBmcm9tICcuL3NvY2lhbCc7XG4iLCJpbXBvcnQgZGVsZWdhdGUgZnJvbSBcIi4uL19pbnRlcm5hbHMvZGVsZWdhdGVcIjtcblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRGlHcmFwaCBmcm9tICcuLi9jbGFzc2VzL0RpR3JhcGgnO1xuaW1wb3J0IEdyYXBoIGZyb20gJy4uL2NsYXNzZXMvR3JhcGgnO1xuXG5pbXBvcnQge1xuICBjb21wbGV0ZUdyYXBoLFxuICBlbXB0eUdyYXBoXG59IGZyb20gJy4vY2xhc3NpYyc7XG5cbmltcG9ydCB7XG4gIGdlbkNvbWJpbmF0aW9ucyxcbiAgZ2VuUGVybXV0YXRpb25zLFxuICByYW5nZSxcbiAgc3ByaW50ZlxufSBmcm9tICcuLi9faW50ZXJuYWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZhc3RHbnBSYW5kb21HcmFwaChuLCBwLCBvcHREaXJlY3RlZD1mYWxzZSkge1xuICB2YXIgRyA9IGVtcHR5R3JhcGgobik7XG4gIEcubmFtZSA9IHNwcmludGYoJ2Zhc3RHbnBSYW5kb21HcmFwaCglcywgJXMpJywgbiwgcCk7XG5cbiAgaWYgKHAgPD0gMCB8fCBwID49IDEpIHtcbiAgICByZXR1cm4gZ25wUmFuZG9tR3JhcGgobiwgcCwgb3B0RGlyZWN0ZWQpO1xuICB9XG4gIHZhciB2O1xuICB2YXIgdyA9IC0xO1xuICB2YXIgbHAgPSBNYXRoLmxvZygxIC0gcCk7XG4gIHZhciBscjtcblxuICBpZiAob3B0RGlyZWN0ZWQpIHtcbiAgICAvLyBOb2RlcyBpbiBncmFwaCBhcmUgZnJvbSAwLG4tMSAoc3RhcnQgd2l0aCB2IGFzIHRoZSBmaXJzdCBub2RlIGluZGV4KS5cbiAgICB2ID0gMDtcbiAgICBHID0gbmV3IERpR3JhcGgoRyk7XG4gICAgd2hpbGUgKHYgPCBuKSB7XG4gICAgICBsciA9IE1hdGgubG9nKDEgLSBNYXRoLnJhbmRvbSgpKTtcbiAgICAgIHcgPSB3ICsgMSArIE1hdGguZmxvb3IobHIvbHApO1xuICAgICAgaWYgKHYgPT09IHcpIHsgLy8gYXZvaWQgc2VsZiBsb29wc1xuICAgICAgICB3ID0gdyArIDE7XG4gICAgICB9XG4gICAgICB3aGlsZSAodyA+PSBuICYmIHYgPCBuKSB7XG4gICAgICAgIHcgPSB3IC0gbjtcbiAgICAgICAgdiA9IHYgKyAxO1xuICAgICAgICBpZiAodiA9PT0gdykgeyAvLyBhdm9pZCBzZWxmIGxvb3BzXG4gICAgICAgICAgdyA9IHcgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodiA8IG4pIHtcbiAgICAgICAgRy5hZGRFZGdlKHYsIHcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB2ID0gMTsgLy8gTm9kZXMgaW4gZ3JhcGggYXJlIGZyb20gMCwgbi0xICh0aGlzIGlzIHRoZSBzZWNvbmQgbm9kZSBpbmRleCkuXG4gICAgd2hpbGUgKHYgPCBuKSB7XG4gICAgICBsciA9IE1hdGgubG9nKDEgLSBNYXRoLnJhbmRvbSgpKTtcbiAgICAgIHcgPSB3ICsgMSArIE1hdGguZmxvb3IobHIvbHApO1xuICAgICAgd2hpbGUgKHcgPj0gdiAmJiB2IDwgbikge1xuICAgICAgICB3ID0gdyAtIHY7XG4gICAgICAgIHYgPSB2ICsgMTtcbiAgICAgIH1cbiAgICAgIGlmICh2IDwgbikge1xuICAgICAgICBHLmFkZEVkZ2Uodiwgdyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBHO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5GYXN0R25wUmFuZG9tR3JhcGgobiwgcCwgb3B0RGlyZWN0ZWQpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwiZmFzdEducFJhbmRvbUdyYXBoXCIsIFtuLCBwLCBvcHREaXJlY3RlZF0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGducFJhbmRvbUdyYXBoKG4sIHAsIG9wdERpcmVjdGVkKSB7XG4gIHZhciBHID0gb3B0RGlyZWN0ZWQgPyBuZXcgRGlHcmFwaCgpIDogbmV3IEdyYXBoKCk7XG4gIHZhciBlZGdlcztcbiAgdmFyIHJhbmdlTiA9IHJhbmdlKG4pO1xuXG4gIEcuYWRkTm9kZXNGcm9tKHJhbmdlTik7XG4gIEcubmFtZSA9IHNwcmludGYoJ2ducFJhbmRvbUdyYXBoKCVzLCAlcyknLCBuLCBwKTtcbiAgaWYocCA8PSAwKSB7XG4gICAgcmV0dXJuIEc7XG4gIH1cbiAgaWYocCA+PSAxKSB7XG4gICAgcmV0dXJuIGNvbXBsZXRlR3JhcGgobiwgRyk7XG4gIH1cblxuICBlZGdlcyA9IEcuaXNEaXJlY3RlZCgpID9cbiAgICBnZW5QZXJtdXRhdGlvbnMocmFuZ2VOLCAyKSA6XG4gICAgZ2VuQ29tYmluYXRpb25zKHJhbmdlTiwgMik7XG5cbiAgZm9yICh2YXIgZWRnZSBvZiBlZGdlcykge1xuICAgIGlmKE1hdGgucmFuZG9tKCkgPCBwKSB7XG4gICAgICBHLmFkZEVkZ2UoZWRnZVswXSwgZWRnZVsxXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBHO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuR25wUmFuZG9tR3JhcGgobiwgcCwgb3B0RGlyZWN0ZWQpIHtcbiAgcmV0dXJuIGRlbGVnYXRlKFwiZ25wUmFuZG9tR3JhcGhcIiwgW24sIHAsIG9wdERpcmVjdGVkXSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYmlub21pYWxHcmFwaChuLCBwLCBvcHREaXJlY3RlZCkge1xuICByZXR1cm4gZ25wUmFuZG9tR3JhcGgobiwgcCwgb3B0RGlyZWN0ZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuQmlub21pYWxHcmFwaChuLCBwLCBvcHREaXJlY3RlZCkge1xuICByZXR1cm4gZGVsZWdhdGUoXCJiaW5vbWlhbEdyYXBoXCIsIFtuLCBwLCBvcHREaXJlY3RlZF0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVyZG9zUmVueWlHcmFwaChuLCBwLCBvcHREaXJlY3RlZCkge1xuICByZXR1cm4gZ25wUmFuZG9tR3JhcGgobiwgcCwgb3B0RGlyZWN0ZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuRXJkb3NSZW55aUdyYXBoKG4sIHAsIG9wdERpcmVjdGVkKSB7XG4gIHJldHVybiBkZWxlZ2F0ZShcImVyZG9zUmVueWlHcmFwaFwiLCBbbiwgcCwgb3B0RGlyZWN0ZWRdKTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBKU05ldHdvcmtYRXJyb3IgZnJvbSAnLi4vZXhjZXB0aW9ucy9KU05ldHdvcmtYRXJyb3InO1xuXG5pbXBvcnQge2VtcHR5R3JhcGh9IGZyb20gJy4vY2xhc3NpYyc7XG5pbXBvcnQge2ZvckVhY2h9IGZyb20gJy4uL19pbnRlcm5hbHMnO1xuXG4vKipcbiAqIFJldHVybiBhIHNtYWxsIHVuZGlyZWN0ZWQgZ3JhcGggZGVzY3JpYmVkIGJ5IGdyYXBoX2Rlc2NyaXB0aW9uLlxuICpcbiAqIEBzZWUgbWFrZVNtYWxsR3JhcGguXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZ3JhcGhEZXNjcmlwdGlvblxuICogICAgRGVzY3JpcHRpb24gb2YgdGhlIGdyYXBoIHRvIGNyZWF0ZSBpbiB0aGUgZm9ybSBge3R5cGUsIG5hbWUsIG4sIGxpc3R9YC5cbiAqIEBwYXJhbSB7R3JhcGg9fVxuICogICAgb3B0Q3JlYXRlVXNpbmcgR3JhcGggaW5zdGFuY2UgdG8gZW1wdHkgYW5kIGFkZCBub2RlcyB0by5cbiAqXG4gKiBAcmV0dXJuIHtHcmFwaH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTbWFsbFVuZGlyZWN0ZWRHcmFwaChncmFwaERlc2NyaXB0aW9uLCBvcHRDcmVhdGVVc2luZykge1xuICBpZiAob3B0Q3JlYXRlVXNpbmcgIT0gbnVsbCAmJiBvcHRDcmVhdGVVc2luZy5pc0RpcmVjdGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKCdEaXJlY3RlZCBHcmFwaCBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgcmV0dXJuIG1ha2VTbWFsbEdyYXBoKGdyYXBoRGVzY3JpcHRpb24sIG9wdENyZWF0ZVVzaW5nKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHNtYWxsIGdyYXBoIGRlc2NyaWJlZCBieSBncmFwaF9kZXNjcmlwdGlvbi5cbiAqXG4gKiBncmFwaERlc2NyaXB0aW9uIGlzIGEgbGlzdCBvZiB0aGUgZm9ybSBge3R5cGUsIG5hbWUsIG4sIGxpc3R9YC5cbiAqXG4gKiBIZXJlIGBsdHlwZWAgaXMgb25lIG9mIGBcImFkamFjZW5jeWxpc3RcImAgb3IgYFwiZWRnZWxpc3RcImAsXG4gKiBgbmFtZWAgaXMgdGhlIG5hbWUgb2YgdGhlIGdyYXBoIGFuZCBgbmAgdGhlIG51bWJlciBvZiBub2Rlcy5cbiAqIFRoaXMgY29uc3RydWN0cyBhIGdyYXBoIG9mIGBuYCBub2RlcyB3aXRoIGludGVnZXIgbGFiZWxzIDAsLi4sbi0xLlxuICpcbiAqIElmIGBsdHlwZT1cImFkamFjZW5jeWxpc3RcImAgdGhlbiBgeGxpc3RgIGlzIGFuIGFkamFjZW5jeSBsaXN0XG4gKiB3aXRoIGV4YWN0bHkgYG5gIGVudHJpZXMsIGluIHdpdGggdGhlIGBqYCd0aCBlbnRyeSAod2hpY2ggY2FuIGJlIGVtcHR5KVxuICogc3BlY2lmaWVzIHRoZSBub2RlcyBjb25uZWN0ZWQgdG8gdmVydGV4IGBqYC5cbiAqXG4gKiBFLmcuIHRoZSBcInNxdWFyZVwiIGdyYXBoIGAkQ180JGAgY2FuIGJlIG9idGFpbmVkIGJ5XG4gKlxuICogYGBgXG4gKiB2YXIgRyA9IG1ha2VTbWFsbEdyYXBoKHtcbiAqICAgdHlwZTogXCJhZGphY2VuY3lsaXN0XCIsXG4gKiAgIG5hbWU6IFwiQ180XCIsXG4gKiAgIG46IDQsXG4gKiAgIGxpc3Q6IFtbMiw0XSxbMSwzXSxbMiw0XSxbMSwzXV1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogb3IsIHNpbmNlIHdlIGRvIG5vdCBuZWVkIHRvIGFkZCBlZGdlcyB0d2ljZSxcbiAqXG4gKiBgYGBcbiAqIHZhciBHID0gbWFrZVNtYWxsR3JhcGgoe1xuICogICB0eXBlOiBcImFkamFjZW5jeWxpc3RcIixcbiAqICAgbmFtZTogXCJDXzRcIixcbiAqICAgbjogNCxcbiAqICAgbGlzdDogW1syLDRdLFszXSxbNF0sW11dXVxuICogfSk7XG4gKlxuICogSWYgYGx0eXBlPVwiZWRnZWxpc3RcImAgdGhlbiBgeGxpc3RgIGlzIGFuIGVkZ2UgbGlzdCB3cml0dGVuIGFzXG4gKiBgW1t2MSx3Ml0sW3YyLHcyXSwuLi4sW3ZrLHdrXV1gLCB3aGVyZSBgdmpgIGFuZCBgd2pgIGludGVnZXJzIGluIHRoZSByYW5nZVxuICogMSwuLixuXG4gKlxuICogRS5nLiB0aGUgXCJzcXVhcmVcIiBncmFwaCBgJENfNCRgIGNhbiBiZSBvYnRhaW5lZCBieVxuICpcbiAqIGBgYFxuICogdmFyIEcgPSBtYWtlU21hbGxHcmFwaCh7XG4gKiAgIHR5cGU6IFwiZWRnZWxpc3RcIixcbiAqICAgbmFtZTogXCJDXzRcIixcbiAqICAgbjogNCxcbiAqICAgbGlzdDogW1sxLDJdLFszLDRdLFsyLDNdLFs0LDFdXV1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIHRoZSBvcHRDcmVhdGVVc2luZyBhcmd1bWVudCB0byBjaG9vc2UgdGhlIGdyYXBoIGNsYXNzL3R5cGUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZ3JhcGhEZXNjcmlwdGlvblxuICogICAgRGVzY3JpcHRpb24gb2YgdGhlIGdyYXBoIHRvIGNyZWF0ZSBpbiB0aGUgZm9ybSBge3R5cGUsIG5hbWUsIG4sIGxpc3R9YC5cbiAqIEBwYXJhbSB7R3JhcGg9fSBvcHRDcmVhdGVVc2luZyBHcmFwaCBpbnN0YW5jZSB0byBlbXB0eSBhbmQgYWRkIG5vZGVzIHRvLlxuICogQHJldHVybiB7R3JhcGh9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlU21hbGxHcmFwaCh7dHlwZSwgbmFtZSwgbiwgbGlzdH0sIG9wdENyZWF0ZVVzaW5nKSB7XG4gIHZhciBHID0gZW1wdHlHcmFwaChuLCBvcHRDcmVhdGVVc2luZyk7XG4gIHZhciBub2RlcyA9IEcubm9kZXMoKTtcblxuICBpZiAodHlwZSA9PT0gJ2FkamFjZW5jeWxpc3QnKSB7XG4gICAgaWYgKGxpc3QubGVuZ3RoICE9PSBuKSB7XG4gICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKCdpbnZhbGlkIGdyYXBoRGVzY3JpcHRpb24nKTtcbiAgICB9XG4gICAgbm9kZXMuZm9yRWFjaCh2ID0+IHtcbiAgICAgIGZvckVhY2gobGlzdFt2XSwgdSA9PiBHLmFkZEVkZ2UodSAtIDEsIHYpKTtcbiAgICB9KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlID09PSAnZWRnZWxpc3QnKSB7XG4gICAgZm9yRWFjaChsaXN0LCAoW3YsIHVdKSA9PiB7XG4gICAgICB2IC09IDE7XG4gICAgICB1IC09IDE7XG4gICAgICBpZiAodiA8IDAgfHwgdiA+IG4gLSAxIHx8IHUgPCAwIHx8IHUgPiBuIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKCdpbnZhbGlkIGdyYXBoRGVzY3JpcHRpb24nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEcuYWRkRWRnZSh2LCB1KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBHLm5hbWUgPSBuYW1lO1xuICByZXR1cm4gRztcbn1cblxuLy8gVE9ETzogTENGX2dyYXBoXG5cbi8qKlxuICogUmV0dXJuIHRoZSBCdWxsIGdyYXBoLlxuICpcbiAqIEBwYXJhbSB7R3JhcGg9fSBvcHRDcmVhdGVVc2luZyAgR3JhcGggaW5zdGFuY2UgdG8gZW1wdHkgYW5kIGFkZCBub2RlcyB0by5cbiAqIEByZXR1cm4ge0dyYXBofVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVsbEdyYXBoKG9wdENyZWF0ZVVzaW5nKSB7XG4gIHZhciB0eXBlID0gXCJhZGphY2VuY3lsaXN0XCI7XG4gIHZhciBuYW1lID0gXCJCdWxsIEdyYXBoXCI7XG4gIHZhciBuID0gNTtcbiAgdmFyIGxpc3QgPSBbWzIsM10sWzEsMyw0XSxbMSwyLDVdLFsyXSxbM11dO1xuXG4gIHJldHVybiBtYWtlU21hbGxVbmRpcmVjdGVkR3JhcGgoe3R5cGUsIG5hbWUsIG4sIGxpc3R9LCBvcHRDcmVhdGVVc2luZyk7XG59XG5cbi8vIFRPRE86IGNodmF0YWxfZ3JhcGhcbi8vIFRPRE86IGN1YmljYWxfZ3JhcGhcbi8vIFRPRE86IGRlc2FyZ3Vlc19ncmFwaFxuLy8gVE9ETzogZGlhbW9uZF9ncmFwaFxuLy8gVE9ETzogZG9kZWNhaGVkcmFsX2dyYXBoXG4vLyBUT0RPOiBmcnVjaHRfZ3JhcGhcbi8vIFRPRE86IGhlYXdvb2RfZ3JhcGhcbi8vIFRPRE86IGhvdXNlX2dyYXBoXG4vLyBUT0RPOiBob3VzZV94X2dyYXBoXG4vLyBUT0RPOiBpY29zYWhlZHJhbF9ncmFwaFxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBLcmFja2hhcmR0IEtpdGUgU29jaWFsIE5ldHdvcmsuXG4gKlxuICogQSAxMCBhY3RvciBzb2NpYWwgbmV0d29yayBpbnRyb2R1Y2VkIGJ5IERhdmlkIEtyYWNraGFyZHRcbiAqIHRvIGlsbHVzdHJhdGU6IGRlZ3JlZSwgYmV0d2Vlbm5lc3MsIGNlbnRyYWxpdHksIGNsb3NlbmVzcywgZXRjLlxuICogVGhlIHRyYWRpdGlvbmFsIGxhYmVsaW5nIGlzOlxuICogQW5kcmU9MSwgQmV2ZXJsZXk9MiwgQ2Fyb2w9MywgRGlhbmU9NCxcbiAqIEVkPTUsIEZlcm5hbmRvPTYsIEdhcnRoPTcsIEhlYXRoZXI9OCwgSWtlPTksIEphbmU9MTAuXG4gKlxuICogQHBhcmFtIHtHcmFwaD19IG9wdF9jcmVhdGVfdXNpbmcgR3JhcGggaW5zdGFuY2UgdG8gZW1wdHkgYW5kIGFkZCBub2RlcyB0by5cbiAqIEByZXR1cm4ge0dyYXBofVxuICovXG5leHBvcnQgZnVuY3Rpb24ga3JhY2toYXJkdEtpdGVHcmFwaChvcHRDcmVhdGVVc2luZykge1xuICB2YXIgdHlwZSA9IFwiYWRqYWNlbmN5bGlzdFwiO1xuICB2YXIgbmFtZSA9IFwiS3JhY2toYXJkdCBLaXRlIFNvY2lhbCBOZXR3b3JrXCI7XG4gIHZhciBuID0gMTA7XG4gIHZhciBsaXN0ID0gW1syLDMsNCw2XSxbMSw0LDUsN10sWzEsNCw2XSxbMSwyLDMsNSw2LDddLFsyLDQsN10sWzEsMyw0LDcsOF0sXG4gICAgIFsyLDQsNSw2LDhdLFs2LDcsOV0sWzgsMTBdLFs5XV07XG5cbiAgcmV0dXJuIG1ha2VTbWFsbFVuZGlyZWN0ZWRHcmFwaCh7dHlwZSwgbmFtZSwgbiwgbGlzdH0sIG9wdENyZWF0ZVVzaW5nKTtcbn1cblxuLy8gVE9ETzogbW9lYml1c19rYW50b3JfZ3JhcGhcbi8vIFRPRE86IG9jdGFoZWRyYWxfZ3JhcGhcbi8vIFRPRE86IHBhcHB1c19ncmFwaFxuLy8gVE9ETzogcGV0ZXJzZW5fZ3JhcGhcbi8vIFRPRE86IHNlZGdld2lja19tYXplX2dyYXBoXG4vLyBUT0RPOiB0ZXRyYWhlZHJhbF9ncmFwaFxuLy8gVE9ETzogdHJ1bmNhdGVkX2N1YmVfZ3JhcGhcbi8vIFRPRE86IHRydW5jYXRlZF90ZXRyYWhlZHJvbl9ncmFwaFxuLy8gVE9ETzogdHV0dGVfZ3JhcGhcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZhbW91cyBzb2NpYWwgbmV0d29ya3hcbiAqL1xuXG5pbXBvcnQgR3JhcGggZnJvbSAnLi4vY2xhc3Nlcy9HcmFwaCc7XG5cbmltcG9ydCByYW5nZSBmcm9tICcuLi9faW50ZXJuYWxzL3JhbmdlJztcblxuLyoqXG4gKiBSZXR1cm4gWmFjaGFyeSdzIEthcmF0ZSBjbHViIGdyYXBoLlxuICpcbiAqIEByZXR1cm4ge0dyYXBofVxuICovXG5leHBvcnQgZnVuY3Rpb24ga2FyYXRlQ2x1YkdyYXBoKCkge1xuICB2YXIgRyA9IG5ldyBHcmFwaCgpO1xuICBHLmFkZE5vZGVzRnJvbShyYW5nZSgzNCkpO1xuICBHLm5hbWUgPSBcIlphY2hhcnkncyBLYXJhdGUgQ2x1YlwiO1xuXG4gIHZhciB6YWNoYXJ5RGF0YSA9IFtcbiAgICAnMCAxIDEgMSAxIDEgMSAxIDEgMCAxIDEgMSAxIDAgMCAwIDEgMCAxIDAgMSAwIDAgMCAwIDAgMCAwIDAgMCAxIDAgMCcsXG4gICAgJzEgMCAxIDEgMCAwIDAgMSAwIDAgMCAwIDAgMSAwIDAgMCAxIDAgMSAwIDEgMCAwIDAgMCAwIDAgMCAwIDEgMCAwIDAnLFxuICAgICcxIDEgMCAxIDAgMCAwIDEgMSAxIDAgMCAwIDEgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxIDEgMCAwIDAgMSAwJyxcbiAgICAnMSAxIDEgMCAwIDAgMCAxIDAgMCAwIDAgMSAxIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCcsXG4gICAgJzEgMCAwIDAgMCAwIDEgMCAwIDAgMSAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAnLFxuICAgICcxIDAgMCAwIDAgMCAxIDAgMCAwIDEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwJyxcbiAgICAnMSAwIDAgMCAxIDEgMCAwIDAgMCAwIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCcsXG4gICAgJzEgMSAxIDEgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAnLFxuICAgICcxIDAgMSAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxIDAgMSAxJyxcbiAgICAnMCAwIDEgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMScsXG4gICAgJzEgMCAwIDAgMSAxIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAnLFxuICAgICcxIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwJyxcbiAgICAnMSAwIDAgMSAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCcsXG4gICAgJzEgMSAxIDEgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEnLFxuICAgICcwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMSAxJyxcbiAgICAnMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEgMScsXG4gICAgJzAgMCAwIDAgMCAxIDEgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAnLFxuICAgICcxIDEgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwJyxcbiAgICAnMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEgMScsXG4gICAgJzEgMSAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEnLFxuICAgICcwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMSAxJyxcbiAgICAnMSAxIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCcsXG4gICAgJzAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxIDEnLFxuICAgICcwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEgMCAxIDAgMSAwIDAgMSAxJyxcbiAgICAnMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxIDAgMSAwIDAgMCAxIDAgMCcsXG4gICAgJzAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxIDEgMCAwIDAgMCAwIDAgMSAwIDAnLFxuICAgICcwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMSAwIDAgMCAxJyxcbiAgICAnMCAwIDEgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEgMSAwIDAgMCAwIDAgMCAwIDAgMScsXG4gICAgJzAgMCAxIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMSAwIDEnLFxuICAgICcwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMSAwIDAgMSAwIDAgMCAwIDAgMSAxJyxcbiAgICAnMCAxIDAgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEgMScsXG4gICAgJzEgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEgMSAwIDAgMSAwIDAgMCAxIDEnLFxuICAgICcwIDAgMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAxIDAgMCAxIDAgMSAwIDEgMSAwIDAgMCAwIDAgMSAxIDEgMCAxJyxcbiAgICAnMCAwIDAgMCAwIDAgMCAwIDEgMSAwIDAgMCAxIDEgMSAwIDAgMSAxIDEgMCAxIDEgMCAwIDEgMSAxIDEgMSAxIDEgMCdcbiAgXTtcblxuICB6YWNoYXJ5RGF0YS5mb3JFYWNoKChsaW5lLCByb3cpID0+IHtcbiAgICB2YXIgdGhpc3JvdyA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICB0aGlzcm93LmZvckVhY2goKHZhbCwgY29sKSA9PiB7XG4gICAgICBpZiAodmFsID09PSAnMScpIHtcbiAgICAgICAgRy5hZGRFZGdlKHJvdywgY29sKTsgLy8gY29sIGdvZXMgZnJvbSAwLDMzXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIEcuYWRkTm9kZXNGcm9tKFswLDEsMiwzLDQsNSw2LDcsOCwxMCwxMSwxMiwxMywxNiwxNywxOSwyMV0sIHtjbHViOiAnTXIuIEhpJ30pO1xuICBHLmFkZE5vZGVzRnJvbShcbiAgICBbOSwxNCwxNSwxOCwyMCwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzM10sXG4gICAge2NsdWI6ICdPZmZpY2VyJ31cbiAgKTtcblxuICByZXR1cm4gRztcbn1cblxuLyoqXG4gKiBSZXR1cm4gRGF2aXMgU2FvdXRoZXJuIHdvbWVuIHNvY2lhbCBuZXR3b3JrLlxuICpcbiAqIFRoaXMgaXMgYSBiaXBhcnRpdGUgZ3JhcGguXG4gKlxuICogQHJldHVybiB7R3JhcGh9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXZpc1NvdXRoZXJuV29tZW5HcmFwaCgpIHtcbiAgdmFyIEcgPSBuZXcgR3JhcGgoKTtcbiAgLy8gdG9wIG5vZGVzXG4gIEcuYWRkTm9kZXNGcm9tKFxuICAgIFtcbiAgICAgICdFdmVseW4gSmVmZmVyc29uJyxcbiAgICAgICdMYXVyYSBNYW5kZXZpbGxlJyxcbiAgICAgICdUaGVyZXNhIEFuZGVyc29uJyxcbiAgICAgICdCcmVuZGEgUm9nZXJzJyxcbiAgICAgICdDaGFybG90dGUgTWNEb3dkJyxcbiAgICAgICdGcmFuY2VzIEFuZGVyc29uJyxcbiAgICAgICdFbGVhbm9yIE55ZScsXG4gICAgICAnUGVhcmwgT2dsZXRob3JwZScsXG4gICAgICAnUnV0aCBEZVNhbmQnLFxuICAgICAgJ1Zlcm5lIFNhbmRlcnNvbicsXG4gICAgICAnTXlyYSBMaWRkZWwnLFxuICAgICAgJ0thdGhlcmluYSBSb2dlcnMnLFxuICAgICAgJ1N5bHZpYSBBdm9uZGFsZScsXG4gICAgICAnTm9yYSBGYXlldHRlJyxcbiAgICAgICdIZWxlbiBMbG95ZCcsXG4gICAgICAnRG9yb3RoeSBNdXJjaGlzb24nLFxuICAgICAgJ09saXZpYSBDYXJsZXRvbicsXG4gICAgICAnRmxvcmEgUHJpY2UnXG4gICAgXSxcbiAgICB7YmlwYXJ0aXRlOiAwfVxuICApO1xuXG4gIC8vIGJvdHRvbSBub2Rlc1xuICBHLmFkZE5vZGVzRnJvbShcbiAgICBbXG4gICAgICAnRTEnLFxuICAgICAgJ0UyJyxcbiAgICAgICdFMycsXG4gICAgICAnRTQnLFxuICAgICAgJ0U1JyxcbiAgICAgICdFNicsXG4gICAgICAnRTcnLFxuICAgICAgJ0U4JyxcbiAgICAgICdFOScsXG4gICAgICAnRTEwJyxcbiAgICAgICdFMTEnLFxuICAgICAgJ0UxMicsXG4gICAgICAnRTEzJyxcbiAgICAgICdFMTQnXG4gICAgXSxcbiAgICB7YmlwYXJ0aXRlOiAxfVxuICApO1xuXG4gIEcuYWRkX2VkZ2VzX2Zyb20oW1xuICAgIFsnRXZlbHluIEplZmZlcnNvbicsJ0UxJ10sXG4gICAgWydFdmVseW4gSmVmZmVyc29uJywnRTInXSxcbiAgICBbJ0V2ZWx5biBKZWZmZXJzb24nLCdFMyddLFxuICAgIFsnRXZlbHluIEplZmZlcnNvbicsJ0U0J10sXG4gICAgWydFdmVseW4gSmVmZmVyc29uJywnRTUnXSxcbiAgICBbJ0V2ZWx5biBKZWZmZXJzb24nLCdFNiddLFxuICAgIFsnRXZlbHluIEplZmZlcnNvbicsJ0U4J10sXG4gICAgWydFdmVseW4gSmVmZmVyc29uJywnRTknXSxcbiAgICBbJ0xhdXJhIE1hbmRldmlsbGUnLCdFMSddLFxuICAgIFsnTGF1cmEgTWFuZGV2aWxsZScsJ0UyJ10sXG4gICAgWydMYXVyYSBNYW5kZXZpbGxlJywnRTMnXSxcbiAgICBbJ0xhdXJhIE1hbmRldmlsbGUnLCdFNSddLFxuICAgIFsnTGF1cmEgTWFuZGV2aWxsZScsJ0U2J10sXG4gICAgWydMYXVyYSBNYW5kZXZpbGxlJywnRTcnXSxcbiAgICBbJ0xhdXJhIE1hbmRldmlsbGUnLCdFOCddLFxuICAgIFsnVGhlcmVzYSBBbmRlcnNvbicsJ0UyJ10sXG4gICAgWydUaGVyZXNhIEFuZGVyc29uJywnRTMnXSxcbiAgICBbJ1RoZXJlc2EgQW5kZXJzb24nLCdFNCddLFxuICAgIFsnVGhlcmVzYSBBbmRlcnNvbicsJ0U1J10sXG4gICAgWydUaGVyZXNhIEFuZGVyc29uJywnRTYnXSxcbiAgICBbJ1RoZXJlc2EgQW5kZXJzb24nLCdFNyddLFxuICAgIFsnVGhlcmVzYSBBbmRlcnNvbicsJ0U4J10sXG4gICAgWydUaGVyZXNhIEFuZGVyc29uJywnRTknXSxcbiAgICBbJ0JyZW5kYSBSb2dlcnMnLCdFMSddLFxuICAgIFsnQnJlbmRhIFJvZ2VycycsJ0UzJ10sXG4gICAgWydCcmVuZGEgUm9nZXJzJywnRTQnXSxcbiAgICBbJ0JyZW5kYSBSb2dlcnMnLCdFNSddLFxuICAgIFsnQnJlbmRhIFJvZ2VycycsJ0U2J10sXG4gICAgWydCcmVuZGEgUm9nZXJzJywnRTcnXSxcbiAgICBbJ0JyZW5kYSBSb2dlcnMnLCdFOCddLFxuICAgIFsnQ2hhcmxvdHRlIE1jRG93ZCcsJ0UzJ10sXG4gICAgWydDaGFybG90dGUgTWNEb3dkJywnRTQnXSxcbiAgICBbJ0NoYXJsb3R0ZSBNY0Rvd2QnLCdFNSddLFxuICAgIFsnQ2hhcmxvdHRlIE1jRG93ZCcsJ0U3J10sXG4gICAgWydGcmFuY2VzIEFuZGVyc29uJywnRTMnXSxcbiAgICBbJ0ZyYW5jZXMgQW5kZXJzb24nLCdFNSddLFxuICAgIFsnRnJhbmNlcyBBbmRlcnNvbicsJ0U2J10sXG4gICAgWydGcmFuY2VzIEFuZGVyc29uJywnRTgnXSxcbiAgICBbJ0VsZWFub3IgTnllJywnRTUnXSxcbiAgICBbJ0VsZWFub3IgTnllJywnRTYnXSxcbiAgICBbJ0VsZWFub3IgTnllJywnRTcnXSxcbiAgICBbJ0VsZWFub3IgTnllJywnRTgnXSxcbiAgICBbJ1BlYXJsIE9nbGV0aG9ycGUnLCdFNiddLFxuICAgIFsnUGVhcmwgT2dsZXRob3JwZScsJ0U4J10sXG4gICAgWydQZWFybCBPZ2xldGhvcnBlJywnRTknXSxcbiAgICBbJ1J1dGggRGVTYW5kJywnRTUnXSxcbiAgICBbJ1J1dGggRGVTYW5kJywnRTcnXSxcbiAgICBbJ1J1dGggRGVTYW5kJywnRTgnXSxcbiAgICBbJ1J1dGggRGVTYW5kJywnRTknXSxcbiAgICBbJ1Zlcm5lIFNhbmRlcnNvbicsJ0U3J10sXG4gICAgWydWZXJuZSBTYW5kZXJzb24nLCdFOCddLFxuICAgIFsnVmVybmUgU2FuZGVyc29uJywnRTknXSxcbiAgICBbJ1Zlcm5lIFNhbmRlcnNvbicsJ0UxMiddLFxuICAgIFsnTXlyYSBMaWRkZWwnLCdFOCddLFxuICAgIFsnTXlyYSBMaWRkZWwnLCdFOSddLFxuICAgIFsnTXlyYSBMaWRkZWwnLCdFMTAnXSxcbiAgICBbJ015cmEgTGlkZGVsJywnRTEyJ10sXG4gICAgWydLYXRoZXJpbmEgUm9nZXJzJywnRTgnXSxcbiAgICBbJ0thdGhlcmluYSBSb2dlcnMnLCdFOSddLFxuICAgIFsnS2F0aGVyaW5hIFJvZ2VycycsJ0UxMCddLFxuICAgIFsnS2F0aGVyaW5hIFJvZ2VycycsJ0UxMiddLFxuICAgIFsnS2F0aGVyaW5hIFJvZ2VycycsJ0UxMyddLFxuICAgIFsnS2F0aGVyaW5hIFJvZ2VycycsJ0UxNCddLFxuICAgIFsnU3lsdmlhIEF2b25kYWxlJywnRTcnXSxcbiAgICBbJ1N5bHZpYSBBdm9uZGFsZScsJ0U4J10sXG4gICAgWydTeWx2aWEgQXZvbmRhbGUnLCdFOSddLFxuICAgIFsnU3lsdmlhIEF2b25kYWxlJywnRTEwJ10sXG4gICAgWydTeWx2aWEgQXZvbmRhbGUnLCdFMTInXSxcbiAgICBbJ1N5bHZpYSBBdm9uZGFsZScsJ0UxMyddLFxuICAgIFsnU3lsdmlhIEF2b25kYWxlJywnRTE0J10sXG4gICAgWydOb3JhIEZheWV0dGUnLCdFNiddLFxuICAgIFsnTm9yYSBGYXlldHRlJywnRTcnXSxcbiAgICBbJ05vcmEgRmF5ZXR0ZScsJ0U5J10sXG4gICAgWydOb3JhIEZheWV0dGUnLCdFMTAnXSxcbiAgICBbJ05vcmEgRmF5ZXR0ZScsJ0UxMSddLFxuICAgIFsnTm9yYSBGYXlldHRlJywnRTEyJ10sXG4gICAgWydOb3JhIEZheWV0dGUnLCdFMTMnXSxcbiAgICBbJ05vcmEgRmF5ZXR0ZScsJ0UxNCddLFxuICAgIFsnSGVsZW4gTGxveWQnLCdFNyddLFxuICAgIFsnSGVsZW4gTGxveWQnLCdFOCddLFxuICAgIFsnSGVsZW4gTGxveWQnLCdFMTAnXSxcbiAgICBbJ0hlbGVuIExsb3lkJywnRTExJ10sXG4gICAgWydIZWxlbiBMbG95ZCcsJ0UxMiddLFxuICAgIFsnRG9yb3RoeSBNdXJjaGlzb24nLCdFOCddLFxuICAgIFsnRG9yb3RoeSBNdXJjaGlzb24nLCdFOSddLFxuICAgIFsnT2xpdmlhIENhcmxldG9uJywnRTknXSxcbiAgICBbJ09saXZpYSBDYXJsZXRvbicsJ0UxMSddLFxuICAgIFsnRmxvcmEgUHJpY2UnLCdFOSddLFxuICAgIFsnRmxvcmEgUHJpY2UnLCdFMTEnXVxuICBdKTtcblxuICByZXR1cm4gRztcbn1cblxuLyoqXG4gKiBSZXR1cm4gRmxvcmVudGluZSBmYW1pbGllcyBncmFwaC5cbiAqXG4gKiBAcmV0dXJuIHtHcmFwaH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsb3JlbnRpbmVGYW1pbGllc0dyYXBoKCkge1xuICB2YXIgRyA9IG5ldyBHcmFwaCgpO1xuICBHLmFkZEVkZ2UoJ0FjY2lhaXVvbGknLCdNZWRpY2knKTtcbiAgRy5hZGRFZGdlKCdDYXN0ZWxsYW5pJywnUGVydXp6aScpO1xuICBHLmFkZEVkZ2UoJ0Nhc3RlbGxhbmknLCdTdHJvenppJyk7XG4gIEcuYWRkRWRnZSgnQ2FzdGVsbGFuaScsJ0JhcmJhZG9yaScpO1xuICBHLmFkZEVkZ2UoJ01lZGljaScsJ0JhcmJhZG9yaScpO1xuICBHLmFkZEVkZ2UoJ01lZGljaScsJ1JpZG9sZmknKTtcbiAgRy5hZGRFZGdlKCdNZWRpY2knLCdUb3JuYWJ1b25pJyk7XG4gIEcuYWRkRWRnZSgnTWVkaWNpJywnQWxiaXp6aScpO1xuICBHLmFkZEVkZ2UoJ01lZGljaScsJ1NhbHZpYXRpJyk7XG4gIEcuYWRkRWRnZSgnU2FsdmlhdGknLCdQYXp6aScpO1xuICBHLmFkZEVkZ2UoJ1BlcnV6emknLCdTdHJvenppJyk7XG4gIEcuYWRkRWRnZSgnUGVydXp6aScsJ0Jpc2NoZXJpJyk7XG4gIEcuYWRkRWRnZSgnU3Ryb3p6aScsJ1JpZG9sZmknKTtcbiAgRy5hZGRFZGdlKCdTdHJvenppJywnQmlzY2hlcmknKTtcbiAgRy5hZGRFZGdlKCdSaWRvbGZpJywnVG9ybmFidW9uaScpO1xuICBHLmFkZEVkZ2UoJ1Rvcm5hYnVvbmknLCdHdWFkYWduaScpO1xuICBHLmFkZEVkZ2UoJ0FsYml6emknLCdHaW5vcmknKTtcbiAgRy5hZGRFZGdlKCdBbGJpenppJywnR3VhZGFnbmknKTtcbiAgRy5hZGRFZGdlKCdCaXNjaGVyaScsJ0d1YWRhZ25pJyk7XG4gIEcuYWRkRWRnZSgnR3VhZGFnbmknLCdMYW1iZXJ0ZXNjaGknKTtcbiAgcmV0dXJuIEc7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0ICogYXMgYWxnb3JpdGhtcyBmcm9tICcuL2FsZ29yaXRobXMnO1xuaW1wb3J0ICogYXMgY2xhc3NlcyBmcm9tICcuL2NsYXNzZXMnO1xuaW1wb3J0ICogYXMgY29udmVydCBmcm9tICcuL2NvbnZlcnQnO1xuaW1wb3J0ICogYXMgZHJhd2luZyBmcm9tICcuL2RyYXdpbmcnO1xuaW1wb3J0ICogYXMgZXhjZXB0aW9ucyBmcm9tICcuL2V4Y2VwdGlvbnMnO1xuaW1wb3J0ICogYXMgZ2VuZXJhdG9ycyBmcm9tICcuL2dlbmVyYXRvcnMnO1xuaW1wb3J0ICogYXMgcmVsYWJlbCBmcm9tICcuL3JlbGFiZWwnO1xuXG5pbXBvcnQgTWFwIGZyb20gJy4vX2ludGVybmFscy9NYXAnO1xuaW1wb3J0IFNldCBmcm9tICcuL19pbnRlcm5hbHMvU2V0JztcblxuZXhwb3J0IHtcbiAgTWFwLFxuICBTZXQsXG4gIGFsZ29yaXRobXMsXG4gIGNsYXNzZXMsXG4gIGNvbnZlcnQsXG4gIGRyYXdpbmcsXG4gIGV4Y2VwdGlvbnMsXG4gIGdlbmVyYXRvcnMsXG4gIHJlbGFiZWxcbn07XG5cbmV4cG9ydCAqIGZyb20gJy4vYWxnb3JpdGhtcyc7XG5leHBvcnQgKiBmcm9tICcuL2NsYXNzZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb252ZXJ0JztcbmV4cG9ydCAqIGZyb20gJy4vZHJhd2luZyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbnRyaWIvb2JzZXJ2ZXInO1xuZXhwb3J0ICogZnJvbSAnLi9leGNlcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vZ2VuZXJhdG9ycyc7XG5leHBvcnQgKiBmcm9tICcuL3JlbGFiZWwnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGlHcmFwaCA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9EaUdyYXBoJyk7XG4vKmpzaGludCBpZ25vcmU6c3RhcnQqL1xudmFyIE1hcCA9IHJlcXVpcmUoJy4vX2ludGVybmFscy9NYXAnKTtcbnZhciBTZXQgPSByZXF1aXJlKCcuL19pbnRlcm5hbHMvU2V0Jyk7XG4vKmpzaGludCBpZ25vcmU6ZW5kKi9cbnZhciB7SlNOZXR3b3JrWEVycm9yLCBKU05ldHdvcmtYVW5mZWFzaWJsZX0gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbnMnKTtcblxudmFyIHtcbiAgY2xvbmUsXG4gIGZvckVhY2gsXG4gIGlzTWFwLFxuICBtYXBJdGVyYXRvcixcbiAgc29tZUl0ZXJhdG9yLFxuICBzcHJpbnRmLFxuICB0b3BvbG9naWNhbFNvcnQsXG4gIHR1cGxlMixcbiAgdHVwbGUzYyxcbiAgdHVwbGU0Y1xufSA9IHJlcXVpcmUoJy4vX2ludGVybmFscycpO1xuXG4vKipcbiAqIFJlbGFiZWwgdGhlIG5vZGVzIG9mIHRoZSBncmFwaCBHLlxuICpcbiAqIE5vdGVzXG4gKiAtLS0tLVxuICogT25seSB0aGUgbm9kZXMgc3BlY2lmaWVkIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgcmVsYWJlbGVkLlxuICpcbiAqIFRoZSBzZXR0aW5nIGNvcHk9ZmFsc2UgbW9kaWZpZXMgdGhlIGdyYXBoIGluIHBsYWNlLlxuICogVGhpcyBpcyBub3QgYWx3YXlzIHBvc3NpYmxlIGlmIHRoZSBtYXBwaW5nIGlzIGNpcmN1bGFyLlxuICogSW4gdGhhdCBjYXNlIHVzZSBjb3B5PXRydWUuXG4gKlxuICogQHNlZSAjY29udmVydE5vZGVMYWJlbHNUb19pbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7R3JhcGh9IEcgQSBKU05ldHdvcmtYIGdyYXBoXG4gKiBAcGFyYW0geyhPYmplY3R8TWFwfGZ1bmN0aW9uKE5vZGUpOk5vZGUpfSBtYXBwaW5nXG4gKiAgICAgIEEgZGljdGlvbmFyeSB3aXRoIHRoZSBvbGQgbGFiZWxzIGFzIGtleXMgYW5kIG5ldyBsYWJlbHMgYXMgdmFsdWVzLlxuICogICAgICBBIHBhcnRpYWwgbWFwcGluZyBpcyBhbGxvd2VkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0Q29weSAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgSWYgVHJ1ZSByZXR1cm4gYSBjb3B5IG9yIGlmIEZhbHNlIHJlbGFiZWwgdGhlIG5vZGVzIGluIHBsYWNlLlxuICpcbiAqIEByZXR1cm4ge0dyYXBofVxuICogQGV4cG9ydFxuICovXG5mdW5jdGlvbiByZWxhYmVsTm9kZXMoRywgbWFwcGluZywgb3B0Q29weT10cnVlKSB7XG4gIC8vIHlvdSBjYW4gcGFzcyBhIGZ1bmN0aW9uIGYob2xkTGFiZWwpLT5uZXdMYWJlbFxuICAvLyBidXQgd2UnbGwganVzdCBtYWtlIGEgZGljdGlvbmFyeSBoZXJlIHJlZ2FyZGxlc3NcbiAgdmFyIG0gPSBtYXBwaW5nO1xuICBpZiAodHlwZW9mIG1hcHBpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoIWlzTWFwKG0pKSB7XG4gICAgICBtID0gbmV3IE1hcChtKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgbSA9IG5ldyBNYXAobWFwSXRlcmF0b3IoRy5ub2Rlc0l0ZXIoKSwgbiA9PiB0dXBsZTIobiwgbWFwcGluZyhuKSkpKTtcbiAgfVxuXG4gIHJldHVybiBvcHRDb3B5ID8gcmVsYWJlbENvcHkoRywgbSkgOiByZWxhYmVsSW5wbGFjZShHLCBtKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7R3JhcGh9IEcgQSBKU05ldHdvcmtYIGdyYXBoXG4gKiBAcGFyYW0ge01hcH0gbWFwcGluZ1xuICogICAgICBBIGRpY3Rpb25hcnkgd2l0aCB0aGUgb2xkIGxhYmVscyBhcyBrZXlzIGFuZCBuZXcgbGFiZWxzIGFzIHZhbHVlcy5cbiAqICAgICAgQSBwYXJ0aWFsIG1hcHBpbmcgaXMgYWxsb3dlZC5cbiAqXG4gKiBAcmV0dXJuIC5HcmFwaH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbGFiZWxJbnBsYWNlKEcsIG1hcHBpbmcpIHtcbiAgdmFyIG9sZExhYmVscyA9IG5ldyBTZXQobWFwcGluZy5rZXlzKCkpO1xuICB2YXIgbm9kZXM7XG5cbiAgaWYgKHNvbWVJdGVyYXRvcihtYXBwaW5nLnZhbHVlcygpLCB2ID0+IG9sZExhYmVscy5oYXModikpKSB7XG4gICAgLy8gbGFiZWxzIHNldHMgb3ZlcmxhcFxuICAgIC8vIGNhbiB3ZSB0b3BvbG9naWNhbCBzb3J0IGFuZCBzdGlsbCBkbyB0aGUgcmVsYWJlbGluZz9cbiAgICB2YXIgRCA9IG5ldyBEaUdyYXBoKG1hcHBpbmcpO1xuICAgIEQucmVtb3ZlRWRnZXNGcm9tKEQuc2VsZmxvb3BFZGdlcygpKTtcbiAgICB0cnkge1xuICAgICAgbm9kZXMgPSB0b3BvbG9naWNhbFNvcnQoRCk7XG4gICAgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgSlNOZXR3b3JrWFVuZmVhc2libGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpTTmV0d29ya1hVbmZlYXNpYmxlKFxuICAgICAgICAgICdUaGUgbm9kZSBsYWJlbCBzZXRzIGFyZSBvdmVybGFwcGluZyBhbmQnICtcbiAgICAgICAgICAnIG5vIG9yZGVyaW5nIGNhbiByZXNvbHZlIHRoZSBtYXBwaW5nLicgK1xuICAgICAgICAgICcgVXNlIGNvcHk9VHJ1ZS4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGVzLnJldmVyc2UoKTsgLy8gcmV2ZXJzZSB0b3BvbG9naWNhbCBvcmRlclxuICB9XG4gIGVsc2Uge1xuICAgIC8vIG5vbi1vdmVybGFwcGluZyBsYWJlbCBzZXRzXG4gICAgbm9kZXMgPSBvbGRMYWJlbHMudmFsdWVzKCk7XG4gIH1cbiAgdmFyIG11bHRpZ3JhcGggPSBHLmlzTXVsdGlncmFwaCgpO1xuICB2YXIgZGlyZWN0ZWQgPSBHLmlzRGlyZWN0ZWQoKTtcbiAgdmFyIG5ld0VkZ2VzO1xuXG4gIGZvckVhY2gobm9kZXMsIGZ1bmN0aW9uKG9sZCkge1xuICAgIHZhciBuZXdfO1xuICAgIGlmIChtYXBwaW5nLmhhcyhvbGQpKSB7XG4gICAgICBuZXdfID0gbWFwcGluZy5nZXQob2xkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm47IC8vIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKCFHLmhhc05vZGUob2xkKSkge1xuICAgICAgdGhyb3cgbmV3IEpTTmV0d29ya1hFcnJvcihzcHJpbnRmKCdOb2RlICVqIGlzIG5vdCBpbiB0aGUgZ3JhcGguJywgb2xkKSk7XG4gICAgfVxuICAgIEcuYWRkTm9kZShuZXdfLCBHLm5vZGUuZ2V0KG9sZCkpO1xuICAgIGlmIChtdWx0aWdyYXBoKSB7XG4gICAgICBuZXdFZGdlcyA9IEcuZWRnZXMob2xkLCB0cnVlLCB0cnVlKS5tYXAoXG4gICAgICAgICAgZCA9PiB0dXBsZTRjKG5ld18sIGRbMV0sIGRbMl0sIGRbM10sIGQpXG4gICAgICApO1xuXG4gICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgbmV3RWRnZXMgPSBuZXdFZGdlcy5jb25jYXQoXG4gICAgICAgICAgRy5pbkVkZ2VzKG9sZCwgdHJ1ZSwgdHJ1ZSkubWFwKFxuICAgICAgICAgICAgZCA9PiB0dXBsZTRjKGRbMF0sIG5ld18sIGRbMl0sIGRbM10sIGQpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5ld0VkZ2VzID0gRy5lZGdlcyhvbGQsIHRydWUpLm1hcChkID0+IHR1cGxlM2MobmV3XywgZFsxXSwgZFsyXSwgZCkpO1xuXG4gICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgbmV3RWRnZXMgPSBuZXdFZGdlcy5jb25jYXQoXG4gICAgICAgICAgRy5pbkVkZ2VzKG9sZCwgdHJ1ZSkubWFwKGQgPT4gdHVwbGUzYyhkWzBdLCBuZXdfLCBkWzJdLCBkKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgRy5yZW1vdmVOb2RlKG9sZCk7XG4gICAgRy5hZGRFZGdlc0Zyb20obmV3RWRnZXMpO1xuICB9KTtcbiAgcmV0dXJuIEc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtHcmFwaH0gRyBBIEpTTmV0d29ya1ggZ3JhcGhcbiAqIEBwYXJhbSB7TWFwfSBtYXBwaW5nXG4gKiAgICAgIEEgZGljdGlvbmFyeSB3aXRoIHRoZSBvbGQgbGFiZWxzIGFzIGtleXMgYW5kIG5ldyBsYWJlbHMgYXMgdmFsdWVzLlxuICogICAgICBBIHBhcnRpYWwgbWFwcGluZyBpcyBhbGxvd2VkLlxuICpcbiAqIEByZXR1cm4ge0dyYXBofVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVsYWJlbENvcHkoRywgbWFwcGluZykge1xuICB2YXIgSCA9IG5ldyBHLmNvbnN0cnVjdG9yKCk7XG4gIEgubmFtZSA9ICcoJyArIEcubmFtZSArICcpJztcbiAgaWYgKEcuaXNNdWx0aWdyYXBoKCkpIHtcbiAgICBILmFkZEVkZ2VzRnJvbShtYXBJdGVyYXRvcihcbiAgICAgIEcuZWRnZXNJdGVyKG51bGwsIHRydWUsIHRydWUpLFxuICAgICAgZCA9PiB0dXBsZTRjKFxuICAgICAgICBtYXBwaW5nLmhhcyhkWzBdKSA/IG1hcHBpbmcuZ2V0KGRbMF0pIDogZFswXSxcbiAgICAgICAgbWFwcGluZy5oYXMoZFsxXSkgPyBtYXBwaW5nLmdldChkWzFdKSA6IGRbMV0sXG4gICAgICAgIGRbMl0sXG4gICAgICAgIGNsb25lKGRbM10pLFxuICAgICAgICBkXG4gICAgICApXG4gICAgKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgSC5hZGRFZGdlc0Zyb20obWFwSXRlcmF0b3IoXG4gICAgICBHLmVkZ2VzSXRlcihudWxsLCB0cnVlKSxcbiAgICAgIGQgPT4gdHVwbGUzYyhcbiAgICAgICAgbWFwcGluZy5oYXMoZFswXSkgPyBtYXBwaW5nLmdldChkWzBdKSA6IGRbMF0sXG4gICAgICAgIG1hcHBpbmcuaGFzKGRbMV0pID8gbWFwcGluZy5nZXQoZFsxXSkgOiBkWzFdLFxuICAgICAgICBjbG9uZShkWzNdKSxcbiAgICAgICAgZFxuICAgICAgKVxuICAgICkpO1xuICB9XG4gIEcubm9kZS5mb3JFYWNoKChkYXRhLCBuKSA9PlxuICAgIEguYWRkTm9kZShtYXBwaW5nLmhhcyhuKSA/IG1hcHBpbmcuZ2V0KG4pIDogbiwgY2xvbmUoZGF0YSkpXG4gICk7XG4gIE9iamVjdC5hc3NpZ24oSC5ncmFwaCwgY2xvbmUoRy5ncmFwaCkpO1xuXG4gIHJldHVybiBIO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGNvcHkgb2YgRyBub2RlIGxhYmVscyByZXBsYWNlZCB3aXRoIGludGVnZXJzLlxuICpcbiAqIEBwYXJhbSB7R3JhcGh9IEcgQSBKU05ldHdvcmtYIGdyYXBoXG4gKiBAcGFyYW0gez9udW1iZXI9fSBvcHRGaXJzdExhYmVsIChkZWZhdWx0PTApXG4gKiAgICAgIEFuIGludGVnZXIgc3BlY2lmeWluZyB0aGUgb2Zmc2V0IGluIG51bWJlcmluZyBub2Rlcy5cbiAqICAgICAgVGhlIG4gbmV3IGludGVnZXIgbGFiZWxzIGFyZSBudW1iZXJlZCBmaXJzdExhYmVsLCAuLi4sIG4tMStmaXJzdExhYmVsLlxuICogQHBhcmFtIHs/c3RyaW5nPX0gb3B0T3JkZXJpbmcgKGRlZmF1bHQ9XCJkZWZhdWx0XCIpXG4gKiAgICAgIFwiZGVmYXVsdFwiIDogaW5oZXJpdCBub2RlIG9yZGVyaW5nIGZyb20gRy5ub2RlcygpXG4gKiAgICAgIFwic29ydGVkXCIgIDogaW5oZXJpdCBub2RlIG9yZGVyaW5nIGZyb20gc29ydGVkKEcubm9kZXMoKSlcbiAqICAgICAgXCJpbmNyZWFzaW5nIGRlZ3JlZVwiIDogbm9kZXMgYXJlIHNvcnRlZCBieSBpbmNyZWFzaW5nIGRlZ3JlZVxuICogICAgICBcImRlY3JlYXNpbmcgZGVncmVlXCIgOiBub2RlcyBhcmUgc29ydGVkIGJ5IGRlY3JlYXNpbmcgZGVncmVlXG4gKiBAcGFyYW0gez9ib29sZWFuPX0gb3B0RGlzY2FyZE9sZExhYmVscyAoZGVmYXVsdD10cnVlKVxuICogICAgICBJZiB0cnVlIGRpc2NhcmQgb2xkIGxhYmVscy4gSWYgZmFsc2UsIGNyZWF0ZSBhIG5vZGUgYXR0cmlidXRlXG4gKiAgICAgICdvbGRMYWJlbCcgdG8gaG9sZCB0aGUgb2xkIGxhYmVscy5cbiAqXG4gKiBAcmV0dXJuIHtHcmFwaH1cbiAqIEBleHBvcnRcbiAqL1xuZnVuY3Rpb24gY29udmVydE5vZGVMYWJlbHNUb0ludGVnZXJzKFxuICBHLFxuICBvcHRGaXJzdExhYmVsPTAsXG4gIG9wdE9yZGVyaW5nPSdkZWZhdWx0JyxcbiAgb3B0RGlzY2FyZE9sZExhYmVscz10cnVlXG4pIHtcbiAgLy8gICBUaGlzIGZ1bmN0aW9uIHN0cmlwcyBpbmZvcm1hdGlvbiBhdHRhY2hlZCB0byB0aGUgbm9kZXMgYW5kL29yXG4gIC8vICAgZWRnZXMgb2YgYSBncmFwaCwgYW5kIHJldHVybnMgYSBncmFwaCB3aXRoIGFwcHJvcHJpYXRlIGludGVnZXJcbiAgLy8gICBsYWJlbHMuIE9uZSBjYW4gdmlldyB0aGlzIGFzIGEgcmUtbGFiZWxpbmcgb2YgdGhlIG5vZGVzLiBCZVxuICAvLyAgIHdhcm5lZCB0aGF0IHRoZSB0ZXJtIFwibGFiZWxlZCBncmFwaFwiIGhhcyBhIGxvYWRlZCBtZWFuaW5nXG4gIC8vICAgaW4gZ3JhcGggdGhlb3J5LiBUaGUgZnVuZGFtZW50YWwgaXNzdWUgaXMgd2hldGhlciB0aGUgbmFtZXNcbiAgLy8gICAobGFiZWxzKSBvZiB0aGUgbm9kZXMgKGFuZCBlZGdlcykgbWF0dGVyIGluIGRlY2lkaW5nIHdoZW4gdHdvXG4gIC8vICAgZ3JhcGhzIGFyZSB0aGUgc2FtZS4gRm9yIGV4YW1wbGUsIGluIHByb2JsZW1zIG9mIGdyYXBoIGVudW1lcmF0aW9uXG4gIC8vICAgdGhlcmUgaXMgYSBkaXN0aW5jdCBkaWZmZXJlbmNlIGluIHRlY2huaXF1ZXMgcmVxdWlyZWQgd2hlblxuICAvLyAgIGNvdW50aW5nIGxhYmVsZWQgdnMuIHVubGFiZWxlZCBncmFwaHMuXG4gIC8vXG4gIC8vICAgV2hlbiBpbXBsZW1lbnRpbmcgZ3JhcGhcbiAgLy8gICBhbGdvcml0aG1zIGl0IGlzIG9mdGVuIGNvbnZlbmllbnQgdG8gc3RyaXAgb2ZmIHRoZSBvcmlnaW5hbCBub2RlXG4gIC8vICAgYW5kIGVkZ2UgaW5mb3JtYXRpb24gYW5kIGFwcHJvcHJpYXRlbHkgcmVsYWJlbCB0aGUgbiBub2RlcyB3aXRoXG4gIC8vICAgdGhlIGludGVnZXIgdmFsdWVzIDEsLi4sbi4gVGhpcyBpcyB0aGUgcHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uLFxuICAvLyAgIGFuZCBpdCBwcm92aWRlcyB0aGUgb3B0aW9uIChzZWUgZGlzY2FyZE9sZExhYmVscyB2YXJpYWJsZSkgdG8gZWl0aGVyXG4gIC8vICAgcHJlc2VydmUgdGhlIG9yaWdpbmFsIGxhYmVscyBpbiBzZXBhcmF0ZSBkaWN0cyAodGhlc2UgYXJlIG5vdFxuICAvLyAgIHJldHVybmVkIGJ1dCBtYWRlIGFuIGF0dHJpYnV0ZSBvZiB0aGUgbmV3IGdyYXBoLlxuXG4gIGlmICh0eXBlb2Ygb3B0T3JkZXJpbmcgPT09ICdib29sZWFuJykge1xuICAgIG9wdERpc2NhcmRPbGRMYWJlbHMgPSBvcHRPcmRlcmluZztcbiAgICBvcHRPcmRlcmluZyA9ICdkZWZhdWx0JztcbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIG9wdEZpcnN0TGFiZWwpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgb3B0T3JkZXJpbmcgPSBvcHRGaXJzdExhYmVsO1xuICAgICAgb3B0Rmlyc3RMYWJlbCA9IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIG9wdERpc2NhcmRPbGRMYWJlbHMgPSBvcHRGaXJzdExhYmVsO1xuICAgICAgb3B0Rmlyc3RMYWJlbCA9IDA7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBtYXBwaW5nID0gbmV3IE1hcCgpO1xuICB2YXIgbm9kZXM7XG4gIHZhciBkdlBhaXJzO1xuICB2YXIgaTtcbiAgdmFyIGo7XG4gIHZhciBsO1xuXG4gIHN3aXRjaCAob3B0T3JkZXJpbmcpIHtcbiAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgIG5vZGVzID0gRy5ub2RlcygpO1xuICAgICAgZm9yKGkgPSAwLCBqID0gb3B0Rmlyc3RMYWJlbCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKywgaisrKSB7XG4gICAgICAgIG1hcHBpbmcuc2V0KG5vZGVzW2ldLCBqKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvcnRlZCc6XG4gICAgICBub2RlcyA9IEcubm9kZXMoKTtcbiAgICAgIG5vZGVzLnNvcnQoKTtcbiAgICAgIGZvcihpID0gMCwgaiA9IG9wdEZpcnN0TGFiZWwsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyssIGorKykge1xuICAgICAgICBtYXBwaW5nLnNldChub2Rlc1tpXSwgaik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbmNyZWFzaW5nIGRlZ3JlZSc6XG4gICAgICBkdlBhaXJzID0gQXJyYXkuZnJvbShHLmRlZ3JlZUl0ZXIoKSk7XG4gICAgICBkdlBhaXJzLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKTtcbiAgICAgIGZvcihpID0gMCwgaiA9IG9wdEZpcnN0TGFiZWwsIGwgPSBkdlBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKywgaisrKSB7XG4gICAgICAgIG1hcHBpbmcuc2V0KGR2UGFpcnNbaV1bMF0sIGopO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGVjcmVhc2luZyBkZWdyZWUnOlxuICAgICAgZHZQYWlycyA9IEFycmF5LmZyb20oRy5kZWdyZWVJdGVyKCkpO1xuICAgICAgZHZQYWlycy5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSk7XG4gICAgICBmb3IoaSA9IDAsIGogPSBvcHRGaXJzdExhYmVsLCBsID0gZHZQYWlycy5sZW5ndGg7IGkgPCBsOyBpKyssIGorKykge1xuICAgICAgICBtYXBwaW5nLnNldChkdlBhaXJzW2ldWzBdLCBqKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgSlNOZXR3b3JrWEVycm9yKFxuICAgICAgICBzcHJpbnRmKCdVbmtvd24gbm9kZSBvcmRlcmluZzogXCIlc1wiJywgb3B0T3JkZXJpbmcpXG4gICAgICApO1xuICB9XG5cbiAgdmFyIEggPSByZWxhYmVsTm9kZXMoRywgbWFwcGluZyk7XG4gIEgubmFtZSA9ICcoJyArIEcubmFtZSArICcpV2l0aEludExhYmVscyc7XG4gIGlmICghb3B0RGlzY2FyZE9sZExhYmVscykge1xuICAgIEgubm9kZUxhYmVscyA9IG1hcHBpbmc7XG4gIH1cbiAgcmV0dXJuIEg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZWxhYmVsTm9kZXMsXG4gIGNvbnZlcnROb2RlTGFiZWxzVG9JbnRlZ2Vycyxcbn07XG4iLCIvKipcbiAqIENvcmUuanMgMC42LjFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzXG4gKiBMaWNlbnNlOiBodHRwOi8vcm9jay5taXQtbGljZW5zZS5vcmdcbiAqIMKpIDIwMTUgRGVuaXMgUHVzaGthcmV2XG4gKi9cbiFmdW5jdGlvbihnbG9iYWwsIGZyYW1ld29yaywgdW5kZWZpbmVkKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogY29tbW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvLyBTaG9ydGN1dHMgZm9yIFtbQ2xhc3NdXSAmIHByb3BlcnR5IG5hbWVzXHJcbnZhciBPQkpFQ1QgICAgICAgICAgPSAnT2JqZWN0J1xyXG4gICwgRlVOQ1RJT04gICAgICAgID0gJ0Z1bmN0aW9uJ1xyXG4gICwgQVJSQVkgICAgICAgICAgID0gJ0FycmF5J1xyXG4gICwgU1RSSU5HICAgICAgICAgID0gJ1N0cmluZydcclxuICAsIE5VTUJFUiAgICAgICAgICA9ICdOdW1iZXInXHJcbiAgLCBSRUdFWFAgICAgICAgICAgPSAnUmVnRXhwJ1xyXG4gICwgREFURSAgICAgICAgICAgID0gJ0RhdGUnXHJcbiAgLCBNQVAgICAgICAgICAgICAgPSAnTWFwJ1xyXG4gICwgU0VUICAgICAgICAgICAgID0gJ1NldCdcclxuICAsIFdFQUtNQVAgICAgICAgICA9ICdXZWFrTWFwJ1xyXG4gICwgV0VBS1NFVCAgICAgICAgID0gJ1dlYWtTZXQnXHJcbiAgLCBTWU1CT0wgICAgICAgICAgPSAnU3ltYm9sJ1xyXG4gICwgUFJPTUlTRSAgICAgICAgID0gJ1Byb21pc2UnXHJcbiAgLCBNQVRIICAgICAgICAgICAgPSAnTWF0aCdcclxuICAsIEFSR1VNRU5UUyAgICAgICA9ICdBcmd1bWVudHMnXHJcbiAgLCBQUk9UT1RZUEUgICAgICAgPSAncHJvdG90eXBlJ1xyXG4gICwgQ09OU1RSVUNUT1IgICAgID0gJ2NvbnN0cnVjdG9yJ1xyXG4gICwgVE9fU1RSSU5HICAgICAgID0gJ3RvU3RyaW5nJ1xyXG4gICwgVE9fU1RSSU5HX1RBRyAgID0gVE9fU1RSSU5HICsgJ1RhZydcclxuICAsIFRPX0xPQ0FMRSAgICAgICA9ICd0b0xvY2FsZVN0cmluZydcclxuICAsIEhBU19PV04gICAgICAgICA9ICdoYXNPd25Qcm9wZXJ0eSdcclxuICAsIEZPUl9FQUNIICAgICAgICA9ICdmb3JFYWNoJ1xyXG4gICwgSVRFUkFUT1IgICAgICAgID0gJ2l0ZXJhdG9yJ1xyXG4gICwgRkZfSVRFUkFUT1IgICAgID0gJ0BAJyArIElURVJBVE9SXHJcbiAgLCBQUk9DRVNTICAgICAgICAgPSAncHJvY2VzcydcclxuICAsIENSRUFURV9FTEVNRU5UICA9ICdjcmVhdGVFbGVtZW50J1xyXG4gIC8vIEFsaWFzZXMgZ2xvYmFsIG9iamVjdHMgYW5kIHByb3RvdHlwZXNcclxuICAsIEZ1bmN0aW9uICAgICAgICA9IGdsb2JhbFtGVU5DVElPTl1cclxuICAsIE9iamVjdCAgICAgICAgICA9IGdsb2JhbFtPQkpFQ1RdXHJcbiAgLCBBcnJheSAgICAgICAgICAgPSBnbG9iYWxbQVJSQVldXHJcbiAgLCBTdHJpbmcgICAgICAgICAgPSBnbG9iYWxbU1RSSU5HXVxyXG4gICwgTnVtYmVyICAgICAgICAgID0gZ2xvYmFsW05VTUJFUl1cclxuICAsIFJlZ0V4cCAgICAgICAgICA9IGdsb2JhbFtSRUdFWFBdXHJcbiAgLCBEYXRlICAgICAgICAgICAgPSBnbG9iYWxbREFURV1cclxuICAsIE1hcCAgICAgICAgICAgICA9IGdsb2JhbFtNQVBdXHJcbiAgLCBTZXQgICAgICAgICAgICAgPSBnbG9iYWxbU0VUXVxyXG4gICwgV2Vha01hcCAgICAgICAgID0gZ2xvYmFsW1dFQUtNQVBdXHJcbiAgLCBXZWFrU2V0ICAgICAgICAgPSBnbG9iYWxbV0VBS1NFVF1cclxuICAsIFN5bWJvbCAgICAgICAgICA9IGdsb2JhbFtTWU1CT0xdXHJcbiAgLCBNYXRoICAgICAgICAgICAgPSBnbG9iYWxbTUFUSF1cclxuICAsIFR5cGVFcnJvciAgICAgICA9IGdsb2JhbC5UeXBlRXJyb3JcclxuICAsIFJhbmdlRXJyb3IgICAgICA9IGdsb2JhbC5SYW5nZUVycm9yXHJcbiAgLCBzZXRUaW1lb3V0ICAgICAgPSBnbG9iYWwuc2V0VGltZW91dFxyXG4gICwgc2V0SW1tZWRpYXRlICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxyXG4gICwgY2xlYXJJbW1lZGlhdGUgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXHJcbiAgLCBwYXJzZUludCAgICAgICAgPSBnbG9iYWwucGFyc2VJbnRcclxuICAsIGlzRmluaXRlICAgICAgICA9IGdsb2JhbC5pc0Zpbml0ZVxyXG4gICwgcHJvY2VzcyAgICAgICAgID0gZ2xvYmFsW1BST0NFU1NdXHJcbiAgLCBuZXh0VGljayAgICAgICAgPSBwcm9jZXNzICYmIHByb2Nlc3MubmV4dFRpY2tcclxuICAsIGRvY3VtZW50ICAgICAgICA9IGdsb2JhbC5kb2N1bWVudFxyXG4gICwgaHRtbCAgICAgICAgICAgID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XHJcbiAgLCBuYXZpZ2F0b3IgICAgICAgPSBnbG9iYWwubmF2aWdhdG9yXHJcbiAgLCBkZWZpbmUgICAgICAgICAgPSBnbG9iYWwuZGVmaW5lXHJcbiAgLCBjb25zb2xlICAgICAgICAgPSBnbG9iYWwuY29uc29sZSB8fCB7fVxyXG4gICwgQXJyYXlQcm90byAgICAgID0gQXJyYXlbUFJPVE9UWVBFXVxyXG4gICwgT2JqZWN0UHJvdG8gICAgID0gT2JqZWN0W1BST1RPVFlQRV1cclxuICAsIEZ1bmN0aW9uUHJvdG8gICA9IEZ1bmN0aW9uW1BST1RPVFlQRV1cclxuICAsIEluZmluaXR5ICAgICAgICA9IDEgLyAwXHJcbiAgLCBET1QgICAgICAgICAgICAgPSAnLic7XHJcblxyXG4vLyBodHRwOi8vanNwZXJmLmNvbS9jb3JlLWpzLWlzb2JqZWN0XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KGl0KXtcclxuICByZXR1cm4gaXQgIT09IG51bGwgJiYgKHR5cGVvZiBpdCA9PSAnb2JqZWN0JyB8fCB0eXBlb2YgaXQgPT0gJ2Z1bmN0aW9uJyk7XHJcbn1cclxuZnVuY3Rpb24gaXNGdW5jdGlvbihpdCl7XHJcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnZnVuY3Rpb24nO1xyXG59XHJcbi8vIE5hdGl2ZSBmdW5jdGlvbj9cclxudmFyIGlzTmF0aXZlID0gY3R4KC8uLy50ZXN0LCAvXFxbbmF0aXZlIGNvZGVcXF1cXHMqXFx9XFxzKiQvLCAxKTtcclxuXHJcbi8vIE9iamVjdCBpbnRlcm5hbCBbW0NsYXNzXV0gb3IgdG9TdHJpbmdUYWdcclxuLy8gaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xyXG52YXIgdG9TdHJpbmcgPSBPYmplY3RQcm90b1tUT19TVFJJTkddO1xyXG5mdW5jdGlvbiBzZXRUb1N0cmluZ1RhZyhpdCwgdGFnLCBzdGF0KXtcclxuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXRbUFJPVE9UWVBFXSwgU1lNQk9MX1RBRykpaGlkZGVuKGl0LCBTWU1CT0xfVEFHLCB0YWcpO1xyXG59XHJcbmZ1bmN0aW9uIGNvZihpdCl7XHJcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcclxufVxyXG5mdW5jdGlvbiBjbGFzc29mKGl0KXtcclxuICB2YXIgTywgVDtcclxuICByZXR1cm4gaXQgPT0gdW5kZWZpbmVkID8gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogJ051bGwnXHJcbiAgICA6IHR5cGVvZiAoVCA9IChPID0gT2JqZWN0KGl0KSlbU1lNQk9MX1RBR10pID09ICdzdHJpbmcnID8gVCA6IGNvZihPKTtcclxufVxyXG5cclxuLy8gRnVuY3Rpb25cclxudmFyIGNhbGwgID0gRnVuY3Rpb25Qcm90by5jYWxsXHJcbiAgLCBhcHBseSA9IEZ1bmN0aW9uUHJvdG8uYXBwbHlcclxuICAsIFJFRkVSRU5DRV9HRVQ7XHJcbi8vIFBhcnRpYWwgYXBwbHlcclxuZnVuY3Rpb24gcGFydCgvKiAuLi5hcmdzICovKXtcclxuICB2YXIgZm4gICAgID0gYXNzZXJ0RnVuY3Rpb24odGhpcylcclxuICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgLCBhcmdzICAgPSBBcnJheShsZW5ndGgpXHJcbiAgICAsIGkgICAgICA9IDBcclxuICAgICwgXyAgICAgID0gcGF0aC5fXHJcbiAgICAsIGhvbGRlciA9IGZhbHNlO1xyXG4gIHdoaWxlKGxlbmd0aCA+IGkpaWYoKGFyZ3NbaV0gPSBhcmd1bWVudHNbaSsrXSkgPT09IF8paG9sZGVyID0gdHJ1ZTtcclxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XHJcbiAgICB2YXIgdGhhdCAgICA9IHRoaXNcclxuICAgICAgLCBfbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAsIGkgPSAwLCBqID0gMCwgX2FyZ3M7XHJcbiAgICBpZighaG9sZGVyICYmICFfbGVuZ3RoKXJldHVybiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xyXG4gICAgX2FyZ3MgPSBhcmdzLnNsaWNlKCk7XHJcbiAgICBpZihob2xkZXIpZm9yKDtsZW5ndGggPiBpOyBpKyspaWYoX2FyZ3NbaV0gPT09IF8pX2FyZ3NbaV0gPSBhcmd1bWVudHNbaisrXTtcclxuICAgIHdoaWxlKF9sZW5ndGggPiBqKV9hcmdzLnB1c2goYXJndW1lbnRzW2orK10pO1xyXG4gICAgcmV0dXJuIGludm9rZShmbiwgX2FyZ3MsIHRoYXQpO1xyXG4gIH1cclxufVxyXG4vLyBPcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcclxuZnVuY3Rpb24gY3R4KGZuLCB0aGF0LCBsZW5ndGgpe1xyXG4gIGFzc2VydEZ1bmN0aW9uKGZuKTtcclxuICBpZih+bGVuZ3RoICYmIHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XHJcbiAgc3dpdGNoKGxlbmd0aCl7XHJcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcclxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XHJcbiAgICB9XHJcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcclxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XHJcbiAgICB9XHJcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcclxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XHJcbiAgICB9XHJcbiAgfSByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XHJcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xyXG4gIH1cclxufVxyXG4vLyBGYXN0IGFwcGx5XHJcbi8vIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxyXG5mdW5jdGlvbiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpe1xyXG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcclxuICBzd2l0Y2goYXJncy5sZW5ndGggfCAwKXtcclxuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xyXG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xyXG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xyXG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xyXG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xyXG4gICAgY2FzZSA1OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xyXG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcclxufVxyXG5cclxuLy8gT2JqZWN0OlxyXG52YXIgY3JlYXRlICAgICAgICAgICA9IE9iamVjdC5jcmVhdGVcclxuICAsIGdldFByb3RvdHlwZU9mICAgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcclxuICAsIHNldFByb3RvdHlwZU9mICAgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcclxuICAsIGRlZmluZVByb3BlcnR5ICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcclxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xyXG4gICwgZ2V0T3duRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcclxuICAsIGdldEtleXMgICAgICAgICAgPSBPYmplY3Qua2V5c1xyXG4gICwgZ2V0TmFtZXMgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXHJcbiAgLCBnZXRTeW1ib2xzICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xyXG4gICwgaXNGcm96ZW4gICAgICAgICA9IE9iamVjdC5pc0Zyb3plblxyXG4gICwgaGFzICAgICAgICAgICAgICA9IGN0eChjYWxsLCBPYmplY3RQcm90b1tIQVNfT1dOXSwgMilcclxuICAvLyBEdW1teSwgZml4IGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5nIGluIGVzNSBtb2R1bGVcclxuICAsIEVTNU9iamVjdCAgICAgICAgPSBPYmplY3RcclxuICAsIERpY3Q7XHJcbmZ1bmN0aW9uIHRvT2JqZWN0KGl0KXtcclxuICByZXR1cm4gRVM1T2JqZWN0KGFzc2VydERlZmluZWQoaXQpKTtcclxufVxyXG5mdW5jdGlvbiByZXR1cm5JdChpdCl7XHJcbiAgcmV0dXJuIGl0O1xyXG59XHJcbmZ1bmN0aW9uIHJldHVyblRoaXMoKXtcclxuICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBrZXkpe1xyXG4gIGlmKGhhcyhvYmplY3QsIGtleSkpcmV0dXJuIG9iamVjdFtrZXldO1xyXG59XHJcbmZ1bmN0aW9uIG93bktleXMoaXQpe1xyXG4gIGFzc2VydE9iamVjdChpdCk7XHJcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBnZXROYW1lcyhpdCkuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGdldE5hbWVzKGl0KTtcclxufVxyXG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXHJcbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKXtcclxuICB2YXIgVCA9IE9iamVjdChhc3NlcnREZWZpbmVkKHRhcmdldCkpXHJcbiAgICAsIGwgPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAsIGkgPSAxO1xyXG4gIHdoaWxlKGwgPiBpKXtcclxuICAgIHZhciBTICAgICAgPSBFUzVPYmplY3QoYXJndW1lbnRzW2krK10pXHJcbiAgICAgICwga2V5cyAgID0gZ2V0S2V5cyhTKVxyXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAgICwgaiAgICAgID0gMFxyXG4gICAgICAsIGtleTtcclxuICAgIHdoaWxlKGxlbmd0aCA+IGopVFtrZXkgPSBrZXlzW2orK11dID0gU1trZXldO1xyXG4gIH1cclxuICByZXR1cm4gVDtcclxufVxyXG5mdW5jdGlvbiBrZXlPZihvYmplY3QsIGVsKXtcclxuICB2YXIgTyAgICAgID0gdG9PYmplY3Qob2JqZWN0KVxyXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXHJcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAsIGluZGV4ICA9IDBcclxuICAgICwga2V5O1xyXG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XHJcbn1cclxuXHJcbi8vIEFycmF5XHJcbi8vIGFycmF5KCdzdHIxLHN0cjIsc3RyMycpID0+IFsnc3RyMScsICdzdHIyJywgJ3N0cjMnXVxyXG5mdW5jdGlvbiBhcnJheShpdCl7XHJcbiAgcmV0dXJuIFN0cmluZyhpdCkuc3BsaXQoJywnKTtcclxufVxyXG52YXIgcHVzaCAgICA9IEFycmF5UHJvdG8ucHVzaFxyXG4gICwgdW5zaGlmdCA9IEFycmF5UHJvdG8udW5zaGlmdFxyXG4gICwgc2xpY2UgICA9IEFycmF5UHJvdG8uc2xpY2VcclxuICAsIHNwbGljZSAgPSBBcnJheVByb3RvLnNwbGljZVxyXG4gICwgaW5kZXhPZiA9IEFycmF5UHJvdG8uaW5kZXhPZlxyXG4gICwgZm9yRWFjaCA9IEFycmF5UHJvdG9bRk9SX0VBQ0hdO1xyXG4vKlxyXG4gKiAwIC0+IGZvckVhY2hcclxuICogMSAtPiBtYXBcclxuICogMiAtPiBmaWx0ZXJcclxuICogMyAtPiBzb21lXHJcbiAqIDQgLT4gZXZlcnlcclxuICogNSAtPiBmaW5kXHJcbiAqIDYgLT4gZmluZEluZGV4XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVBcnJheU1ldGhvZCh0eXBlKXtcclxuICB2YXIgaXNNYXAgICAgICAgPSB0eXBlID09IDFcclxuICAgICwgaXNGaWx0ZXIgICAgPSB0eXBlID09IDJcclxuICAgICwgaXNTb21lICAgICAgPSB0eXBlID09IDNcclxuICAgICwgaXNFdmVyeSAgICAgPSB0eXBlID09IDRcclxuICAgICwgaXNGaW5kSW5kZXggPSB0eXBlID09IDZcclxuICAgICwgbm9ob2xlcyAgICAgPSB0eXBlID09IDUgfHwgaXNGaW5kSW5kZXg7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XHJcbiAgICB2YXIgTyAgICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICwgdGhhdCAgID0gYXJndW1lbnRzWzFdXHJcbiAgICAgICwgc2VsZiAgID0gRVM1T2JqZWN0KE8pXHJcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXHJcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpXHJcbiAgICAgICwgaW5kZXggID0gMFxyXG4gICAgICAsIHJlc3VsdCA9IGlzTWFwID8gQXJyYXkobGVuZ3RoKSA6IGlzRmlsdGVyID8gW10gOiB1bmRlZmluZWRcclxuICAgICAgLCB2YWwsIHJlcztcclxuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYobm9ob2xlcyB8fCBpbmRleCBpbiBzZWxmKXtcclxuICAgICAgdmFsID0gc2VsZltpbmRleF07XHJcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XHJcbiAgICAgIGlmKHR5cGUpe1xyXG4gICAgICAgIGlmKGlzTWFwKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgIC8vIG1hcFxyXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaCh0eXBlKXtcclxuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXHJcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxyXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxyXG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxyXG4gICAgICAgIH0gZWxzZSBpZihpc0V2ZXJ5KXJldHVybiBmYWxzZTsgICAgICAgICAgIC8vIGV2ZXJ5XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpc0ZpbmRJbmRleCA/IC0xIDogaXNTb21lIHx8IGlzRXZlcnkgPyBpc0V2ZXJ5IDogcmVzdWx0O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBcnJheUNvbnRhaW5zKGlzQ29udGFpbnMpe1xyXG4gIHJldHVybiBmdW5jdGlvbihlbCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XHJcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhpcylcclxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcclxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGFyZ3VtZW50c1sxXSwgbGVuZ3RoKTtcclxuICAgIGlmKGlzQ29udGFpbnMgJiYgZWwgIT0gZWwpe1xyXG4gICAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKHNhbWVOYU4oT1tpbmRleF0pKXJldHVybiBpc0NvbnRhaW5zIHx8IGluZGV4O1xyXG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoaXNDb250YWlucyB8fCBpbmRleCBpbiBPKXtcclxuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBpc0NvbnRhaW5zIHx8IGluZGV4O1xyXG4gICAgfSByZXR1cm4gIWlzQ29udGFpbnMgJiYgLTE7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbmVyaWMoQSwgQil7XHJcbiAgLy8gc3RyYW5nZSBJRSBxdWlya3MgbW9kZSBidWcgLT4gdXNlIHR5cGVvZiB2cyBpc0Z1bmN0aW9uXHJcbiAgcmV0dXJuIHR5cGVvZiBBID09ICdmdW5jdGlvbicgPyBBIDogQjtcclxufVxyXG5cclxuLy8gTWF0aFxyXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxyXG4gICwgcG93ICAgID0gTWF0aC5wb3dcclxuICAsIGFicyAgICA9IE1hdGguYWJzXHJcbiAgLCBjZWlsICAgPSBNYXRoLmNlaWxcclxuICAsIGZsb29yICA9IE1hdGguZmxvb3JcclxuICAsIG1heCAgICA9IE1hdGgubWF4XHJcbiAgLCBtaW4gICAgPSBNYXRoLm1pblxyXG4gICwgcmFuZG9tID0gTWF0aC5yYW5kb21cclxuICAsIHRydW5jICA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24oaXQpe1xyXG4gICAgICByZXR1cm4gKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xyXG4gICAgfVxyXG4vLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxyXG5mdW5jdGlvbiBzYW1lTmFOKG51bWJlcil7XHJcbiAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XHJcbn1cclxuLy8gNy4xLjQgVG9JbnRlZ2VyXHJcbmZ1bmN0aW9uIHRvSW50ZWdlcihpdCl7XHJcbiAgcmV0dXJuIGlzTmFOKGl0KSA/IDAgOiB0cnVuYyhpdCk7XHJcbn1cclxuLy8gNy4xLjE1IFRvTGVuZ3RoXHJcbmZ1bmN0aW9uIHRvTGVuZ3RoKGl0KXtcclxuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIE1BWF9TQUZFX0lOVEVHRVIpIDogMDtcclxufVxyXG5mdW5jdGlvbiB0b0luZGV4KGluZGV4LCBsZW5ndGgpe1xyXG4gIHZhciBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XHJcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XHJcbn1cclxuZnVuY3Rpb24gbHoobnVtKXtcclxuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUmVwbGFjZXIocmVnRXhwLCByZXBsYWNlLCBpc1N0YXRpYyl7XHJcbiAgdmFyIHJlcGxhY2VyID0gaXNPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcclxuICAgIHJldHVybiByZXBsYWNlW3BhcnRdO1xyXG4gIH0gOiByZXBsYWNlO1xyXG4gIHJldHVybiBmdW5jdGlvbihpdCl7XHJcbiAgICByZXR1cm4gU3RyaW5nKGlzU3RhdGljID8gaXQgOiB0aGlzKS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZXIpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQb2ludEF0KHRvU3RyaW5nKXtcclxuICByZXR1cm4gZnVuY3Rpb24ocG9zKXtcclxuICAgIHZhciBzID0gU3RyaW5nKGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXHJcbiAgICAgICwgbCA9IHMubGVuZ3RoXHJcbiAgICAgICwgYSwgYjtcclxuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gdG9TdHJpbmcgPyAnJyA6IHVuZGVmaW5lZDtcclxuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XHJcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxyXG4gICAgICA/IHRvU3RyaW5nID8gcy5jaGFyQXQoaSkgOiBhXHJcbiAgICAgIDogdG9TdHJpbmcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBBc3NlcnRpb24gJiBlcnJvcnNcclxudmFyIFJFRFVDRV9FUlJPUiA9ICdSZWR1Y2Ugb2YgZW1wdHkgb2JqZWN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZzEsIG1zZzIpe1xyXG4gIGlmKCFjb25kaXRpb24pdGhyb3cgVHlwZUVycm9yKG1zZzIgPyBtc2cxICsgbXNnMiA6IG1zZzEpO1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydERlZmluZWQoaXQpe1xyXG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0Z1bmN0aW9uIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xyXG4gIHJldHVybiBpdDtcclxufVxyXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbihpdCl7XHJcbiAgYXNzZXJ0KGlzRnVuY3Rpb24oaXQpLCBpdCwgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcclxuICByZXR1cm4gaXQ7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KGl0KXtcclxuICBhc3NlcnQoaXNPYmplY3QoaXQpLCBpdCwgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xyXG4gIHJldHVybiBpdDtcclxufVxyXG5mdW5jdGlvbiBhc3NlcnRJbnN0YW5jZShpdCwgQ29uc3RydWN0b3IsIG5hbWUpe1xyXG4gIGFzc2VydChpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCBuYW1lLCBcIjogdXNlIHRoZSAnbmV3JyBvcGVyYXRvciFcIik7XHJcbn1cclxuXHJcbi8vIFByb3BlcnR5IGRlc2NyaXB0b3JzICYgU3ltYm9sXHJcbmZ1bmN0aW9uIGRlc2NyaXB0b3IoYml0bWFwLCB2YWx1ZSl7XHJcbiAgcmV0dXJuIHtcclxuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcclxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcclxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcclxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2ltcGxlU2V0KG9iamVjdCwga2V5LCB2YWx1ZSl7XHJcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcclxuICByZXR1cm4gb2JqZWN0O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZURlZmluZXIoYml0bWFwKXtcclxuICByZXR1cm4gREVTQyA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XHJcbiAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIGRlc2NyaXB0b3IoYml0bWFwLCB2YWx1ZSkpO1xyXG4gIH0gOiBzaW1wbGVTZXQ7XHJcbn1cclxuZnVuY3Rpb24gdWlkKGtleSl7XHJcbiAgcmV0dXJuIFNZTUJPTCArICcoJyArIGtleSArICcpXycgKyAoKytzaWQgKyByYW5kb20oKSlbVE9fU1RSSU5HXSgzNik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2VsbEtub3duU3ltYm9sKG5hbWUsIHNldHRlcil7XHJcbiAgcmV0dXJuIChTeW1ib2wgJiYgU3ltYm9sW25hbWVdKSB8fCAoc2V0dGVyID8gU3ltYm9sIDogc2FmZVN5bWJvbCkoU1lNQk9MICsgRE9UICsgbmFtZSk7XHJcbn1cclxuLy8gVGhlIGVuZ2luZSB3b3JrcyBmaW5lIHdpdGggZGVzY3JpcHRvcnM/IFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHkuXHJcbnZhciBERVNDID0gISFmdW5jdGlvbigpe1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gMiB9fSkuYSA9PSAyO1xyXG4gICAgICB9IGNhdGNoKGUpe31cclxuICAgIH0oKVxyXG4gICwgc2lkICAgID0gMFxyXG4gICwgaGlkZGVuID0gY3JlYXRlRGVmaW5lcigxKVxyXG4gICwgc2V0ICAgID0gU3ltYm9sID8gc2ltcGxlU2V0IDogaGlkZGVuXHJcbiAgLCBzYWZlU3ltYm9sID0gU3ltYm9sIHx8IHVpZDtcclxuZnVuY3Rpb24gYXNzaWduSGlkZGVuKHRhcmdldCwgc3JjKXtcclxuICBmb3IodmFyIGtleSBpbiBzcmMpaGlkZGVuKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XHJcbiAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxudmFyIFNZTUJPTF9VTlNDT1BBQkxFUyA9IGdldFdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKVxyXG4gICwgQXJyYXlVbnNjb3BhYmxlcyAgID0gQXJyYXlQcm90b1tTWU1CT0xfVU5TQ09QQUJMRVNdIHx8IHt9XHJcbiAgLCBTWU1CT0xfVEFHICAgICAgICAgPSBnZXRXZWxsS25vd25TeW1ib2woVE9fU1RSSU5HX1RBRylcclxuICAsIFNZTUJPTF9TUEVDSUVTICAgICA9IGdldFdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpXHJcbiAgLCBTWU1CT0xfSVRFUkFUT1I7XHJcbmZ1bmN0aW9uIHNldFNwZWNpZXMoQyl7XHJcbiAgaWYoREVTQyAmJiAoZnJhbWV3b3JrIHx8ICFpc05hdGl2ZShDKSkpZGVmaW5lUHJvcGVydHkoQywgU1lNQk9MX1NQRUNJRVMsIHtcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogcmV0dXJuVGhpc1xyXG4gIH0pO1xyXG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvbW1vbi5leHBvcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBOT0RFID0gY29mKHByb2Nlc3MpID09IFBST0NFU1NcclxuICAsIGNvcmUgPSB7fVxyXG4gICwgcGF0aCA9IGZyYW1ld29yayA/IGdsb2JhbCA6IGNvcmVcclxuICAsIG9sZCAgPSBnbG9iYWwuY29yZVxyXG4gICwgZXhwb3J0R2xvYmFsXHJcbiAgLy8gdHlwZSBiaXRtYXBcclxuICAsIEZPUkNFRCA9IDFcclxuICAsIEdMT0JBTCA9IDJcclxuICAsIFNUQVRJQyA9IDRcclxuICAsIFBST1RPICA9IDhcclxuICAsIEJJTkQgICA9IDE2XHJcbiAgLCBXUkFQICAgPSAzMjtcclxuZnVuY3Rpb24gJGRlZmluZSh0eXBlLCBuYW1lLCBzb3VyY2Upe1xyXG4gIHZhciBrZXksIG93biwgb3V0LCBleHBcclxuICAgICwgaXNHbG9iYWwgPSB0eXBlICYgR0xPQkFMXHJcbiAgICAsIHRhcmdldCAgID0gaXNHbG9iYWwgPyBnbG9iYWwgOiAodHlwZSAmIFNUQVRJQylcclxuICAgICAgICA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwgT2JqZWN0UHJvdG8pW1BST1RPVFlQRV1cclxuICAgICwgZXhwb3J0cyAgPSBpc0dsb2JhbCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xyXG4gIGlmKGlzR2xvYmFsKXNvdXJjZSA9IG5hbWU7XHJcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xyXG4gICAgLy8gdGhlcmUgaXMgYSBzaW1pbGFyIG5hdGl2ZVxyXG4gICAgb3duID0gISh0eXBlICYgRk9SQ0VEKSAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldFxyXG4gICAgICAmJiAoIWlzRnVuY3Rpb24odGFyZ2V0W2tleV0pIHx8IGlzTmF0aXZlKHRhcmdldFtrZXldKSk7XHJcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxyXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcclxuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xyXG4gICAgaWYoIWZyYW1ld29yayAmJiBpc0dsb2JhbCAmJiAhaXNGdW5jdGlvbih0YXJnZXRba2V5XSkpZXhwID0gc291cmNlW2tleV07XHJcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxyXG4gICAgZWxzZSBpZih0eXBlICYgQklORCAmJiBvd24pZXhwID0gY3R4KG91dCwgZ2xvYmFsKTtcclxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XHJcbiAgICBlbHNlIGlmKHR5cGUgJiBXUkFQICYmICFmcmFtZXdvcmsgJiYgdGFyZ2V0W2tleV0gPT0gb3V0KXtcclxuICAgICAgZXhwID0gZnVuY3Rpb24ocGFyYW0pe1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2Ygb3V0ID8gbmV3IG91dChwYXJhbSkgOiBvdXQocGFyYW0pO1xyXG4gICAgICB9XHJcbiAgICAgIGV4cFtQUk9UT1RZUEVdID0gb3V0W1BST1RPVFlQRV07XHJcbiAgICB9IGVsc2UgZXhwID0gdHlwZSAmIFBST1RPICYmIGlzRnVuY3Rpb24ob3V0KSA/IGN0eChjYWxsLCBvdXQpIDogb3V0O1xyXG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxyXG4gICAgaWYoZnJhbWV3b3JrICYmIHRhcmdldCAmJiAhb3duKXtcclxuICAgICAgaWYoaXNHbG9iYWwpdGFyZ2V0W2tleV0gPSBvdXQ7XHJcbiAgICAgIGVsc2UgZGVsZXRlIHRhcmdldFtrZXldICYmIGhpZGRlbih0YXJnZXQsIGtleSwgb3V0KTtcclxuICAgIH1cclxuICAgIC8vIGV4cG9ydFxyXG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCloaWRkZW4oZXhwb3J0cywga2V5LCBleHApO1xyXG4gIH1cclxufVxyXG4vLyBDb21tb25KUyBleHBvcnRcclxuaWYodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyltb2R1bGUuZXhwb3J0cyA9IGNvcmU7XHJcbi8vIFJlcXVpcmVKUyBleHBvcnRcclxuZWxzZSBpZihpc0Z1bmN0aW9uKGRlZmluZSkgJiYgZGVmaW5lLmFtZClkZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gY29yZX0pO1xyXG4vLyBFeHBvcnQgdG8gZ2xvYmFsIG9iamVjdFxyXG5lbHNlIGV4cG9ydEdsb2JhbCA9IHRydWU7XHJcbmlmKGV4cG9ydEdsb2JhbCB8fCBmcmFtZXdvcmspe1xyXG4gIGNvcmUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCl7XHJcbiAgICBnbG9iYWwuY29yZSA9IG9sZDtcclxuICAgIHJldHVybiBjb3JlO1xyXG4gIH1cclxuICBnbG9iYWwuY29yZSA9IGNvcmU7XHJcbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogY29tbW9uLml0ZXJhdG9ycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuU1lNQk9MX0lURVJBVE9SID0gZ2V0V2VsbEtub3duU3ltYm9sKElURVJBVE9SKTtcclxudmFyIElURVIgID0gc2FmZVN5bWJvbCgnaXRlcicpXHJcbiAgLCBLRVkgICA9IDFcclxuICAsIFZBTFVFID0gMlxyXG4gICwgSXRlcmF0b3JzID0ge31cclxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge31cclxuICAgIC8vIFNhZmFyaSBoYXMgYnlnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcclxuICAsIEJVR0dZX0lURVJBVE9SUyA9ICdrZXlzJyBpbiBBcnJheVByb3RvICYmICEoJ25leHQnIGluIFtdLmtleXMoKSk7XHJcbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXHJcbnNldEl0ZXJhdG9yKEl0ZXJhdG9yUHJvdG90eXBlLCByZXR1cm5UaGlzKTtcclxuZnVuY3Rpb24gc2V0SXRlcmF0b3IoTywgdmFsdWUpe1xyXG4gIGhpZGRlbihPLCBTWU1CT0xfSVRFUkFUT1IsIHZhbHVlKTtcclxuICAvLyBBZGQgaXRlcmF0b3IgZm9yIEZGIGl0ZXJhdG9yIHByb3RvY29sXHJcbiAgRkZfSVRFUkFUT1IgaW4gQXJyYXlQcm90byAmJiBoaWRkZW4oTywgRkZfSVRFUkFUT1IsIHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvcihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCwgcHJvdG8pe1xyXG4gIENvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBjcmVhdGUocHJvdG8gfHwgSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XHJcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3IoQ29uc3RydWN0b3IsIE5BTUUsIHZhbHVlLCBERUZBVUxUKXtcclxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3RvcltQUk9UT1RZUEVdXHJcbiAgICAsIGl0ZXIgID0gZ2V0KHByb3RvLCBTWU1CT0xfSVRFUkFUT1IpIHx8IGdldChwcm90bywgRkZfSVRFUkFUT1IpIHx8IChERUZBVUxUICYmIGdldChwcm90bywgREVGQVVMVCkpIHx8IHZhbHVlO1xyXG4gIGlmKGZyYW1ld29yayl7XHJcbiAgICAvLyBEZWZpbmUgaXRlcmF0b3JcclxuICAgIHNldEl0ZXJhdG9yKHByb3RvLCBpdGVyKTtcclxuICAgIGlmKGl0ZXIgIT09IHZhbHVlKXtcclxuICAgICAgdmFyIGl0ZXJQcm90byA9IGdldFByb3RvdHlwZU9mKGl0ZXIuY2FsbChuZXcgQ29uc3RydWN0b3IpKTtcclxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xyXG4gICAgICBzZXRUb1N0cmluZ1RhZyhpdGVyUHJvdG8sIE5BTUUgKyAnIEl0ZXJhdG9yJywgdHJ1ZSk7XHJcbiAgICAgIC8vIEZGIGZpeFxyXG4gICAgICBoYXMocHJvdG8sIEZGX0lURVJBVE9SKSAmJiBzZXRJdGVyYXRvcihpdGVyUHJvdG8sIHJldHVyblRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XHJcbiAgSXRlcmF0b3JzW05BTUVdID0gaXRlcjtcclxuICAvLyBGRiAmIHY4IGZpeFxyXG4gIEl0ZXJhdG9yc1tOQU1FICsgJyBJdGVyYXRvciddID0gcmV0dXJuVGhpcztcclxuICByZXR1cm4gaXRlcjtcclxufVxyXG5mdW5jdGlvbiBkZWZpbmVTdGRJdGVyYXRvcnMoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCl7XHJcbiAgZnVuY3Rpb24gY3JlYXRlSXRlcihraW5kKXtcclxuICAgIHJldHVybiBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpO1xyXG4gICAgfVxyXG4gIH1cclxuICBjcmVhdGVJdGVyYXRvcihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XHJcbiAgdmFyIGVudHJpZXMgPSBjcmVhdGVJdGVyKEtFWStWQUxVRSlcclxuICAgICwgdmFsdWVzICA9IGNyZWF0ZUl0ZXIoVkFMVUUpO1xyXG4gIGlmKERFRkFVTFQgPT0gVkFMVUUpdmFsdWVzID0gZGVmaW5lSXRlcmF0b3IoQmFzZSwgTkFNRSwgdmFsdWVzLCAndmFsdWVzJyk7XHJcbiAgZWxzZSBlbnRyaWVzID0gZGVmaW5lSXRlcmF0b3IoQmFzZSwgTkFNRSwgZW50cmllcywgJ2VudHJpZXMnKTtcclxuICBpZihERUZBVUxUKXtcclxuICAgICRkZWZpbmUoUFJPVE8gKyBGT1JDRUQgKiBCVUdHWV9JVEVSQVRPUlMsIE5BTUUsIHtcclxuICAgICAgZW50cmllczogZW50cmllcyxcclxuICAgICAga2V5czogSVNfU0VUID8gdmFsdWVzIDogY3JlYXRlSXRlcihLRVkpLFxyXG4gICAgICB2YWx1ZXM6IHZhbHVlc1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGl0ZXJSZXN1bHQoZG9uZSwgdmFsdWUpe1xyXG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xyXG59XHJcbmZ1bmN0aW9uIGlzSXRlcmFibGUoaXQpe1xyXG4gIHZhciBPICAgICAgPSBPYmplY3QoaXQpXHJcbiAgICAsIFN5bWJvbCA9IGdsb2JhbFtTWU1CT0xdXHJcbiAgICAsIGhhc0V4dCA9IChTeW1ib2wgJiYgU3ltYm9sW0lURVJBVE9SXSB8fCBGRl9JVEVSQVRPUikgaW4gTztcclxuICByZXR1cm4gaGFzRXh0IHx8IFNZTUJPTF9JVEVSQVRPUiBpbiBPIHx8IGhhcyhJdGVyYXRvcnMsIGNsYXNzb2YoTykpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0KXtcclxuICB2YXIgU3ltYm9sICA9IGdsb2JhbFtTWU1CT0xdXHJcbiAgICAsIGV4dCAgICAgPSBpdFtTeW1ib2wgJiYgU3ltYm9sW0lURVJBVE9SXSB8fCBGRl9JVEVSQVRPUl1cclxuICAgICwgZ2V0SXRlciA9IGV4dCB8fCBpdFtTWU1CT0xfSVRFUkFUT1JdIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XHJcbiAgcmV0dXJuIGFzc2VydE9iamVjdChnZXRJdGVyLmNhbGwoaXQpKTtcclxufVxyXG5mdW5jdGlvbiBzdGVwQ2FsbChmbiwgdmFsdWUsIGVudHJpZXMpe1xyXG4gIHJldHVybiBlbnRyaWVzID8gaW52b2tlKGZuLCB2YWx1ZSkgOiBmbih2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tEYW5nZXJJdGVyQ2xvc2luZyhmbil7XHJcbiAgdmFyIGRhbmdlciA9IHRydWU7XHJcbiAgdmFyIE8gPSB7XHJcbiAgICBuZXh0OiBmdW5jdGlvbigpeyB0aHJvdyAxIH0sXHJcbiAgICAncmV0dXJuJzogZnVuY3Rpb24oKXsgZGFuZ2VyID0gZmFsc2UgfVxyXG4gIH07XHJcbiAgT1tTWU1CT0xfSVRFUkFUT1JdID0gcmV0dXJuVGhpcztcclxuICB0cnkge1xyXG4gICAgZm4oTyk7XHJcbiAgfSBjYXRjaChlKXt9XHJcbiAgcmV0dXJuIGRhbmdlcjtcclxufVxyXG5mdW5jdGlvbiBjbG9zZUl0ZXJhdG9yKGl0ZXJhdG9yKXtcclxuICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xyXG4gIGlmKHJldCAhPT0gdW5kZWZpbmVkKXJldC5jYWxsKGl0ZXJhdG9yKTtcclxufVxyXG5mdW5jdGlvbiBzYWZlSXRlckNsb3NlKGV4ZWMsIGl0ZXJhdG9yKXtcclxuICB0cnkge1xyXG4gICAgZXhlYyhpdGVyYXRvcik7XHJcbiAgfSBjYXRjaChlKXtcclxuICAgIGNsb3NlSXRlcmF0b3IoaXRlcmF0b3IpO1xyXG4gICAgdGhyb3cgZTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZm9yT2YoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0KXtcclxuICBzYWZlSXRlckNsb3NlKGZ1bmN0aW9uKGl0ZXJhdG9yKXtcclxuICAgIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXHJcbiAgICAgICwgc3RlcDtcclxuICAgIHdoaWxlKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSlpZihzdGVwQ2FsbChmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKSA9PT0gZmFsc2Upe1xyXG4gICAgICByZXR1cm4gY2xvc2VJdGVyYXRvcihpdGVyYXRvcik7XHJcbiAgICB9XHJcbiAgfSwgZ2V0SXRlcmF0b3IoaXRlcmFibGUpKTtcclxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuc3ltYm9sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXHJcbiFmdW5jdGlvbihUQUcsIFN5bWJvbFJlZ2lzdHJ5LCBBbGxTeW1ib2xzLCBzZXR0ZXIpe1xyXG4gIC8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxyXG4gIGlmKCFpc05hdGl2ZShTeW1ib2wpKXtcclxuICAgIFN5bWJvbCA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKXtcclxuICAgICAgYXNzZXJ0KCEodGhpcyBpbnN0YW5jZW9mIFN5bWJvbCksIFNZTUJPTCArICcgaXMgbm90IGEgJyArIENPTlNUUlVDVE9SKTtcclxuICAgICAgdmFyIHRhZyA9IHVpZChkZXNjcmlwdGlvbilcclxuICAgICAgICAsIHN5bSA9IHNldChjcmVhdGUoU3ltYm9sW1BST1RPVFlQRV0pLCBUQUcsIHRhZyk7XHJcbiAgICAgIEFsbFN5bWJvbHNbdGFnXSA9IHN5bTtcclxuICAgICAgREVTQyAmJiBzZXR0ZXIgJiYgZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG8sIHRhZywge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICAgIGhpZGRlbih0aGlzLCB0YWcsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gc3ltO1xyXG4gICAgfVxyXG4gICAgaGlkZGVuKFN5bWJvbFtQUk9UT1RZUEVdLCBUT19TVFJJTkcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiB0aGlzW1RBR107XHJcbiAgICB9KTtcclxuICB9XHJcbiAgJGRlZmluZShHTE9CQUwgKyBXUkFQLCB7U3ltYm9sOiBTeW1ib2x9KTtcclxuICBcclxuICB2YXIgc3ltYm9sU3RhdGljcyA9IHtcclxuICAgIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxyXG4gICAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcclxuICAgICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cclxuICAgICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSBTeW1ib2woa2V5KTtcclxuICAgIH0sXHJcbiAgICAvLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3JcclxuICAgIGl0ZXJhdG9yOiBTWU1CT0xfSVRFUkFUT1IgfHwgZ2V0V2VsbEtub3duU3ltYm9sKElURVJBVE9SKSxcclxuICAgIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxyXG4gICAga2V5Rm9yOiBwYXJ0LmNhbGwoa2V5T2YsIFN5bWJvbFJlZ2lzdHJ5KSxcclxuICAgIC8vIDE5LjQuMi4xMCBTeW1ib2wuc3BlY2llc1xyXG4gICAgc3BlY2llczogU1lNQk9MX1NQRUNJRVMsXHJcbiAgICAvLyAxOS40LjIuMTMgU3ltYm9sLnRvU3RyaW5nVGFnXHJcbiAgICB0b1N0cmluZ1RhZzogU1lNQk9MX1RBRyA9IGdldFdlbGxLbm93blN5bWJvbChUT19TVFJJTkdfVEFHLCB0cnVlKSxcclxuICAgIC8vIDE5LjQuMi4xNCBTeW1ib2wudW5zY29wYWJsZXNcclxuICAgIHVuc2NvcGFibGVzOiBTWU1CT0xfVU5TQ09QQUJMRVMsXHJcbiAgICBwdXJlOiBzYWZlU3ltYm9sLFxyXG4gICAgc2V0OiBzZXQsXHJcbiAgICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7c2V0dGVyID0gdHJ1ZX0sXHJcbiAgICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7c2V0dGVyID0gZmFsc2V9XHJcbiAgfTtcclxuICAvLyAxOS40LjIuMiBTeW1ib2wuaGFzSW5zdGFuY2VcclxuICAvLyAxOS40LjIuMyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXHJcbiAgLy8gMTkuNC4yLjYgU3ltYm9sLm1hdGNoXHJcbiAgLy8gMTkuNC4yLjggU3ltYm9sLnJlcGxhY2VcclxuICAvLyAxOS40LjIuOSBTeW1ib2wuc2VhcmNoXHJcbiAgLy8gMTkuNC4yLjExIFN5bWJvbC5zcGxpdFxyXG4gIC8vIDE5LjQuMi4xMiBTeW1ib2wudG9QcmltaXRpdmVcclxuICBmb3JFYWNoLmNhbGwoYXJyYXkoJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGxpdCx0b1ByaW1pdGl2ZScpLFxyXG4gICAgZnVuY3Rpb24oaXQpe1xyXG4gICAgICBzeW1ib2xTdGF0aWNzW2l0XSA9IGdldFdlbGxLbm93blN5bWJvbChpdCk7XHJcbiAgICB9XHJcbiAgKTtcclxuICAkZGVmaW5lKFNUQVRJQywgU1lNQk9MLCBzeW1ib2xTdGF0aWNzKTtcclxuICBcclxuICBzZXRUb1N0cmluZ1RhZyhTeW1ib2wsIFNZTUJPTCk7XHJcbiAgXHJcbiAgJGRlZmluZShTVEFUSUMgKyBGT1JDRUQgKiAhaXNOYXRpdmUoU3ltYm9sKSwgT0JKRUNULCB7XHJcbiAgICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxyXG4gICAgZ2V0T3duUHJvcGVydHlOYW1lczogZnVuY3Rpb24oaXQpe1xyXG4gICAgICB2YXIgbmFtZXMgPSBnZXROYW1lcyh0b09iamVjdChpdCkpLCByZXN1bHQgPSBbXSwga2V5LCBpID0gMDtcclxuICAgICAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSloYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbiAgICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXHJcbiAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgdmFyIG5hbWVzID0gZ2V0TmFtZXModG9PYmplY3QoaXQpKSwgcmVzdWx0ID0gW10sIGtleSwgaSA9IDA7XHJcbiAgICAgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxyXG4gIHNldFRvU3RyaW5nVGFnKE1hdGgsIE1BVEgsIHRydWUpO1xyXG4gIC8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXHJcbiAgc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XHJcbn0oc2FmZVN5bWJvbCgndGFnJyksIHt9LCB7fSwgdHJ1ZSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5vYmplY3Quc3RhdGljcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbigpe1xyXG4gIHZhciBvYmplY3RTdGF0aWMgPSB7XHJcbiAgICAvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxyXG4gICAgYXNzaWduOiBhc3NpZ24sXHJcbiAgICAvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxyXG4gICAgaXM6IGZ1bmN0aW9uKHgsIHkpe1xyXG4gICAgICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcclxuICAgIH1cclxuICB9O1xyXG4gIC8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXHJcbiAgLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmtzIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxyXG4gICdfX3Byb3RvX18nIGluIE9iamVjdFByb3RvICYmIGZ1bmN0aW9uKGJ1Z2d5LCBzZXQpe1xyXG4gICAgdHJ5IHtcclxuICAgICAgc2V0ID0gY3R4KGNhbGwsIGdldE93bkRlc2NyaXB0b3IoT2JqZWN0UHJvdG8sICdfX3Byb3RvX18nKS5zZXQsIDIpO1xyXG4gICAgICBzZXQoe30sIEFycmF5UHJvdG8pO1xyXG4gICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlIH1cclxuICAgIG9iamVjdFN0YXRpYy5zZXRQcm90b3R5cGVPZiA9IHNldFByb3RvdHlwZU9mID0gc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTywgcHJvdG8pe1xyXG4gICAgICBhc3NlcnRPYmplY3QoTyk7XHJcbiAgICAgIGFzc2VydChwcm90byA9PT0gbnVsbCB8fCBpc09iamVjdChwcm90byksIHByb3RvLCBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XHJcbiAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XHJcbiAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcclxuICAgICAgcmV0dXJuIE87XHJcbiAgICB9XHJcbiAgfSgpO1xyXG4gICRkZWZpbmUoU1RBVElDLCBPQkpFQ1QsIG9iamVjdFN0YXRpYyk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lm9iamVjdC5zdGF0aWNzLWFjY2VwdC1wcmltaXRpdmVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKCl7XHJcbiAgLy8gT2JqZWN0IHN0YXRpYyBtZXRob2RzIGFjY2VwdCBwcmltaXRpdmVzXHJcbiAgZnVuY3Rpb24gd3JhcE9iamVjdE1ldGhvZChrZXksIE1PREUpe1xyXG4gICAgdmFyIGZuICA9IE9iamVjdFtrZXldXHJcbiAgICAgICwgZXhwID0gY29yZVtPQkpFQ1RdW2tleV1cclxuICAgICAgLCBmICAgPSAwXHJcbiAgICAgICwgbyAgID0ge307XHJcbiAgICBpZighZXhwIHx8IGlzTmF0aXZlKGV4cCkpe1xyXG4gICAgICBvW2tleV0gPSBNT0RFID09IDEgPyBmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IGl0O1xyXG4gICAgICB9IDogTU9ERSA9PSAyID8gZnVuY3Rpb24oaXQpe1xyXG4gICAgICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiB0cnVlO1xyXG4gICAgICB9IDogTU9ERSA9PSAzID8gZnVuY3Rpb24oaXQpe1xyXG4gICAgICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiBmYWxzZTtcclxuICAgICAgfSA6IE1PREUgPT0gNCA/IGZ1bmN0aW9uKGl0LCBrZXkpe1xyXG4gICAgICAgIHJldHVybiBmbih0b09iamVjdChpdCksIGtleSk7XHJcbiAgICAgIH0gOiBmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgcmV0dXJuIGZuKHRvT2JqZWN0KGl0KSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRyeSB7IGZuKERPVCkgfVxyXG4gICAgICBjYXRjaChlKXsgZiA9IDEgfVxyXG4gICAgICAkZGVmaW5lKFNUQVRJQyArIEZPUkNFRCAqIGYsIE9CSkVDVCwgbyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2ZyZWV6ZScsIDEpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ3NlYWwnLCAxKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdwcmV2ZW50RXh0ZW5zaW9ucycsIDEpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2lzRnJvemVuJywgMik7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnaXNTZWFsZWQnLCAyKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdpc0V4dGVuc2libGUnLCAzKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCA0KTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdnZXRQcm90b3R5cGVPZicpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2tleXMnKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJyk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lm51bWJlci5zdGF0aWNzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKGlzSW50ZWdlcil7XHJcbiAgJGRlZmluZShTVEFUSUMsIE5VTUJFUiwge1xyXG4gICAgLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cclxuICAgIEVQU0lMT046IHBvdygyLCAtNTIpLFxyXG4gICAgLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcclxuICAgIGlzRmluaXRlOiBmdW5jdGlvbihpdCl7XHJcbiAgICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgaXNGaW5pdGUoaXQpO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxyXG4gICAgaXNJbnRlZ2VyOiBpc0ludGVnZXIsXHJcbiAgICAvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxyXG4gICAgaXNOYU46IHNhbWVOYU4sXHJcbiAgICAvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXHJcbiAgICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbihudW1iZXIpe1xyXG4gICAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gTUFYX1NBRkVfSU5URUdFUjtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxyXG4gICAgTUFYX1NBRkVfSU5URUdFUjogTUFYX1NBRkVfSU5URUdFUixcclxuICAgIC8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxyXG4gICAgTUlOX1NBRkVfSU5URUdFUjogLU1BWF9TQUZFX0lOVEVHRVIsXHJcbiAgICAvLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxyXG4gICAgcGFyc2VGbG9hdDogcGFyc2VGbG9hdCxcclxuICAgIC8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcclxuICAgIHBhcnNlSW50OiBwYXJzZUludFxyXG4gIH0pO1xyXG4vLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcclxufShOdW1iZXIuaXNJbnRlZ2VyIHx8IGZ1bmN0aW9uKGl0KXtcclxuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcclxufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5tYXRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEVDTUFTY3JpcHQgNiBzaGltXHJcbiFmdW5jdGlvbigpe1xyXG4gIC8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcclxuICB2YXIgRSAgICA9IE1hdGguRVxyXG4gICAgLCBleHAgID0gTWF0aC5leHBcclxuICAgICwgbG9nICA9IE1hdGgubG9nXHJcbiAgICAsIHNxcnQgPSBNYXRoLnNxcnRcclxuICAgICwgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KXtcclxuICAgICAgICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XHJcbiAgICAgIH07XHJcbiAgXHJcbiAgLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxyXG4gIGZ1bmN0aW9uIGFzaW5oKHgpe1xyXG4gICAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBsb2coeCArIHNxcnQoeCAqIHggKyAxKSk7XHJcbiAgfVxyXG4gIC8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXHJcbiAgZnVuY3Rpb24gZXhwbTEoeCl7XHJcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogZXhwKHgpIC0gMTtcclxuICB9XHJcbiAgICBcclxuICAkZGVmaW5lKFNUQVRJQywgTUFUSCwge1xyXG4gICAgLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxyXG4gICAgYWNvc2g6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogaXNGaW5pdGUoeCkgPyBsb2coeCAvIEUgKyBzcXJ0KHggKyAxKSAqIHNxcnQoeCAtIDEpIC8gRSkgKyAxIDogeDtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXHJcbiAgICBhc2luaDogYXNpbmgsXHJcbiAgICAvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXHJcbiAgICBhdGFuaDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IGxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxyXG4gICAgY2JydDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiBzaWduKHggPSAreCkgKiBwb3coYWJzKHgpLCAxIC8gMyk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcclxuICAgIGNsejMyOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMiAtIHhbVE9fU1RSSU5HXSgyKS5sZW5ndGggOiAzMjtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXHJcbiAgICBjb3NoOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxyXG4gICAgZXhwbTE6IGV4cG0xLFxyXG4gICAgLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXHJcbiAgICAvLyBUT0RPOiBmYWxsYmFjayBmb3IgSUU5LVxyXG4gICAgZnJvdW5kOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW3hdKVswXTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcclxuICAgIGh5cG90OiBmdW5jdGlvbih2YWx1ZTEsIHZhbHVlMil7XHJcbiAgICAgIHZhciBzdW0gID0gMFxyXG4gICAgICAgICwgbGVuMSA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgICAsIGxlbjIgPSBsZW4xXHJcbiAgICAgICAgLCBhcmdzID0gQXJyYXkobGVuMSlcclxuICAgICAgICAsIGxhcmcgPSAtSW5maW5pdHlcclxuICAgICAgICAsIGFyZztcclxuICAgICAgd2hpbGUobGVuMS0tKXtcclxuICAgICAgICBhcmcgPSBhcmdzW2xlbjFdID0gK2FyZ3VtZW50c1tsZW4xXTtcclxuICAgICAgICBpZihhcmcgPT0gSW5maW5pdHkgfHwgYXJnID09IC1JbmZpbml0eSlyZXR1cm4gSW5maW5pdHk7XHJcbiAgICAgICAgaWYoYXJnID4gbGFyZylsYXJnID0gYXJnO1xyXG4gICAgICB9XHJcbiAgICAgIGxhcmcgPSBhcmcgfHwgMTtcclxuICAgICAgd2hpbGUobGVuMi0tKXN1bSArPSBwb3coYXJnc1tsZW4yXSAvIGxhcmcsIDIpO1xyXG4gICAgICByZXR1cm4gbGFyZyAqIHNxcnQoc3VtKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXHJcbiAgICBpbXVsOiBmdW5jdGlvbih4LCB5KXtcclxuICAgICAgdmFyIFVJbnQxNiA9IDB4ZmZmZlxyXG4gICAgICAgICwgeG4gPSAreFxyXG4gICAgICAgICwgeW4gPSAreVxyXG4gICAgICAgICwgeGwgPSBVSW50MTYgJiB4blxyXG4gICAgICAgICwgeWwgPSBVSW50MTYgJiB5bjtcclxuICAgICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSW50MTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSW50MTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxyXG4gICAgbG9nMXA6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBsb2coMSArIHgpO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXHJcbiAgICBsb2cxMDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiBsb2coeCkgLyBNYXRoLkxOMTA7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxyXG4gICAgbG9nMjogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiBsb2coeCkgLyBNYXRoLkxOMjtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXHJcbiAgICBzaWduOiBzaWduLFxyXG4gICAgLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxyXG4gICAgc2luaDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiAoYWJzKHggPSAreCkgPCAxKSA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyIDogKGV4cCh4IC0gMSkgLSBleHAoLXggLSAxKSkgKiAoRSAvIDIpO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcclxuICAgIHRhbmg6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICB2YXIgYSA9IGV4cG0xKHggPSAreClcclxuICAgICAgICAsIGIgPSBleHBtMSgteCk7XHJcbiAgICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcclxuICAgIHRydW5jOiB0cnVuY1xyXG4gIH0pO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5zdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbihmcm9tQ2hhckNvZGUpe1xyXG4gIGZ1bmN0aW9uIGFzc2VydE5vdFJlZ0V4cChpdCl7XHJcbiAgICBpZihjb2YoaXQpID09IFJFR0VYUCl0aHJvdyBUeXBlRXJyb3IoKTtcclxuICB9XHJcbiAgXHJcbiAgJGRlZmluZShTVEFUSUMsIFNUUklORywge1xyXG4gICAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcclxuICAgIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICB2YXIgcmVzID0gW11cclxuICAgICAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgICAsIGkgICA9IDBcclxuICAgICAgICAsIGNvZGVcclxuICAgICAgd2hpbGUobGVuID4gaSl7XHJcbiAgICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcclxuICAgICAgICBpZih0b0luZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSl0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcclxuICAgICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxyXG4gICAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcclxuICAgICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcclxuICAgICAgICApO1xyXG4gICAgICB9IHJldHVybiByZXMuam9pbignJyk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcclxuICAgIHJhdzogZnVuY3Rpb24oY2FsbFNpdGUpe1xyXG4gICAgICB2YXIgcmF3ID0gdG9PYmplY3QoY2FsbFNpdGUucmF3KVxyXG4gICAgICAgICwgbGVuID0gdG9MZW5ndGgocmF3Lmxlbmd0aClcclxuICAgICAgICAsIHNsbiA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgICAsIHJlcyA9IFtdXHJcbiAgICAgICAgLCBpICAgPSAwO1xyXG4gICAgICB3aGlsZShsZW4gPiBpKXtcclxuICAgICAgICByZXMucHVzaChTdHJpbmcocmF3W2krK10pKTtcclxuICAgICAgICBpZihpIDwgc2xuKXJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcclxuICAgICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gICRkZWZpbmUoUFJPVE8sIFNUUklORywge1xyXG4gICAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXHJcbiAgICBjb2RlUG9pbnRBdDogY3JlYXRlUG9pbnRBdChmYWxzZSksXHJcbiAgICAvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXHJcbiAgICBlbmRzV2l0aDogZnVuY3Rpb24oc2VhcmNoU3RyaW5nIC8qLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pe1xyXG4gICAgICBhc3NlcnROb3RSZWdFeHAoc2VhcmNoU3RyaW5nKTtcclxuICAgICAgdmFyIHRoYXQgPSBTdHJpbmcoYXNzZXJ0RGVmaW5lZCh0aGlzKSlcclxuICAgICAgICAsIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzWzFdXHJcbiAgICAgICAgLCBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aClcclxuICAgICAgICAsIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBtaW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pO1xyXG4gICAgICBzZWFyY2hTdHJpbmcgKz0gJyc7XHJcbiAgICAgIHJldHVybiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaFN0cmluZy5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaFN0cmluZztcclxuICAgIH0sXHJcbiAgICAvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxyXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uKHNlYXJjaFN0cmluZyAvKiwgcG9zaXRpb24gPSAwICovKXtcclxuICAgICAgYXNzZXJ0Tm90UmVnRXhwKHNlYXJjaFN0cmluZyk7XHJcbiAgICAgIHJldHVybiAhIX5TdHJpbmcoYXNzZXJ0RGVmaW5lZCh0aGlzKSkuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50c1sxXSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxyXG4gICAgcmVwZWF0OiBmdW5jdGlvbihjb3VudCl7XHJcbiAgICAgIHZhciBzdHIgPSBTdHJpbmcoYXNzZXJ0RGVmaW5lZCh0aGlzKSlcclxuICAgICAgICAsIHJlcyA9ICcnXHJcbiAgICAgICAgLCBuICAgPSB0b0ludGVnZXIoY291bnQpO1xyXG4gICAgICBpZigwID4gbiB8fCBuID09IEluZmluaXR5KXRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcclxuICAgICAgZm9yKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpaWYobiAmIDEpcmVzICs9IHN0cjtcclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0sXHJcbiAgICAvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxyXG4gICAgc3RhcnRzV2l0aDogZnVuY3Rpb24oc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xyXG4gICAgICBhc3NlcnROb3RSZWdFeHAoc2VhcmNoU3RyaW5nKTtcclxuICAgICAgdmFyIHRoYXQgID0gU3RyaW5nKGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICAgLCBpbmRleCA9IHRvTGVuZ3RoKG1pbihhcmd1bWVudHNbMV0sIHRoYXQubGVuZ3RoKSk7XHJcbiAgICAgIHNlYXJjaFN0cmluZyArPSAnJztcclxuICAgICAgcmV0dXJuIHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcclxuICAgIH1cclxuICB9KTtcclxufShTdHJpbmcuZnJvbUNoYXJDb2RlKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LmFycmF5LnN0YXRpY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKCl7XHJcbiAgJGRlZmluZShTVEFUSUMgKyBGT1JDRUQgKiBjaGVja0Rhbmdlckl0ZXJDbG9zaW5nKEFycmF5LmZyb20pLCBBUlJBWSwge1xyXG4gICAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxyXG4gICAgZnJvbTogZnVuY3Rpb24oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xyXG4gICAgICB2YXIgTyAgICAgICA9IE9iamVjdChhc3NlcnREZWZpbmVkKGFycmF5TGlrZSkpXHJcbiAgICAgICAgLCBtYXBmbiAgID0gYXJndW1lbnRzWzFdXHJcbiAgICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICwgZiAgICAgICA9IG1hcHBpbmcgPyBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMikgOiB1bmRlZmluZWRcclxuICAgICAgICAsIGluZGV4ICAgPSAwXHJcbiAgICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcDtcclxuICAgICAgaWYoaXNJdGVyYWJsZShPKSl7XHJcbiAgICAgICAgcmVzdWx0ID0gbmV3IChnZW5lcmljKHRoaXMsIEFycmF5KSk7XHJcbiAgICAgICAgc2FmZUl0ZXJDbG9zZShmdW5jdGlvbihpdGVyYXRvcil7XHJcbiAgICAgICAgICBmb3IoOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xyXG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IGYoc3RlcC52YWx1ZSwgaW5kZXgpIDogc3RlcC52YWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCBnZXRJdGVyYXRvcihPKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gbmV3IChnZW5lcmljKHRoaXMsIEFycmF5KSkobGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpKTtcclxuICAgICAgICBmb3IoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XHJcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IGYoT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgJGRlZmluZShTVEFUSUMsIEFSUkFZLCB7XHJcbiAgICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXHJcbiAgICBvZjogZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XHJcbiAgICAgIHZhciBpbmRleCAgPSAwXHJcbiAgICAgICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAgICAgLCByZXN1bHQgPSBuZXcgKGdlbmVyaWModGhpcywgQXJyYXkpKShsZW5ndGgpO1xyXG4gICAgICB3aGlsZShsZW5ndGggPiBpbmRleClyZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xyXG4gICAgICByZXN1bHQubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIHNldFNwZWNpZXMoQXJyYXkpO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5hcnJheS5wcm90b3R5cGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbigpe1xyXG4gICRkZWZpbmUoUFJPVE8sIEFSUkFZLCB7XHJcbiAgICAvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcclxuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uKHRhcmdldCAvKiA9IDAgKi8sIHN0YXJ0IC8qID0gMCwgZW5kID0gQGxlbmd0aCAqLyl7XHJcbiAgICAgIHZhciBPICAgICA9IE9iamVjdChhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAgICwgbGVuICAgPSB0b0xlbmd0aChPLmxlbmd0aClcclxuICAgICAgICAsIHRvICAgID0gdG9JbmRleCh0YXJnZXQsIGxlbilcclxuICAgICAgICAsIGZyb20gID0gdG9JbmRleChzdGFydCwgbGVuKVxyXG4gICAgICAgICwgZW5kICAgPSBhcmd1bWVudHNbMl1cclxuICAgICAgICAsIGZpbiAgID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0luZGV4KGVuZCwgbGVuKVxyXG4gICAgICAgICwgY291bnQgPSBtaW4oZmluIC0gZnJvbSwgbGVuIC0gdG8pXHJcbiAgICAgICAgLCBpbmMgICA9IDE7XHJcbiAgICAgIGlmKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCl7XHJcbiAgICAgICAgaW5jICA9IC0xO1xyXG4gICAgICAgIGZyb20gPSBmcm9tICsgY291bnQgLSAxO1xyXG4gICAgICAgIHRvICAgPSB0byArIGNvdW50IC0gMTtcclxuICAgICAgfVxyXG4gICAgICB3aGlsZShjb3VudC0tID4gMCl7XHJcbiAgICAgICAgaWYoZnJvbSBpbiBPKU9bdG9dID0gT1tmcm9tXTtcclxuICAgICAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcclxuICAgICAgICB0byArPSBpbmM7XHJcbiAgICAgICAgZnJvbSArPSBpbmM7XHJcbiAgICAgIH0gcmV0dXJuIE87XHJcbiAgICB9LFxyXG4gICAgLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXHJcbiAgICBmaWxsOiBmdW5jdGlvbih2YWx1ZSAvKiwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcclxuICAgICAgdmFyIE8gICAgICA9IE9iamVjdChhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXHJcbiAgICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGFyZ3VtZW50c1sxXSwgbGVuZ3RoKVxyXG4gICAgICAgICwgZW5kICAgID0gYXJndW1lbnRzWzJdXHJcbiAgICAgICAgLCBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW5kZXgoZW5kLCBsZW5ndGgpO1xyXG4gICAgICB3aGlsZShlbmRQb3MgPiBpbmRleClPW2luZGV4KytdID0gdmFsdWU7XHJcbiAgICAgIHJldHVybiBPO1xyXG4gICAgfSxcclxuICAgIC8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcclxuICAgIGZpbmQ6IGNyZWF0ZUFycmF5TWV0aG9kKDUpLFxyXG4gICAgLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXHJcbiAgICBmaW5kSW5kZXg6IGNyZWF0ZUFycmF5TWV0aG9kKDYpXHJcbiAgfSk7XHJcbiAgXHJcbiAgaWYoZnJhbWV3b3JrKXtcclxuICAgIC8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cclxuICAgIGZvckVhY2guY2FsbChhcnJheSgnZmluZCxmaW5kSW5kZXgsZmlsbCxjb3B5V2l0aGluLGVudHJpZXMsa2V5cyx2YWx1ZXMnKSwgZnVuY3Rpb24oaXQpe1xyXG4gICAgICBBcnJheVVuc2NvcGFibGVzW2l0XSA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIFNZTUJPTF9VTlNDT1BBQkxFUyBpbiBBcnJheVByb3RvIHx8IGhpZGRlbihBcnJheVByb3RvLCBTWU1CT0xfVU5TQ09QQUJMRVMsIEFycmF5VW5zY29wYWJsZXMpO1xyXG4gIH1cclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuaXRlcmF0b3JzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oYXQpe1xyXG4gIC8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcclxuICAvLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxyXG4gIC8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcclxuICAvLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcclxuICBkZWZpbmVTdGRJdGVyYXRvcnMoQXJyYXksIEFSUkFZLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XHJcbiAgICBzZXQodGhpcywgSVRFUiwge286IHRvT2JqZWN0KGl0ZXJhdGVkKSwgaTogMCwgazoga2luZH0pO1xyXG4gIC8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxyXG4gIH0sIGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgaXRlciAgPSB0aGlzW0lURVJdXHJcbiAgICAgICwgTyAgICAgPSBpdGVyLm9cclxuICAgICAgLCBraW5kICA9IGl0ZXIua1xyXG4gICAgICAsIGluZGV4ID0gaXRlci5pKys7XHJcbiAgICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XHJcbiAgICAgIGl0ZXIubyA9IHVuZGVmaW5lZDtcclxuICAgICAgcmV0dXJuIGl0ZXJSZXN1bHQoMSk7XHJcbiAgICB9XHJcbiAgICBpZihraW5kID09IEtFWSkgIHJldHVybiBpdGVyUmVzdWx0KDAsIGluZGV4KTtcclxuICAgIGlmKGtpbmQgPT0gVkFMVUUpcmV0dXJuIGl0ZXJSZXN1bHQoMCwgT1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlclJlc3VsdCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XHJcbiAgfSwgVkFMVUUpO1xyXG4gIFxyXG4gIC8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcclxuICBJdGVyYXRvcnNbQVJHVU1FTlRTXSA9IEl0ZXJhdG9yc1tBUlJBWV07XHJcbiAgXHJcbiAgLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxyXG4gIGRlZmluZVN0ZEl0ZXJhdG9ycyhTdHJpbmcsIFNUUklORywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xyXG4gICAgc2V0KHRoaXMsIElURVIsIHtvOiBTdHJpbmcoaXRlcmF0ZWQpLCBpOiAwfSk7XHJcbiAgLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxyXG4gIH0sIGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgaXRlciAgPSB0aGlzW0lURVJdXHJcbiAgICAgICwgTyAgICAgPSBpdGVyLm9cclxuICAgICAgLCBpbmRleCA9IGl0ZXIuaVxyXG4gICAgICAsIHBvaW50O1xyXG4gICAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIGl0ZXJSZXN1bHQoMSk7XHJcbiAgICBwb2ludCA9IGF0LmNhbGwoTywgaW5kZXgpO1xyXG4gICAgaXRlci5pICs9IHBvaW50Lmxlbmd0aDtcclxuICAgIHJldHVybiBpdGVyUmVzdWx0KDAsIHBvaW50KTtcclxuICB9KTtcclxufShjcmVhdGVQb2ludEF0KHRydWUpKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogd2ViLmltbWVkaWF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gc2V0SW1tZWRpYXRlIHNoaW1cclxuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgZWxzZTpcclxuaXNGdW5jdGlvbihzZXRJbW1lZGlhdGUpICYmIGlzRnVuY3Rpb24oY2xlYXJJbW1lZGlhdGUpIHx8IGZ1bmN0aW9uKE9OUkVBRFlTVEFURUNIQU5HRSl7XHJcbiAgdmFyIHBvc3RNZXNzYWdlICAgICAgPSBnbG9iYWwucG9zdE1lc3NhZ2VcclxuICAgICwgYWRkRXZlbnRMaXN0ZW5lciA9IGdsb2JhbC5hZGRFdmVudExpc3RlbmVyXHJcbiAgICAsIE1lc3NhZ2VDaGFubmVsICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcclxuICAgICwgY291bnRlciAgICAgICAgICA9IDBcclxuICAgICwgcXVldWUgICAgICAgICAgICA9IHt9XHJcbiAgICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xyXG4gIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGZuKXtcclxuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xyXG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcclxuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xyXG4gICAgICBpbnZva2UoaXNGdW5jdGlvbihmbikgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBkZWZlcihjb3VudGVyKTtcclxuICAgIHJldHVybiBjb3VudGVyO1xyXG4gIH1cclxuICBjbGVhckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGlkKXtcclxuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJ1bihpZCl7XHJcbiAgICBpZihoYXMocXVldWUsIGlkKSl7XHJcbiAgICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcclxuICAgICAgZGVsZXRlIHF1ZXVlW2lkXTtcclxuICAgICAgZm4oKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gbGlzdG5lcihldmVudCl7XHJcbiAgICBydW4oZXZlbnQuZGF0YSk7XHJcbiAgfVxyXG4gIC8vIE5vZGUuanMgMC44LVxyXG4gIGlmKE5PREUpe1xyXG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XHJcbiAgICAgIG5leHRUaWNrKHBhcnQuY2FsbChydW4sIGlkKSk7XHJcbiAgICB9XHJcbiAgLy8gTW9kZXJuIGJyb3dzZXJzLCBza2lwIGltcGxlbWVudGF0aW9uIGZvciBXZWJXb3JrZXJzXHJcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgb2JqZWN0XHJcbiAgfSBlbHNlIGlmKGFkZEV2ZW50TGlzdGVuZXIgJiYgaXNGdW5jdGlvbihwb3N0TWVzc2FnZSkgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcclxuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xyXG4gICAgICBwb3N0TWVzc2FnZShpZCwgJyonKTtcclxuICAgIH1cclxuICAgIGFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0bmVyLCBmYWxzZSk7XHJcbiAgLy8gV2ViV29ya2Vyc1xyXG4gIH0gZWxzZSBpZihpc0Z1bmN0aW9uKE1lc3NhZ2VDaGFubmVsKSl7XHJcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xyXG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XHJcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RuZXI7XHJcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcclxuICAvLyBJRTgtXHJcbiAgfSBlbHNlIGlmKGRvY3VtZW50ICYmIE9OUkVBRFlTVEFURUNIQU5HRSBpbiBkb2N1bWVudFtDUkVBVEVfRUxFTUVOVF0oJ3NjcmlwdCcpKXtcclxuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xyXG4gICAgICBodG1sLmFwcGVuZENoaWxkKGRvY3VtZW50W0NSRUFURV9FTEVNRU5UXSgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgcnVuKGlkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXHJcbiAgfSBlbHNlIHtcclxuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xyXG4gICAgICBzZXRUaW1lb3V0KHJ1biwgMCwgaWQpO1xyXG4gICAgfVxyXG4gIH1cclxufSgnb25yZWFkeXN0YXRlY2hhbmdlJyk7XHJcbiRkZWZpbmUoR0xPQkFMICsgQklORCwge1xyXG4gIHNldEltbWVkaWF0ZTogICBzZXRJbW1lZGlhdGUsXHJcbiAgY2xlYXJJbW1lZGlhdGU6IGNsZWFySW1tZWRpYXRlXHJcbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYucHJvbWlzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBFUzYgcHJvbWlzZXMgc2hpbVxyXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZ2V0aWZ5L25hdGl2ZS1wcm9taXNlLW9ubHkvXHJcbiFmdW5jdGlvbihQcm9taXNlLCB0ZXN0KXtcclxuICBpc0Z1bmN0aW9uKFByb21pc2UpICYmIGlzRnVuY3Rpb24oUHJvbWlzZS5yZXNvbHZlKVxyXG4gICYmIFByb21pc2UucmVzb2x2ZSh0ZXN0ID0gbmV3IFByb21pc2UoZnVuY3Rpb24oKXt9KSkgPT0gdGVzdFxyXG4gIHx8IGZ1bmN0aW9uKGFzYXAsIFJFQ09SRCl7XHJcbiAgICBmdW5jdGlvbiBpc1RoZW5hYmxlKGl0KXtcclxuICAgICAgdmFyIHRoZW47XHJcbiAgICAgIGlmKGlzT2JqZWN0KGl0KSl0aGVuID0gaXQudGhlbjtcclxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odGhlbikgPyB0aGVuIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVkUmVqZWN0aW9uT3JIYXNPblJlamVjdGVkKHByb21pc2Upe1xyXG4gICAgICB2YXIgcmVjb3JkID0gcHJvbWlzZVtSRUNPUkRdXHJcbiAgICAgICAgLCBjaGFpbiAgPSByZWNvcmQuY1xyXG4gICAgICAgICwgaSAgICAgID0gMFxyXG4gICAgICAgICwgcmVhY3Q7XHJcbiAgICAgIGlmKHJlY29yZC5oKXJldHVybiB0cnVlO1xyXG4gICAgICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcclxuICAgICAgICByZWFjdCA9IGNoYWluW2krK107XHJcbiAgICAgICAgaWYocmVhY3QuZmFpbCB8fCBoYW5kbGVkUmVqZWN0aW9uT3JIYXNPblJlamVjdGVkKHJlYWN0LlApKXJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBub3RpZnkocmVjb3JkLCByZWplY3Qpe1xyXG4gICAgICB2YXIgY2hhaW4gPSByZWNvcmQuYztcclxuICAgICAgaWYocmVqZWN0IHx8IGNoYWluLmxlbmd0aClhc2FwKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSByZWNvcmQucFxyXG4gICAgICAgICAgLCB2YWx1ZSAgID0gcmVjb3JkLnZcclxuICAgICAgICAgICwgb2sgICAgICA9IHJlY29yZC5zID09IDFcclxuICAgICAgICAgICwgaSAgICAgICA9IDA7XHJcbiAgICAgICAgaWYocmVqZWN0ICYmICFoYW5kbGVkUmVqZWN0aW9uT3JIYXNPblJlamVjdGVkKHByb21pc2UpKXtcclxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYoIWhhbmRsZWRSZWplY3Rpb25Pckhhc09uUmVqZWN0ZWQocHJvbWlzZSkpe1xyXG4gICAgICAgICAgICAgIGlmKE5PREUpe1xyXG4gICAgICAgICAgICAgICAgaWYoIXByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpKXtcclxuICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBub2RlLmpzIGJlaGF2aW9yXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKGlzRnVuY3Rpb24oY29uc29sZS5lcnJvcikpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSwgMWUzKTtcclxuICAgICAgICB9IGVsc2Ugd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSkhZnVuY3Rpb24ocmVhY3Qpe1xyXG4gICAgICAgICAgdmFyIGNiID0gb2sgPyByZWFjdC5vayA6IHJlYWN0LmZhaWxcclxuICAgICAgICAgICAgLCByZXQsIHRoZW47XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZihjYil7XHJcbiAgICAgICAgICAgICAgaWYoIW9rKXJlY29yZC5oID0gdHJ1ZTtcclxuICAgICAgICAgICAgICByZXQgPSBjYiA9PT0gdHJ1ZSA/IHZhbHVlIDogY2IodmFsdWUpO1xyXG4gICAgICAgICAgICAgIGlmKHJldCA9PT0gcmVhY3QuUCl7XHJcbiAgICAgICAgICAgICAgICByZWFjdC5yZWooVHlwZUVycm9yKFBST01JU0UgKyAnLWNoYWluIGN5Y2xlJykpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZih0aGVuID0gaXNUaGVuYWJsZShyZXQpKXtcclxuICAgICAgICAgICAgICAgIHRoZW4uY2FsbChyZXQsIHJlYWN0LnJlcywgcmVhY3QucmVqKTtcclxuICAgICAgICAgICAgICB9IGVsc2UgcmVhY3QucmVzKHJldCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSByZWFjdC5yZWoodmFsdWUpO1xyXG4gICAgICAgICAgfSBjYXRjaChlcnIpe1xyXG4gICAgICAgICAgICByZWFjdC5yZWooZXJyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KGNoYWluW2krK10pO1xyXG4gICAgICAgIGNoYWluLmxlbmd0aCA9IDA7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSl7XHJcbiAgICAgIHZhciByZWNvcmQgPSB0aGlzXHJcbiAgICAgICAgLCB0aGVuLCB3cmFwcGVyO1xyXG4gICAgICBpZihyZWNvcmQuZClyZXR1cm47XHJcbiAgICAgIHJlY29yZC5kID0gdHJ1ZTtcclxuICAgICAgcmVjb3JkID0gcmVjb3JkLnIgfHwgcmVjb3JkOyAvLyB1bndyYXBcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xyXG4gICAgICAgICAgd3JhcHBlciA9IHtyOiByZWNvcmQsIGQ6IGZhbHNlfTsgLy8gd3JhcFxyXG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgocmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eChyZWplY3QsIHdyYXBwZXIsIDEpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVjb3JkLnYgPSB2YWx1ZTtcclxuICAgICAgICAgIHJlY29yZC5zID0gMTtcclxuICAgICAgICAgIG5vdGlmeShyZWNvcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaChlcnIpe1xyXG4gICAgICAgIHJlamVjdC5jYWxsKHdyYXBwZXIgfHwge3I6IHJlY29yZCwgZDogZmFsc2V9LCBlcnIpOyAvLyB3cmFwXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSl7XHJcbiAgICAgIHZhciByZWNvcmQgPSB0aGlzO1xyXG4gICAgICBpZihyZWNvcmQuZClyZXR1cm47XHJcbiAgICAgIHJlY29yZC5kID0gdHJ1ZTtcclxuICAgICAgcmVjb3JkID0gcmVjb3JkLnIgfHwgcmVjb3JkOyAvLyB1bndyYXBcclxuICAgICAgcmVjb3JkLnYgPSB2YWx1ZTtcclxuICAgICAgcmVjb3JkLnMgPSAyO1xyXG4gICAgICBub3RpZnkocmVjb3JkLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldENvbnN0cnVjdG9yKEMpe1xyXG4gICAgICB2YXIgUyA9IGFzc2VydE9iamVjdChDKVtTWU1CT0xfU1BFQ0lFU107XHJcbiAgICAgIHJldHVybiBTICE9IHVuZGVmaW5lZCA/IFMgOiBDO1xyXG4gICAgfVxyXG4gICAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcclxuICAgIFByb21pc2UgPSBmdW5jdGlvbihleGVjdXRvcil7XHJcbiAgICAgIGFzc2VydEZ1bmN0aW9uKGV4ZWN1dG9yKTtcclxuICAgICAgYXNzZXJ0SW5zdGFuY2UodGhpcywgUHJvbWlzZSwgUFJPTUlTRSk7XHJcbiAgICAgIHZhciByZWNvcmQgPSB7XHJcbiAgICAgICAgcDogdGhpcywgICAgICAvLyBwcm9taXNlXHJcbiAgICAgICAgYzogW10sICAgICAgICAvLyBjaGFpblxyXG4gICAgICAgIHM6IDAsICAgICAgICAgLy8gc3RhdGVcclxuICAgICAgICBkOiBmYWxzZSwgICAgIC8vIGRvbmVcclxuICAgICAgICB2OiB1bmRlZmluZWQsIC8vIHZhbHVlXHJcbiAgICAgICAgaDogZmFsc2UgICAgICAvLyBoYW5kbGVkIHJlamVjdGlvblxyXG4gICAgICB9O1xyXG4gICAgICBoaWRkZW4odGhpcywgUkVDT1JELCByZWNvcmQpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGV4ZWN1dG9yKGN0eChyZXNvbHZlLCByZWNvcmQsIDEpLCBjdHgocmVqZWN0LCByZWNvcmQsIDEpKTtcclxuICAgICAgfSBjYXRjaChlcnIpe1xyXG4gICAgICAgIHJlamVjdC5jYWxsKHJlY29yZCwgZXJyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXNzaWduSGlkZGVuKFByb21pc2VbUFJPVE9UWVBFXSwge1xyXG4gICAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxyXG4gICAgICB0aGVuOiBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XHJcbiAgICAgICAgdmFyIFMgPSBhc3NlcnRPYmplY3QoYXNzZXJ0T2JqZWN0KHRoaXMpW0NPTlNUUlVDVE9SXSlbU1lNQk9MX1NQRUNJRVNdO1xyXG4gICAgICAgIHZhciByZWFjdCA9IHtcclxuICAgICAgICAgIG9rOiAgIGlzRnVuY3Rpb24ob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiB0cnVlLFxyXG4gICAgICAgICAgZmFpbDogaXNGdW5jdGlvbihvblJlamVjdGVkKSAgPyBvblJlamVjdGVkICA6IGZhbHNlXHJcbiAgICAgICAgfSAsIFAgPSByZWFjdC5QID0gbmV3IChTICE9IHVuZGVmaW5lZCA/IFMgOiBQcm9taXNlKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xyXG4gICAgICAgICAgcmVhY3QucmVzID0gYXNzZXJ0RnVuY3Rpb24ocmVzb2x2ZSk7XHJcbiAgICAgICAgICByZWFjdC5yZWogPSBhc3NlcnRGdW5jdGlvbihyZWplY3QpO1xyXG4gICAgICAgIH0pLCByZWNvcmQgPSB0aGlzW1JFQ09SRF07XHJcbiAgICAgICAgcmVjb3JkLmMucHVzaChyZWFjdCk7XHJcbiAgICAgICAgcmVjb3JkLnMgJiYgbm90aWZ5KHJlY29yZCk7XHJcbiAgICAgICAgcmV0dXJuIFA7XHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXHJcbiAgICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBhc3NpZ25IaWRkZW4oUHJvbWlzZSwge1xyXG4gICAgICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcclxuICAgICAgYWxsOiBmdW5jdGlvbihpdGVyYWJsZSl7XHJcbiAgICAgICAgdmFyIFByb21pc2UgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKVxyXG4gICAgICAgICAgLCB2YWx1ZXMgID0gW107XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XHJcbiAgICAgICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIHB1c2gsIHZhbHVlcyk7XHJcbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gdmFsdWVzLmxlbmd0aFxyXG4gICAgICAgICAgICAsIHJlc3VsdHMgICA9IEFycmF5KHJlbWFpbmluZyk7XHJcbiAgICAgICAgICBpZihyZW1haW5pbmcpZm9yRWFjaC5jYWxsKHZhbHVlcywgZnVuY3Rpb24ocHJvbWlzZSwgaW5kZXgpe1xyXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBlbHNlIHJlc29sdmUocmVzdWx0cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcclxuICAgICAgcmFjZTogZnVuY3Rpb24oaXRlcmFibGUpe1xyXG4gICAgICAgIHZhciBQcm9taXNlID0gZ2V0Q29uc3RydWN0b3IodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XHJcbiAgICAgICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xyXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUocHJvbWlzZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXHJcbiAgICAgIHJlamVjdDogZnVuY3Rpb24ocil7XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoZ2V0Q29uc3RydWN0b3IodGhpcykpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XHJcbiAgICAgICAgICByZWplY3Qocik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxyXG4gICAgICByZXNvbHZlOiBmdW5jdGlvbih4KXtcclxuICAgICAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgUkVDT1JEIGluIHggJiYgZ2V0UHJvdG90eXBlT2YoeCkgPT09IHRoaXNbUFJPVE9UWVBFXVxyXG4gICAgICAgICAgPyB4IDogbmV3IChnZXRDb25zdHJ1Y3Rvcih0aGlzKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcclxuICAgICAgICAgICAgcmVzb2x2ZSh4KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KG5leHRUaWNrIHx8IHNldEltbWVkaWF0ZSwgc2FmZVN5bWJvbCgncmVjb3JkJykpO1xyXG4gIHNldFRvU3RyaW5nVGFnKFByb21pc2UsIFBST01JU0UpO1xyXG4gIHNldFNwZWNpZXMoUHJvbWlzZSk7XHJcbiAgJGRlZmluZShHTE9CQUwgKyBGT1JDRUQgKiAhaXNOYXRpdmUoUHJvbWlzZSksIHtQcm9taXNlOiBQcm9taXNlfSk7XHJcbn0oZ2xvYmFsW1BST01JU0VdKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LmNvbGxlY3Rpb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gRUNNQVNjcmlwdCA2IGNvbGxlY3Rpb25zIHNoaW1cclxuIWZ1bmN0aW9uKCl7XHJcbiAgdmFyIFVJRCAgID0gc2FmZVN5bWJvbCgndWlkJylcclxuICAgICwgTzEgICAgPSBzYWZlU3ltYm9sKCdPMScpXHJcbiAgICAsIFdFQUsgID0gc2FmZVN5bWJvbCgnd2VhaycpXHJcbiAgICAsIExFQUsgID0gc2FmZVN5bWJvbCgnbGVhaycpXHJcbiAgICAsIExBU1QgID0gc2FmZVN5bWJvbCgnbGFzdCcpXHJcbiAgICAsIEZJUlNUID0gc2FmZVN5bWJvbCgnZmlyc3QnKVxyXG4gICAgLCBTSVpFICA9IERFU0MgPyBzYWZlU3ltYm9sKCdzaXplJykgOiAnc2l6ZSdcclxuICAgICwgdWlkICAgPSAwXHJcbiAgICAsIHRtcCAgID0ge307XHJcbiAgXHJcbiAgZnVuY3Rpb24gZ2V0Q29sbGVjdGlvbihDLCBOQU1FLCBtZXRob2RzLCBjb21tb25NZXRob2RzLCBpc01hcCwgaXNXZWFrKXtcclxuICAgIHZhciBBRERFUiA9IGlzTWFwID8gJ3NldCcgOiAnYWRkJ1xyXG4gICAgICAsIHByb3RvID0gQyAmJiBDW1BST1RPVFlQRV1cclxuICAgICAgLCBPICAgICA9IHt9O1xyXG4gICAgZnVuY3Rpb24gaW5pdEZyb21JdGVyYWJsZSh0aGF0LCBpdGVyYWJsZSl7XHJcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgaXNNYXAsIHRoYXRbQURERVJdLCB0aGF0KTtcclxuICAgICAgcmV0dXJuIHRoYXQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaXhTVlooa2V5LCBjaGFpbil7XHJcbiAgICAgIHZhciBtZXRob2QgPSBwcm90b1trZXldO1xyXG4gICAgICBpZihmcmFtZXdvcmspcHJvdG9ba2V5XSA9IGZ1bmN0aW9uKGEsIGIpe1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBtZXRob2QuY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpO1xyXG4gICAgICAgIHJldHVybiBjaGFpbiA/IHRoaXMgOiByZXN1bHQ7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZighaXNOYXRpdmUoQykgfHwgIShpc1dlYWsgfHwgKCFCVUdHWV9JVEVSQVRPUlMgJiYgaGFzKHByb3RvLCBGT1JfRUFDSCkgJiYgaGFzKHByb3RvLCAnZW50cmllcycpKSkpe1xyXG4gICAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxyXG4gICAgICBDID0gaXNXZWFrXHJcbiAgICAgICAgPyBmdW5jdGlvbihpdGVyYWJsZSl7XHJcbiAgICAgICAgICAgIGFzc2VydEluc3RhbmNlKHRoaXMsIEMsIE5BTUUpO1xyXG4gICAgICAgICAgICBzZXQodGhpcywgVUlELCB1aWQrKyk7XHJcbiAgICAgICAgICAgIGluaXRGcm9tSXRlcmFibGUodGhpcywgaXRlcmFibGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIDogZnVuY3Rpb24oaXRlcmFibGUpe1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIGFzc2VydEluc3RhbmNlKHRoYXQsIEMsIE5BTUUpO1xyXG4gICAgICAgICAgICBzZXQodGhhdCwgTzEsIGNyZWF0ZShudWxsKSk7XHJcbiAgICAgICAgICAgIHNldCh0aGF0LCBTSVpFLCAwKTtcclxuICAgICAgICAgICAgc2V0KHRoYXQsIExBU1QsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHNldCh0aGF0LCBGSVJTVCwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgaW5pdEZyb21JdGVyYWJsZSh0aGF0LCBpdGVyYWJsZSk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICBhc3NpZ25IaWRkZW4oYXNzaWduSGlkZGVuKENbUFJPVE9UWVBFXSwgbWV0aG9kcyksIGNvbW1vbk1ldGhvZHMpO1xyXG4gICAgICBpc1dlYWsgfHwgIURFU0MgfHwgZGVmaW5lUHJvcGVydHkoQ1tQUk9UT1RZUEVdLCAnc2l6ZScsIHtnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIGFzc2VydERlZmluZWQodGhpc1tTSVpFXSk7XHJcbiAgICAgIH19KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBOYXRpdmUgPSBDXHJcbiAgICAgICAgLCBpbnN0ICAgPSBuZXcgQ1xyXG4gICAgICAgICwgY2hhaW4gID0gaW5zdFtBRERFUl0oaXNXZWFrID8ge30gOiAtMCwgMSlcclxuICAgICAgICAsIGJ1Z2d5WmVybztcclxuICAgICAgLy8gd3JhcCB0byBpbml0IGNvbGxlY3Rpb25zIGZyb20gaXRlcmFibGVcclxuICAgICAgaWYoY2hlY2tEYW5nZXJJdGVyQ2xvc2luZyhmdW5jdGlvbihPKXsgbmV3IEMoTykgfSkpe1xyXG4gICAgICAgIEMgPSBmdW5jdGlvbihpdGVyYWJsZSl7XHJcbiAgICAgICAgICBhc3NlcnRJbnN0YW5jZSh0aGlzLCBDLCBOQU1FKTtcclxuICAgICAgICAgIHJldHVybiBpbml0RnJvbUl0ZXJhYmxlKG5ldyBOYXRpdmUsIGl0ZXJhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ1tQUk9UT1RZUEVdID0gcHJvdG87XHJcbiAgICAgICAgaWYoZnJhbWV3b3JrKXByb3RvW0NPTlNUUlVDVE9SXSA9IEM7XHJcbiAgICAgIH1cclxuICAgICAgaXNXZWFrIHx8IGluc3RbRk9SX0VBQ0hdKGZ1bmN0aW9uKHZhbCwga2V5KXtcclxuICAgICAgICBidWdneVplcm8gPSAxIC8ga2V5ID09PSAtSW5maW5pdHk7XHJcbiAgICAgIH0pO1xyXG4gICAgICAvLyBmaXggY29udmVydGluZyAtMCBrZXkgdG8gKzBcclxuICAgICAgaWYoYnVnZ3laZXJvKXtcclxuICAgICAgICBmaXhTVlooJ2RlbGV0ZScpO1xyXG4gICAgICAgIGZpeFNWWignaGFzJyk7XHJcbiAgICAgICAgaXNNYXAgJiYgZml4U1ZaKCdnZXQnKTtcclxuICAgICAgfVxyXG4gICAgICAvLyArIGZpeCAuYWRkICYgLnNldCBmb3IgY2hhaW5pbmdcclxuICAgICAgaWYoYnVnZ3laZXJvIHx8IGNoYWluICE9PSBpbnN0KWZpeFNWWihBRERFUiwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcclxuICAgIHNldFNwZWNpZXMoQyk7XHJcbiAgICBcclxuICAgIE9bTkFNRV0gPSBDO1xyXG4gICAgJGRlZmluZShHTE9CQUwgKyBXUkFQICsgRk9SQ0VEICogIWlzTmF0aXZlKEMpLCBPKTtcclxuICAgIFxyXG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXHJcbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXHJcbiAgICBpc1dlYWsgfHwgZGVmaW5lU3RkSXRlcmF0b3JzKEMsIE5BTUUsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcclxuICAgICAgc2V0KHRoaXMsIElURVIsIHtvOiBpdGVyYXRlZCwgazoga2luZH0pO1xyXG4gICAgfSwgZnVuY3Rpb24oKXtcclxuICAgICAgdmFyIGl0ZXIgID0gdGhpc1tJVEVSXVxyXG4gICAgICAgICwga2luZCAgPSBpdGVyLmtcclxuICAgICAgICAsIGVudHJ5ID0gaXRlci5sO1xyXG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcclxuICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XHJcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XHJcbiAgICAgIGlmKCFpdGVyLm8gfHwgIShpdGVyLmwgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IGl0ZXIub1tGSVJTVF0pKXtcclxuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxyXG4gICAgICAgIGl0ZXIubyA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gaXRlclJlc3VsdCgxKTtcclxuICAgICAgfVxyXG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXHJcbiAgICAgIGlmKGtpbmQgPT0gS0VZKSAgcmV0dXJuIGl0ZXJSZXN1bHQoMCwgZW50cnkuayk7XHJcbiAgICAgIGlmKGtpbmQgPT0gVkFMVUUpcmV0dXJuIGl0ZXJSZXN1bHQoMCwgZW50cnkudik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJSZXN1bHQoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTsgICBcclxuICAgIH0sIGlzTWFwID8gS0VZK1ZBTFVFIDogVkFMVUUsICFpc01hcCk7XHJcbiAgICBcclxuICAgIHJldHVybiBDO1xyXG4gIH1cclxuICBcclxuICBmdW5jdGlvbiBmYXN0S2V5KGl0LCBjcmVhdGUpe1xyXG4gICAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxyXG4gICAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcclxuICAgIC8vIGNhbid0IHNldCBpZCB0byBmcm96ZW4gb2JqZWN0XHJcbiAgICBpZihpc0Zyb3plbihpdCkpcmV0dXJuICdGJztcclxuICAgIGlmKCFoYXMoaXQsIFVJRCkpe1xyXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBpZFxyXG4gICAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XHJcbiAgICAgIC8vIGFkZCBtaXNzaW5nIG9iamVjdCBpZFxyXG4gICAgICBoaWRkZW4oaXQsIFVJRCwgKyt1aWQpO1xyXG4gICAgLy8gcmV0dXJuIG9iamVjdCBpZCB3aXRoIHByZWZpeFxyXG4gICAgfSByZXR1cm4gJ08nICsgaXRbVUlEXTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZ2V0RW50cnkodGhhdCwga2V5KXtcclxuICAgIC8vIGZhc3QgY2FzZVxyXG4gICAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcclxuICAgIGlmKGluZGV4ICE9ICdGJylyZXR1cm4gdGhhdFtPMV1baW5kZXhdO1xyXG4gICAgLy8gZnJvemVuIG9iamVjdCBjYXNlXHJcbiAgICBmb3IoZW50cnkgPSB0aGF0W0ZJUlNUXTsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XHJcbiAgICAgIGlmKGVudHJ5LmsgPT0ga2V5KXJldHVybiBlbnRyeTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gZGVmKHRoYXQsIGtleSwgdmFsdWUpe1xyXG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KVxyXG4gICAgICAsIHByZXYsIGluZGV4O1xyXG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XHJcbiAgICBpZihlbnRyeSllbnRyeS52ID0gdmFsdWU7XHJcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhhdFtMQVNUXSA9IGVudHJ5ID0ge1xyXG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxyXG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcclxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcclxuICAgICAgICBwOiBwcmV2ID0gdGhhdFtMQVNUXSwgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcclxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxyXG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXHJcbiAgICAgIH07XHJcbiAgICAgIGlmKCF0aGF0W0ZJUlNUXSl0aGF0W0ZJUlNUXSA9IGVudHJ5O1xyXG4gICAgICBpZihwcmV2KXByZXYubiA9IGVudHJ5O1xyXG4gICAgICB0aGF0W1NJWkVdKys7XHJcbiAgICAgIC8vIGFkZCB0byBpbmRleFxyXG4gICAgICBpZihpbmRleCAhPSAnRicpdGhhdFtPMV1baW5kZXhdID0gZW50cnk7XHJcbiAgICB9IHJldHVybiB0aGF0O1xyXG4gIH1cclxuXHJcbiAgdmFyIGNvbGxlY3Rpb25NZXRob2RzID0ge1xyXG4gICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXHJcbiAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcclxuICAgIGNsZWFyOiBmdW5jdGlvbigpe1xyXG4gICAgICBmb3IodmFyIHRoYXQgPSB0aGlzLCBkYXRhID0gdGhhdFtPMV0sIGVudHJ5ID0gdGhhdFtGSVJTVF07IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xyXG4gICAgICAgIGVudHJ5LnIgPSB0cnVlO1xyXG4gICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcclxuICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcclxuICAgICAgfVxyXG4gICAgICB0aGF0W0ZJUlNUXSA9IHRoYXRbTEFTVF0gPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoYXRbU0laRV0gPSAwO1xyXG4gICAgfSxcclxuICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcclxuICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxyXG4gICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcclxuICAgICAgICAsIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcclxuICAgICAgaWYoZW50cnkpe1xyXG4gICAgICAgIHZhciBuZXh0ID0gZW50cnkublxyXG4gICAgICAgICAgLCBwcmV2ID0gZW50cnkucDtcclxuICAgICAgICBkZWxldGUgdGhhdFtPMV1bZW50cnkuaV07XHJcbiAgICAgICAgZW50cnkuciA9IHRydWU7XHJcbiAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xyXG4gICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcclxuICAgICAgICBpZih0aGF0W0ZJUlNUXSA9PSBlbnRyeSl0aGF0W0ZJUlNUXSA9IG5leHQ7XHJcbiAgICAgICAgaWYodGhhdFtMQVNUXSA9PSBlbnRyeSl0aGF0W0xBU1RdID0gcHJldjtcclxuICAgICAgICB0aGF0W1NJWkVdLS07XHJcbiAgICAgIH0gcmV0dXJuICEhZW50cnk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXHJcbiAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcclxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xyXG4gICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0sIDMpXHJcbiAgICAgICAgLCBlbnRyeTtcclxuICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzW0ZJUlNUXSl7XHJcbiAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcclxuICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcclxuICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcclxuICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxyXG4gICAgaGFzOiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvLyAyMy4xIE1hcCBPYmplY3RzXHJcbiAgTWFwID0gZ2V0Q29sbGVjdGlvbihNYXAsIE1BUCwge1xyXG4gICAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxyXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGlzLCBrZXkpO1xyXG4gICAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcclxuICAgIH0sXHJcbiAgICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxyXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKXtcclxuICAgICAgcmV0dXJuIGRlZih0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfSwgY29sbGVjdGlvbk1ldGhvZHMsIHRydWUpO1xyXG4gIFxyXG4gIC8vIDIzLjIgU2V0IE9iamVjdHNcclxuICBTZXQgPSBnZXRDb2xsZWN0aW9uKFNldCwgU0VULCB7XHJcbiAgICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcclxuICAgIGFkZDogZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICByZXR1cm4gZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcclxuICAgIH1cclxuICB9LCBjb2xsZWN0aW9uTWV0aG9kcyk7XHJcbiAgXHJcbiAgZnVuY3Rpb24gZGVmV2Vhayh0aGF0LCBrZXksIHZhbHVlKXtcclxuICAgIGlmKGlzRnJvemVuKGFzc2VydE9iamVjdChrZXkpKSlsZWFrU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgIGhhcyhrZXksIFdFQUspIHx8IGhpZGRlbihrZXksIFdFQUssIHt9KTtcclxuICAgICAga2V5W1dFQUtdW3RoYXRbVUlEXV0gPSB2YWx1ZTtcclxuICAgIH0gcmV0dXJuIHRoYXQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGxlYWtTdG9yZSh0aGF0KXtcclxuICAgIHJldHVybiB0aGF0W0xFQUtdIHx8IGhpZGRlbih0aGF0LCBMRUFLLCBuZXcgTWFwKVtMRUFLXTtcclxuICB9XHJcbiAgXHJcbiAgdmFyIHdlYWtNZXRob2RzID0ge1xyXG4gICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcclxuICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcclxuICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmKGlzRnJvemVuKGtleSkpcmV0dXJuIGxlYWtTdG9yZSh0aGlzKVsnZGVsZXRlJ10oa2V5KTtcclxuICAgICAgcmV0dXJuIGhhcyhrZXksIFdFQUspICYmIGhhcyhrZXlbV0VBS10sIHRoaXNbVUlEXSkgJiYgZGVsZXRlIGtleVtXRUFLXVt0aGlzW1VJRF1dO1xyXG4gICAgfSxcclxuICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXHJcbiAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXHJcbiAgICBoYXM6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcclxuICAgICAgaWYoaXNGcm96ZW4oa2V5KSlyZXR1cm4gbGVha1N0b3JlKHRoaXMpLmhhcyhrZXkpO1xyXG4gICAgICByZXR1cm4gaGFzKGtleSwgV0VBSykgJiYgaGFzKGtleVtXRUFLXSwgdGhpc1tVSURdKTtcclxuICAgIH1cclxuICB9O1xyXG4gIFxyXG4gIC8vIDIzLjMgV2Vha01hcCBPYmplY3RzXHJcbiAgV2Vha01hcCA9IGdldENvbGxlY3Rpb24oV2Vha01hcCwgV0VBS01BUCwge1xyXG4gICAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcclxuICAgIGdldDogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgaWYoaXNPYmplY3Qoa2V5KSl7XHJcbiAgICAgICAgaWYoaXNGcm96ZW4oa2V5KSlyZXR1cm4gbGVha1N0b3JlKHRoaXMpLmdldChrZXkpO1xyXG4gICAgICAgIGlmKGhhcyhrZXksIFdFQUspKXJldHVybiBrZXlbV0VBS11bdGhpc1tVSURdXTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxyXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKXtcclxuICAgICAgcmV0dXJuIGRlZldlYWsodGhpcywga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfSwgd2Vha01ldGhvZHMsIHRydWUsIHRydWUpO1xyXG4gIFxyXG4gIC8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcclxuICBpZihmcmFtZXdvcmsgJiYgbmV3IFdlYWtNYXAoKS5zZXQoT2JqZWN0LmZyZWV6ZSh0bXApLCA3KS5nZXQodG1wKSAhPSA3KXtcclxuICAgIGZvckVhY2guY2FsbChhcnJheSgnZGVsZXRlLGhhcyxnZXQsc2V0JyksIGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHZhciBtZXRob2QgPSBXZWFrTWFwW1BST1RPVFlQRV1ba2V5XTtcclxuICAgICAgV2Vha01hcFtQUk9UT1RZUEVdW2tleV0gPSBmdW5jdGlvbihhLCBiKXtcclxuICAgICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBsZWFreSBtYXBcclxuICAgICAgICBpZihpc09iamVjdChhKSAmJiBpc0Zyb3plbihhKSl7XHJcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbGVha1N0b3JlKHRoaXMpW2tleV0oYSwgYik7XHJcbiAgICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcclxuICAgICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcclxuICAgICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBcclxuICAvLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xyXG4gIFdlYWtTZXQgPSBnZXRDb2xsZWN0aW9uKFdlYWtTZXQsIFdFQUtTRVQsIHtcclxuICAgIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcclxuICAgIGFkZDogZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICByZXR1cm4gZGVmV2Vhayh0aGlzLCB2YWx1ZSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgfSwgd2Vha01ldGhvZHMsIGZhbHNlLCB0cnVlKTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYucmVmbGVjdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oKXtcclxuICBmdW5jdGlvbiBFbnVtZXJhdGUoaXRlcmF0ZWQpe1xyXG4gICAgdmFyIGtleXMgPSBbXSwga2V5O1xyXG4gICAgZm9yKGtleSBpbiBpdGVyYXRlZClrZXlzLnB1c2goa2V5KTtcclxuICAgIHNldCh0aGlzLCBJVEVSLCB7bzogaXRlcmF0ZWQsIGE6IGtleXMsIGk6IDB9KTtcclxuICB9XHJcbiAgY3JlYXRlSXRlcmF0b3IoRW51bWVyYXRlLCBPQkpFQ1QsIGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgaXRlciA9IHRoaXNbSVRFUl1cclxuICAgICAgLCBrZXlzID0gaXRlci5hXHJcbiAgICAgICwga2V5O1xyXG4gICAgZG8ge1xyXG4gICAgICBpZihpdGVyLmkgPj0ga2V5cy5sZW5ndGgpcmV0dXJuIGl0ZXJSZXN1bHQoMSk7XHJcbiAgICB9IHdoaWxlKCEoKGtleSA9IGtleXNbaXRlci5pKytdKSBpbiBpdGVyLm8pKTtcclxuICAgIHJldHVybiBpdGVyUmVzdWx0KDAsIGtleSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgZnVuY3Rpb24gd3JhcChmbil7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oaXQpe1xyXG4gICAgICBhc3NlcnRPYmplY3QoaXQpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyksIHRydWU7XHJcbiAgICAgIH0gY2F0Y2goZSl7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIGZ1bmN0aW9uIHJlZmxlY3RHZXQodGFyZ2V0LCBwcm9wZXJ0eUtleS8qLCByZWNlaXZlciovKXtcclxuICAgIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdXHJcbiAgICAgICwgZGVzYyA9IGdldE93bkRlc2NyaXB0b3IoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KSwgcHJvdG87XHJcbiAgICBpZihkZXNjKXJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJylcclxuICAgICAgPyBkZXNjLnZhbHVlXHJcbiAgICAgIDogZGVzYy5nZXQgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gdW5kZWZpbmVkXHJcbiAgICAgICAgOiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcclxuICAgIHJldHVybiBpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpXHJcbiAgICAgID8gcmVmbGVjdEdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKVxyXG4gICAgICA6IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVmbGVjdFNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWLyosIHJlY2VpdmVyKi8pe1xyXG4gICAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM11cclxuICAgICAgLCBvd25EZXNjICA9IGdldE93bkRlc2NyaXB0b3IoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KVxyXG4gICAgICAsIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XHJcbiAgICBpZighb3duRGVzYyl7XHJcbiAgICAgIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpe1xyXG4gICAgICAgIHJldHVybiByZWZsZWN0U2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIG93bkRlc2MgPSBkZXNjcmlwdG9yKDApO1xyXG4gICAgfVxyXG4gICAgaWYoaGFzKG93bkRlc2MsICd2YWx1ZScpKXtcclxuICAgICAgaWYob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSlyZXR1cm4gZmFsc2U7XHJcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvciA9IGdldE93bkRlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSB8fCBkZXNjcmlwdG9yKDApO1xyXG4gICAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xyXG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpLCB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWRcclxuICAgICAgPyBmYWxzZVxyXG4gICAgICA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XHJcbiAgfVxyXG4gIHZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IHJldHVybkl0O1xyXG4gIFxyXG4gIHZhciByZWZsZWN0ID0ge1xyXG4gICAgLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXHJcbiAgICBhcHBseTogY3R4KGNhbGwsIGFwcGx5LCAzKSxcclxuICAgIC8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcclxuICAgIGNvbnN0cnVjdDogZnVuY3Rpb24odGFyZ2V0LCBhcmd1bWVudHNMaXN0IC8qLCBuZXdUYXJnZXQqLyl7XHJcbiAgICAgIHZhciBwcm90byAgICA9IGFzc2VydEZ1bmN0aW9uKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdKVtQUk9UT1RZUEVdXHJcbiAgICAgICAgLCBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdFByb3RvKVxyXG4gICAgICAgICwgcmVzdWx0ICAgPSBhcHBseS5jYWxsKHRhcmdldCwgaW5zdGFuY2UsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xyXG4gICAgfSxcclxuICAgIC8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXHJcbiAgICBkZWZpbmVQcm9wZXJ0eTogd3JhcChkZWZpbmVQcm9wZXJ0eSksXHJcbiAgICAvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxyXG4gICAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcGVydHlLZXkpe1xyXG4gICAgICB2YXIgZGVzYyA9IGdldE93bkRlc2NyaXB0b3IoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcclxuICAgICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcclxuICAgIH0sXHJcbiAgICAvLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxyXG4gICAgZW51bWVyYXRlOiBmdW5jdGlvbih0YXJnZXQpe1xyXG4gICAgICByZXR1cm4gbmV3IEVudW1lcmF0ZShhc3NlcnRPYmplY3QodGFyZ2V0KSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxyXG4gICAgZ2V0OiByZWZsZWN0R2V0LFxyXG4gICAgLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXHJcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcGVydHlLZXkpe1xyXG4gICAgICByZXR1cm4gZ2V0T3duRGVzY3JpcHRvcihhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xyXG4gICAgfSxcclxuICAgIC8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcclxuICAgIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbih0YXJnZXQpe1xyXG4gICAgICByZXR1cm4gZ2V0UHJvdG90eXBlT2YoYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xyXG4gICAgfSxcclxuICAgIC8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxyXG4gICAgaGFzOiBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5S2V5KXtcclxuICAgICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcclxuICAgIH0sXHJcbiAgICAvLyAyNi4xLjEwIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcclxuICAgIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24odGFyZ2V0KXtcclxuICAgICAgcmV0dXJuICEhaXNFeHRlbnNpYmxlKGFzc2VydE9iamVjdCh0YXJnZXQpKTtcclxuICAgIH0sXHJcbiAgICAvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXHJcbiAgICBvd25LZXlzOiBvd25LZXlzLFxyXG4gICAgLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcclxuICAgIHByZXZlbnRFeHRlbnNpb25zOiB3cmFwKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyB8fCByZXR1cm5JdCksXHJcbiAgICAvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxyXG4gICAgc2V0OiByZWZsZWN0U2V0XHJcbiAgfVxyXG4gIC8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxyXG4gIGlmKHNldFByb3RvdHlwZU9mKXJlZmxlY3Quc2V0UHJvdG90eXBlT2YgPSBmdW5jdGlvbih0YXJnZXQsIHByb3RvKXtcclxuICAgIHJldHVybiBzZXRQcm90b3R5cGVPZihhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvdG8pLCB0cnVlO1xyXG4gIH07XHJcbiAgXHJcbiAgJGRlZmluZShHTE9CQUwsIHtSZWZsZWN0OiB7fX0pO1xyXG4gICRkZWZpbmUoU1RBVElDLCAnUmVmbGVjdCcsIHJlZmxlY3QpO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNy5wcm9wb3NhbHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbigpe1xyXG4gICRkZWZpbmUoUFJPVE8sIEFSUkFZLCB7XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZG9tZW5pYy9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcclxuICAgIGluY2x1ZGVzOiBjcmVhdGVBcnJheUNvbnRhaW5zKHRydWUpXHJcbiAgfSk7XHJcbiAgJGRlZmluZShQUk9UTywgU1RSSU5HLCB7XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XHJcbiAgICBhdDogY3JlYXRlUG9pbnRBdCh0cnVlKVxyXG4gIH0pO1xyXG4gIFxyXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFRvQXJyYXkoaXNFbnRyaWVzKXtcclxuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3Qpe1xyXG4gICAgICB2YXIgTyAgICAgID0gdG9PYmplY3Qob2JqZWN0KVxyXG4gICAgICAgICwga2V5cyAgID0gZ2V0S2V5cyhvYmplY3QpXHJcbiAgICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxyXG4gICAgICAgICwgaSAgICAgID0gMFxyXG4gICAgICAgICwgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKVxyXG4gICAgICAgICwga2V5O1xyXG4gICAgICBpZihpc0VudHJpZXMpd2hpbGUobGVuZ3RoID4gaSlyZXN1bHRbaV0gPSBba2V5ID0ga2V5c1tpKytdLCBPW2tleV1dO1xyXG4gICAgICBlbHNlIHdoaWxlKGxlbmd0aCA+IGkpcmVzdWx0W2ldID0gT1trZXlzW2krK11dO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH1cclxuICAkZGVmaW5lKFNUQVRJQywgT0JKRUNULCB7XHJcbiAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uLzkzNTM3ODFcclxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uKG9iamVjdCl7XHJcbiAgICAgIHZhciBPICAgICAgPSB0b09iamVjdChvYmplY3QpXHJcbiAgICAgICAgLCByZXN1bHQgPSB7fTtcclxuICAgICAgZm9yRWFjaC5jYWxsKG93bktleXMoTyksIGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2NyaXB0b3IoMCwgZ2V0T3duRGVzY3JpcHRvcihPLCBrZXkpKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yd2FsZHJvbi90YzM5LW5vdGVzL2Jsb2IvbWFzdGVyL2VzNi8yMDE0LTA0L2Fwci05Lm1kIzUxLW9iamVjdGVudHJpZXMtb2JqZWN0dmFsdWVzXHJcbiAgICB2YWx1ZXM6ICBjcmVhdGVPYmplY3RUb0FycmF5KGZhbHNlKSxcclxuICAgIGVudHJpZXM6IGNyZWF0ZU9iamVjdFRvQXJyYXkodHJ1ZSlcclxuICB9KTtcclxuICAkZGVmaW5lKFNUQVRJQywgUkVHRVhQLCB7XHJcbiAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9rYW5nYXgvOTY5ODEwMFxyXG4gICAgZXNjYXBlOiBjcmVhdGVSZXBsYWNlcigvKFtcXFxcXFwtW1xcXXt9KCkqKz8uLF4kfF0pL2csICdcXFxcJDEnLCB0cnVlKVxyXG4gIH0pO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNy5hYnN0cmFjdC1yZWZzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLWFic3RyYWN0LXJlZnNcclxuIWZ1bmN0aW9uKFJFRkVSRU5DRSl7XHJcbiAgUkVGRVJFTkNFX0dFVCA9IGdldFdlbGxLbm93blN5bWJvbChSRUZFUkVOQ0UrJ0dldCcsIHRydWUpO1xyXG4gIHZhciBSRUZFUkVOQ0VfU0VUID0gZ2V0V2VsbEtub3duU3ltYm9sKFJFRkVSRU5DRStTRVQsIHRydWUpXHJcbiAgICAsIFJFRkVSRU5DRV9ERUxFVEUgPSBnZXRXZWxsS25vd25TeW1ib2woUkVGRVJFTkNFKydEZWxldGUnLCB0cnVlKTtcclxuICBcclxuICAkZGVmaW5lKFNUQVRJQywgU1lNQk9MLCB7XHJcbiAgICByZWZlcmVuY2VHZXQ6IFJFRkVSRU5DRV9HRVQsXHJcbiAgICByZWZlcmVuY2VTZXQ6IFJFRkVSRU5DRV9TRVQsXHJcbiAgICByZWZlcmVuY2VEZWxldGU6IFJFRkVSRU5DRV9ERUxFVEVcclxuICB9KTtcclxuICBcclxuICBoaWRkZW4oRnVuY3Rpb25Qcm90bywgUkVGRVJFTkNFX0dFVCwgcmV0dXJuVGhpcyk7XHJcbiAgXHJcbiAgZnVuY3Rpb24gc2V0TWFwTWV0aG9kcyhDb25zdHJ1Y3Rvcil7XHJcbiAgICBpZihDb25zdHJ1Y3Rvcil7XHJcbiAgICAgIHZhciBNYXBQcm90byA9IENvbnN0cnVjdG9yW1BST1RPVFlQRV07XHJcbiAgICAgIGhpZGRlbihNYXBQcm90bywgUkVGRVJFTkNFX0dFVCwgTWFwUHJvdG8uZ2V0KTtcclxuICAgICAgaGlkZGVuKE1hcFByb3RvLCBSRUZFUkVOQ0VfU0VULCBNYXBQcm90by5zZXQpO1xyXG4gICAgICBoaWRkZW4oTWFwUHJvdG8sIFJFRkVSRU5DRV9ERUxFVEUsIE1hcFByb3RvWydkZWxldGUnXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHNldE1hcE1ldGhvZHMoTWFwKTtcclxuICBzZXRNYXBNZXRob2RzKFdlYWtNYXApO1xyXG59KCdyZWZlcmVuY2UnKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogY29yZS5kaWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKERJQ1Qpe1xyXG4gIERpY3QgPSBmdW5jdGlvbihpdGVyYWJsZSl7XHJcbiAgICB2YXIgZGljdCA9IGNyZWF0ZShudWxsKTtcclxuICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgIGlmKGlzSXRlcmFibGUoaXRlcmFibGUpKXtcclxuICAgICAgICBmb3JPZihpdGVyYWJsZSwgdHJ1ZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XHJcbiAgICAgICAgICBkaWN0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIGFzc2lnbihkaWN0LCBpdGVyYWJsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGljdDtcclxuICB9XHJcbiAgRGljdFtQUk9UT1RZUEVdID0gbnVsbDtcclxuICBcclxuICBmdW5jdGlvbiBEaWN0SXRlcmF0b3IoaXRlcmF0ZWQsIGtpbmQpe1xyXG4gICAgc2V0KHRoaXMsIElURVIsIHtvOiB0b09iamVjdChpdGVyYXRlZCksIGE6IGdldEtleXMoaXRlcmF0ZWQpLCBpOiAwLCBrOiBraW5kfSk7XHJcbiAgfVxyXG4gIGNyZWF0ZUl0ZXJhdG9yKERpY3RJdGVyYXRvciwgRElDVCwgZnVuY3Rpb24oKXtcclxuICAgIHZhciBpdGVyID0gdGhpc1tJVEVSXVxyXG4gICAgICAsIE8gICAgPSBpdGVyLm9cclxuICAgICAgLCBrZXlzID0gaXRlci5hXHJcbiAgICAgICwga2luZCA9IGl0ZXIua1xyXG4gICAgICAsIGtleTtcclxuICAgIGRvIHtcclxuICAgICAgaWYoaXRlci5pID49IGtleXMubGVuZ3RoKXtcclxuICAgICAgICBpdGVyLm8gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIGl0ZXJSZXN1bHQoMSk7XHJcbiAgICAgIH1cclxuICAgIH0gd2hpbGUoIWhhcyhPLCBrZXkgPSBrZXlzW2l0ZXIuaSsrXSkpO1xyXG4gICAgaWYoa2luZCA9PSBLRVkpICByZXR1cm4gaXRlclJlc3VsdCgwLCBrZXkpO1xyXG4gICAgaWYoa2luZCA9PSBWQUxVRSlyZXR1cm4gaXRlclJlc3VsdCgwLCBPW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlclJlc3VsdCgwLCBba2V5LCBPW2tleV1dKTtcclxuICB9KTtcclxuICBmdW5jdGlvbiBjcmVhdGVEaWN0SXRlcihraW5kKXtcclxuICAgIHJldHVybiBmdW5jdGlvbihpdCl7XHJcbiAgICAgIHJldHVybiBuZXcgRGljdEl0ZXJhdG9yKGl0LCBraW5kKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLypcclxuICAgKiAwIC0+IGZvckVhY2hcclxuICAgKiAxIC0+IG1hcFxyXG4gICAqIDIgLT4gZmlsdGVyXHJcbiAgICogMyAtPiBzb21lXHJcbiAgICogNCAtPiBldmVyeVxyXG4gICAqIDUgLT4gZmluZFxyXG4gICAqIDYgLT4gZmluZEtleVxyXG4gICAqIDcgLT4gbWFwUGFpcnNcclxuICAgKi9cclxuICBmdW5jdGlvbiBjcmVhdGVEaWN0TWV0aG9kKHR5cGUpe1xyXG4gICAgdmFyIGlzTWFwICAgID0gdHlwZSA9PSAxXHJcbiAgICAgICwgaXNFdmVyeSAgPSB0eXBlID09IDQ7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFja2ZuLCB0aGF0IC8qID0gdW5kZWZpbmVkICovKXtcclxuICAgICAgdmFyIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxyXG4gICAgICAgICwgTyAgICAgID0gdG9PYmplY3Qob2JqZWN0KVxyXG4gICAgICAgICwgcmVzdWx0ID0gaXNNYXAgfHwgdHlwZSA9PSA3IHx8IHR5cGUgPT0gMiA/IG5ldyAoZ2VuZXJpYyh0aGlzLCBEaWN0KSkgOiB1bmRlZmluZWRcclxuICAgICAgICAsIGtleSwgdmFsLCByZXM7XHJcbiAgICAgIGZvcihrZXkgaW4gTylpZihoYXMoTywga2V5KSl7XHJcbiAgICAgICAgdmFsID0gT1trZXldO1xyXG4gICAgICAgIHJlcyA9IGYodmFsLCBrZXksIG9iamVjdCk7XHJcbiAgICAgICAgaWYodHlwZSl7XHJcbiAgICAgICAgICBpZihpc01hcClyZXN1bHRba2V5XSA9IHJlczsgICAgICAgICAgICAgLy8gbWFwXHJcbiAgICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2godHlwZSl7XHJcbiAgICAgICAgICAgIGNhc2UgMjogcmVzdWx0W2tleV0gPSB2YWw7IGJyZWFrICAgICAgLy8gZmlsdGVyXHJcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgLy8gc29tZVxyXG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcclxuICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4ga2V5OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kS2V5XHJcbiAgICAgICAgICAgIGNhc2UgNzogcmVzdWx0W3Jlc1swXV0gPSByZXNbMV07ICAgICAgLy8gbWFwUGFpcnNcclxuICAgICAgICAgIH0gZWxzZSBpZihpc0V2ZXJ5KXJldHVybiBmYWxzZTsgICAgICAgICAvLyBldmVyeVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHlwZSA9PSAzIHx8IGlzRXZlcnkgPyBpc0V2ZXJ5IDogcmVzdWx0O1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBjcmVhdGVEaWN0UmVkdWNlKGlzVHVybil7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBtYXBmbiwgaW5pdCl7XHJcbiAgICAgIGFzc2VydEZ1bmN0aW9uKG1hcGZuKTtcclxuICAgICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KG9iamVjdClcclxuICAgICAgICAsIGtleXMgICA9IGdldEtleXMoTylcclxuICAgICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAgICAgLCBpICAgICAgPSAwXHJcbiAgICAgICAgLCBtZW1vLCBrZXksIHJlc3VsdDtcclxuICAgICAgaWYoaXNUdXJuKW1lbW8gPSBpbml0ID09IHVuZGVmaW5lZCA/IG5ldyAoZ2VuZXJpYyh0aGlzLCBEaWN0KSkgOiBPYmplY3QoaW5pdCk7XHJcbiAgICAgIGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDMpe1xyXG4gICAgICAgIGFzc2VydChsZW5ndGgsIFJFRFVDRV9FUlJPUik7XHJcbiAgICAgICAgbWVtbyA9IE9ba2V5c1tpKytdXTtcclxuICAgICAgfSBlbHNlIG1lbW8gPSBPYmplY3QoaW5pdCk7XHJcbiAgICAgIHdoaWxlKGxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IGtleXNbaSsrXSkpe1xyXG4gICAgICAgIHJlc3VsdCA9IG1hcGZuKG1lbW8sIE9ba2V5XSwga2V5LCBvYmplY3QpO1xyXG4gICAgICAgIGlmKGlzVHVybil7XHJcbiAgICAgICAgICBpZihyZXN1bHQgPT09IGZhbHNlKWJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBtZW1vID0gcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBtZW1vO1xyXG4gICAgfVxyXG4gIH1cclxuICB2YXIgZmluZEtleSA9IGNyZWF0ZURpY3RNZXRob2QoNik7XHJcbiAgZnVuY3Rpb24gaW5jbHVkZXMob2JqZWN0LCBlbCl7XHJcbiAgICByZXR1cm4gKGVsID09IGVsID8ga2V5T2Yob2JqZWN0LCBlbCkgOiBmaW5kS2V5KG9iamVjdCwgc2FtZU5hTikpICE9PSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIFxyXG4gIHZhciBkaWN0TWV0aG9kcyA9IHtcclxuICAgIGtleXM6ICAgIGNyZWF0ZURpY3RJdGVyKEtFWSksXHJcbiAgICB2YWx1ZXM6ICBjcmVhdGVEaWN0SXRlcihWQUxVRSksXHJcbiAgICBlbnRyaWVzOiBjcmVhdGVEaWN0SXRlcihLRVkrVkFMVUUpLFxyXG4gICAgZm9yRWFjaDogY3JlYXRlRGljdE1ldGhvZCgwKSxcclxuICAgIG1hcDogICAgIGNyZWF0ZURpY3RNZXRob2QoMSksXHJcbiAgICBmaWx0ZXI6ICBjcmVhdGVEaWN0TWV0aG9kKDIpLFxyXG4gICAgc29tZTogICAgY3JlYXRlRGljdE1ldGhvZCgzKSxcclxuICAgIGV2ZXJ5OiAgIGNyZWF0ZURpY3RNZXRob2QoNCksXHJcbiAgICBmaW5kOiAgICBjcmVhdGVEaWN0TWV0aG9kKDUpLFxyXG4gICAgZmluZEtleTogZmluZEtleSxcclxuICAgIG1hcFBhaXJzOmNyZWF0ZURpY3RNZXRob2QoNyksXHJcbiAgICByZWR1Y2U6ICBjcmVhdGVEaWN0UmVkdWNlKGZhbHNlKSxcclxuICAgIHR1cm46ICAgIGNyZWF0ZURpY3RSZWR1Y2UodHJ1ZSksXHJcbiAgICBrZXlPZjogICBrZXlPZixcclxuICAgIGluY2x1ZGVzOmluY2x1ZGVzLFxyXG4gICAgLy8gSGFzIC8gZ2V0IC8gc2V0IG93biBwcm9wZXJ0eVxyXG4gICAgaGFzOiBoYXMsXHJcbiAgICBnZXQ6IGdldCxcclxuICAgIHNldDogY3JlYXRlRGVmaW5lcigwKSxcclxuICAgIGlzRGljdDogZnVuY3Rpb24oaXQpe1xyXG4gICAgICByZXR1cm4gaXNPYmplY3QoaXQpICYmIGdldFByb3RvdHlwZU9mKGl0KSA9PT0gRGljdFtQUk9UT1RZUEVdO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgXHJcbiAgaWYoUkVGRVJFTkNFX0dFVClmb3IodmFyIGtleSBpbiBkaWN0TWV0aG9kcykhZnVuY3Rpb24oZm4pe1xyXG4gICAgZnVuY3Rpb24gbWV0aG9kKCl7XHJcbiAgICAgIGZvcih2YXIgYXJncyA9IFt0aGlzXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOylhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgICByZXR1cm4gaW52b2tlKGZuLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGZuW1JFRkVSRU5DRV9HRVRdID0gZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIG1ldGhvZDtcclxuICAgIH1cclxuICB9KGRpY3RNZXRob2RzW2tleV0pO1xyXG4gIFxyXG4gICRkZWZpbmUoR0xPQkFMICsgRk9SQ0VELCB7RGljdDogYXNzaWduSGlkZGVuKERpY3QsIGRpY3RNZXRob2RzKX0pO1xyXG59KCdEaWN0Jyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvcmUuJGZvciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbihFTlRSSUVTLCBGTil7ICBcclxuICBmdW5jdGlvbiAkZm9yKGl0ZXJhYmxlLCBlbnRyaWVzKXtcclxuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mICRmb3IpKXJldHVybiBuZXcgJGZvcihpdGVyYWJsZSwgZW50cmllcyk7XHJcbiAgICB0aGlzW0lURVJdICAgID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xyXG4gICAgdGhpc1tFTlRSSUVTXSA9ICEhZW50cmllcztcclxuICB9XHJcbiAgXHJcbiAgY3JlYXRlSXRlcmF0b3IoJGZvciwgJ1dyYXBwZXInLCBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXNbSVRFUl0ubmV4dCgpO1xyXG4gIH0pO1xyXG4gIHZhciAkZm9yUHJvdG8gPSAkZm9yW1BST1RPVFlQRV07XHJcbiAgc2V0SXRlcmF0b3IoJGZvclByb3RvLCBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXNbSVRFUl07IC8vIHVud3JhcFxyXG4gIH0pO1xyXG4gIFxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluSXRlcmF0b3IobmV4dCl7XHJcbiAgICBmdW5jdGlvbiBJdGVyKEksIGZuLCB0aGF0KXtcclxuICAgICAgdGhpc1tJVEVSXSAgICA9IGdldEl0ZXJhdG9yKEkpO1xyXG4gICAgICB0aGlzW0VOVFJJRVNdID0gSVtFTlRSSUVTXTtcclxuICAgICAgdGhpc1tGTl0gICAgICA9IGN0eChmbiwgdGhhdCwgSVtFTlRSSUVTXSA/IDIgOiAxKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUl0ZXJhdG9yKEl0ZXIsICdDaGFpbicsIG5leHQsICRmb3JQcm90byk7XHJcbiAgICBzZXRJdGVyYXRvcihJdGVyW1BST1RPVFlQRV0sIHJldHVyblRoaXMpOyAvLyBvdmVycmlkZSAkZm9yUHJvdG8gaXRlcmF0b3JcclxuICAgIHJldHVybiBJdGVyO1xyXG4gIH1cclxuICBcclxuICB2YXIgTWFwSXRlciA9IGNyZWF0ZUNoYWluSXRlcmF0b3IoZnVuY3Rpb24oKXtcclxuICAgIHZhciBzdGVwID0gdGhpc1tJVEVSXS5uZXh0KCk7XHJcbiAgICByZXR1cm4gc3RlcC5kb25lID8gc3RlcCA6IGl0ZXJSZXN1bHQoMCwgc3RlcENhbGwodGhpc1tGTl0sIHN0ZXAudmFsdWUsIHRoaXNbRU5UUklFU10pKTtcclxuICB9KTtcclxuICBcclxuICB2YXIgRmlsdGVySXRlciA9IGNyZWF0ZUNoYWluSXRlcmF0b3IoZnVuY3Rpb24oKXtcclxuICAgIGZvcig7Oyl7XHJcbiAgICAgIHZhciBzdGVwID0gdGhpc1tJVEVSXS5uZXh0KCk7XHJcbiAgICAgIGlmKHN0ZXAuZG9uZSB8fCBzdGVwQ2FsbCh0aGlzW0ZOXSwgc3RlcC52YWx1ZSwgdGhpc1tFTlRSSUVTXSkpcmV0dXJuIHN0ZXA7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgYXNzaWduSGlkZGVuKCRmb3JQcm90bywge1xyXG4gICAgb2Y6IGZ1bmN0aW9uKGZuLCB0aGF0KXtcclxuICAgICAgZm9yT2YodGhpcywgdGhpc1tFTlRSSUVTXSwgZm4sIHRoYXQpO1xyXG4gICAgfSxcclxuICAgIGFycmF5OiBmdW5jdGlvbihmbiwgdGhhdCl7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgZm9yT2YoZm4gIT0gdW5kZWZpbmVkID8gdGhpcy5tYXAoZm4sIHRoYXQpIDogdGhpcywgZmFsc2UsIHB1c2gsIHJlc3VsdCk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgZmlsdGVyOiBmdW5jdGlvbihmbiwgdGhhdCl7XHJcbiAgICAgIHJldHVybiBuZXcgRmlsdGVySXRlcih0aGlzLCBmbiwgdGhhdCk7XHJcbiAgICB9LFxyXG4gICAgbWFwOiBmdW5jdGlvbihmbiwgdGhhdCl7XHJcbiAgICAgIHJldHVybiBuZXcgTWFwSXRlcih0aGlzLCBmbiwgdGhhdCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgJGZvci5pc0l0ZXJhYmxlICA9IGlzSXRlcmFibGU7XHJcbiAgJGZvci5nZXRJdGVyYXRvciA9IGdldEl0ZXJhdG9yO1xyXG4gIFxyXG4gICRkZWZpbmUoR0xPQkFMICsgRk9SQ0VELCB7JGZvcjogJGZvcn0pO1xyXG59KCdlbnRyaWVzJywgc2FmZVN5bWJvbCgnZm4nKSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvcmUuZGVsYXkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIGh0dHBzOi8vZXNkaXNjdXNzLm9yZy90b3BpYy9wcm9taXNlLXJldHVybmluZy1kZWxheS1mdW5jdGlvblxyXG4kZGVmaW5lKEdMT0JBTCArIEZPUkNFRCwge1xyXG4gIGRlbGF5OiBmdW5jdGlvbih0aW1lKXtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKXtcclxuICAgICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lLCB0cnVlKTtcclxuICAgIH0pO1xyXG4gIH1cclxufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvcmUuYmluZGluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbihfLCB0b0xvY2FsZVN0cmluZyl7XHJcbiAgLy8gUGxhY2Vob2xkZXJcclxuICBjb3JlLl8gPSBwYXRoLl8gPSBwYXRoLl8gfHwge307XHJcblxyXG4gICRkZWZpbmUoUFJPVE8gKyBGT1JDRUQsIEZVTkNUSU9OLCB7XHJcbiAgICBwYXJ0OiBwYXJ0LFxyXG4gICAgb25seTogZnVuY3Rpb24obnVtYmVyQXJndW1lbnRzLCB0aGF0IC8qID0gQCAqLyl7XHJcbiAgICAgIHZhciBmbiAgICAgPSBhc3NlcnRGdW5jdGlvbih0aGlzKVxyXG4gICAgICAgICwgbiAgICAgID0gdG9MZW5ndGgobnVtYmVyQXJndW1lbnRzKVxyXG4gICAgICAgICwgaXNUaGF0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDE7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gbWluKG4sIGFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgICAsIGFyZ3MgICA9IEFycmF5KGxlbmd0aClcclxuICAgICAgICAgICwgaSAgICAgID0gMDtcclxuICAgICAgICB3aGlsZShsZW5ndGggPiBpKWFyZ3NbaV0gPSBhcmd1bWVudHNbaSsrXTtcclxuICAgICAgICByZXR1cm4gaW52b2tlKGZuLCBhcmdzLCBpc1RoYXQgPyB0aGF0IDogdGhpcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuICBcclxuICBmdW5jdGlvbiB0aWUoa2V5KXtcclxuICAgIHZhciB0aGF0ICA9IHRoaXNcclxuICAgICAgLCBib3VuZCA9IHt9O1xyXG4gICAgcmV0dXJuIGhpZGRlbih0aGF0LCBfLCBmdW5jdGlvbihrZXkpe1xyXG4gICAgICBpZihrZXkgPT09IHVuZGVmaW5lZCB8fCAhKGtleSBpbiB0aGF0KSlyZXR1cm4gdG9Mb2NhbGVTdHJpbmcuY2FsbCh0aGF0KTtcclxuICAgICAgcmV0dXJuIGhhcyhib3VuZCwga2V5KSA/IGJvdW5kW2tleV0gOiAoYm91bmRba2V5XSA9IGN0eCh0aGF0W2tleV0sIHRoYXQsIC0xKSk7XHJcbiAgICB9KVtfXShrZXkpO1xyXG4gIH1cclxuICBcclxuICBoaWRkZW4ocGF0aC5fLCBUT19TVFJJTkcsIGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gXztcclxuICB9KTtcclxuICBcclxuICBoaWRkZW4oT2JqZWN0UHJvdG8sIF8sIHRpZSk7XHJcbiAgREVTQyB8fCBoaWRkZW4oQXJyYXlQcm90bywgXywgdGllKTtcclxuICAvLyBJRTgtIGRpcnR5IGhhY2sgLSByZWRlZmluZWQgdG9Mb2NhbGVTdHJpbmcgaXMgbm90IGVudW1lcmFibGVcclxufShERVNDID8gdWlkKCd0aWUnKSA6IFRPX0xPQ0FMRSwgT2JqZWN0UHJvdG9bVE9fTE9DQUxFXSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvcmUub2JqZWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbigpe1xyXG4gIGZ1bmN0aW9uIGRlZmluZSh0YXJnZXQsIG1peGluKXtcclxuICAgIHZhciBrZXlzICAgPSBvd25LZXlzKHRvT2JqZWN0KG1peGluKSlcclxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxyXG4gICAgICAsIGkgPSAwLCBrZXk7XHJcbiAgICB3aGlsZShsZW5ndGggPiBpKWRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5ID0ga2V5c1tpKytdLCBnZXRPd25EZXNjcmlwdG9yKG1peGluLCBrZXkpKTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgfTtcclxuICAkZGVmaW5lKFNUQVRJQyArIEZPUkNFRCwgT0JKRUNULCB7XHJcbiAgICBpc09iamVjdDogaXNPYmplY3QsXHJcbiAgICBjbGFzc29mOiBjbGFzc29mLFxyXG4gICAgZGVmaW5lOiBkZWZpbmUsXHJcbiAgICBtYWtlOiBmdW5jdGlvbihwcm90bywgbWl4aW4pe1xyXG4gICAgICByZXR1cm4gZGVmaW5lKGNyZWF0ZShwcm90byksIG1peGluKTtcclxuICAgIH1cclxuICB9KTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBjb3JlLmFycmF5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4kZGVmaW5lKFBST1RPICsgRk9SQ0VELCBBUlJBWSwge1xyXG4gIHR1cm46IGZ1bmN0aW9uKGZuLCB0YXJnZXQgLyogPSBbXSAqLyl7XHJcbiAgICBhc3NlcnRGdW5jdGlvbihmbik7XHJcbiAgICB2YXIgbWVtbyAgID0gdGFyZ2V0ID09IHVuZGVmaW5lZCA/IFtdIDogT2JqZWN0KHRhcmdldClcclxuICAgICAgLCBPICAgICAgPSBFUzVPYmplY3QodGhpcylcclxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcclxuICAgICAgLCBpbmRleCAgPSAwO1xyXG4gICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoZm4obWVtbywgT1tpbmRleF0sIGluZGV4KyssIHRoaXMpID09PSBmYWxzZSlicmVhaztcclxuICAgIHJldHVybiBtZW1vO1xyXG4gIH1cclxufSk7XHJcbmlmKGZyYW1ld29yaylBcnJheVVuc2NvcGFibGVzLnR1cm4gPSB0cnVlO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBjb3JlLm51bWJlciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24obnVtYmVyTWV0aG9kcyl7ICBcclxuICBmdW5jdGlvbiBOdW1iZXJJdGVyYXRvcihpdGVyYXRlZCl7XHJcbiAgICBzZXQodGhpcywgSVRFUiwge2w6IHRvTGVuZ3RoKGl0ZXJhdGVkKSwgaTogMH0pO1xyXG4gIH1cclxuICBjcmVhdGVJdGVyYXRvcihOdW1iZXJJdGVyYXRvciwgTlVNQkVSLCBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGl0ZXIgPSB0aGlzW0lURVJdXHJcbiAgICAgICwgaSAgICA9IGl0ZXIuaSsrO1xyXG4gICAgcmV0dXJuIGkgPCBpdGVyLmwgPyBpdGVyUmVzdWx0KDAsIGkpIDogaXRlclJlc3VsdCgxKTtcclxuICB9KTtcclxuICBkZWZpbmVJdGVyYXRvcihOdW1iZXIsIE5VTUJFUiwgZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiBuZXcgTnVtYmVySXRlcmF0b3IodGhpcyk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgbnVtYmVyTWV0aG9kcy5yYW5kb20gPSBmdW5jdGlvbihsaW0gLyogPSAwICovKXtcclxuICAgIHZhciBhID0gK3RoaXNcclxuICAgICAgLCBiID0gbGltID09IHVuZGVmaW5lZCA/IDAgOiArbGltXHJcbiAgICAgICwgbSA9IG1pbihhLCBiKTtcclxuICAgIHJldHVybiByYW5kb20oKSAqIChtYXgoYSwgYikgLSBtKSArIG07XHJcbiAgfTtcclxuXHJcbiAgZm9yRWFjaC5jYWxsKGFycmF5KFxyXG4gICAgICAvLyBFUzM6XHJcbiAgICAgICdyb3VuZCxmbG9vcixjZWlsLGFicyxzaW4sYXNpbixjb3MsYWNvcyx0YW4sYXRhbixleHAsc3FydCxtYXgsbWluLHBvdyxhdGFuMiwnICtcclxuICAgICAgLy8gRVM2OlxyXG4gICAgICAnYWNvc2gsYXNpbmgsYXRhbmgsY2JydCxjbHozMixjb3NoLGV4cG0xLGh5cG90LGltdWwsbG9nMXAsbG9nMTAsbG9nMixzaWduLHNpbmgsdGFuaCx0cnVuYydcclxuICAgICksIGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHZhciBmbiA9IE1hdGhba2V5XTtcclxuICAgICAgaWYoZm4pbnVtYmVyTWV0aG9kc1trZXldID0gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XHJcbiAgICAgICAgLy8gaWU5LSBkb250IHN1cHBvcnQgc3RyaWN0IG1vZGUgJiBjb252ZXJ0IGB0aGlzYCB0byBvYmplY3QgLT4gY29udmVydCBpdCB0byBudW1iZXJcclxuICAgICAgICB2YXIgYXJncyA9IFsrdGhpc11cclxuICAgICAgICAgICwgaSAgICA9IDA7XHJcbiAgICAgICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcclxuICAgICAgICByZXR1cm4gaW52b2tlKGZuLCBhcmdzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICk7XHJcbiAgXHJcbiAgJGRlZmluZShQUk9UTyArIEZPUkNFRCwgTlVNQkVSLCBudW1iZXJNZXRob2RzKTtcclxufSh7fSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvcmUuc3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbigpe1xyXG4gIHZhciBlc2NhcGVIVE1MRGljdCA9IHtcclxuICAgICcmJzogJyZhbXA7JyxcclxuICAgICc8JzogJyZsdDsnLFxyXG4gICAgJz4nOiAnJmd0OycsXHJcbiAgICAnXCInOiAnJnF1b3Q7JyxcclxuICAgIFwiJ1wiOiAnJmFwb3M7J1xyXG4gIH0sIHVuZXNjYXBlSFRNTERpY3QgPSB7fSwga2V5O1xyXG4gIGZvcihrZXkgaW4gZXNjYXBlSFRNTERpY3QpdW5lc2NhcGVIVE1MRGljdFtlc2NhcGVIVE1MRGljdFtrZXldXSA9IGtleTtcclxuICAkZGVmaW5lKFBST1RPICsgRk9SQ0VELCBTVFJJTkcsIHtcclxuICAgIGVzY2FwZUhUTUw6ICAgY3JlYXRlUmVwbGFjZXIoL1smPD5cIiddL2csIGVzY2FwZUhUTUxEaWN0KSxcclxuICAgIHVuZXNjYXBlSFRNTDogY3JlYXRlUmVwbGFjZXIoLyYoPzphbXB8bHR8Z3R8cXVvdHxhcG9zKTsvZywgdW5lc2NhcGVIVE1MRGljdClcclxuICB9KTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBjb3JlLmRhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oZm9ybWF0UmVnRXhwLCBmbGV4aW9SZWdFeHAsIGxvY2FsZXMsIGN1cnJlbnQsIFNFQ09ORFMsIE1JTlVURVMsIEhPVVJTLCBNT05USCwgWUVBUil7XHJcbiAgZnVuY3Rpb24gY3JlYXRlRm9ybWF0KHByZWZpeCl7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24odGVtcGxhdGUsIGxvY2FsZSAvKiA9IGN1cnJlbnQgKi8pe1xyXG4gICAgICB2YXIgdGhhdCA9IHRoaXNcclxuICAgICAgICAsIGRpY3QgPSBsb2NhbGVzW2hhcyhsb2NhbGVzLCBsb2NhbGUpID8gbG9jYWxlIDogY3VycmVudF07XHJcbiAgICAgIGZ1bmN0aW9uIGdldCh1bml0KXtcclxuICAgICAgICByZXR1cm4gdGhhdFtwcmVmaXggKyB1bml0XSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBTdHJpbmcodGVtcGxhdGUpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbihwYXJ0KXtcclxuICAgICAgICBzd2l0Y2gocGFydCl7XHJcbiAgICAgICAgICBjYXNlICdzJyAgOiByZXR1cm4gZ2V0KFNFQ09ORFMpOyAgICAgICAgICAgICAgICAgIC8vIFNlY29uZHMgOiAwLTU5XHJcbiAgICAgICAgICBjYXNlICdzcycgOiByZXR1cm4gbHooZ2V0KFNFQ09ORFMpKTsgICAgICAgICAgICAgIC8vIFNlY29uZHMgOiAwMC01OVxyXG4gICAgICAgICAgY2FzZSAnbScgIDogcmV0dXJuIGdldChNSU5VVEVTKTsgICAgICAgICAgICAgICAgICAvLyBNaW51dGVzIDogMC01OVxyXG4gICAgICAgICAgY2FzZSAnbW0nIDogcmV0dXJuIGx6KGdldChNSU5VVEVTKSk7ICAgICAgICAgICAgICAvLyBNaW51dGVzIDogMDAtNTlcclxuICAgICAgICAgIGNhc2UgJ2gnICA6IHJldHVybiBnZXQoSE9VUlMpOyAgICAgICAgICAgICAgICAgICAgLy8gSG91cnMgICA6IDAtMjNcclxuICAgICAgICAgIGNhc2UgJ2hoJyA6IHJldHVybiBseihnZXQoSE9VUlMpKTsgICAgICAgICAgICAgICAgLy8gSG91cnMgICA6IDAwLTIzXHJcbiAgICAgICAgICBjYXNlICdEJyAgOiByZXR1cm4gZ2V0KERBVEUpOyAgICAgICAgICAgICAgICAgICAgIC8vIERhdGUgICAgOiAxLTMxXHJcbiAgICAgICAgICBjYXNlICdERCcgOiByZXR1cm4gbHooZ2V0KERBVEUpKTsgICAgICAgICAgICAgICAgIC8vIERhdGUgICAgOiAwMS0zMVxyXG4gICAgICAgICAgY2FzZSAnVycgIDogcmV0dXJuIGRpY3RbMF1bZ2V0KCdEYXknKV07ICAgICAgICAgICAvLyBEYXkgICAgIDog0J/QvtC90LXQtNC10LvRjNC90LjQulxyXG4gICAgICAgICAgY2FzZSAnTicgIDogcmV0dXJuIGdldChNT05USCkgKyAxOyAgICAgICAgICAgICAgICAvLyBNb250aCAgIDogMS0xMlxyXG4gICAgICAgICAgY2FzZSAnTk4nIDogcmV0dXJuIGx6KGdldChNT05USCkgKyAxKTsgICAgICAgICAgICAvLyBNb250aCAgIDogMDEtMTJcclxuICAgICAgICAgIGNhc2UgJ00nICA6IHJldHVybiBkaWN0WzJdW2dldChNT05USCldOyAgICAgICAgICAgLy8gTW9udGggICA6INCv0L3QstCw0YDRjFxyXG4gICAgICAgICAgY2FzZSAnTU0nIDogcmV0dXJuIGRpY3RbMV1bZ2V0KE1PTlRIKV07ICAgICAgICAgICAvLyBNb250aCAgIDog0K/QvdCy0LDRgNGPXHJcbiAgICAgICAgICBjYXNlICdZJyAgOiByZXR1cm4gZ2V0KFlFQVIpOyAgICAgICAgICAgICAgICAgICAgIC8vIFllYXIgICAgOiAyMDE0XHJcbiAgICAgICAgICBjYXNlICdZWScgOiByZXR1cm4gbHooZ2V0KFlFQVIpICUgMTAwKTsgICAgICAgICAgIC8vIFllYXIgICAgOiAxNFxyXG4gICAgICAgIH0gcmV0dXJuIHBhcnQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBhZGRMb2NhbGUobGFuZywgbG9jYWxlKXtcclxuICAgIGZ1bmN0aW9uIHNwbGl0KGluZGV4KXtcclxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICBmb3JFYWNoLmNhbGwoYXJyYXkobG9jYWxlLm1vbnRocyksIGZ1bmN0aW9uKGl0KXtcclxuICAgICAgICByZXN1bHQucHVzaChpdC5yZXBsYWNlKGZsZXhpb1JlZ0V4cCwgJyQnICsgaW5kZXgpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBsb2NhbGVzW2xhbmddID0gW2FycmF5KGxvY2FsZS53ZWVrZGF5cyksIHNwbGl0KDEpLCBzcGxpdCgyKV07XHJcbiAgICByZXR1cm4gY29yZTtcclxuICB9XHJcbiAgJGRlZmluZShQUk9UTyArIEZPUkNFRCwgREFURSwge1xyXG4gICAgZm9ybWF0OiAgICBjcmVhdGVGb3JtYXQoJ2dldCcpLFxyXG4gICAgZm9ybWF0VVRDOiBjcmVhdGVGb3JtYXQoJ2dldFVUQycpXHJcbiAgfSk7XHJcbiAgYWRkTG9jYWxlKGN1cnJlbnQsIHtcclxuICAgIHdlZWtkYXlzOiAnU3VuZGF5LE1vbmRheSxUdWVzZGF5LFdlZG5lc2RheSxUaHVyc2RheSxGcmlkYXksU2F0dXJkYXknLFxyXG4gICAgbW9udGhzOiAnSmFudWFyeSxGZWJydWFyeSxNYXJjaCxBcHJpbCxNYXksSnVuZSxKdWx5LEF1Z3VzdCxTZXB0ZW1iZXIsT2N0b2JlcixOb3ZlbWJlcixEZWNlbWJlcidcclxuICB9KTtcclxuICBhZGRMb2NhbGUoJ3J1Jywge1xyXG4gICAgd2Vla2RheXM6ICfQktC+0YHQutGA0LXRgdC10L3RjNC1LNCf0L7QvdC10LTQtdC70YzQvdC40Los0JLRgtC+0YDQvdC40Los0KHRgNC10LTQsCzQp9C10YLQstC10YDQsyzQn9GP0YLQvdC40YbQsCzQodGD0LHQsdC+0YLQsCcsXHJcbiAgICBtb250aHM6ICfQr9C90LLQsNGAOtGPfNGMLNCk0LXQstGA0LDQuzrRj3zRjCzQnNCw0YDRgjrQsHws0JDQv9GA0LXQuzrRj3zRjCzQnNCwOtGPfNC5LNCY0Y7QvTrRj3zRjCwnICtcclxuICAgICAgICAgICAgJ9CY0Y7QuzrRj3zRjCzQkNCy0LPRg9GB0YI60LB8LNCh0LXQvdGC0Y/QsdGAOtGPfNGMLNCe0LrRgtGP0LHRgDrRj3zRjCzQndC+0Y/QsdGAOtGPfNGMLNCU0LXQutCw0LHRgDrRj3zRjCdcclxuICB9KTtcclxuICBjb3JlLmxvY2FsZSA9IGZ1bmN0aW9uKGxvY2FsZSl7XHJcbiAgICByZXR1cm4gaGFzKGxvY2FsZXMsIGxvY2FsZSkgPyBjdXJyZW50ID0gbG9jYWxlIDogY3VycmVudDtcclxuICB9O1xyXG4gIGNvcmUuYWRkTG9jYWxlID0gYWRkTG9jYWxlO1xyXG59KC9cXGJcXHdcXHc/XFxiL2csIC86KC4qKVxcfCguKikkLywge30sICdlbicsICdTZWNvbmRzJywgJ01pbnV0ZXMnLCAnSG91cnMnLCAnTW9udGgnLCAnRnVsbFllYXInKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogY29yZS5nbG9iYWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuJGRlZmluZShHTE9CQUwgKyBGT1JDRUQsIHtnbG9iYWw6IGdsb2JhbH0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBqcy5hcnJheS5zdGF0aWNzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBKYXZhU2NyaXB0IDEuNiAvIFN0cmF3bWFuIGFycmF5IHN0YXRpY3Mgc2hpbVxyXG4hZnVuY3Rpb24oYXJyYXlTdGF0aWNzKXtcclxuICBmdW5jdGlvbiBzZXRBcnJheVN0YXRpY3Moa2V5cywgbGVuZ3RoKXtcclxuICAgIGZvckVhY2guY2FsbChhcnJheShrZXlzKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgICAgaWYoa2V5IGluIEFycmF5UHJvdG8pYXJyYXlTdGF0aWNzW2tleV0gPSBjdHgoY2FsbCwgQXJyYXlQcm90b1trZXldLCBsZW5ndGgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldEFycmF5U3RhdGljcygncG9wLHJldmVyc2Usc2hpZnQsa2V5cyx2YWx1ZXMsZW50cmllcycsIDEpO1xyXG4gIHNldEFycmF5U3RhdGljcygnaW5kZXhPZixldmVyeSxzb21lLGZvckVhY2gsbWFwLGZpbHRlcixmaW5kLGZpbmRJbmRleCxpbmNsdWRlcycsIDMpO1xyXG4gIHNldEFycmF5U3RhdGljcygnam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLCcgK1xyXG4gICAgICAgICAgICAgICAgICAncmVkdWNlLHJlZHVjZVJpZ2h0LGNvcHlXaXRoaW4sZmlsbCx0dXJuJyk7XHJcbiAgJGRlZmluZShTVEFUSUMsIEFSUkFZLCBhcnJheVN0YXRpY3MpO1xyXG59KHt9KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogd2ViLmRvbS5pdGFyYWJsZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKE5vZGVMaXN0KXtcclxuICBpZihmcmFtZXdvcmsgJiYgTm9kZUxpc3QgJiYgIShTWU1CT0xfSVRFUkFUT1IgaW4gTm9kZUxpc3RbUFJPVE9UWVBFXSkpe1xyXG4gICAgaGlkZGVuKE5vZGVMaXN0W1BST1RPVFlQRV0sIFNZTUJPTF9JVEVSQVRPUiwgSXRlcmF0b3JzW0FSUkFZXSk7XHJcbiAgfVxyXG4gIEl0ZXJhdG9ycy5Ob2RlTGlzdCA9IEl0ZXJhdG9yc1tBUlJBWV07XHJcbn0oZ2xvYmFsLk5vZGVMaXN0KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogY29yZS5sb2cgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKGxvZywgZW5hYmxlZCl7XHJcbiAgLy8gTWV0aG9kcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9EZXZlbG9wZXJUb29sc1dHL2NvbnNvbGUtb2JqZWN0L2Jsb2IvbWFzdGVyL2FwaS5tZFxyXG4gIGZvckVhY2guY2FsbChhcnJheSgnYXNzZXJ0LGNsZWFyLGNvdW50LGRlYnVnLGRpcixkaXJ4bWwsZXJyb3IsZXhjZXB0aW9uLCcgK1xyXG4gICAgICAnZ3JvdXAsZ3JvdXBDb2xsYXBzZWQsZ3JvdXBFbmQsaW5mbyxpc0luZGVwZW5kZW50bHlDb21wb3NlZCxsb2csJyArXHJcbiAgICAgICdtYXJrVGltZWxpbmUscHJvZmlsZSxwcm9maWxlRW5kLHRhYmxlLHRpbWUsdGltZUVuZCx0aW1lbGluZSwnICtcclxuICAgICAgJ3RpbWVsaW5lRW5kLHRpbWVTdGFtcCx0cmFjZSx3YXJuJyksIGZ1bmN0aW9uKGtleSl7XHJcbiAgICBsb2dba2V5XSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGlmKGVuYWJsZWQgJiYga2V5IGluIGNvbnNvbGUpcmV0dXJuIGFwcGx5LmNhbGwoY29uc29sZVtrZXldLCBjb25zb2xlLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICB9KTtcclxuICAkZGVmaW5lKEdMT0JBTCArIEZPUkNFRCwge2xvZzogYXNzaWduKGxvZy5sb2csIGxvZywge1xyXG4gICAgZW5hYmxlOiBmdW5jdGlvbigpe1xyXG4gICAgICBlbmFibGVkID0gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBkaXNhYmxlOiBmdW5jdGlvbigpe1xyXG4gICAgICBlbmFibGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSl9KTtcclxufSh7fSwgdHJ1ZSk7XG59KHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpLCBmYWxzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IG1vZHVsZS5leHBvcnRzLCBfX2VzTW9kdWxlOiB0cnVlIH07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9jb3JlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qc1wiKVtcImRlZmF1bHRcIl07XG5cbnZhciBoZWxwZXJzID0gZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB7fTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmhlbHBlcnMuaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cbmhlbHBlcnMuZGVmYXVsdHMgPSBmdW5jdGlvbiAob2JqLCBkZWZhdWx0cykge1xuICB2YXIga2V5cyA9IF9jb3JlLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlZmF1bHRzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgIHZhciB2YWx1ZSA9IF9jb3JlLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdHMsIGtleSk7XG5cbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuY29uZmlndXJhYmxlICYmIG9ialtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5oZWxwZXJzLnByb3RvdHlwZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoY2hpbGQsIHN0YXRpY1Byb3BzLCBpbnN0YW5jZVByb3BzKSB7XG4gIGlmIChzdGF0aWNQcm9wcykgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2hpbGQsIHN0YXRpY1Byb3BzKTtcbiAgaWYgKGluc3RhbmNlUHJvcHMpIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNoaWxkLnByb3RvdHlwZSwgaW5zdGFuY2VQcm9wcyk7XG59O1xuXG5oZWxwZXJzLmFwcGx5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGFyZ3MpIHtcbiAgdmFyIGluc3RhbmNlID0gT2JqZWN0LmNyZWF0ZShDb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICB2YXIgcmVzdWx0ID0gQ29uc3RydWN0b3IuYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xuICByZXR1cm4gcmVzdWx0ICE9IG51bGwgJiYgKHR5cGVvZiByZXN1bHQgPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcmVzdWx0ID09IFwiZnVuY3Rpb25cIikgPyByZXN1bHQgOiBpbnN0YW5jZTtcbn07XG5cbmhlbHBlcnMudGFnZ2VkVGVtcGxhdGVMaXRlcmFsID0gZnVuY3Rpb24gKHN0cmluZ3MsIHJhdykge1xuICByZXR1cm4gX2NvcmUuT2JqZWN0LmZyZWV6ZShPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7XG4gICAgcmF3OiB7XG4gICAgICB2YWx1ZTogX2NvcmUuT2JqZWN0LmZyZWV6ZShyYXcpXG4gICAgfVxuICB9KSk7XG59O1xuXG5oZWxwZXJzLnRhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlID0gZnVuY3Rpb24gKHN0cmluZ3MsIHJhdykge1xuICBzdHJpbmdzLnJhdyA9IHJhdztcbiAgcmV0dXJuIHN0cmluZ3M7XG59O1xuXG5oZWxwZXJzLmludGVyb3BSZXF1aXJlID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqW1wiZGVmYXVsdFwiXSA6IG9iajtcbn07XG5cbmhlbHBlcnMudG9BcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSA/IGFyciA6IF9jb3JlLkFycmF5LmZyb20oYXJyKTtcbn07XG5cbmhlbHBlcnMudG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIF9jb3JlLkFycmF5LmZyb20oYXJyKTtcbiAgfVxufTtcblxuaGVscGVycy5zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKGFyciwgaSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIGlmIChfY29yZS4kZm9yLmlzSXRlcmFibGUoT2JqZWN0KGFycikpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jb3JlLiRmb3IuZ2V0SXRlcmF0b3IoYXJyKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgICAgX2Fyci5wdXNoKF9zdGVwLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICB9XG59O1xuXG5oZWxwZXJzLm9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5oZWxwZXJzLmhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5oZWxwZXJzLnNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuaGVscGVycy5iaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG5cbmhlbHBlcnMuZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSk7XG59O1xuXG5oZWxwZXJzLmFzeW5jVG9HZW5lcmF0b3IgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gbmV3IF9jb3JlLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGNhbGxOZXh0ID0gc3RlcC5iaW5kKG51bGwsIFwibmV4dFwiKTtcbiAgICAgIHZhciBjYWxsVGhyb3cgPSBzdGVwLmJpbmQobnVsbCwgXCJ0aHJvd1wiKTtcblxuICAgICAgZnVuY3Rpb24gc3RlcChrZXksIGFyZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9jb3JlLlByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihjYWxsTmV4dCwgY2FsbFRocm93KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsTmV4dCgpO1xuICAgIH0pO1xuICB9O1xufTtcblxuaGVscGVycy5pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn07XG5cbmhlbHBlcnMuX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9jb3JlLlN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuaGVscGVycy5fZXh0ZW5kcyA9IF9jb3JlLk9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5oZWxwZXJzLmdldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHtcbiAgdmFyIF9hZ2FpbiA9IHRydWU7XG5cbiAgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7XG4gICAgX2FnYWluID0gZmFsc2U7XG4gICAgdmFyIG9iamVjdCA9IF94LFxuICAgICAgICBwcm9wZXJ0eSA9IF94MixcbiAgICAgICAgcmVjZWl2ZXIgPSBfeDM7XG4gICAgZGVzYyA9IHBhcmVudCA9IGdldHRlciA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBkZXNjID0gX2NvcmUuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBfY29yZS5PYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3ggPSBwYXJlbnQ7XG4gICAgICAgIF94MiA9IHByb3BlcnR5O1xuICAgICAgICBfeDMgPSByZWNlaXZlcjtcbiAgICAgICAgX2FnYWluID0gdHJ1ZTtcbiAgICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MgJiYgZGVzYy53cml0YWJsZSkge1xuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgICAgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7XG4gICAgfVxuICB9XG59O1xuXG5oZWxwZXJzLnNldCA9IGZ1bmN0aW9uIHNldChfeCwgX3gyLCBfeDMsIF94NCkge1xuICB2YXIgX2FnYWluID0gdHJ1ZTtcblxuICBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHtcbiAgICBfYWdhaW4gPSBmYWxzZTtcbiAgICB2YXIgb2JqZWN0ID0gX3gsXG4gICAgICAgIHByb3BlcnR5ID0gX3gyLFxuICAgICAgICB2YWx1ZSA9IF94MyxcbiAgICAgICAgcmVjZWl2ZXIgPSBfeDQ7XG4gICAgZGVzYyA9IHBhcmVudCA9IHNldHRlciA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBkZXNjID0gX2NvcmUuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBfY29yZS5PYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBfeCA9IHBhcmVudDtcbiAgICAgICAgX3gyID0gcHJvcGVydHk7XG4gICAgICAgIF94MyA9IHZhbHVlO1xuICAgICAgICBfeDQgPSByZWNlaXZlcjtcbiAgICAgICAgX2FnYWluID0gdHJ1ZTtcbiAgICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MgJiYgZGVzYy53cml0YWJsZSkge1xuICAgICAgcmV0dXJuIGRlc2MudmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNldHRlciA9IGRlc2Muc2V0O1xuXG4gICAgICBpZiAoc2V0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNldHRlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5oZWxwZXJzLmNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbmhlbHBlcnMub2JqZWN0RGVzdHJ1Y3R1cmluZ0VtcHR5ID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgZGVzdHJ1Y3R1cmUgdW5kZWZpbmVkXCIpO1xufTtcblxuaGVscGVycy50ZW1wb3JhbFVuZGVmaW5lZCA9IHt9O1xuXG5oZWxwZXJzLnRlbXBvcmFsQXNzZXJ0RGVmaW5lZCA9IGZ1bmN0aW9uICh2YWwsIG5hbWUsIHVuZGVmKSB7XG4gIGlmICh2YWwgPT09IHVuZGVmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG5hbWUgKyBcIiBpcyBub3QgZGVmaW5lZCAtIHRlbXBvcmFsIGRlYWQgem9uZVwiKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuaGVscGVycy5zZWxmR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiBnbG9iYWw7IiwiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOiB0aGlzO1xuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoYWRSdW50aW1lID0gaGFzT3duLmNhbGwoZywgXCJyZWdlbmVyYXRvclJ1bnRpbWVcIik7XG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5kZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7IC8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuXG5pZiAoaGFkUnVudGltZSkge1xuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XG59IGVsc2Uge1xuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxuICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogbW9kdWxlLmV4cG9ydHMsIF9fZXNNb2R1bGU6IHRydWUgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzXCIpW1wiZGVmYXVsdFwiXTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIF9jb3JlLlN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIF9jb3JlLlN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICByZXR1cm4gbmV3IEdlbmVyYXRvcihpbm5lckZuLCBvdXRlckZuLCBzZWxmIHx8IG51bGwsIHRyeUxvY3NMaXN0IHx8IFtdKTtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHJldHVybiBuZXcgX2NvcmUuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCk7XG4gICAgICB2YXIgY2FsbE5leHQgPSBzdGVwLmJpbmQoZ2VuZXJhdG9yLm5leHQpO1xuICAgICAgdmFyIGNhbGxUaHJvdyA9IHN0ZXAuYmluZChnZW5lcmF0b3JbXCJ0aHJvd1wiXSk7XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXAoYXJnKSB7XG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaCh0aGlzLCBudWxsLCBhcmcpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICByZXNvbHZlKGluZm8udmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9jb3JlLlByb21pc2UucmVzb2x2ZShpbmZvLnZhbHVlKS50aGVuKGNhbGxOZXh0LCBjYWxsVGhyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxOZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGdlbmVyYXRvciA9IG91dGVyRm4gPyBPYmplY3QuY3JlYXRlKG91dGVyRm4ucHJvdG90eXBlKSA6IHRoaXM7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCk7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0sIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCAmJiB0eXBlb2YgYXJnICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdCB0byBzZW5kIFwiICsgSlNPTi5zdHJpbmdpZnkoYXJnKSArIFwiIHRvIG5ld2Jvcm4gZ2VuZXJhdG9yXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCkge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gYXJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgY29udGV4dC5zZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBHZW5TdGF0ZUNvbXBsZXRlZCA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG5cbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihyZWNvcmQuYXJnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZW5lcmF0b3IubmV4dCA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJuZXh0XCIpO1xuICAgIGdlbmVyYXRvcltcInRocm93XCJdID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIGdlbmVyYXRvcltcInJldHVyblwiXSA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJyZXR1cm5cIik7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgLy8gUHJlLWluaXRpYWxpemUgYXQgbGVhc3QgMjAgdGVtcG9yYXJ5IHZhcmlhYmxlcyB0byBlbmFibGUgaGlkZGVuXG4gICAgICAvLyBjbGFzcyBvcHRpbWl6YXRpb25zIGZvciBzaW1wbGUgZ2VuZXJhdG9ycy5cbiAgICAgIGZvciAodmFyIHRlbXBJbmRleCA9IDAsIHRlbXBOYW1lOyBoYXNPd24uY2FsbCh0aGlzLCB0ZW1wTmFtZSA9IFwidFwiICsgdGVtcEluZGV4KSB8fCB0ZW1wSW5kZXggPCAyMDsgKyt0ZW1wSW5kZXgpIHtcbiAgICAgICAgdGhpc1t0ZW1wTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJiAodHlwZSA9PT0gXCJicmVha1wiIHx8IHR5cGUgPT09IFwiY29udGludWVcIikgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDwgZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fCByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4vLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4vLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3Rcbi8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG50eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6IHVuZGVmaW5lZCk7IiwidmFyIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2FycmF5RWFjaCcpLFxuICAgIGJhc2VFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZUVhY2gnKSxcbiAgICBiaW5kQ2FsbGJhY2sgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iaW5kQ2FsbGJhY2snKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBJdGVyYXRvciBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5XG4gKiBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBgbGVuZ3RoYCBwcm9wZXJ0eVxuICogYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIGBfLmZvckluYCBvciBgXy5mb3JPd25gXG4gKiBtYXkgYmUgdXNlZCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGFsaWFzIGVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXyhbMSwgMl0pLmZvckVhY2goZnVuY3Rpb24obikge1xuICogICBjb25zb2xlLmxvZyhuKTtcbiAqIH0pLnZhbHVlKCk7XG4gKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUgZnJvbSBsZWZ0IHRvIHJpZ2h0IGFuZCByZXR1cm5zIHRoZSBhcnJheVxuICpcbiAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKG4sIGtleSkge1xuICogICBjb25zb2xlLmxvZyhuLCBrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUta2V5IHBhaXIgYW5kIHJldHVybnMgdGhlIG9iamVjdCAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gIHJldHVybiAodHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgJiYgaXNBcnJheShjb2xsZWN0aW9uKSlcbiAgICA/IGFycmF5RWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSlcbiAgICA6IGJhc2VFYWNoKGNvbGxlY3Rpb24sIGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG4iLCJ2YXIgYmFzZVJhbmRvbSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VSYW5kb20nKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzSXRlcmF0ZWVDYWxsJyksXG4gICAgc2h1ZmZsZSA9IHJlcXVpcmUoJy4vc2h1ZmZsZScpLFxuICAgIHRvSXRlcmFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC90b0l0ZXJhYmxlJyk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IG9yIGBuYCByYW5kb20gZWxlbWVudHMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBzYW1wbGUocykuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gKiAvLyA9PiAyXG4gKlxuICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdLCAyKTtcbiAqIC8vID0+IFszLCAxXVxuICovXG5mdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgY29sbGVjdGlvbiA9IHRvSXRlcmFibGUoY29sbGVjdGlvbik7XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPiAwID8gY29sbGVjdGlvbltiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gc2h1ZmZsZShjb2xsZWN0aW9uKTtcbiAgcmVzdWx0Lmxlbmd0aCA9IG5hdGl2ZU1pbihuIDwgMCA/IDAgOiAoK24gfHwgMCksIHJlc3VsdC5sZW5ndGgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhbXBsZTtcbiIsInZhciBiYXNlUmFuZG9tID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZVJhbmRvbScpLFxuICAgIHRvSXRlcmFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC90b0l0ZXJhYmxlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGUgRmlzaGVyLVlhdGVzXG4gKiBzaHVmZmxlLiBTZWUgW1dpa2lwZWRpYV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIGNvbGxlY3Rpb24gPSB0b0l0ZXJhYmxlKGNvbGxlY3Rpb24pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKDAsIGluZGV4KTtcbiAgICBpZiAoaW5kZXggIT0gcmFuZCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdFtyYW5kXTtcbiAgICB9XG4gICAgcmVzdWx0W3JhbmRdID0gY29sbGVjdGlvbltpbmRleF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaHVmZmxlO1xuIiwidmFyIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNMZW5ndGgnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi4vb2JqZWN0L2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgYGNvbGxlY3Rpb24ubGVuZ3RoYCBmb3JcbiAqIGFycmF5LWxpa2UgdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICogLy8gPT4gMlxuICpcbiAqIF8uc2l6ZSgncGViYmxlcycpO1xuICogLy8gPT4gN1xuICovXG5mdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gIHJldHVybiBpc0xlbmd0aChsZW5ndGgpID8gbGVuZ3RoIDoga2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2l6ZTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlDb3B5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5Q29weTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICogc2hvcnRoYW5kcyBvciBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9iYXNlUHJvcGVydHknKSxcbiAgICBiaW5kQ2FsbGJhY2sgPSByZXF1aXJlKCcuL2JpbmRDYWxsYmFjaycpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vdXRpbGl0eS9pZGVudGl0eScpLFxuICAgIGlzQmluZGFibGUgPSByZXF1aXJlKCcuL2lzQmluZGFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jYWxsYmFja2Agd2hpY2ggc3VwcG9ydHMgc3BlY2lmeWluZyB0aGVcbiAqIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGJhc2VDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBmdW5jO1xuICBpZiAodHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdGhpc0FyZyAhPSAndW5kZWZpbmVkJyAmJiBpc0JpbmRhYmxlKGZ1bmMpKVxuICAgICAgPyBiaW5kQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpXG4gICAgICA6IGZ1bmM7XG4gIH1cbiAgaWYgKGZ1bmMgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBiYXNlTWF0Y2hlcyhmdW5jKTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCdcbiAgICA/IGJhc2VQcm9wZXJ0eShmdW5jICsgJycpXG4gICAgOiBiYXNlTWF0Y2hlc1Byb3BlcnR5KGZ1bmMgKyAnJywgdGhpc0FyZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNhbGxiYWNrO1xuIiwidmFyIGFycmF5Q29weSA9IHJlcXVpcmUoJy4vYXJyYXlDb3B5JyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9hcnJheUVhY2gnKSxcbiAgICBiYXNlQ29weSA9IHJlcXVpcmUoJy4vYmFzZUNvcHknKSxcbiAgICBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9iYXNlRm9yT3duJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL2luaXRDbG9uZUFycmF5JyksXG4gICAgaW5pdENsb25lQnlUYWcgPSByZXF1aXJlKCcuL2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID1cbmNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDhUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgYHRvU3RyaW5nVGFnYCBvZiB2YWx1ZXMuXG4gKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nXG4gKiBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgYHZhbHVlYCBiZWxvbmdzIHRvLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCkgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGFycmF5Q29weSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IG9ialRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZztcblxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZU9iamVjdChpc0Z1bmMgPyB7fSA6IHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBiYXNlQ29weSh2YWx1ZSwgcmVzdWx0LCBrZXlzKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjbG9uZWFibGVUYWdzW3RhZ11cbiAgICAgICAgPyBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApXG4gICAgICAgIDogKG9iamVjdCA/IHZhbHVlIDoge30pO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF07XG4gICAgfVxuICB9XG4gIC8vIEFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lLlxuICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgKGlzQXJyID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikodmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFja0EsIHN0YWNrQik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gY29weS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDb3B5KHNvdXJjZSwgb2JqZWN0LCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcHJvcHMgPSBvYmplY3Q7XG4gICAgb2JqZWN0ID0ge307XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ29weTtcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9iYXNlRm9yT3duJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9PYmplY3QgPSByZXF1aXJlKCcuL3RvT2JqZWN0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG5mdW5jdGlvbiBiYXNlRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgcmV0dXJuIGJhc2VGb3JPd24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaXRlcmFibGUgPSB0b09iamVjdChjb2xsZWN0aW9uKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCJ2YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL3RvT2JqZWN0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JJbmAgYW5kIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlc1xuICogb3ZlciBgb2JqZWN0YCBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3JcbiAqIGVhY2ggcHJvcGVydHkuIEl0ZXJhdG9yIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseVxuICogcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpdGVyYWJsZSA9IHRvT2JqZWN0KG9iamVjdCksXG4gICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vYmFzZUZvcicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9ySW47XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuLi9vYmplY3Qva2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9iYXNlSXNFcXVhbERlZXAnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aXRob3V0IHN1cHBvcnQgZm9yIGB0aGlzYCBiaW5kaW5nXG4gKiBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1doZXJlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIGlkZW50aWNhbCB2YWx1ZXMuXG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAvLyBUcmVhdCBgKzBgIHZzLiBgLTBgIGFzIG5vdCBlcXVhbC5cbiAgICByZXR1cm4gdmFsdWUgIT09IDAgfHwgKDEgLyB2YWx1ZSA9PSAxIC8gb3RoZXIpO1xuICB9XG4gIHZhciB2YWxUeXBlID0gdHlwZW9mIHZhbHVlLFxuICAgICAgb3RoVHlwZSA9IHR5cGVvZiBvdGhlcjtcblxuICAvLyBFeGl0IGVhcmx5IGZvciB1bmxpa2UgcHJpbWl0aXZlIHZhbHVlcy5cbiAgaWYgKCh2YWxUeXBlICE9ICdmdW5jdGlvbicgJiYgdmFsVHlwZSAhPSAnb2JqZWN0JyAmJiBvdGhUeXBlICE9ICdmdW5jdGlvbicgJiYgb3RoVHlwZSAhPSAnb2JqZWN0JykgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCkge1xuICAgIC8vIFJldHVybiBgZmFsc2VgIHVubGVzcyBib3RoIHZhbHVlcyBhcmUgYE5hTmAuXG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBjdXN0b21pemVyLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vZXF1YWxPYmplY3RzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgdmFsdWVzLlxuICogU2VlIHRoZSBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgb2JqZWN0cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzV2hlcmVdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gYXJyYXlUYWcsXG4gICAgICBvdGhUYWcgPSBhcnJheVRhZztcblxuICBpZiAoIW9iaklzQXJyKSB7XG4gICAgb2JqVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICAgIGlmIChvYmpUYWcgPT0gYXJnc1RhZykge1xuICAgICAgb2JqVGFnID0gb2JqZWN0VGFnO1xuICAgIH0gZWxzZSBpZiAob2JqVGFnICE9IG9iamVjdFRhZykge1xuICAgICAgb2JqSXNBcnIgPSBpc1R5cGVkQXJyYXkob2JqZWN0KTtcbiAgICB9XG4gIH1cbiAgaWYgKCFvdGhJc0Fycikge1xuICAgIG90aFRhZyA9IG9ialRvU3RyaW5nLmNhbGwob3RoZXIpO1xuICAgIGlmIChvdGhUYWcgPT0gYXJnc1RhZykge1xuICAgICAgb3RoVGFnID0gb2JqZWN0VGFnO1xuICAgIH0gZWxzZSBpZiAob3RoVGFnICE9IG9iamVjdFRhZykge1xuICAgICAgb3RoSXNBcnIgPSBpc1R5cGVkQXJyYXkob3RoZXIpO1xuICAgIH1cbiAgfVxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmICEob2JqSXNBcnIgfHwgb2JqSXNPYmopKSB7XG4gICAgcmV0dXJuIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnKTtcbiAgfVxuICB2YXIgdmFsV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgIG90aFdyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICBpZiAodmFsV3JhcHBlZCB8fCBvdGhXcmFwcGVkKSB7XG4gICAgcmV0dXJuIGVxdWFsRnVuYyh2YWxXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsIG90aFdyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXIsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGRldGVjdGluZyBjaXJjdWxhciByZWZlcmVuY2VzIHNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI0pPLlxuICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cbiAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBvYmplY3QpIHtcbiAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PSBvdGhlcjtcbiAgICB9XG4gIH1cbiAgLy8gQWRkIGBvYmplY3RgIGFuZCBgb3RoZXJgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgc3RhY2tBLnB1c2gob2JqZWN0KTtcbiAgc3RhY2tCLnB1c2gob3RoZXIpO1xuXG4gIHZhciByZXN1bHQgPSAob2JqSXNBcnIgPyBlcXVhbEFycmF5cyA6IGVxdWFsT2JqZWN0cykob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQik7XG5cbiAgc3RhY2tBLnBvcCgpO1xuICBzdGFja0IucG9wKCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRnVuY3Rpb25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZW52aXJvbm1lbnRzXG4gKiB3aXRoIGluY29ycmVjdCBgdHlwZW9mYCByZXN1bHRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgQ2hha3JhIEpJVCBidWcgaW4gY29tcGF0aWJpbGl0eSBtb2RlcyBvZiBJRSAxMS5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9pc3N1ZXMvMTYyMSBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRnVuY3Rpb247XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAqIHNob3J0aGFuZHMgb3IgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHNvdXJjZSBwcm9wZXJ0eSBuYW1lcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgc291cmNlIHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IHN0cmljdENvbXBhcmVGbGFncyBTdHJpY3QgY29tcGFyaXNvbiBmbGFncyBmb3Igc291cmNlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBwcm9wcywgdmFsdWVzLCBzdHJpY3RDb21wYXJlRmxhZ3MsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIHN0cmljdENvbXBhcmVGbGFnc1tpbmRleF0pXG4gICAgICAgICAgPyB2YWx1ZXNbaW5kZXhdICE9PSBvYmplY3RbcHJvcHNbaW5kZXhdXVxuICAgICAgICAgIDogIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wc1tpbmRleF0pXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpbmRleCA9IC0xO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBzdHJpY3RDb21wYXJlRmxhZ3NbaW5kZXhdKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgIHNyY1ZhbHVlID0gdmFsdWVzW2luZGV4XTtcblxuICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmVzdWx0ID0gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBjdXN0b21pemVyLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL2Jhc2VJc01hdGNoJyksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi4vb2JqZWN0L2tleXMnKTtcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lcyBub3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoID09IDEpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbMF0sXG4gICAgICAgIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICBpZiAoaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgb2JqZWN0W2tleV0gPT09IHZhbHVlICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCksXG4gICAgICBzdHJpY3RDb21wYXJlRmxhZ3MgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhbHVlID0gc291cmNlW3Byb3BzW2xlbmd0aF1dO1xuICAgIHZhbHVlc1tsZW5ndGhdID0gdmFsdWU7XG4gICAgc3RyaWN0Q29tcGFyZUZsYWdzW2xlbmd0aF0gPSBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBwcm9wcywgdmFsdWVzLCBzdHJpY3RDb21wYXJlRmxhZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9iYXNlSXNFcXVhbCcpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vaXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2VzIG5vdCBjb2VyY2UgYGtleWBcbiAqIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShrZXksIHZhbHVlKSB7XG4gIGlmIChpc1N0cmljdENvbXBhcmFibGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIG9iamVjdFtrZXldID09PSB2YWx1ZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgYmFzZUlzRXF1YWwodmFsdWUsIG9iamVjdFtrZXldLCBudWxsLCB0cnVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwidmFyIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vYXJyYXlFYWNoJyksXG4gICAgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vYmFzZUZvck93bicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL2Jhc2VNZXJnZURlZXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzVHlwZWRBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLFxuICogbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnaW5nIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgdmFyIGlzU3JjQXJyID0gaXNMZW5ndGgoc291cmNlLmxlbmd0aCkgJiYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1R5cGVkQXJyYXkoc291cmNlKSk7XG4gIChpc1NyY0FyciA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSwgc291cmNlKSB7XG4gICAgaWYgKGlzT2JqZWN0TGlrZShzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG4gICAgICByZXR1cm4gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQsXG4gICAgICAgIGlzQ29tbW9uID0gdHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJztcblxuICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgcmVzdWx0ID0gc3JjVmFsdWU7XG4gICAgfVxuICAgIGlmICgoaXNTcmNBcnIgfHwgdHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgKGlzQ29tbW9uIHx8IChyZXN1bHQgPT09IHJlc3VsdCA/IHJlc3VsdCAhPT0gdmFsdWUgOiB2YWx1ZSA9PT0gdmFsdWUpKSkge1xuICAgICAgb2JqZWN0W2tleV0gPSByZXN1bHQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2U7XG4iLCJ2YXIgYXJyYXlDb3B5ID0gcmVxdWlyZSgnLi9hcnJheUNvcHknKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNUeXBlZEFycmF5JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnaW5nIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aCxcbiAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHNyY1ZhbHVlKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHN0YWNrQltsZW5ndGhdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQsXG4gICAgICBpc0NvbW1vbiA9IHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCc7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgcmVzdWx0ID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzTGVuZ3RoKHNyY1ZhbHVlLmxlbmd0aCkgJiYgKGlzQXJyYXkoc3JjVmFsdWUpIHx8IGlzVHlwZWRBcnJheShzcmNWYWx1ZSkpKSB7XG4gICAgICByZXN1bHQgPSBpc0FycmF5KHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogKHZhbHVlID8gYXJyYXlDb3B5KHZhbHVlKSA6IFtdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICByZXN1bHQgPSBpc0FyZ3VtZW50cyh2YWx1ZSlcbiAgICAgICAgPyB0b1BsYWluT2JqZWN0KHZhbHVlKVxuICAgICAgICA6IChpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDoge30pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgYXNzb2NpYXRlXG4gIC8vIGl0IHdpdGggaXRzIG1lcmdlZCB2YWx1ZS5cbiAgc3RhY2tBLnB1c2goc3JjVmFsdWUpO1xuICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIG9iamVjdFtrZXldID0gbWVyZ2VGdW5jKHJlc3VsdCwgc3JjVmFsdWUsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKTtcbiAgfSBlbHNlIGlmIChyZXN1bHQgPT09IHJlc3VsdCA/IHJlc3VsdCAhPT0gdmFsdWUgOiB2YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aGljaCBkb2VzIG5vdCBjb2VyY2UgYGtleWAgdG8gYSBzdHJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcbiIsIi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZ1xuICogYW5kIHJldHVybmluZyBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5kb20obWluLCBtYXgpIHtcbiAgcmV0dXJuIG1pbiArIGZsb29yKG5hdGl2ZVJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmFuZG9tO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vdXRpbGl0eS9pZGVudGl0eScpLFxuICAgIG1ldGFNYXAgPSByZXF1aXJlKCcuL21ldGFNYXAnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0RGF0YWAgd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBkZXRlY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0RGF0YSA9ICFtZXRhTWFwID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBkYXRhKSB7XG4gIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICByZXR1cm4gZnVuYztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldERhdGE7XG4iLCIvKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgaWYgaXQgaXMgbm90IG9uZS4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkXG4gKiBmb3IgYG51bGxgIG9yIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6ICh2YWx1ZSArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBvYmplY3RbcHJvcHNbaW5kZXhdXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VWYWx1ZXM7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi91dGlsaXR5L2lkZW50aXR5Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQ2FsbGJhY2tgIHdoaWNoIG9ubHkgc3VwcG9ydHMgYHRoaXNgIGJpbmRpbmdcbiAqIGFuZCBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxuICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kQ2FsbGJhY2s7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuLi91dGlsaXR5L2NvbnN0YW50JyksXG4gICAgaXNOYXRpdmUgPSByZXF1aXJlKCcuLi9sYW5nL2lzTmF0aXZlJyk7XG5cbi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgQXJyYXlCdWZmZXIgPSBpc05hdGl2ZShBcnJheUJ1ZmZlciA9IGdsb2JhbC5BcnJheUJ1ZmZlcikgJiYgQXJyYXlCdWZmZXIsXG4gICAgYnVmZmVyU2xpY2UgPSBpc05hdGl2ZShidWZmZXJTbGljZSA9IEFycmF5QnVmZmVyICYmIG5ldyBBcnJheUJ1ZmZlcigwKS5zbGljZSkgJiYgYnVmZmVyU2xpY2UsXG4gICAgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgIFVpbnQ4QXJyYXkgPSBpc05hdGl2ZShVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkpICYmIFVpbnQ4QXJyYXk7XG5cbi8qKiBVc2VkIHRvIGNsb25lIGFycmF5IGJ1ZmZlcnMuICovXG52YXIgRmxvYXQ2NEFycmF5ID0gKGZ1bmN0aW9uKCkge1xuICAvLyBTYWZhcmkgNSBlcnJvcnMgd2hlbiB1c2luZyBhbiBhcnJheSBidWZmZXIgdG8gaW5pdGlhbGl6ZSBhIHR5cGVkIGFycmF5XG4gIC8vIHdoZXJlIHRoZSBhcnJheSBidWZmZXIncyBgYnl0ZUxlbmd0aGAgaXMgbm90IGEgbXVsdGlwbGUgb2YgdGhlIHR5cGVkXG4gIC8vIGFycmF5J3MgYEJZVEVTX1BFUl9FTEVNRU5UYC5cbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGlzTmF0aXZlKGZ1bmMgPSBnbG9iYWwuRmxvYXQ2NEFycmF5KSAmJiBmdW5jLFxuICAgICAgICByZXN1bHQgPSBuZXcgZnVuYyhuZXcgQXJyYXlCdWZmZXIoMTApLCAwLCAxKSAmJiBmdW5jO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByZXN1bHQ7XG59KCkpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSwgaW4gYnl0ZXMsIG9mIGVhY2ggYEZsb2F0NjRBcnJheWAgZWxlbWVudC4gKi9cbnZhciBGTE9BVDY0X0JZVEVTX1BFUl9FTEVNRU5UID0gRmxvYXQ2NEFycmF5ID8gRmxvYXQ2NEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UIDogMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGdpdmVuIGFycmF5IGJ1ZmZlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyU2xpY2UuY2FsbChidWZmZXIsIDApO1xufVxuaWYgKCFidWZmZXJTbGljZSkge1xuICAvLyBQaGFudG9tSlMgaGFzIGBBcnJheUJ1ZmZlcmAgYW5kIGBVaW50OEFycmF5YCBidXQgbm90IGBGbG9hdDY0QXJyYXlgLlxuICBidWZmZXJDbG9uZSA9ICEoQXJyYXlCdWZmZXIgJiYgVWludDhBcnJheSkgPyBjb25zdGFudChudWxsKSA6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIHZhciBieXRlTGVuZ3RoID0gYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgIGZsb2F0TGVuZ3RoID0gRmxvYXQ2NEFycmF5ID8gZmxvb3IoYnl0ZUxlbmd0aCAvIEZMT0FUNjRfQllURVNfUEVSX0VMRU1FTlQpIDogMCxcbiAgICAgICAgb2Zmc2V0ID0gZmxvYXRMZW5ndGggKiBGTE9BVDY0X0JZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG5cbiAgICBpZiAoZmxvYXRMZW5ndGgpIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IEZsb2F0NjRBcnJheShyZXN1bHQsIDAsIGZsb2F0TGVuZ3RoKTtcbiAgICAgIHZpZXcuc2V0KG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyLCAwLCBmbG9hdExlbmd0aCkpO1xuICAgIH1cbiAgICBpZiAoYnl0ZUxlbmd0aCAhPSBvZmZzZXQpIHtcbiAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShyZXN1bHQsIG9mZnNldCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlckNsb25lO1xuIiwidmFyIGJpbmRDYWxsYmFjayA9IHJlcXVpcmUoJy4vYmluZENhbGxiYWNrJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYXNzaWducyBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gYSBnaXZlblxuICogZGVzdGluYXRpb24gb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIG9iamVjdCA9IGFyZ3VtZW50c1swXTtcblxuICAgIGlmIChsZW5ndGggPCAyIHx8IG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID4gMyAmJiBpc0l0ZXJhdGVlQ2FsbChhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKSkge1xuICAgICAgbGVuZ3RoID0gMjtcbiAgICB9XG4gICAgLy8gSnVnZ2xlIGFyZ3VtZW50cy5cbiAgICBpZiAobGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJndW1lbnRzW2xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBjdXN0b21pemVyID0gYmluZENhbGxiYWNrKGFyZ3VtZW50c1stLWxlbmd0aCAtIDFdLCBhcmd1bWVudHNbbGVuZ3RoLS1dLCA1KTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1tsZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXN0b21pemVyID0gYXJndW1lbnRzWy0tbGVuZ3RoXTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIGFycmF5cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzV2hlcmVdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1doZXJlICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgd2hpbGUgKHJlc3VsdCAmJiArK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgcmVzdWx0ID0gaXNXaGVyZVxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleClcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIGlmIChpc1doZXJlKSB7XG4gICAgICAgIHZhciBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgICAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW290aEluZGV4XTtcbiAgICAgICAgICByZXN1bHQgPSAoYXJyVmFsdWUgJiYgYXJyVmFsdWUgPT09IG90aFZhbHVlKSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSAoYXJyVmFsdWUgJiYgYXJyVmFsdWUgPT09IG90aFZhbHVlKSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAhIXJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsIi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtYmVycywgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzIGFuZCBib29sZWFuc1xuICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsLlxuICAgICAgcmV0dXJuICtvYmplY3QgPT0gK290aGVyO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIFRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbC5cbiAgICAgIHJldHVybiAob2JqZWN0ICE9ICtvYmplY3QpXG4gICAgICAgID8gb3RoZXIgIT0gK290aGVyXG4gICAgICAgIC8vIEJ1dCwgdHJlYXQgYC0wYCB2cy4gYCswYCBhcyBub3QgZXF1YWwuXG4gICAgICAgIDogKG9iamVjdCA9PSAwID8gKCgxIC8gb2JqZWN0KSA9PSAoMSAvIG90aGVyKSkgOiBvYmplY3QgPT0gK290aGVyKTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncyBwcmltaXRpdmVzIGFuZCBzdHJpbmdcbiAgICAgIC8vIG9iamVjdHMgYXMgZXF1YWwuIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xMC42LjQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwidmFyIGtleXMgPSByZXF1aXJlKCcuLi9vYmplY3Qva2V5cycpO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNXaGVyZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIHZhciBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0ga2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzV2hlcmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGhhc0N0b3IsXG4gICAgICBpbmRleCA9IC0xO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XSxcbiAgICAgICAgcmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KTtcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gaXNXaGVyZVxuICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSlcbiAgICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHJlc3VsdCA9IChvYmpWYWx1ZSAmJiBvYmpWYWx1ZSA9PT0gb3RoVmFsdWUpIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFzQ3RvciB8fCAoaGFzQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAoIWhhc0N0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcbiIsIi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuIiwidmFyIGJ1ZmZlckNsb25lID0gcmVxdWlyZSgnLi9idWZmZXJDbG9uZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gYnVmZmVyQ2xvbmUob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHZhciBidWZmZXIgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBDdG9yKGlzRGVlcCA/IGJ1ZmZlckNsb25lKGJ1ZmZlcikgOiBidWZmZXIsIG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QubGVuZ3RoKTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcihvYmplY3Quc291cmNlLCByZUZsYWdzLmV4ZWMob2JqZWN0KSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gb2JqZWN0Lmxhc3RJbmRleDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwiLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoISh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkge1xuICAgIEN0b3IgPSBPYmplY3Q7XG4gIH1cbiAgcmV0dXJuIG5ldyBDdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsInZhciBiYXNlU2V0RGF0YSA9IHJlcXVpcmUoJy4vYmFzZVNldERhdGEnKSxcbiAgICBpc05hdGl2ZSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNOYXRpdmUnKSxcbiAgICBzdXBwb3J0ID0gcmVxdWlyZSgnLi4vc3VwcG9ydCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbmFtZWQgZnVuY3Rpb25zLiAqL1xudmFyIHJlRnVuY05hbWUgPSAvXlxccypmdW5jdGlvblsgXFxuXFxyXFx0XStcXHcvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgZnVuY3Rpb25zIGNvbnRhaW5pbmcgYSBgdGhpc2AgcmVmZXJlbmNlLiAqL1xudmFyIHJlVGhpcyA9IC9cXGJ0aGlzXFxiLztcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBpcyBlbGlnaWJsZSBmb3IgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBlbGlnaWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0JpbmRhYmxlKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9ICEoc3VwcG9ydC5mdW5jTmFtZXMgPyBmdW5jLm5hbWUgOiBzdXBwb3J0LmZ1bmNEZWNvbXApO1xuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgdmFyIHNvdXJjZSA9IGZuVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICBpZiAoIXN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICByZXN1bHQgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAvLyBDaGVjayBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgICByZXN1bHQgPSByZVRoaXMudGVzdChzb3VyY2UpIHx8IGlzTmF0aXZlKGZ1bmMpO1xuICAgICAgYmFzZVNldERhdGEoZnVuYywgcmVzdWx0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0JpbmRhYmxlO1xuIiwiLyoqXG4gKiBVc2VkIGFzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICogU2VlIHRoZSBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzSW5kZXggPSByZXF1aXJlKCcuL2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgICAgcHJlcmVxID0gaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGluZGV4LCBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHByZXJlcSA9IHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0O1xuICB9XG4gIGlmIChwcmVyZXEpIHtcbiAgICB2YXIgb3RoZXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA9PT0gb3RoZXIgOiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwiLyoqXG4gKiBVc2VkIGFzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICogU2VlIHRoZSBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gRVMgYFRvTGVuZ3RoYC4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aClcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JykgfHwgZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICh2YWx1ZSA9PT0gMCA/ICgoMSAvIHZhbHVlKSA+IDApIDogIWlzT2JqZWN0KHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwidmFyIGlzTmF0aXZlID0gcmVxdWlyZSgnLi4vbGFuZy9pc05hdGl2ZScpO1xuXG4vKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIFdlYWtNYXAgPSBpc05hdGl2ZShXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXApICYmIFdlYWtNYXA7XG5cbi8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIG1ldGFNYXAgPSBXZWFrTWFwICYmIG5ldyBXZWFrTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1ldGFNYXA7XG4iLCJ2YXIgYmFzZUZvckluID0gcmVxdWlyZSgnLi9iYXNlRm9ySW4nKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgYHRvU3RyaW5nVGFnYCBvZiB2YWx1ZXMuXG4gKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNQbGFpbk9iamVjdGAgd2hpY2ggY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBoYXMgYSBgW1tQcm90b3R5cGVdXWBcbiAqIG9mIGBudWxsYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICB2YXIgQ3RvcjtcblxuICAvLyBFeGl0IGVhcmx5IGZvciBub24gYE9iamVjdGAgb2JqZWN0cy5cbiAgaWYgKCEoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RUYWcpIHx8XG4gICAgICAoIWhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjb25zdHJ1Y3RvcicpICYmXG4gICAgICAgIChDdG9yID0gdmFsdWUuY29uc3RydWN0b3IsIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgIShDdG9yIGluc3RhbmNlb2YgQ3RvcikpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBJRSA8IDkgaXRlcmF0ZXMgaW5oZXJpdGVkIHByb3BlcnRpZXMgYmVmb3JlIG93biBwcm9wZXJ0aWVzLiBJZiB0aGUgZmlyc3RcbiAgLy8gaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZFxuICAvLyBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gIHZhciByZXN1bHQ7XG4gIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgLy8gaXRzIGluaGVyaXRlZCBwcm9wZXJ0aWVzLiBJZiB0aGUgbGFzdCBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qnc1xuICAvLyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgYmFzZUZvckluKHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0ID0ga2V5O1xuICB9KTtcbiAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVzdWx0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGltSXNQbGFpbk9iamVjdDtcbiIsInZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vaXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzSW4nKSxcbiAgICBzdXBwb3J0ID0gcmVxdWlyZSgnLi4vc3VwcG9ydCcpO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZiB0aGVcbiAqIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIHNoaW1LZXlzKG9iamVjdCkge1xuICB2YXIgcHJvcHMgPSBrZXlzSW4ob2JqZWN0KSxcbiAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gcHJvcHNMZW5ndGggJiYgb2JqZWN0Lmxlbmd0aDtcblxuICB2YXIgYWxsb3dJbmRleGVzID0gbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IChzdXBwb3J0Lm5vbkVudW1BcmdzICYmIGlzQXJndW1lbnRzKG9iamVjdCkpKTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGltS2V5cztcbiIsInZhciBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKSxcbiAgICB2YWx1ZXMgPSByZXF1aXJlKCcuLi9vYmplY3QvdmFsdWVzJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS1saWtlIG9iamVjdCBpZiBpdCBpcyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgYXJyYXktbGlrZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvSXRlcmFibGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIHZhbHVlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogT2JqZWN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0l0ZXJhYmxlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gb2JqZWN0IGlmIGl0IGlzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IE9iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9PYmplY3Q7XG4iLCJ2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZUNsb25lJyksXG4gICAgYmluZENhbGxiYWNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmluZENhbGxiYWNrJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgbmVzdGVkIG9iamVjdHMgYXJlIGNsb25lZCxcbiAqIG90aGVyd2lzZSB0aGV5IGFyZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpc1xuICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0b1xuICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGUgc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG0uXG4gKiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kIG9iamVjdHMgY3JlYXRlZCBieVxuICogY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLiBBblxuICogZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaCBhcyBmdW5jdGlvbnMsIERPTSBub2RlcyxcbiAqIE1hcHMsIFNldHMsIGFuZCBXZWFrTWFwcy4gU2VlIHRoZSBbSFRNTDUgc3BlY2lmaWNhdGlvbl0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICogXTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUodXNlcnMpO1xuICogc2hhbGxvd1swXSA9PT0gdXNlcnNbMF07XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lKHVzZXJzLCB0cnVlKTtcbiAqIGRlZXBbMF0gPT09IHVzZXJzWzBdO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAqIHZhciBlbCA9IF8uY2xvbmUoZG9jdW1lbnQuYm9keSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICogICB9XG4gKiB9KTtcbiAqXG4gKiBlbCA9PT0gZG9jdW1lbnQuYm9keVxuICogLy8gPT4gZmFsc2VcbiAqIGVsLm5vZGVOYW1lXG4gKiAvLyA9PiBCT0RZXG4gKiBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAqIC8vID0+IDBcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICBpZiAoaXNEZWVwICYmIHR5cGVvZiBpc0RlZXAgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIpKSB7XG4gICAgaXNEZWVwID0gZmFsc2U7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGlzRGVlcCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpc0FyZyA9IGN1c3RvbWl6ZXI7XG4gICAgY3VzdG9taXplciA9IGlzRGVlcDtcbiAgICBpc0RlZXAgPSBmYWxzZTtcbiAgfVxuICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyAmJiBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSk7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG4iLCJ2YXIgaXNMZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgdmFsdWVzLlxuICogU2VlIHRoZSBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gaXNPYmplY3RMaWtlKHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIChpc0xlbmd0aChsZW5ndGgpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpIHx8IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwidmFyIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNMZW5ndGgnKSxcbiAgICBpc05hdGl2ZSA9IHJlcXVpcmUoJy4vaXNOYXRpdmUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBgdG9TdHJpbmdUYWdgIG9mIHZhbHVlcy5cbiAqIFNlZSB0aGUgW0VTIHNwZWNdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNBcnJheSA9IGlzTmF0aXZlKG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KSAmJiBuYXRpdmVJc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZykgfHwgZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgdmFsdWVzLlxuICogU2VlIHRoZSBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHwgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBib29sVGFnKSB8fCBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Jvb2xlYW47XG4iLCJ2YXIgYmFzZUlzRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlSXNGdW5jdGlvbicpLFxuICAgIGlzTmF0aXZlID0gcmVxdWlyZSgnLi9pc05hdGl2ZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgYHRvU3RyaW5nVGFnYCBvZiB2YWx1ZXMuXG4gKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSBpc05hdGl2ZShVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkpICYmIFVpbnQ4QXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0Z1bmN0aW9uID0gIShiYXNlSXNGdW5jdGlvbigveC8pIHx8IChVaW50OEFycmF5ICYmICFiYXNlSXNGdW5jdGlvbihVaW50OEFycmF5KSkpID8gYmFzZUlzRnVuY3Rpb24gOiBmdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsInZhciBlc2NhcGVSZWdFeHAgPSByZXF1aXJlKCcuLi9zdHJpbmcvZXNjYXBlUmVnRXhwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbnZhciByZUhvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgYHRvU3RyaW5nVGFnYCBvZiB2YWx1ZXMuXG4gKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGVzY2FwZVJlZ0V4cChvYmpUb1N0cmluZylcbiAgLnJlcGxhY2UoL3RvU3RyaW5nfChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmF0aXZlKF8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWcpIHtcbiAgICByZXR1cm4gcmVOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVIb3N0Q3Rvci50ZXN0KHZhbHVlKSkgfHwgZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOYXRpdmU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBsYW5ndWFnZSB0eXBlIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogKipOb3RlOioqIFNlZSB0aGUgW0VTNSBzcGVjXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09ICdmdW5jdGlvbicgfHwgKHZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCcpIHx8IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwidmFyIGlzTmF0aXZlID0gcmVxdWlyZSgnLi9pc05hdGl2ZScpLFxuICAgIHNoaW1Jc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvc2hpbUlzUGxhaW5PYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgdmFsdWVzLlxuICogU2VlIHRoZSBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGVPZiA9IGlzTmF0aXZlKGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKSAmJiBnZXRQcm90b3R5cGVPZjtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFzc3VtZXMgb2JqZWN0cyBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvclxuICogaGF2ZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG52YXIgaXNQbGFpbk9iamVjdCA9ICFnZXRQcm90b3R5cGVPZiA/IHNoaW1Jc1BsYWluT2JqZWN0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCEodmFsdWUgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0VGFnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YsXG4gICAgICBvYmpQcm90byA9IGlzTmF0aXZlKHZhbHVlT2YpICYmIChvYmpQcm90byA9IGdldFByb3RvdHlwZU9mKHZhbHVlT2YpKSAmJiBnZXRQcm90b3R5cGVPZihvYmpQcm90byk7XG5cbiAgcmV0dXJuIG9ialByb3RvXG4gICAgPyAodmFsdWUgPT0gb2JqUHJvdG8gfHwgZ2V0UHJvdG90eXBlT2YodmFsdWUpID09IG9ialByb3RvKVxuICAgIDogc2hpbUlzUGxhaW5PYmplY3QodmFsdWUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwidmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgYHRvU3RyaW5nVGFnYCBvZiB2YWx1ZXMuXG4gKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdUYWcpIHx8IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuIiwidmFyIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPSB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPSB0eXBlZEFycmF5VGFnc1ttYXBUYWddID1cbnR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID1cbnR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzZXRUYWddID1cbnR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPSB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgdmFsdWVzLlxuICogU2VlIHRoZSBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIChpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgdHlwZWRBcnJheVRhZ3Nbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldKSB8fCBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYmFzZUNvcHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlQ29weScpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGVcbiAqIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDb3B5KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1BsYWluT2JqZWN0O1xuIiwidmFyIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNMZW5ndGgnKSxcbiAgICBpc05hdGl2ZSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNOYXRpdmUnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKSxcbiAgICBzaGltS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3NoaW1LZXlzJyk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IGlzTmF0aXZlKG5hdGl2ZUtleXMgPSBPYmplY3Qua2V5cykgJiYgbmF0aXZlS2V5cztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xudmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QpIHtcbiAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcbiAgfVxuICBpZiAoKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCkgfHxcbiAgICAgKHR5cGVvZiBvYmplY3QgIT0gJ2Z1bmN0aW9uJyAmJiAobGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkpKSkge1xuICAgIHJldHVybiBzaGltS2V5cyhvYmplY3QpO1xuICB9XG4gIHJldHVybiBpc09iamVjdChvYmplY3QpID8gbmF0aXZlS2V5cyhvYmplY3QpIDogW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpLFxuICAgIHN1cHBvcnQgPSByZXF1aXJlKCcuLi9zdXBwb3J0Jyk7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG4gIGxlbmd0aCA9IChsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgKHN1cHBvcnQubm9uRW51bUFyZ3MgJiYgaXNBcmd1bWVudHMob2JqZWN0KSkpICYmIGxlbmd0aCkgfHwgMDtcblxuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBpc1Byb3RvID0gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0LFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSAoaW5kZXggKyAnJyk7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKHNraXBJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSAmJlxuICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsInZhciBiYXNlQ2FsbGJhY2sgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlQ2FsbGJhY2snKSxcbiAgICBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZUZvck93bicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZCBieVxuICogcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocm91Z2ggYGl0ZXJhdGVlYC4gVGhlXG4gKiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAqXG4gKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gKlxuICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICogIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLm1hcFZhbHVlcyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKG4pIHtcbiAqICAgcmV0dXJuIG4gKiAzO1xuICogfSk7XG4gKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2IH1cbiAqXG4gKiB2YXIgdXNlcnMgPSB7XG4gKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICogfTtcbiAqXG4gKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpdGVyYXRlZSA9IGJhc2VDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgIHJlc3VsdFtrZXldID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVmFsdWVzO1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZXMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdChzKSwgdGhhdFxuICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICogb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuIElmIGBjdXN0b21pemVyYCBpc1xuICogcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmRcbiAqIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIGlzIGhhbmRsZWRcbiAqIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAqIHdpdGggZml2ZSBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSB7XG4gKiAgICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICd1c2VyJzogJ2ZyZWQnIH1dXG4gKiB9O1xuICpcbiAqIHZhciBhZ2VzID0ge1xuICogICAnZGF0YSc6IFt7ICdhZ2UnOiAzNiB9LCB7ICdhZ2UnOiA0MCB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKHVzZXJzLCBhZ2VzKTtcbiAqIC8vID0+IHsgJ2RhdGEnOiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dIH1cbiAqXG4gKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gKiAgICd2ZWdldGFibGVzJzogWydiZWV0J11cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnZnJ1aXRzJzogWydiYW5hbmEnXSxcbiAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlciwgZnVuY3Rpb24oYSwgYikge1xuICogICBpZiAoXy5pc0FycmF5KGEpKSB7XG4gKiAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICogICB9XG4gKiB9KTtcbiAqIC8vID0+IHsgJ2ZydWl0cyc6IFsnYXBwbGUnLCAnYmFuYW5hJ10sICd2ZWdldGFibGVzJzogWydiZWV0JywgJ2NhcnJvdCddIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoYmFzZU1lcmdlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiIsInZhciBiYXNlVmFsdWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZVZhbHVlcycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMuXG4gKiBTZWUgdGhpcyBbYXJ0aWNsZSBvbiBgUmVnRXhwYCBjaGFyYWN0ZXJzXShodHRwOi8vd3d3LnJlZ3VsYXItZXhwcmVzc2lvbnMuaW5mby9jaGFyYWN0ZXJzLmh0bWwjc3BlY2lhbClcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciByZVJlZ0V4cENoYXJzID0gL1suKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nLFxuICAgIHJlSGFzUmVnRXhwQ2hhcnMgPSBSZWdFeHAocmVSZWdFeHBDaGFycy5zb3VyY2UpO1xuXG4vKipcbiAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIlxcXCIsIFwiXlwiLCBcIiRcIiwgXCIuXCIsIFwifFwiLCBcIj9cIiwgXCIqXCIsXG4gKiBcIitcIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiIGFuZCBcIn1cIiBpbiBgc3RyaW5nYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAqL1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFycy50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXJzLCAnXFxcXCQmJylcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVSZWdFeHA7XG4iLCJ2YXIgaXNOYXRpdmUgPSByZXF1aXJlKCcuL2xhbmcvaXNOYXRpdmUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGZ1bmN0aW9ucyBjb250YWluaW5nIGEgYHRoaXNgIHJlZmVyZW5jZS4gKi9cbnZhciByZVRoaXMgPSAvXFxidGhpc1xcYi87XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgRE9NIHN1cHBvcnQuICovXG52YXIgZG9jdW1lbnQgPSAoZG9jdW1lbnQgPSBnbG9iYWwud2luZG93KSAmJiBkb2N1bWVudC5kb2N1bWVudDtcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIEFuIG9iamVjdCBlbnZpcm9ubWVudCBmZWF0dXJlIGZsYWdzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSBPYmplY3RcbiAqL1xudmFyIHN1cHBvcnQgPSB7fTtcblxuKGZ1bmN0aW9uKHgpIHtcblxuICAvKipcbiAgICogRGV0ZWN0IGlmIGZ1bmN0aW9ucyBjYW4gYmUgZGVjb21waWxlZCBieSBgRnVuY3Rpb24jdG9TdHJpbmdgXG4gICAqIChhbGwgYnV0IEZpcmVmb3ggT1MgY2VydGlmaWVkIGFwcHMsIG9sZGVyIE9wZXJhIG1vYmlsZSBicm93c2VycywgYW5kXG4gICAqIHRoZSBQbGF5U3RhdGlvbiAzOyBmb3JjZWQgYGZhbHNlYCBmb3IgV2luZG93cyA4IGFwcHMpLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIHN1cHBvcnQuZnVuY0RlY29tcCA9ICFpc05hdGl2ZShnbG9iYWwuV2luUlRFcnJvcikgJiYgcmVUaGlzLnRlc3QoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KTtcblxuICAvKipcbiAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNuYW1lYCBpcyBzdXBwb3J0ZWQgKGFsbCBidXQgSUUpLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIHN1cHBvcnQuZnVuY05hbWVzID0gdHlwZW9mIEZ1bmN0aW9uLm5hbWUgPT0gJ3N0cmluZyc7XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiB0aGUgRE9NIGlzIHN1cHBvcnRlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqL1xuICB0cnkge1xuICAgIHN1cHBvcnQuZG9tID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLm5vZGVUeXBlID09PSAxMTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3VwcG9ydC5kb20gPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgYGFyZ3VtZW50c2Agb2JqZWN0IGluZGV4ZXMgYXJlIG5vbi1lbnVtZXJhYmxlLlxuICAgKlxuICAgKiBJbiBGaXJlZm94IDwgNCwgSUUgPCA5LCBQaGFudG9tSlMsIGFuZCBTYWZhcmkgPCA1LjEgYGFyZ3VtZW50c2Agb2JqZWN0XG4gICAqIGluZGV4ZXMgYXJlIG5vbi1lbnVtZXJhYmxlLiBDaHJvbWUgPCAyNSBhbmQgTm9kZS5qcyA8IDAuMTEuMCB0cmVhdFxuICAgKiBgYXJndW1lbnRzYCBvYmplY3QgaW5kZXhlcyBhcyBub24tZW51bWVyYWJsZSBhbmQgZmFpbCBgaGFzT3duUHJvcGVydHlgXG4gICAqIGNoZWNrcyBmb3IgaW5kZXhlcyB0aGF0IGV4Y2VlZCB0aGVpciBmdW5jdGlvbidzIGZvcm1hbCBwYXJhbWV0ZXJzIHdpdGhcbiAgICogYXNzb2NpYXRlZCB2YWx1ZXMgb2YgYDBgLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIHRyeSB7XG4gICAgc3VwcG9ydC5ub25FbnVtQXJncyA9ICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHN1cHBvcnQubm9uRW51bUFyZ3MgPSB0cnVlO1xuICB9XG59KDAsIDApKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKiB2YXIgZ2V0dGVyID0gXy5jb25zdGFudChvYmplY3QpO1xuICpcbiAqIGdldHRlcigpID09PSBvYmplY3Q7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIGl0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0O1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCIvKipcbiAqIHNwcmludGYgaW1wbGVtZW50YXRpb24uIEdldCBwcmV0dHkgaW5kZW50ZWQgbW9ub3NwYWNlIHN0cmluZ3MuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICogQHBhcmFtIHsuLi4qfSBhcmdzIC0gYXJndW1lbnRzLCB1c2VkIGluIG9yZGVyLCBvciByZWZlcmVuY2VkIGJ5IG4kXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGV4YW1wbGVcbiAqIC8vIFR5cGUgY2FzdGluZy4uLlxuICogc3ByaW50ZignJXMnLCAxMCk7IC8vICcxMCdcbiAqIHNwcmludGYoJyVzJywgJ2FiYycpOyAvLyAnYWJjJ1xuICpcbiAqIC8vIEVzY2FwZSBhbnl0aGluZyBlbHNlXG4gKiBzcHJpbnRmKCclJScsIDEpOyAvLyAnJSdcbiAqIHNwcmludGYoJyVUJywgJ2FiYycpOyAvLyAnVCdcbiAqXG4gKiAvLyBMaW1pdCBsZW5ndGhcbiAqIHNwcmludGYoXCIlLjVzXCIsICdhYmNkZWYnKTsgLy8gJ2JjZGVmJ1xuICogc3ByaW50ZihcIiUtLjVzXCIsICdhYmNkZWYnKTsgLy8gJ2FiY2RlJ1xuICpcbiAqIC8vIEluZGVudCB0byBsZW5ndGhcbiAqIHNwcmludGYoXCIlNXNcIiwgJ2EnKTsgLy8gJyAgICBhJ1xuICogc3ByaW50ZihcIiUtNXNcIiwgJ2EnKTsgLy8gJ2EgICAgJ1xuICogc3ByaW50ZihcIiU1LjRzXCIsICdhYmMnKTsgLy8gJyBhYmMnXG4gKiBzcHJpbnRmKFwiJS01LjRzXCIsICdhYmMnKTsgLy8gJ2FiYyAnXG4gKlxuICogLy8gVXNlIHBhZCBjaGFyc1xuICogc3ByaW50ZihcIiUwNHNcIiwgMTApOyAvLyBcIjAwMTBcIlxuICogc3ByaW50ZihcIiUnIzRzXCIsIDEwKTsgLy8gXCIjIzEwXCJcbiAqXG4gKiAvLyBVc2UgYXJndW1lbnRzIGluIG9yZGVyXG4gKiBzcHJpbnRmKFwiJTEkcywgJTIkcywgJTIkcywgJTEkcyFcIiwgJ2xlZnQnLCAncmlnaHQnKTsgLy8gJ2xlZnQsIHJpZ2h0LCByaWdodCwgbGVmdCEnXG4gKi9cblxudmFyIHVuZGVmaW5lZCxcblx0LyogbWV0aG9kIHZhcnMgKi9cblx0ciA9IC8lKFxcKyk/KFxcZCtcXCQpPygwfCcuKT8oLSk/KFxcZCspPyhcXC5cXGQrKT8oLikvZyxcblx0cyA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGluZGV4ID0gMSxcblx0XHRcdGV4ZWNNYXRjaCxcblx0XHRcdHRlbXBWYXIxLFxuXHRcdFx0dGVtcFZhcjIsXG5cdFx0XHR0ZW1wVmFyMztcblx0XHR3aGlsZSAoZXhlY01hdGNoID0gci5leGVjKHN0cikpIHtcblx0XHRcdHZhbHVlID0gZXhlY01hdGNoWzddO1xuXG5cdFx0XHQvLyBhcmcgZnJvbSBpbmRleFxuXHRcdFx0aWYgKCh0ZW1wVmFyMiA9IGV4ZWNNYXRjaFsyXSkgJiYgdGVtcFZhcjJbKHRlbXBWYXIxID0gdGVtcFZhcjIubGVuZ3RoIC0gMSldID09IFwiJFwiKSB7XG5cdFx0XHRcdHRlbXBWYXIyID0gdGVtcFZhcjIuc3Vic3RyKDAsIHRlbXBWYXIxKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNbdGVtcFZhcjEgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpXSAmJlxuXHRcdFx0XHQodGVtcFZhcjMgPSBzW3RlbXBWYXIxXShhcmd1bWVudHNbdGVtcFZhcjIgfHwgaW5kZXhdLCAvW0EtWl0vLnRlc3QodmFsdWUpLCBleGVjTWF0Y2hbMV0pKSAhPT0gdW5kZWZpbmVkKSB7XG5cblx0XHRcdFx0dmFsdWU9JycrdGVtcFZhcjM7XG5cblx0XHRcdFx0Ly8gcGFkIGNoYXJcblx0XHRcdFx0aWYgKHRlbXBWYXIxID0gZXhlY01hdGNoWzNdKSB7XG5cdFx0XHRcdFx0aWYgKHRlbXBWYXIxWzBdID09IFwiJ1wiKSB7XG5cdFx0XHRcdFx0XHR0ZW1wVmFyMSA9IHRlbXBWYXIxWzFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0ZW1wVmFyMSA9ICcgJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGVtcFZhcjIgPSBleGVjTWF0Y2hbNV0pIHdoaWxlICh2YWx1ZS5sZW5ndGggPCB0ZW1wVmFyMikge1xuXHRcdFx0XHRcdHZhbHVlID0gZXhlY01hdGNoWzRdID8gKHZhbHVlICsgdGVtcFZhcjEpIDogKHRlbXBWYXIxICsgdmFsdWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCh0ZW1wVmFyMSA9IGV4ZWNNYXRjaFs2XSAmJiBleGVjTWF0Y2hbNl0uc3Vic3RyKDEpKSAmJiB2YWx1ZS5sZW5ndGggPiB0ZW1wVmFyMSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZXhlY01hdGNoWzRdID8gdmFsdWUuc3Vic3RyKDAsIHRlbXBWYXIxKSA6IHZhbHVlLnN1YnN0cih2YWx1ZS5sZW5ndGggLSB0ZW1wVmFyMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdH1cblx0XHRcdHN0ciA9IHN0ci5zdWJzdHIoMCwgdGVtcFZhcjEgPSBleGVjTWF0Y2guaW5kZXgpICsgdmFsdWUgKyBzdHIuc3Vic3RyKHIubGFzdEluZGV4KTtcblx0XHRcdHIubGFzdEluZGV4ID0gdmFsdWUubGVuZ3RoICsgdGVtcFZhcjE7XG5cdFx0fVxuXHRcdHJldHVybiBzdHI7XG5cdH07XG5cbi8qKlxuICogUmV0dXJucyBzdHJpbmcgdmFsdWUgb25seSBpZiBsb3dlcmNhc2Ugcy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2Fwc1xuICogQHJldHVybnMge1N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbnMucz1mdW5jdGlvbih2YWx1ZSwgY2Fwcykge1xuXHRyZXR1cm4gY2FwcyA/IHVuZGVmaW5lZCA6IHZhbHVlKycnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzOyJdfQ==
