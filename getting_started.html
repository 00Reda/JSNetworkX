---
layout: main
menu: Getting Started
title: "Getting Started"
sub: "Your first steps with JSNetworkX"
css: [prettify, getting_started]
---

<div class="row">
  <div class="span3" style="padding-top: 60px">
    <ul class="nav nav-list sidebar" data-spy="affix" data-offset-top="240">
      <li><a href="#install">Installation</a></li>
      <li><a href="#create">Create a graph</a></li>
      <li><a href="#nodes_edges">Nodes and edges</a></li>
      <li><a href="#data">Node and edge data</a></li>
      <li><a href="#analysis">Analyzing graphs</a></li>
      <li><a href="#drawing">Drawing</a></li>
    </ul>
    <div id="demo-canvas" data-spy="affix" data-offset-top="165"></div>
  </div>
  <div class="span9">
  <section id="install">
    <h2 class="page-header">Installation</h2>
<h3>Browser</h3>
<p>Download <a href="https://github.com/fkling/JSNetworkX/blob/master/jsnetworkx.js">jsnetworkx.js</a> and include it in your page:</p>
<pre class="prettyprint linenums">
&lt;script src="jsnetworkx.js&gt;&lt;/script&gt;
</pre>
<p>
There are several <a href="https://github.com/fkling/JSNetworkX/blob/master/dist/">other version</a> for you to choose from. These
are:</p>
<ul>
  <li>
    <code>jsnetworkx-base.js</code>: Contains only graph classes and utility functions, no algorithms, graph generators, visualization etc.
  </li>
  <li>
    <code>jsnetworkx-drawing.js</code>: Like the base version, but with visualization.
  </li>
  <li>
    <code>jsnetworkx-node.js</code>: A special Node.js version with all modules but without visualization.
  </li>
</ul>

<div class="alert alert-info">
<strong>Note</strong> Even though the "base" version does not include 
algorithms explicitly, some might be included due to internal dependencies.
</div>

<p>You can even <a href="https://github.com/fkling/JSNetworkX#how-to-build">build your own version</a> and decide which modules to include.</p>

<p>
If you want to <a href="https://github.com/fkling/JSNetworkX/wiki/Drawing-graphs">visualize graphs</a>, 
you have to include <a href="http://d3js.org/">D3.js</a> as well.<br>
<span class="label label-important">Important</span> It seems that <a href="https://github.com/mbostock/d3/tree/v2.9.3">d3 version 2.9.3</a> works most reliably if you want to use the force layout and be able to drag nodes and pan the canvas.
</p>

<h3>Node.js</h3>

<p>Install JSNetworkX with</p>

<pre class="prettyprint linenums">
npm install <span class="nocode">https://github.com/fkling/JSNetworkX.git</span>
</pre>

<p>and import it in your application</p>
<pre class="prettyprint linenums">
var jsnx = require('jsnetworkx');
</pre>

<p>The package will be made available as official node module once it reaches a certain level of completeness.</p>
</section>
<section id="create">
<h2 class="page-header">Create a graph</h2>
  <p><em>If you are already familiar with NetworkX, than most of the following 
  information will already be familiar to you. Most (if not all) method and function names are the same as in NetworkX.</em></p>

<p>Once you included JSNetworkX you can start working with graphs. If you are 
working in a browser environment, including jsnetworkx.js will create a global 
variable <code>jsnx</code>, which is an object. All functions/methods/modules 
are properties of this object. In Node.js use the name of variable you assigned 
the module to.
</p>

<p>There are basically three ways to create a new graph:</p>
<ol>
  <li>By calling the <code>Graph</code> constructor or one of its subclasses (<code>DiGraph</code>, <code>MultiGraph</code> or <code>MultiDiGraph</code>).</li>
  <li>By transforming an existing graph into a new graph, for example by creating 
  a subgraph with <code>G.subgraph</code> or convert an undirected graph to a directed one (<code>G.to_directed</code>).</li>
  <li>With a graph generator, such as <code>complete_graph().</code></li>
</ol>

<p>Here are some examples:</p>
<pre class="prettyprint linenums">
// This creates a new empty, undirected graph
var G = new jsnx.Graph();
// you can even omit the `new` keyword
var G = jsnx.Graph();

// Generates a complete graph with six nodes
var G = jsnx.complete_graph(6);

// Generates a random graph with six nodes and
// an edge between each node is created with a probability of 0.3
var G = jsnx.binomial_graph(6, 0.3);
</pre>

<p>JSNetworkX provides support for four types of graphs: 
<a href="http://en.wikipedia.org/wiki/Undirected_graph#Undirected_graph">undirected graphs</a> ( <code>Graph</code>),
<a href="http://en.wikipedia.org/wiki/Directed_graph">directed graphs</a> (<code>DiGraph</code>), 
<a href="http://en.wikipedia.org/wiki/Multi-edge">multi edge undirected graphs</a> 
(<code>MultiGraph</code>) and multi edge directed graphs ( <code>MultiDiGraph</code>). 
Each type provides specific methods to access and extract information about the 
structure of the graph.
</p>
</section>
<section id="nodes_edges">
  <h2 class="page-header">Nodes and edges</h2>

  <p>Once we obtained a graph, we want to modify it, by adding or removing nodes and edges, or access node and edge information.</p>

  <h4>Adding and removing nodes</h4>
  <p>Single nodes can be added with <code>G.add_node</code> and a collection 
  of nodes with <code>G.add_nodes_from</code>. Typically the collection will 
  be an array, but it could be another graph as well, or any node collection
  returned by another library function.<br>
  Lets have a look at an example and let us print the nodes:
  </p>
<pre class="prettyprint linenums" data-example="run" data-draw="true">
var G = jsnx.Graph();
G.add_node(1);
G.add_nodes_from([3, 5, 7, 11]);
console.log(G.nodes());
// shows ["1", "3", "5", "7", "11"]
</pre>
<p><code>G.nodes</code> returns an array nodes, which shows us that The graph 
has now four nodes, namely 1, 3, 5 and 7.
</p>
<div class="alert alert-block alert-warning">
  <h4>Node data type: String</h4>
  <p>
  You will notice that the array of nodes consists of <em>strings</em> although we 
  added <em>numbers</em>. This is a limitation the library currently has. Any value you 
  pass as node will be converted to a string. This should generally not be a
  problem if you know what data you are working with, but nevertheless, 
  we are working on <strong>support for generic node values</strong>
  </p>
</div>
<p>Removing nodes is as simple as adding them. You can use either <code>G.remove_node</code>
or <code>G.remove_nodes_from </code>. 

<pre class="prettyprint linenums" data-example="run" data-draw="update" data-depends="0">
G.remove_node(11); // same as G.remove_node("5");
console.log(G.nodes());
// shows ["1", "3", "5", "7"]
</pre>
<div class="alert alert-info">
<strong>Info:</strong> Removing a node will also remove all connected edges.
</div>
<h4>Adding and removing edges</h4>
<p>Adding and removing edges works pretty much the same way, with the methods 
<code>G.add_edge</code> which accepts two nodes as arguments, and 
<code>G.add_edges_from</code> which accepts a list of 2-tuples (arrays).
</p>
<div class="alert alert-info">
  <strong>Info:</strong> If you add an edge between non-existing nodes, the nodes
  will automatically be created.
</div>
<pre class="prettyprint linenums" data-example="run" data-draw="update" data-depends="1">
G.add_edge(1,3);
G.add_edge(3, 1); // does not do anything in undirected graphs
G.add_edges_from([[1,5], [1,7], [7,3], [7,9]]); // node 9 does not exist!
console.log(G.nodes());
// shows ["1", "3", "5", "7", "9"]
console.log(G.edges());
// shows [["1", "3"], ["1", "5"], ["1", "7"], ["7", "3"], ["7", "9"]]
</pre>
<p>
Edges are removed with <code>G.remove_edge</code> and <code>G.remove_edges_from</code>.
</p>
<pre class="prettyprint linenums" data-example="run" data-draw="update" data-depends="2">
G.remove_edge(5,1); // or G.remove_edge(1,5);
G.remove_edges_from([[9,7], [7,1]]);
// Removing a node removes its connected edges as well
G.remove_node(3);
console.log(G.nodes());
// shows ["1", "5", "7", "9"]
console.log(G.edges());
// shows []
</pre>
</section>
<section id="data">
  <h2 class="page-heading">Node and edge data</h2>
  <p>A great feature of NetworkX is the possibility to assign any data to nodes
  and edges and of course JSNetworkX allows you to do this too.</p>

  <h4>New nodes, edges</h4>
  <p><code>G.add_node</code>
  accepts an object as second argument. This will be the node's data. Similarly, 
  <code>G.add_nodes_from</code> accepts a list of <strong>2-tuples</strong>, 
  where the first element is the node, and the second element is a data object.
  It also accepts an object as second argument. Data passed through this object 
  will be added to all nodes.
  </p>
<pre class="prettyprint linenums">
var G = jsnx.Graph();
// Adds a new node, 10, with the data {some_data: 42}
G.add_node(10, {some_data: 42});

// Adds the nodes, "foo" and "bar", with individual data and data for both nodes
G.add_nodes_from([['foo', {size: 5}], ['bar', {size: 10}]], {color: 'blue'});

// Passing `true` to `G.nodes` changes the return value to include the data for each node
console.log(G.nodes(true));
// shows
// [
//    ["10",{"some_data":42}],
//    ["foo",{"color":"blue","size":5}],
//    ["bar",{"color":"blue","size":10}]
// ]
</pre>
<p>It works the same for edges: <code>G.add_edge</code> accepts an object as third
argument and <code>G.add_edges_from</code> a list of 3-tuples, where the first two
elements are nodes and the third one is a data object.</p>

<h4>Existing nodes, edges</h4>
<p> You have two ways to set data on <em>existing</em> nodes and edges: 
Either just add the node (edge) again, the passed data will be <strong>merged</strong>,
or access the nodes (edges) via the graphs <code>G.node</code> (<code>G.adj</code>)
properties.
</p>
<pre class="prettyprint linenums">
var G = jsnx.Graph();
G.add_nodes_from([0,1]);
G.add_edge(0,1);

G.node[0].foo = 'bar';
G.adj[0][1].color = 'blue'; // or G.adj[1][0].color =  ...

console.log(G.nodes(true));
// shows [["0",{"foo":"bar"}],["1",{}]]
console.log(G.edges(true));
// shows [["0","1",{"color":"blue"}]]"[
</pre>
</section>

<div class="alert"><strong>Warning</strong> 
  You should directly modify the <code>G.nodes</code> or <code>G.adj</code> 
  properties, since this can lead to inconsistency within the graph.
</div>
<div class="alert alert-error">
  <h4>Upcoming API changes</h4>
  <p>In order to support generic node values, the <code>G.nodes</code>, 
  <code>G.adj</code> and other related properties won't stay simple objects. 
  You should not rely on them too much or at least be prepared that they will change.
  They will be changed to some kind of maps, like
  <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-15.14">ES6's Map objects</a>.
  </p>
</div>

<h4>What is this data useful for?</h4>
<p>That is really up to your use case. For example, if you are modeling a social
network, the node data can contain more detailed information about a person.
If you are modeling a street network, the edge data could contain timeseries data
about congestion.
</p>
<p>Node and edge data can be very useful if you want to customize the style of 
nodes and edges in a visualization. This will be explained later, but here is 
already a short example of how this can look like:
</p>
<pre class="prettyprint linenums" data-example="run" data-draw="false">
var G = jsnx.Graph();
G.add_nodes_from([
    [1, {color: 'red'}],
    [2, {color: 'green'}],
    [3, {color: 'white'}]
]);

G.add_edges_from([[1,2], [1,3]]);

// `jsnx.draw` accept a graph and configuration object
jsnx.draw(G, {
  element: '#demo-canvas',
  with_labels: true,
  node_style: {
      fill: function(d) {
          return d.data.color;
      }
  }
});
</pre>
</section>
<section id="analysis">
  <h2>Analyzing graphs</h2>
  <p>NetworkX provides a variety of algorithms to analyze graphs, such as detecting
  cliques, computing shortest paths or the centrality of a graph. JSNetworkX 
  aims to provide those algorithms as well. You can see the progress and which
  algorithms are available on the <a href="api_progress.html">API progress page</a>.
  To learn about the algorithms which are generally available, have a look at the 
  <a href="http://networkx.github.com/documentation/latest/reference/algorithms.html">NetworkX documentation</a>.
  </p>

  <p>Most functions implementing those algorithms are available on the
  <code>jsnx</code> object (just like with NetworkX). Here is a small example, 
  which computes the shortest path between two nodes, draws the graph and colors 
  the found nodes differently.
  </p>
<pre class="prettyprint linenums" data-example="run" data-draw="false">
// This is a graph generator
var G = jsnx.cycle_graph(6);
// Compute the shortest path between 0 and 4
var path = jsnx.bidirectional_shortest_path(G, 0, 4);
// A simple way to color all nodes in the path:
G.add_nodes_from(path, {color: '#FFF'});
// Color the start and end differently
G.node[0].color = '#0F0'; // start is green
G.node[4].color = '#F00'; // end is red

jsnx.draw(G, {
  element: '#demo-canvas',
  with_labels: true,
  node_style: {
    fill: function(d) {
      return d.data.color || '#AAA'; // any node without color is gray
    }
  }
});
</pre>
</section>
<section id="drawing">
  <h2>Drawing graphs</h2>
</section>
  </div>
</div>
<script src="javascripts/prettify.js"></script>
<script>
  window.prettyPrint && window.prettyPrint();
  $('body').scrollspy();
</script>
<script src="javascripts/demo.js"></script>
