---
layout: main
menu: Documentation
title: Documentation
css: [prettify]
---

<div class="row">
  <div class="span3 sidebar">
    <div class="sidenav affix-top" data-spy="affix" data-offset-top="140">
    <ul class="nav nav-list">
      <li class="nav-header">Concepts</li>
      <li><a href="#node_values">Node values</a></li>
      <li><a href="#node_access">Node access</a></li>
      <li><a href="#iter_gen">Iterators and Generators</a></li>
      <li><a href="#keyword_args">Keyword arguments</a></li>
      <li><a href="#optional_args">Optional arguments</a></li>
      <li class="divider"></li>
      <li class="nav-header">Migration</li>
      <li><a href="#migration_0.1.1_0.2.0">Migration from v0.1.1 to v0.2.0</a></li>
    </ul>
  </div>
  </div>
  <div class="span9">
    <section>
    <p>A dedicated documentation for JSNetworkX does not exist yet, but we are 
    working on it. Until then,
    please have a look at the excellent <a href="http://networkx.github.com/documentation/latest/">NetworkX documentation</a>.
    JSNetworkX uses (almost always) the same method names. A list of available
    methods can be found on the <a href="api_progress.html">API progress page</a>.
    </p>
    </section>
    <section>
      <h3 id="node_values">Node values: How different data types are handled</h3>
      <p>
        Node values are used internally as keys for a dictionary, e.g. 
        <code>node_value -> node_attribute</code> or <code>node_value -> neighbors</code>.
        There are also methods which return <code>node_value -> result</code> mappings,
        such as <code>G.degree()</code>.
      </p>
      <p>Up to  <span class="label label-info">v0.1.1</span>, JSNetworkX used 
      simple objects to store such mappings, where
      the node values were used as property names. That had the unfortunate side
      effect that all node values were implicitly converted to strings.
      </p>
      <p>
        Since <span class="label label-info">v0.2.0</span>, instead of simple objects
        we use a custom Map implementation which preservers the actual node values.
        This is how different data types are treated:
      </p>
      <p>
        <strong>Numbers</strong> and <strong>strings</strong> work as expected:
        <pre class="prettyprint">
var G = jsnx.Graph();
G.add_nodes_from([1,2,3, "foo"]);
console.log(G.nodes());
// [1, 2, 3, "foo"]
</pre>
        <p>
        For everything else, such as <strong>objects</strong> and 
        <strong>arrays</strong> a string <em>key</em> is generated by calling 
        the object's <code>toString</code> method. This means that any two 
        objects are considered equal if their <code>toString</code> method 
        returns the same value. It also has the nice side-effect that simple 
        arrays (arrays containing primitive values, like numbers or string) 
        behave like Python's tuples.
        </p>
        <p>Examples:
        <pre class="prettyprint">
// Use arrays as tuples
var G = jsnx.Graph();
G.add_node([1,2], {data: 'foo'});
console.log(G.node.get([1,2]).data); // because [1,2].toString() === "1, 2"
// "foo"
</pre>
<div class="alert alert-warning">
  <strong>Note:</strong>
  The built-in array <code>toString</code> method does not format string values
  in any special way. That means that <code>[1,2]</code> and <code>["1","2"]</code>
  cannot be distinguished, since both produce the same string <code>"1, 2"</code>.
</div>

<pre class="prettyprint">
// Overwrite toString of objects
var nodeA = {toString: function() { return 'nodeA'; }};
var nodeB = {toString: function() { return 'nodeB'; }};

var G = jsnx.Graph();
G.add_nodes_from([nodeA, nodeB]);
console.log(G.nodes());
// [Object, Object]
</pre>
</p>

      <div class="alert alert-info alert-block">
        <h4>Old info for v0.1.1</h4>
      <p>
      Since nodes are stored as property names of an object, all node values are essentially converted to strings.
      </p>
      <p>
      This bears no problem for strings or numbers (with a caveat, mentioned in the next paragraph)
      but each other type has to be handled with care. For example, the default 
      string representation of any object is <code>"[object Object]"</code>,
      which means that two different objects will map to the same node.<br>
      If you want to use an object as a node, you have to override its 
      <code>toString()</code> method.
      </p>
      <p>
      Even more attention has to be paid when retrieving nodes from the graph. Since all nodes are converted to strings, only the string representation of the node can be returned. That means all number nodes ( <code>1</code> ) will be returned as numeric strings ( <code>"1"</code> ).
      </p>
      <p>
      If the original value is required, it is advised to either add it as node attribute or maintain an external map.
      </p>
    </div>

      <h3 id="node_access">Node access</h3>
      <p>
      Python lets users access a node of a graph with <code>G[n]</code>.
      Technically this is possible in JavaScript as well, but to keep the 
      implementation simple, JSNetworkX does not support this access path. 
      Instead, one has to use <code>G.get(n)</code>.
      </p>
      <p>
      Similarly, wherever a dictionary is used in Python to store nodes or edges,
      JSNetworkX uses its Map implementation. A map provides various methods to
      access the data it contains, among others <code>Map#get</code> and 
      <code>Map#forEach</code>. For example:
      </p>
      <pre class="prettyprint">
var G = jsnx.Graph({1: [2, 3], 2: [3, 4]});
var degrees = G.degree();

console.log(degrees.get(1)); // 2

degrees.forEach(function(node, degree) {
  console.log(node + ': ' + degree); // e.g. "1: 2"
});

console.log(degree.values()); // [2, 3, 2, 1]
</pre>
      <div class="alert alert-info alert-block">
        <h4>Old info for v0.1.1</h4>
        <p>
        Nodes of a graph can be accessed via <code>G.get_node(n)</code>
        and nodes or edges are stored in simple objects, accessible with bracket
        notation (e.g. <code>G.node[n]</code>).
        </p>
      </div>

      <h3 id="iter_gen">Iterators and Generators</h3>
      <div class="alert alert-info">
      <strong>Info</strong>
      ECMAScript 6 will support <a href="http://wiki.ecmascript.org/doku.php?id=harmony:iterators">iterators</a> 
      and <a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">generators</a>. We 
      plan to implement them as soon as possible.
      </div>
      <p>
      The official JavaScript standard (ECMAScript) does currently not support iterators.
      Mozilla's JavaScript implementation provides them in version 1.7, but since
      this is not supported by other browsers, it is not really usable. We use the
      closure library's iterator implementation which is compatible to Mozilla's
      implementation.
      </p>
      <p>
      Each object which implements an <code>.__iterator__()</code> function which returns an object having a <code>.next()</code> method (can be the same object) can be used as iterator.<br>
      Such an object is returned by every method which is supposed to return a generator and you can process them by using <code>jsnx.forEach</code> or <code>jsnx.toArray</code>, as shown in the example:
      </p>
      <pre class="prettyprint linenums">
jsnx.forEach(G.nodes_iter(), function(node) {
  console.log(node);
});

// jsnx.sentinelIterator wraps an iterator to return a sentinel value instead 
// of throwing a StopIteraton exception
var gen = jsnx.sentinelIterator(G.nodes_iter(), null);
var node;
while((node = gen.next()) !== null) {
  console.log(node);
}
</pre>

      <h3 id="keyword_args"> Keyword arguments</h3>
      <p>
      JavaScript only supports positional arguments. If a NetworkX method accepts a variable number of keyword arguments, a dictionary (object) has to be passed instead. So, <code>G.add_node('foo', data=42)</code> becomes <code>G.add_node('foo', {data: 42})</code>.
      </p>

      <h3 id="optional_args">Optional arguments</h3>
      <p>Some methods have one or more optional arguments. In Python one can simply use keyword arguments to pass the desired arguments. In JSNetworkX, optional arguments can be omitted, as long as the arguments are of different types and therefore distinguishable.
      </p>

      <p> For example, this is OK:</p>
      <pre class="prettyprint linenums">
// Python: G.edges(data=true)
G.edges(true);
</pre>
      <p>but this is ambiguous:</p>
      <pre class="prettyprint linenums">
// Python: G.degree(weight='weight')
G.degree('weight'); // get node with name 'weight' or is the weight attribute name 'weight' ?
</pre>
      <p>In this case we decided to interpret the argument as node name. To set the <em>weight</em> attribute name and to get all nodes, <em>null</em> or <em>undefined</em> has to be passed as first argument:
      </p>
      <pre class="prettyprint linenums">
G.degree(null, 'weight');
</pre>
    </section>
    <section>
      <h3 id="migration_0.1.1_0.2.0">Migration from v0.1.1 to v0.2.0</h3>
      <p>
        <span class="label label-info">v0.1.1</span> had the disadvantage that
        every node value was implicitly converted to a string and the original
        value could not be restored (without additional, external logic).
      </p>
      <p>
        In <span class="label label-info">v.0.2.0</span>, instead of using simple
        objects to store node values, JSNetworkX uses instances of 
        <code>jsnx.contrib.Map</code>.
      </p>
      <p>
        This means that whenever a node was used as a property name,
        like
      </p> 
      <pre class="prettyprint">G.node[n]</pre> 
      <p>the <code>.get()</code> method has to be used instead:</p>
      <pre class="prettyprint">G.node.get(n)</pre>
      <p>Instead of assigning to the property:</p>
      <pre class="prettyprint">degrees[n] = 42;</pre>
      <p>the <code>.set()</code> method has to be used:</p>
      <pre class="prettyprint">degress.set(n, 42);</pre>
      
      <p>
        If you use any of the following properties or methods, then you will have
        to adjust the code accordingly.
      </p>
      <p>
        <strong>Changed properties</strong><br>
        These properties hold a map instead of an object keyed by node.
      </p> 
      <ul>
        <li>Graph#node</li>
        <li>Graph#adj</li>
        <li>Graph#edge</li>
        <li>DiGraph#succ</li>
        <li>DiGraph#pred</li>
      </ul>
      <p>
        <strong>Changed methods/functions</strong><br>
        These methods/functions return a map instead of an object keyed by
        node or edge.
      </p> 
      <ul>
        <li>Graph#degree</li>
        <li>Graph#get (previously Graph#get_node)</li>
        <li>DiGraph#in_degree</li>
        <li>DiGraph#out_degree</li>
        <li>jsnx.all_pairs_shortest_path</li>
        <li>jsnx.all_pairs_shortest_path_length</li>
        <li>jsnx.betweenness_centrality</li>
        <li>jsnx.clustering</li>
        <li>jsnx.degree</li>
        <li>jsnx.edge_betweenness_centrality</li>
        <li>jsnx.get_edge_attributes</li>
        <li>jsnx.get_node_attributes</li>
        <li>jsnx.number_of_cliques</li>
        <li>jsnx.predecessor</li>
        <li>jsnx.single_source_shortest_path</li>
        <li>jsnx.single_source_shortest_path_length</li>
        <li>jsnx.square_clustering</li>
        <li>jsnx.triangles</li>
      </ul>

      <p>
        No adjustments have to be made for graph creation. The following
        will still work as expected, because numeric property names of objects 
        containing node data are implicitly converted to numbers.
      </p>
<pre class="prettyprint">
var G = jsnx.Graph({1: [2, 3], 2: [3]});
</pre>
    </section>
  </div>
</div>
<script src="javascripts/prettify.js"></script>
<script>
  window.prettyPrint && window.prettyPrint();
</script>
